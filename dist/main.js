#!/usr/bin/env node
const require_chunk = require('./chunk-BjHgXDHd.js');
let node_util = require("node:util");
node_util = require_chunk.__toESM(node_util);
let node_path = require("node:path");
node_path = require_chunk.__toESM(node_path);
let node_process = require("node:process");
node_process = require_chunk.__toESM(node_process);
let node_tty = require("node:tty");
node_tty = require_chunk.__toESM(node_tty);
let node_fs = require("node:fs");
node_fs = require_chunk.__toESM(node_fs);
let effect_Channel = require("effect/Channel");
effect_Channel = require_chunk.__toESM(effect_Channel);
let effect_Function = require("effect/Function");
effect_Function = require_chunk.__toESM(effect_Function);
let effect_Schema = require("effect/Schema");
effect_Schema = require_chunk.__toESM(effect_Schema);
let effect_Chunk = require("effect/Chunk");
effect_Chunk = require_chunk.__toESM(effect_Chunk);
let effect_Effect = require("effect/Effect");
effect_Effect = require_chunk.__toESM(effect_Effect);
let effect_Inspectable = require("effect/Inspectable");
effect_Inspectable = require_chunk.__toESM(effect_Inspectable);
let effect_Option = require("effect/Option");
effect_Option = require_chunk.__toESM(effect_Option);
let effect_Stream = require("effect/Stream");
effect_Stream = require_chunk.__toESM(effect_Stream);
require("effect/Brand");
let effect_Context = require("effect/Context");
effect_Context = require_chunk.__toESM(effect_Context);
let effect_Sink = require("effect/Sink");
effect_Sink = require_chunk.__toESM(effect_Sink);
require("effect/Predicate");
require("effect/Data");
let effect_Layer = require("effect/Layer");
effect_Layer = require_chunk.__toESM(effect_Layer);
require("effect/Cause");
let effect_Scope = require("effect/Scope");
effect_Scope = require_chunk.__toESM(effect_Scope);
require("effect/Fiber");
let effect_Exit = require("effect/Exit");
effect_Exit = require_chunk.__toESM(effect_Exit);
require("effect/Runtime");
let effect_Mailbox = require("effect/Mailbox");
effect_Mailbox = require_chunk.__toESM(effect_Mailbox);
let effect_Deferred = require("effect/Deferred");
effect_Deferred = require_chunk.__toESM(effect_Deferred);
let node_child_process = require("node:child_process");
node_child_process = require_chunk.__toESM(node_child_process);
let node_os = require("node:os");
node_os = require_chunk.__toESM(node_os);
let __effect_platform_Worker = require("@effect/platform/Worker");
__effect_platform_Worker = require_chunk.__toESM(__effect_platform_Worker);
let effect_MutableRef = require("effect/MutableRef");
effect_MutableRef = require_chunk.__toESM(effect_MutableRef);
let __effect_platform_Error = require("@effect/platform/Error");
__effect_platform_Error = require_chunk.__toESM(__effect_platform_Error);
let node_crypto = require("node:crypto");
node_crypto = require_chunk.__toESM(node_crypto);
let __effect_platform_FileSystem = require("@effect/platform/FileSystem");
__effect_platform_FileSystem = require_chunk.__toESM(__effect_platform_FileSystem);
let __effect_platform_Command = require("@effect/platform/Command");
__effect_platform_Command = require_chunk.__toESM(__effect_platform_Command);
let __effect_platform_CommandExecutor = require("@effect/platform/CommandExecutor");
__effect_platform_CommandExecutor = require_chunk.__toESM(__effect_platform_CommandExecutor);
let __effect_platform_Effectify = require("@effect/platform/Effectify");
__effect_platform_Effectify = require_chunk.__toESM(__effect_platform_Effectify);
let __effect_platform_Path = require("@effect/platform/Path");
__effect_platform_Path = require_chunk.__toESM(__effect_platform_Path);
let node_url = require("node:url");
node_url = require_chunk.__toESM(node_url);
let __effect_platform_Terminal = require("@effect/platform/Terminal");
__effect_platform_Terminal = require_chunk.__toESM(__effect_platform_Terminal);
let effect_RcRef = require("effect/RcRef");
effect_RcRef = require_chunk.__toESM(effect_RcRef);
let node_readline = require("node:readline");
node_readline = require_chunk.__toESM(node_readline);
let __effect_platform_WorkerError = require("@effect/platform/WorkerError");
__effect_platform_WorkerError = require_chunk.__toESM(__effect_platform_WorkerError);
let __effect_platform_Runtime = require("@effect/platform/Runtime");
__effect_platform_Runtime = require_chunk.__toESM(__effect_platform_Runtime);

//#region node_modules/.pnpm/consola@3.4.2/node_modules/consola/dist/core.mjs
const LogLevels = {
	silent: Number.NEGATIVE_INFINITY,
	fatal: 0,
	error: 0,
	warn: 1,
	log: 2,
	info: 3,
	success: 3,
	fail: 3,
	ready: 3,
	start: 3,
	box: 3,
	debug: 4,
	trace: 5,
	verbose: Number.POSITIVE_INFINITY
};
const LogTypes = {
	silent: { level: -1 },
	fatal: { level: LogLevels.fatal },
	error: { level: LogLevels.error },
	warn: { level: LogLevels.warn },
	log: { level: LogLevels.log },
	info: { level: LogLevels.info },
	success: { level: LogLevels.success },
	fail: { level: LogLevels.fail },
	ready: { level: LogLevels.info },
	start: { level: LogLevels.info },
	box: { level: LogLevels.info },
	debug: { level: LogLevels.debug },
	trace: { level: LogLevels.trace },
	verbose: { level: LogLevels.verbose }
};
function isPlainObject$1(value) {
	if (value === null || typeof value !== "object") return false;
	const prototype = Object.getPrototypeOf(value);
	if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) return false;
	if (Symbol.iterator in value) return false;
	if (Symbol.toStringTag in value) return Object.prototype.toString.call(value) === "[object Module]";
	return true;
}
function _defu(baseObject, defaults, namespace = ".", merger) {
	if (!isPlainObject$1(defaults)) return _defu(baseObject, {}, namespace, merger);
	const object = Object.assign({}, defaults);
	for (const key in baseObject) {
		if (key === "__proto__" || key === "constructor") continue;
		const value = baseObject[key];
		if (value === null || value === void 0) continue;
		if (merger && merger(object, key, value, namespace)) continue;
		if (Array.isArray(value) && Array.isArray(object[key])) object[key] = [...value, ...object[key]];
		else if (isPlainObject$1(value) && isPlainObject$1(object[key])) object[key] = _defu(value, object[key], (namespace ? `${namespace}.` : "") + key.toString(), merger);
		else object[key] = value;
	}
	return object;
}
function createDefu(merger) {
	return (...arguments_) => arguments_.reduce((p, c$1) => _defu(p, c$1, "", merger), {});
}
const defu = createDefu();
function isPlainObject(obj) {
	return Object.prototype.toString.call(obj) === "[object Object]";
}
function isLogObj(arg) {
	if (!isPlainObject(arg)) return false;
	if (!arg.message && !arg.args) return false;
	if (arg.stack) return false;
	return true;
}
let paused = false;
const queue = [];
var Consola = class Consola {
	options;
	_lastLog;
	_mockFn;
	/**
	* Creates an instance of Consola with specified options or defaults.
	*
	* @param {Partial<ConsolaOptions>} [options={}] - Configuration options for the Consola instance.
	*/
	constructor(options = {}) {
		const types = options.types || LogTypes;
		this.options = defu({
			...options,
			defaults: { ...options.defaults },
			level: _normalizeLogLevel(options.level, types),
			reporters: [...options.reporters || []]
		}, {
			types: LogTypes,
			throttle: 1e3,
			throttleMin: 5,
			formatOptions: {
				date: true,
				colors: false,
				compact: true
			}
		});
		for (const type in types) {
			const defaults = {
				type,
				...this.options.defaults,
				...types[type]
			};
			this[type] = this._wrapLogFn(defaults);
			this[type].raw = this._wrapLogFn(defaults, true);
		}
		if (this.options.mockFn) this.mockTypes();
		this._lastLog = {};
	}
	/**
	* Gets the current log level of the Consola instance.
	*
	* @returns {number} The current log level.
	*/
	get level() {
		return this.options.level;
	}
	/**
	* Sets the minimum log level that will be output by the instance.
	*
	* @param {number} level - The new log level to set.
	*/
	set level(level) {
		this.options.level = _normalizeLogLevel(level, this.options.types, this.options.level);
	}
	/**
	* Displays a prompt to the user and returns the response.
	* Throw an error if `prompt` is not supported by the current configuration.
	*
	* @template T
	* @param {string} message - The message to display in the prompt.
	* @param {T} [opts] - Optional options for the prompt. See {@link PromptOptions}.
	* @returns {promise<T>} A promise that infer with the prompt options. See {@link PromptOptions}.
	*/
	prompt(message, opts) {
		if (!this.options.prompt) throw new Error("prompt is not supported!");
		return this.options.prompt(message, opts);
	}
	/**
	* Creates a new instance of Consola, inheriting options from the current instance, with possible overrides.
	*
	* @param {Partial<ConsolaOptions>} options - Optional overrides for the new instance. See {@link ConsolaOptions}.
	* @returns {ConsolaInstance} A new Consola instance. See {@link ConsolaInstance}.
	*/
	create(options) {
		const instance = new Consola({
			...this.options,
			...options
		});
		if (this._mockFn) instance.mockTypes(this._mockFn);
		return instance;
	}
	/**
	* Creates a new Consola instance with the specified default log object properties.
	*
	* @param {InputLogObject} defaults - Default properties to include in any log from the new instance. See {@link InputLogObject}.
	* @returns {ConsolaInstance} A new Consola instance. See {@link ConsolaInstance}.
	*/
	withDefaults(defaults) {
		return this.create({
			...this.options,
			defaults: {
				...this.options.defaults,
				...defaults
			}
		});
	}
	/**
	* Creates a new Consola instance with a specified tag, which will be included in every log.
	*
	* @param {string} tag - The tag to include in each log of the new instance.
	* @returns {ConsolaInstance} A new Consola instance. See {@link ConsolaInstance}.
	*/
	withTag(tag$1) {
		return this.withDefaults({ tag: this.options.defaults.tag ? this.options.defaults.tag + ":" + tag$1 : tag$1 });
	}
	/**
	* Adds a custom reporter to the Consola instance.
	* Reporters will be called for each log message, depending on their implementation and log level.
	*
	* @param {ConsolaReporter} reporter - The reporter to add. See {@link ConsolaReporter}.
	* @returns {Consola} The current Consola instance.
	*/
	addReporter(reporter) {
		this.options.reporters.push(reporter);
		return this;
	}
	/**
	* Removes a custom reporter from the Consola instance.
	* If no reporter is specified, all reporters will be removed.
	*
	* @param {ConsolaReporter} reporter - The reporter to remove. See {@link ConsolaReporter}.
	* @returns {Consola} The current Consola instance.
	*/
	removeReporter(reporter) {
		if (reporter) {
			const i$1 = this.options.reporters.indexOf(reporter);
			if (i$1 !== -1) return this.options.reporters.splice(i$1, 1);
		} else this.options.reporters.splice(0);
		return this;
	}
	/**
	* Replaces all reporters of the Consola instance with the specified array of reporters.
	*
	* @param {ConsolaReporter[]} reporters - The new reporters to set. See {@link ConsolaReporter}.
	* @returns {Consola} The current Consola instance.
	*/
	setReporters(reporters) {
		this.options.reporters = Array.isArray(reporters) ? reporters : [reporters];
		return this;
	}
	wrapAll() {
		this.wrapConsole();
		this.wrapStd();
	}
	restoreAll() {
		this.restoreConsole();
		this.restoreStd();
	}
	/**
	* Overrides console methods with Consola logging methods for consistent logging.
	*/
	wrapConsole() {
		for (const type in this.options.types) {
			if (!console["__" + type]) console["__" + type] = console[type];
			console[type] = this[type].raw;
		}
	}
	/**
	* Restores the original console methods, removing Consola overrides.
	*/
	restoreConsole() {
		for (const type in this.options.types) if (console["__" + type]) {
			console[type] = console["__" + type];
			delete console["__" + type];
		}
	}
	/**
	* Overrides standard output and error streams to redirect them through Consola.
	*/
	wrapStd() {
		this._wrapStream(this.options.stdout, "log");
		this._wrapStream(this.options.stderr, "log");
	}
	_wrapStream(stream$1, type) {
		if (!stream$1) return;
		if (!stream$1.__write) stream$1.__write = stream$1.write;
		stream$1.write = (data) => {
			this[type].raw(String(data).trim());
		};
	}
	/**
	* Restores the original standard output and error streams, removing the Consola redirection.
	*/
	restoreStd() {
		this._restoreStream(this.options.stdout);
		this._restoreStream(this.options.stderr);
	}
	_restoreStream(stream$1) {
		if (!stream$1) return;
		if (stream$1.__write) {
			stream$1.write = stream$1.__write;
			delete stream$1.__write;
		}
	}
	/**
	* Pauses logging, queues incoming logs until resumed.
	*/
	pauseLogs() {
		paused = true;
	}
	/**
	* Resumes logging, processing any queued logs.
	*/
	resumeLogs() {
		paused = false;
		const _queue = queue.splice(0);
		for (const item of _queue) item[0]._logFn(item[1], item[2]);
	}
	/**
	* Replaces logging methods with mocks if a mock function is provided.
	*
	* @param {ConsolaOptions["mockFn"]} mockFn - The function to use for mocking logging methods. See {@link ConsolaOptions["mockFn"]}.
	*/
	mockTypes(mockFn) {
		const _mockFn = mockFn || this.options.mockFn;
		this._mockFn = _mockFn;
		if (typeof _mockFn !== "function") return;
		for (const type in this.options.types) {
			this[type] = _mockFn(type, this.options.types[type]) || this[type];
			this[type].raw = this[type];
		}
	}
	_wrapLogFn(defaults, isRaw) {
		return (...args$2) => {
			if (paused) {
				queue.push([
					this,
					defaults,
					args$2,
					isRaw
				]);
				return;
			}
			return this._logFn(defaults, args$2, isRaw);
		};
	}
	_logFn(defaults, args$2, isRaw) {
		if ((defaults.level || 0) > this.level) return false;
		const logObj = {
			date: /* @__PURE__ */ new Date(),
			args: [],
			...defaults,
			level: _normalizeLogLevel(defaults.level, this.options.types)
		};
		if (!isRaw && args$2.length === 1 && isLogObj(args$2[0])) Object.assign(logObj, args$2[0]);
		else logObj.args = [...args$2];
		if (logObj.message) {
			logObj.args.unshift(logObj.message);
			delete logObj.message;
		}
		if (logObj.additional) {
			if (!Array.isArray(logObj.additional)) logObj.additional = logObj.additional.split("\n");
			logObj.args.push("\n" + logObj.additional.join("\n"));
			delete logObj.additional;
		}
		logObj.type = typeof logObj.type === "string" ? logObj.type.toLowerCase() : "log";
		logObj.tag = typeof logObj.tag === "string" ? logObj.tag : "";
		const resolveLog = (newLog = false) => {
			const repeated = (this._lastLog.count || 0) - this.options.throttleMin;
			if (this._lastLog.object && repeated > 0) {
				const args2 = [...this._lastLog.object.args];
				if (repeated > 1) args2.push(`(repeated ${repeated} times)`);
				this._log({
					...this._lastLog.object,
					args: args2
				});
				this._lastLog.count = 1;
			}
			if (newLog) {
				this._lastLog.object = logObj;
				this._log(logObj);
			}
		};
		clearTimeout(this._lastLog.timeout);
		const diffTime = this._lastLog.time && logObj.date ? logObj.date.getTime() - this._lastLog.time.getTime() : 0;
		this._lastLog.time = logObj.date;
		if (diffTime < this.options.throttle) try {
			const serializedLog = JSON.stringify([
				logObj.type,
				logObj.tag,
				logObj.args
			]);
			const isSameLog = this._lastLog.serialized === serializedLog;
			this._lastLog.serialized = serializedLog;
			if (isSameLog) {
				this._lastLog.count = (this._lastLog.count || 0) + 1;
				if (this._lastLog.count > this.options.throttleMin) {
					this._lastLog.timeout = setTimeout(resolveLog, this.options.throttle);
					return;
				}
			}
		} catch {}
		resolveLog(true);
	}
	_log(logObj) {
		for (const reporter of this.options.reporters) reporter.log(logObj, { options: this.options });
	}
};
function _normalizeLogLevel(input, types = {}, defaultLevel = 3) {
	if (input === void 0) return defaultLevel;
	if (typeof input === "number") return input;
	if (types[input] && types[input].level !== void 0) return types[input].level;
	return defaultLevel;
}
Consola.prototype.add = Consola.prototype.addReporter;
Consola.prototype.remove = Consola.prototype.removeReporter;
Consola.prototype.clear = Consola.prototype.removeReporter;
Consola.prototype.withScope = Consola.prototype.withTag;
Consola.prototype.mock = Consola.prototype.mockTypes;
Consola.prototype.pause = Consola.prototype.pauseLogs;
Consola.prototype.resume = Consola.prototype.resumeLogs;
function createConsola(options = {}) {
	return new Consola(options);
}

//#endregion
//#region node_modules/.pnpm/consola@3.4.2/node_modules/consola/dist/shared/consola.DRwqZj3T.mjs
function parseStack(stack, message) {
	const cwd = process.cwd() + node_path.sep;
	return stack.split("\n").splice(message.split("\n").length).map((l$1) => l$1.trim().replace("file://", "").replace(cwd, ""));
}
function writeStream(data, stream$1) {
	return (stream$1.__write || stream$1.write).call(stream$1, data);
}
const bracket = (x) => x ? `[${x}]` : "";
var BasicReporter = class {
	formatStack(stack, message, opts) {
		const indent = "  ".repeat((opts?.errorLevel || 0) + 1);
		return indent + parseStack(stack, message).join(`
${indent}`);
	}
	formatError(err, opts) {
		const message = err.message ?? (0, node_util.formatWithOptions)(opts, err);
		const stack = err.stack ? this.formatStack(err.stack, message, opts) : "";
		const level = opts?.errorLevel || 0;
		const causedPrefix = level > 0 ? `${"  ".repeat(level)}[cause]: ` : "";
		const causedError = err.cause ? "\n\n" + this.formatError(err.cause, {
			...opts,
			errorLevel: level + 1
		}) : "";
		return causedPrefix + message + "\n" + stack + causedError;
	}
	formatArgs(args$2, opts) {
		return (0, node_util.formatWithOptions)(opts, ...args$2.map((arg) => {
			if (arg && typeof arg.stack === "string") return this.formatError(arg, opts);
			return arg;
		}));
	}
	formatDate(date, opts) {
		return opts.date ? date.toLocaleTimeString() : "";
	}
	filterAndJoin(arr) {
		return arr.filter(Boolean).join(" ");
	}
	formatLogObj(logObj, opts) {
		const message = this.formatArgs(logObj.args, opts);
		if (logObj.type === "box") return "\n" + [
			bracket(logObj.tag),
			logObj.title && logObj.title,
			...message.split("\n")
		].filter(Boolean).map((l$1) => " > " + l$1).join("\n") + "\n";
		return this.filterAndJoin([
			bracket(logObj.type),
			bracket(logObj.tag),
			message
		]);
	}
	log(logObj, ctx) {
		return writeStream(this.formatLogObj(logObj, {
			columns: ctx.options.stdout.columns || 0,
			...ctx.options.formatOptions
		}) + "\n", logObj.level < 2 ? ctx.options.stderr || process.stderr : ctx.options.stdout || process.stdout);
	}
};

//#endregion
//#region node_modules/.pnpm/consola@3.4.2/node_modules/consola/dist/shared/consola.DXBYu-KD.mjs
const { env: env$1 = {}, argv = [], platform = "" } = typeof process === "undefined" ? {} : process;
const isDisabled$2 = "NO_COLOR" in env$1 || argv.includes("--no-color");
const isForced = "FORCE_COLOR" in env$1 || argv.includes("--color");
const isWindows = platform === "win32";
const isDumbTerminal = env$1.TERM === "dumb";
const isCompatibleTerminal = node_tty && node_tty.isatty && node_tty.isatty(1) && env$1.TERM && !isDumbTerminal;
const isCI = "CI" in env$1 && ("GITHUB_ACTIONS" in env$1 || "GITLAB_CI" in env$1 || "CIRCLECI" in env$1);
const isColorSupported = !isDisabled$2 && (isForced || isWindows && !isDumbTerminal || isCompatibleTerminal || isCI);
function replaceClose(index, string$1, close$1, replace, head$4 = string$1.slice(0, Math.max(0, index)) + replace, tail = string$1.slice(Math.max(0, index + close$1.length)), next = tail.indexOf(close$1)) {
	return head$4 + (next < 0 ? tail : replaceClose(next, tail, close$1, replace));
}
function clearBleed(index, string$1, open$1, close$1, replace) {
	return index < 0 ? open$1 + string$1 + close$1 : open$1 + replaceClose(index, string$1, close$1, replace) + close$1;
}
function filterEmpty(open$1, close$1, replace = open$1, at$2 = open$1.length + 1) {
	return (string$1) => string$1 || !(string$1 === "" || string$1 === void 0) ? clearBleed(("" + string$1).indexOf(close$1, at$2), string$1, open$1, close$1, replace) : "";
}
function init(open$1, close$1, replace) {
	return filterEmpty(`\x1B[${open$1}m`, `\x1B[${close$1}m`, replace);
}
const colorDefs = {
	reset: init(0, 0),
	bold: init(1, 22, "\x1B[22m\x1B[1m"),
	dim: init(2, 22, "\x1B[22m\x1B[2m"),
	italic: init(3, 23),
	underline: init(4, 24),
	inverse: init(7, 27),
	hidden: init(8, 28),
	strikethrough: init(9, 29),
	black: init(30, 39),
	red: init(31, 39),
	green: init(32, 39),
	yellow: init(33, 39),
	blue: init(34, 39),
	magenta: init(35, 39),
	cyan: init(36, 39),
	white: init(37, 39),
	gray: init(90, 39),
	bgBlack: init(40, 49),
	bgRed: init(41, 49),
	bgGreen: init(42, 49),
	bgYellow: init(43, 49),
	bgBlue: init(44, 49),
	bgMagenta: init(45, 49),
	bgCyan: init(46, 49),
	bgWhite: init(47, 49),
	blackBright: init(90, 39),
	redBright: init(91, 39),
	greenBright: init(92, 39),
	yellowBright: init(93, 39),
	blueBright: init(94, 39),
	magentaBright: init(95, 39),
	cyanBright: init(96, 39),
	whiteBright: init(97, 39),
	bgBlackBright: init(100, 49),
	bgRedBright: init(101, 49),
	bgGreenBright: init(102, 49),
	bgYellowBright: init(103, 49),
	bgBlueBright: init(104, 49),
	bgMagentaBright: init(105, 49),
	bgCyanBright: init(106, 49),
	bgWhiteBright: init(107, 49)
};
function createColors(useColor = isColorSupported) {
	return useColor ? colorDefs : Object.fromEntries(Object.keys(colorDefs).map((key) => [key, String]));
}
const colors$1 = createColors();
function getColor$1(color, fallback = "reset") {
	return colors$1[color] || colors$1[fallback];
}
const ansiRegex$1 = [String.raw`[\u001B\u009B][[\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\d\/#&.:=?%@~_]+)*|[a-zA-Z\d]+(?:;[-a-zA-Z\d\/#&.:=?%@~_]*)*)?\u0007)`, String.raw`(?:(?:\d{1,4}(?:;\d{0,4})*)?[\dA-PR-TZcf-nq-uy=><~]))`].join("|");
function stripAnsi(text) {
	return text.replace(new RegExp(ansiRegex$1, "g"), "");
}
const boxStylePresets = {
	solid: {
		tl: "┌",
		tr: "┐",
		bl: "└",
		br: "┘",
		h: "─",
		v: "│"
	},
	double: {
		tl: "╔",
		tr: "╗",
		bl: "╚",
		br: "╝",
		h: "═",
		v: "║"
	},
	doubleSingle: {
		tl: "╓",
		tr: "╖",
		bl: "╙",
		br: "╜",
		h: "─",
		v: "║"
	},
	doubleSingleRounded: {
		tl: "╭",
		tr: "╮",
		bl: "╰",
		br: "╯",
		h: "─",
		v: "║"
	},
	singleThick: {
		tl: "┏",
		tr: "┓",
		bl: "┗",
		br: "┛",
		h: "━",
		v: "┃"
	},
	singleDouble: {
		tl: "╒",
		tr: "╕",
		bl: "╘",
		br: "╛",
		h: "═",
		v: "│"
	},
	singleDoubleRounded: {
		tl: "╭",
		tr: "╮",
		bl: "╰",
		br: "╯",
		h: "═",
		v: "│"
	},
	rounded: {
		tl: "╭",
		tr: "╮",
		bl: "╰",
		br: "╯",
		h: "─",
		v: "│"
	}
};
const defaultStyle = {
	borderColor: "white",
	borderStyle: "rounded",
	valign: "center",
	padding: 2,
	marginLeft: 1,
	marginTop: 1,
	marginBottom: 1
};
function box(text, _opts = {}) {
	const opts = {
		..._opts,
		style: {
			...defaultStyle,
			..._opts.style
		}
	};
	const textLines = text.split("\n");
	const boxLines = [];
	const _color = getColor$1(opts.style.borderColor);
	const borderStyle = { ...typeof opts.style.borderStyle === "string" ? boxStylePresets[opts.style.borderStyle] || boxStylePresets.solid : opts.style.borderStyle };
	if (_color) for (const key in borderStyle) borderStyle[key] = _color(borderStyle[key]);
	const paddingOffset = opts.style.padding % 2 === 0 ? opts.style.padding : opts.style.padding + 1;
	const height = textLines.length + paddingOffset;
	const width = Math.max(...textLines.map((line) => stripAnsi(line).length), opts.title ? stripAnsi(opts.title).length : 0) + paddingOffset;
	const widthOffset = width + paddingOffset;
	const leftSpace = opts.style.marginLeft > 0 ? " ".repeat(opts.style.marginLeft) : "";
	if (opts.style.marginTop > 0) boxLines.push("".repeat(opts.style.marginTop));
	if (opts.title) {
		const title = _color ? _color(opts.title) : opts.title;
		const left$2 = borderStyle.h.repeat(Math.floor((width - stripAnsi(opts.title).length) / 2));
		const right$2 = borderStyle.h.repeat(width - stripAnsi(opts.title).length - stripAnsi(left$2).length + paddingOffset);
		boxLines.push(`${leftSpace}${borderStyle.tl}${left$2}${title}${right$2}${borderStyle.tr}`);
	} else boxLines.push(`${leftSpace}${borderStyle.tl}${borderStyle.h.repeat(widthOffset)}${borderStyle.tr}`);
	const valignOffset = opts.style.valign === "center" ? Math.floor((height - textLines.length) / 2) : opts.style.valign === "top" ? height - textLines.length - paddingOffset : height - textLines.length;
	for (let i$1 = 0; i$1 < height; i$1++) if (i$1 < valignOffset || i$1 >= valignOffset + textLines.length) boxLines.push(`${leftSpace}${borderStyle.v}${" ".repeat(widthOffset)}${borderStyle.v}`);
	else {
		const line = textLines[i$1 - valignOffset];
		const left$2 = " ".repeat(paddingOffset);
		const right$2 = " ".repeat(width - stripAnsi(line).length);
		boxLines.push(`${leftSpace}${borderStyle.v}${left$2}${line}${right$2}${borderStyle.v}`);
	}
	boxLines.push(`${leftSpace}${borderStyle.bl}${borderStyle.h.repeat(widthOffset)}${borderStyle.br}`);
	if (opts.style.marginBottom > 0) boxLines.push("".repeat(opts.style.marginBottom));
	return boxLines.join("\n");
}

//#endregion
//#region node_modules/.pnpm/consola@3.4.2/node_modules/consola/dist/index.mjs
const r = Object.create(null), i = (e) => globalThis.process?.env || {}.env || globalThis.Deno?.env.toObject() || globalThis.__env__ || (e ? r : globalThis), o = new Proxy(r, {
	get(e, s$1) {
		return i()[s$1] ?? r[s$1];
	},
	has(e, s$1) {
		return s$1 in i() || s$1 in r;
	},
	set(e, s$1, E) {
		const B = i(true);
		return B[s$1] = E, true;
	},
	deleteProperty(e, s$1) {
		if (!s$1) return false;
		const E = i(true);
		return delete E[s$1], true;
	},
	ownKeys() {
		const e = i(true);
		return Object.keys(e);
	}
}), t = typeof process < "u" && process.env && process.env.NODE_ENV || "", f = [
	["APPVEYOR"],
	[
		"AWS_AMPLIFY",
		"AWS_APP_ID",
		{ ci: true }
	],
	["AZURE_PIPELINES", "SYSTEM_TEAMFOUNDATIONCOLLECTIONURI"],
	["AZURE_STATIC", "INPUT_AZURE_STATIC_WEB_APPS_API_TOKEN"],
	["APPCIRCLE", "AC_APPCIRCLE"],
	["BAMBOO", "bamboo_planKey"],
	["BITBUCKET", "BITBUCKET_COMMIT"],
	["BITRISE", "BITRISE_IO"],
	["BUDDY", "BUDDY_WORKSPACE_ID"],
	["BUILDKITE"],
	["CIRCLE", "CIRCLECI"],
	["CIRRUS", "CIRRUS_CI"],
	[
		"CLOUDFLARE_PAGES",
		"CF_PAGES",
		{ ci: true }
	],
	["CODEBUILD", "CODEBUILD_BUILD_ARN"],
	["CODEFRESH", "CF_BUILD_ID"],
	["DRONE"],
	["DRONE", "DRONE_BUILD_EVENT"],
	["DSARI"],
	["GITHUB_ACTIONS"],
	["GITLAB", "GITLAB_CI"],
	["GITLAB", "CI_MERGE_REQUEST_ID"],
	["GOCD", "GO_PIPELINE_LABEL"],
	["LAYERCI"],
	["HUDSON", "HUDSON_URL"],
	["JENKINS", "JENKINS_URL"],
	["MAGNUM"],
	["NETLIFY"],
	[
		"NETLIFY",
		"NETLIFY_LOCAL",
		{ ci: false }
	],
	["NEVERCODE"],
	["RENDER"],
	["SAIL", "SAILCI"],
	["SEMAPHORE"],
	["SCREWDRIVER"],
	["SHIPPABLE"],
	["SOLANO", "TDDIUM"],
	["STRIDER"],
	["TEAMCITY", "TEAMCITY_VERSION"],
	["TRAVIS"],
	["VERCEL", "NOW_BUILDER"],
	[
		"VERCEL",
		"VERCEL",
		{ ci: false }
	],
	[
		"VERCEL",
		"VERCEL_ENV",
		{ ci: false }
	],
	["APPCENTER", "APPCENTER_BUILD_ID"],
	[
		"CODESANDBOX",
		"CODESANDBOX_SSE",
		{ ci: false }
	],
	[
		"CODESANDBOX",
		"CODESANDBOX_HOST",
		{ ci: false }
	],
	["STACKBLITZ"],
	["STORMKIT"],
	["CLEAVR"],
	["ZEABUR"],
	[
		"CODESPHERE",
		"CODESPHERE_APP_ID",
		{ ci: true }
	],
	["RAILWAY", "RAILWAY_PROJECT_ID"],
	["RAILWAY", "RAILWAY_SERVICE_ID"],
	["DENO-DEPLOY", "DENO_DEPLOYMENT_ID"],
	[
		"FIREBASE_APP_HOSTING",
		"FIREBASE_APP_HOSTING",
		{ ci: true }
	]
];
function b() {
	if (globalThis.process?.env) for (const e of f) {
		const s$1 = e[1] || e[0];
		if (globalThis.process?.env[s$1]) return {
			name: e[0].toLowerCase(),
			...e[2]
		};
	}
	return globalThis.process?.env?.SHELL === "/bin/jsh" && globalThis.process?.versions?.webcontainer ? {
		name: "stackblitz",
		ci: false
	} : {
		name: "",
		ci: false
	};
}
const l = b();
l.name;
function n(e) {
	return e ? e !== "false" : false;
}
const I = globalThis.process?.platform || "", T = n(o.CI) || l.ci !== false, a = n(globalThis.process?.stdout && globalThis.process?.stdout.isTTY), g = n(o.DEBUG), R = t === "test" || n(o.TEST);
n(o.MINIMAL);
const A = /^win/i.test(I);
!n(o.NO_COLOR) && (n(o.FORCE_COLOR) || (a || A) && o.TERM);
const C = (globalThis.process?.versions?.node || "").replace(/^v/, "") || null;
Number(C?.split(".")[0]);
const y = globalThis.process || Object.create(null), _ = { versions: {} };
new Proxy(y, { get(e, s$1) {
	if (s$1 === "env") return o;
	if (s$1 in e) return e[s$1];
	if (s$1 in _) return _[s$1];
} });
const c = globalThis.process?.release?.name === "node", O = !!globalThis.Bun || !!globalThis.process?.versions?.bun, D = !!globalThis.Deno, L = !!globalThis.fastly, S = !!globalThis.Netlify, u = !!globalThis.EdgeRuntime, N = globalThis.navigator?.userAgent === "Cloudflare-Workers", F = [
	[S, "netlify"],
	[u, "edge-light"],
	[N, "workerd"],
	[L, "fastly"],
	[D, "deno"],
	[O, "bun"],
	[c, "node"]
];
function G() {
	const e = F.find((s$1) => s$1[0]);
	if (e) return { name: e[1] };
}
G()?.name;
function ansiRegex({ onlyFirst = false } = {}) {
	const pattern = [`[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?(?:\\u0007|\\u001B\\u005C|\\u009C))`, "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"].join("|");
	return new RegExp(pattern, onlyFirst ? void 0 : "g");
}
const regex = ansiRegex();
function stripAnsi$1(string$1) {
	if (typeof string$1 !== "string") throw new TypeError(`Expected a \`string\`, got \`${typeof string$1}\``);
	return string$1.replace(regex, "");
}
function isAmbiguous(x) {
	return x === 161 || x === 164 || x === 167 || x === 168 || x === 170 || x === 173 || x === 174 || x >= 176 && x <= 180 || x >= 182 && x <= 186 || x >= 188 && x <= 191 || x === 198 || x === 208 || x === 215 || x === 216 || x >= 222 && x <= 225 || x === 230 || x >= 232 && x <= 234 || x === 236 || x === 237 || x === 240 || x === 242 || x === 243 || x >= 247 && x <= 250 || x === 252 || x === 254 || x === 257 || x === 273 || x === 275 || x === 283 || x === 294 || x === 295 || x === 299 || x >= 305 && x <= 307 || x === 312 || x >= 319 && x <= 322 || x === 324 || x >= 328 && x <= 331 || x === 333 || x === 338 || x === 339 || x === 358 || x === 359 || x === 363 || x === 462 || x === 464 || x === 466 || x === 468 || x === 470 || x === 472 || x === 474 || x === 476 || x === 593 || x === 609 || x === 708 || x === 711 || x >= 713 && x <= 715 || x === 717 || x === 720 || x >= 728 && x <= 731 || x === 733 || x === 735 || x >= 768 && x <= 879 || x >= 913 && x <= 929 || x >= 931 && x <= 937 || x >= 945 && x <= 961 || x >= 963 && x <= 969 || x === 1025 || x >= 1040 && x <= 1103 || x === 1105 || x === 8208 || x >= 8211 && x <= 8214 || x === 8216 || x === 8217 || x === 8220 || x === 8221 || x >= 8224 && x <= 8226 || x >= 8228 && x <= 8231 || x === 8240 || x === 8242 || x === 8243 || x === 8245 || x === 8251 || x === 8254 || x === 8308 || x === 8319 || x >= 8321 && x <= 8324 || x === 8364 || x === 8451 || x === 8453 || x === 8457 || x === 8467 || x === 8470 || x === 8481 || x === 8482 || x === 8486 || x === 8491 || x === 8531 || x === 8532 || x >= 8539 && x <= 8542 || x >= 8544 && x <= 8555 || x >= 8560 && x <= 8569 || x === 8585 || x >= 8592 && x <= 8601 || x === 8632 || x === 8633 || x === 8658 || x === 8660 || x === 8679 || x === 8704 || x === 8706 || x === 8707 || x === 8711 || x === 8712 || x === 8715 || x === 8719 || x === 8721 || x === 8725 || x === 8730 || x >= 8733 && x <= 8736 || x === 8739 || x === 8741 || x >= 8743 && x <= 8748 || x === 8750 || x >= 8756 && x <= 8759 || x === 8764 || x === 8765 || x === 8776 || x === 8780 || x === 8786 || x === 8800 || x === 8801 || x >= 8804 && x <= 8807 || x === 8810 || x === 8811 || x === 8814 || x === 8815 || x === 8834 || x === 8835 || x === 8838 || x === 8839 || x === 8853 || x === 8857 || x === 8869 || x === 8895 || x === 8978 || x >= 9312 && x <= 9449 || x >= 9451 && x <= 9547 || x >= 9552 && x <= 9587 || x >= 9600 && x <= 9615 || x >= 9618 && x <= 9621 || x === 9632 || x === 9633 || x >= 9635 && x <= 9641 || x === 9650 || x === 9651 || x === 9654 || x === 9655 || x === 9660 || x === 9661 || x === 9664 || x === 9665 || x >= 9670 && x <= 9672 || x === 9675 || x >= 9678 && x <= 9681 || x >= 9698 && x <= 9701 || x === 9711 || x === 9733 || x === 9734 || x === 9737 || x === 9742 || x === 9743 || x === 9756 || x === 9758 || x === 9792 || x === 9794 || x === 9824 || x === 9825 || x >= 9827 && x <= 9829 || x >= 9831 && x <= 9834 || x === 9836 || x === 9837 || x === 9839 || x === 9886 || x === 9887 || x === 9919 || x >= 9926 && x <= 9933 || x >= 9935 && x <= 9939 || x >= 9941 && x <= 9953 || x === 9955 || x === 9960 || x === 9961 || x >= 9963 && x <= 9969 || x === 9972 || x >= 9974 && x <= 9977 || x === 9979 || x === 9980 || x === 9982 || x === 9983 || x === 10045 || x >= 10102 && x <= 10111 || x >= 11094 && x <= 11097 || x >= 12872 && x <= 12879 || x >= 57344 && x <= 63743 || x >= 65024 && x <= 65039 || x === 65533 || x >= 127232 && x <= 127242 || x >= 127248 && x <= 127277 || x >= 127280 && x <= 127337 || x >= 127344 && x <= 127373 || x === 127375 || x === 127376 || x >= 127387 && x <= 127404 || x >= 917760 && x <= 917999 || x >= 983040 && x <= 1048573 || x >= 1048576 && x <= 1114109;
}
function isFullWidth(x) {
	return x === 12288 || x >= 65281 && x <= 65376 || x >= 65504 && x <= 65510;
}
function isWide(x) {
	return x >= 4352 && x <= 4447 || x === 8986 || x === 8987 || x === 9001 || x === 9002 || x >= 9193 && x <= 9196 || x === 9200 || x === 9203 || x === 9725 || x === 9726 || x === 9748 || x === 9749 || x >= 9776 && x <= 9783 || x >= 9800 && x <= 9811 || x === 9855 || x >= 9866 && x <= 9871 || x === 9875 || x === 9889 || x === 9898 || x === 9899 || x === 9917 || x === 9918 || x === 9924 || x === 9925 || x === 9934 || x === 9940 || x === 9962 || x === 9970 || x === 9971 || x === 9973 || x === 9978 || x === 9981 || x === 9989 || x === 9994 || x === 9995 || x === 10024 || x === 10060 || x === 10062 || x >= 10067 && x <= 10069 || x === 10071 || x >= 10133 && x <= 10135 || x === 10160 || x === 10175 || x === 11035 || x === 11036 || x === 11088 || x === 11093 || x >= 11904 && x <= 11929 || x >= 11931 && x <= 12019 || x >= 12032 && x <= 12245 || x >= 12272 && x <= 12287 || x >= 12289 && x <= 12350 || x >= 12353 && x <= 12438 || x >= 12441 && x <= 12543 || x >= 12549 && x <= 12591 || x >= 12593 && x <= 12686 || x >= 12688 && x <= 12773 || x >= 12783 && x <= 12830 || x >= 12832 && x <= 12871 || x >= 12880 && x <= 42124 || x >= 42128 && x <= 42182 || x >= 43360 && x <= 43388 || x >= 44032 && x <= 55203 || x >= 63744 && x <= 64255 || x >= 65040 && x <= 65049 || x >= 65072 && x <= 65106 || x >= 65108 && x <= 65126 || x >= 65128 && x <= 65131 || x >= 94176 && x <= 94180 || x === 94192 || x === 94193 || x >= 94208 && x <= 100343 || x >= 100352 && x <= 101589 || x >= 101631 && x <= 101640 || x >= 110576 && x <= 110579 || x >= 110581 && x <= 110587 || x === 110589 || x === 110590 || x >= 110592 && x <= 110882 || x === 110898 || x >= 110928 && x <= 110930 || x === 110933 || x >= 110948 && x <= 110951 || x >= 110960 && x <= 111355 || x >= 119552 && x <= 119638 || x >= 119648 && x <= 119670 || x === 126980 || x === 127183 || x === 127374 || x >= 127377 && x <= 127386 || x >= 127488 && x <= 127490 || x >= 127504 && x <= 127547 || x >= 127552 && x <= 127560 || x === 127568 || x === 127569 || x >= 127584 && x <= 127589 || x >= 127744 && x <= 127776 || x >= 127789 && x <= 127797 || x >= 127799 && x <= 127868 || x >= 127870 && x <= 127891 || x >= 127904 && x <= 127946 || x >= 127951 && x <= 127955 || x >= 127968 && x <= 127984 || x === 127988 || x >= 127992 && x <= 128062 || x === 128064 || x >= 128066 && x <= 128252 || x >= 128255 && x <= 128317 || x >= 128331 && x <= 128334 || x >= 128336 && x <= 128359 || x === 128378 || x === 128405 || x === 128406 || x === 128420 || x >= 128507 && x <= 128591 || x >= 128640 && x <= 128709 || x === 128716 || x >= 128720 && x <= 128722 || x >= 128725 && x <= 128727 || x >= 128732 && x <= 128735 || x === 128747 || x === 128748 || x >= 128756 && x <= 128764 || x >= 128992 && x <= 129003 || x === 129008 || x >= 129292 && x <= 129338 || x >= 129340 && x <= 129349 || x >= 129351 && x <= 129535 || x >= 129648 && x <= 129660 || x >= 129664 && x <= 129673 || x >= 129679 && x <= 129734 || x >= 129742 && x <= 129756 || x >= 129759 && x <= 129769 || x >= 129776 && x <= 129784 || x >= 131072 && x <= 196605 || x >= 196608 && x <= 262141;
}
function validate$2(codePoint) {
	if (!Number.isSafeInteger(codePoint)) throw new TypeError(`Expected a code point, got \`${typeof codePoint}\`.`);
}
function eastAsianWidth(codePoint, { ambiguousAsWide = false } = {}) {
	validate$2(codePoint);
	if (isFullWidth(codePoint) || isWide(codePoint) || ambiguousAsWide && isAmbiguous(codePoint)) return 2;
	return 1;
}
const emojiRegex = () => {
	return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
};
const segmenter = globalThis.Intl?.Segmenter ? new Intl.Segmenter() : { segment: (str) => str.split("") };
const defaultIgnorableCodePointRegex = /^\p{Default_Ignorable_Code_Point}$/u;
function stringWidth$1(string$1, options = {}) {
	if (typeof string$1 !== "string" || string$1.length === 0) return 0;
	const { ambiguousIsNarrow = true, countAnsiEscapeCodes = false } = options;
	if (!countAnsiEscapeCodes) string$1 = stripAnsi$1(string$1);
	if (string$1.length === 0) return 0;
	let width = 0;
	const eastAsianWidthOptions = { ambiguousAsWide: !ambiguousIsNarrow };
	for (const { segment: character } of segmenter.segment(string$1)) {
		const codePoint = character.codePointAt(0);
		if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) continue;
		if (codePoint >= 8203 && codePoint <= 8207 || codePoint === 65279) continue;
		if (codePoint >= 768 && codePoint <= 879 || codePoint >= 6832 && codePoint <= 6911 || codePoint >= 7616 && codePoint <= 7679 || codePoint >= 8400 && codePoint <= 8447 || codePoint >= 65056 && codePoint <= 65071) continue;
		if (codePoint >= 55296 && codePoint <= 57343) continue;
		if (codePoint >= 65024 && codePoint <= 65039) continue;
		if (defaultIgnorableCodePointRegex.test(character)) continue;
		if (emojiRegex().test(character)) {
			width += 2;
			continue;
		}
		width += eastAsianWidth(codePoint, eastAsianWidthOptions);
	}
	return width;
}
function isUnicodeSupported() {
	const { env: env$2 } = node_process.default;
	const { TERM, TERM_PROGRAM } = env$2;
	if (node_process.default.platform !== "win32") return TERM !== "linux";
	return Boolean(env$2.WT_SESSION) || Boolean(env$2.TERMINUS_SUBLIME) || env$2.ConEmuTask === "{cmd::Cmder}" || TERM_PROGRAM === "Terminus-Sublime" || TERM_PROGRAM === "vscode" || TERM === "xterm-256color" || TERM === "alacritty" || TERM === "rxvt-unicode" || TERM === "rxvt-unicode-256color" || env$2.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}
const TYPE_COLOR_MAP = {
	info: "cyan",
	fail: "red",
	success: "green",
	ready: "green",
	start: "magenta"
};
const LEVEL_COLOR_MAP = {
	0: "red",
	1: "yellow"
};
const unicode = isUnicodeSupported();
const s = (c$1, fallback) => unicode ? c$1 : fallback;
const TYPE_ICONS = {
	error: s("✖", "×"),
	fatal: s("✖", "×"),
	ready: s("✔", "√"),
	warn: s("⚠", "‼"),
	info: s("ℹ", "i"),
	success: s("✔", "√"),
	debug: s("⚙", "D"),
	trace: s("→", "→"),
	fail: s("✖", "×"),
	start: s("◐", "o"),
	log: ""
};
function stringWidth(str) {
	if (!(typeof Intl === "object") || !Intl.Segmenter) return stripAnsi(str).length;
	return stringWidth$1(str);
}
var FancyReporter = class extends BasicReporter {
	formatStack(stack, message, opts) {
		const indent = "  ".repeat((opts?.errorLevel || 0) + 1);
		return `
${indent}` + parseStack(stack, message).map((line) => "  " + line.replace(/^at +/, (m) => colors$1.gray(m)).replace(/\((.+)\)/, (_$1, m) => `(${colors$1.cyan(m)})`)).join(`
${indent}`);
	}
	formatType(logObj, isBadge, opts) {
		const typeColor = TYPE_COLOR_MAP[logObj.type] || LEVEL_COLOR_MAP[logObj.level] || "gray";
		if (isBadge) return getBgColor(typeColor)(colors$1.black(` ${logObj.type.toUpperCase()} `));
		const _type = typeof TYPE_ICONS[logObj.type] === "string" ? TYPE_ICONS[logObj.type] : logObj.icon || logObj.type;
		return _type ? getColor(typeColor)(_type) : "";
	}
	formatLogObj(logObj, opts) {
		const [message, ...additional] = this.formatArgs(logObj.args, opts).split("\n");
		if (logObj.type === "box") return box(characterFormat(message + (additional.length > 0 ? "\n" + additional.join("\n") : "")), {
			title: logObj.title ? characterFormat(logObj.title) : void 0,
			style: logObj.style
		});
		const date = this.formatDate(logObj.date, opts);
		const coloredDate = date && colors$1.gray(date);
		const isBadge = logObj.badge ?? logObj.level < 2;
		const type = this.formatType(logObj, isBadge, opts);
		const tag$1 = logObj.tag ? colors$1.gray(logObj.tag) : "";
		let line;
		const left$2 = this.filterAndJoin([type, characterFormat(message)]);
		const right$2 = this.filterAndJoin(opts.columns ? [tag$1, coloredDate] : [tag$1]);
		const space = (opts.columns || 0) - stringWidth(left$2) - stringWidth(right$2) - 2;
		line = space > 0 && (opts.columns || 0) >= 80 ? left$2 + " ".repeat(space) + right$2 : (right$2 ? `${colors$1.gray(`[${right$2}]`)} ` : "") + left$2;
		line += characterFormat(additional.length > 0 ? "\n" + additional.join("\n") : "");
		if (logObj.type === "trace") {
			const _err = /* @__PURE__ */ new Error("Trace: " + logObj.message);
			line += this.formatStack(_err.stack || "", _err.message);
		}
		return isBadge ? "\n" + line + "\n" : line;
	}
};
function characterFormat(str) {
	return str.replace(/`([^`]+)`/gm, (_$1, m) => colors$1.cyan(m)).replace(/\s+_([^_]+)_\s+/gm, (_$1, m) => ` ${colors$1.underline(m)} `);
}
function getColor(color = "white") {
	return colors$1[color] || colors$1.white;
}
function getBgColor(color = "bgWhite") {
	return colors$1[`bg${color[0].toUpperCase()}${color.slice(1)}`] || colors$1.bgWhite;
}
function createConsola$1(options = {}) {
	let level = _getDefaultLogLevel();
	if (process.env.CONSOLA_LEVEL) level = Number.parseInt(process.env.CONSOLA_LEVEL) ?? level;
	return createConsola({
		level,
		defaults: { level },
		stdout: process.stdout,
		stderr: process.stderr,
		prompt: (...args$2) => Promise.resolve().then(() => require("./prompt-DNk9T4Wl.js")).then((m) => m.prompt(...args$2)),
		reporters: options.reporters || [options.fancy ?? !(T || R) ? new FancyReporter() : new BasicReporter()],
		...options
	});
}
function _getDefaultLogLevel() {
	if (g) return LogLevels.debug;
	if (R) return LogLevels.warn;
	return LogLevels.info;
}
const consola = createConsola$1();

//#endregion
//#region src/package-json.ts
const pkg = (() => {
	try {
		const packageJsonPath = `${process.cwd()}/package.json`;
		const packageJsonContent = node_fs.default.readFileSync(packageJsonPath, "utf-8");
		return JSON.parse(packageJsonContent);
	} catch (error) {
		consola.fail(error);
	}
})();

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Function.js
/**
* Tests if a value is a `function`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isFunction } from "effect/Predicate"
*
* assert.deepStrictEqual(isFunction(isFunction), true)
* assert.deepStrictEqual(isFunction("function"), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isFunction$1 = (input) => typeof input === "function";
/**
* Creates a function that can be used in a data-last (aka `pipe`able) or
* data-first style.
*
* The first parameter to `dual` is either the arity of the uncurried function
* or a predicate that determines if the function is being used in a data-first
* or data-last style.
*
* Using the arity is the most common use case, but there are some cases where
* you may want to use a predicate. For example, if you have a function that
* takes an optional argument, you can use a predicate to determine if the
* function is being used in a data-first or data-last style.
*
* You can pass either the arity of the uncurried function or a predicate
* which determines if the function is being used in a data-first or
* data-last style.
*
* **Example** (Using arity to determine data-first or data-last style)
*
* ```ts
* import { dual, pipe } from "effect/Function"
*
* const sum = dual<
*   (that: number) => (self: number) => number,
*   (self: number, that: number) => number
* >(2, (self, that) => self + that)
*
* console.log(sum(2, 3)) // 5
* console.log(pipe(2, sum(3))) // 5
* ```
*
* **Example** (Using call signatures to define the overloads)
*
* ```ts
* import { dual, pipe } from "effect/Function"
*
* const sum: {
*   (that: number): (self: number) => number
*   (self: number, that: number): number
* } = dual(2, (self: number, that: number): number => self + that)
*
* console.log(sum(2, 3)) // 5
* console.log(pipe(2, sum(3))) // 5
* ```
*
* **Example** (Using a predicate to determine data-first or data-last style)
*
* ```ts
* import { dual, pipe } from "effect/Function"
*
* const sum = dual<
*   (that: number) => (self: number) => number,
*   (self: number, that: number) => number
* >(
*   (args) => args.length === 2,
*   (self, that) => self + that
* )
*
* console.log(sum(2, 3)) // 5
* console.log(pipe(2, sum(3))) // 5
* ```
*
* @since 2.0.0
*/
const dual$1 = function(arity, body) {
	if (typeof arity === "function") return function() {
		if (arity(arguments)) return body.apply(this, arguments);
		return (self) => body(self, ...arguments);
	};
	switch (arity) {
		case 0:
		case 1: throw new RangeError(`Invalid arity ${arity}`);
		case 2: return function(a$1, b$1) {
			if (arguments.length >= 2) return body(a$1, b$1);
			return function(self) {
				return body(self, a$1);
			};
		};
		case 3: return function(a$1, b$1, c$1) {
			if (arguments.length >= 3) return body(a$1, b$1, c$1);
			return function(self) {
				return body(self, a$1, b$1);
			};
		};
		case 4: return function(a$1, b$1, c$1, d) {
			if (arguments.length >= 4) return body(a$1, b$1, c$1, d);
			return function(self) {
				return body(self, a$1, b$1, c$1);
			};
		};
		case 5: return function(a$1, b$1, c$1, d, e) {
			if (arguments.length >= 5) return body(a$1, b$1, c$1, d, e);
			return function(self) {
				return body(self, a$1, b$1, c$1, d);
			};
		};
		default: return function() {
			if (arguments.length >= arity) return body.apply(this, arguments);
			const args$2 = arguments;
			return function(self) {
				return body(self, ...args$2);
			};
		};
	}
};
/**
* The identity function, i.e. A function that returns its input argument.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { identity } from "effect/Function"
*
* assert.deepStrictEqual(identity(5), 5)
* ```
*
* @since 2.0.0
*/
const identity$2 = (a$1) => a$1;
/**
* Creates a constant value that never changes.
*
* This is useful when you want to pass a value to a higher-order function (a function that takes another function as its argument)
* and want that inner function to always use the same value, no matter how many times it is called.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { constant } from "effect/Function"
*
* const constNull = constant(null)
*
* assert.deepStrictEqual(constNull(), null)
* assert.deepStrictEqual(constNull(), null)
* ```
*
* @since 2.0.0
*/
const constant = (value) => () => value;
/**
* A thunk that returns always `true`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { constTrue } from "effect/Function"
*
* assert.deepStrictEqual(constTrue(), true)
* ```
*
* @since 2.0.0
*/
const constTrue = /* @__PURE__ */ constant(true);
/**
* A thunk that returns always `false`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { constFalse } from "effect/Function"
*
* assert.deepStrictEqual(constFalse(), false)
* ```
*
* @since 2.0.0
*/
const constFalse = /* @__PURE__ */ constant(false);
/**
* A thunk that returns always `undefined`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { constUndefined } from "effect/Function"
*
* assert.deepStrictEqual(constUndefined(), undefined)
* ```
*
* @since 2.0.0
*/
const constUndefined$1 = /* @__PURE__ */ constant(void 0);
/**
* A thunk that returns always `void`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { constVoid } from "effect/Function"
*
* assert.deepStrictEqual(constVoid(), undefined)
* ```
*
* @since 2.0.0
*/
const constVoid$1 = constUndefined$1;
function pipe$3(a$1, ab, bc, cd, de, ef, fg, gh, hi) {
	switch (arguments.length) {
		case 1: return a$1;
		case 2: return ab(a$1);
		case 3: return bc(ab(a$1));
		case 4: return cd(bc(ab(a$1)));
		case 5: return de(cd(bc(ab(a$1))));
		case 6: return ef(de(cd(bc(ab(a$1)))));
		case 7: return fg(ef(de(cd(bc(ab(a$1))))));
		case 8: return gh(fg(ef(de(cd(bc(ab(a$1)))))));
		case 9: return hi(gh(fg(ef(de(cd(bc(ab(a$1))))))));
		default: {
			let ret = arguments[0];
			for (let i$1 = 1; i$1 < arguments.length; i$1++) ret = arguments[i$1](ret);
			return ret;
		}
	}
}

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Equivalence.js
/**
* @category constructors
* @since 2.0.0
*/
const make$48 = (isEquivalent) => (self, that) => self === that || isEquivalent(self, that);
const isStrictEquivalent = (x, y$1) => x === y$1;
/**
* Return an `Equivalence` that uses strict equality (===) to compare values.
*
* @since 2.0.0
* @category constructors
*/
const strict = () => isStrictEquivalent;
/**
* @category instances
* @since 2.0.0
*/
const number$2 = /* @__PURE__ */ strict();
/**
* @category instances
* @since 2.0.0
*/
const boolean$1 = /* @__PURE__ */ strict();
/**
* @category mapping
* @since 2.0.0
*/
const mapInput$1 = /* @__PURE__ */ dual$1(2, (self, f$1) => make$48((x, y$1) => self(f$1(x), f$1(y$1))));
/**
* @category combining
* @since 2.0.0
*/
const all$5 = (collection) => {
	return make$48((x, y$1) => {
		const len = Math.min(x.length, y$1.length);
		let collectionLength = 0;
		for (const equivalence$1 of collection) {
			if (collectionLength >= len) break;
			if (!equivalence$1(x[collectionLength], y$1[collectionLength])) return false;
			collectionLength++;
		}
		return true;
	});
};
/**
* Similar to `Promise.all` but operates on `Equivalence`s.
*
* ```ts skip-type-checking
* [Equivalence<A>, Equivalence<B>, ...] -> Equivalence<[A, B, ...]>
* ```
*
* Given a tuple of `Equivalence`s returns a new `Equivalence` that compares values of a tuple
* by applying each `Equivalence` to the corresponding element of the tuple.
*
* @category combinators
* @since 2.0.0
*/
const tuple$1 = (...elements) => all$5(elements);
/**
* Creates a new `Equivalence` for an array of values based on a given `Equivalence` for the elements of the array.
*
* @category combinators
* @since 2.0.0
*/
const array$2 = (item) => make$48((self, that) => {
	if (self.length !== that.length) return false;
	for (let i$1 = 0; i$1 < self.length; i$1++) if (!item(self[i$1], that[i$1])) return false;
	return true;
});

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/doNotation.js
/** @internal */
const let_$2 = (map$18) => dual$1(3, (self, name, f$1) => map$18(self, (a$1) => ({
	...a$1,
	[name]: f$1(a$1)
})));
/** @internal */
const bindTo$2 = (map$18) => dual$1(2, (self, name) => map$18(self, (a$1) => ({ [name]: a$1 })));
/** @internal */
const bind$2 = (map$18, flatMap$13) => dual$1(3, (self, name, f$1) => flatMap$13(self, (a$1) => map$18(f$1(a$1), (b$1) => ({
	...a$1,
	[name]: b$1
}))));

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/GlobalValue.js
/**
* The `GlobalValue` module ensures that a single instance of a value is created globally,
* even when modules are imported multiple times (e.g., due to mixing CommonJS and ESM builds)
* or during hot-reloading in development environments like Next.js or Remix.
*
* It achieves this by using a versioned global store, identified by a unique `Symbol` tied to
* the current version of the `effect` library. The store holds values that are keyed by an identifier,
* allowing the reuse of previously computed instances across imports or reloads.
*
* This pattern is particularly useful in scenarios where frequent reloading can cause services or
* single-instance objects to be recreated unnecessarily, such as in development environments with hot-reloading.
*
* @since 2.0.0
*/
const globalStoreId = `effect/GlobalValue`;
let globalStore;
/**
* Retrieves or computes a global value associated with the given `id`. If the value for this `id`
* has already been computed, it will be returned from the global store. If it does not exist yet,
* the provided `compute` function will be executed to compute the value, store it, and then return it.
*
* This ensures that even in cases where the module is imported multiple times (e.g., in mixed environments
* like CommonJS and ESM, or during hot-reloading in development), the value is computed only once and reused
* thereafter.
*
* @example
* ```ts
* import { globalValue } from "effect/GlobalValue"
*
* // This cache will persist as long as the module is running,
* // even if reloaded or imported elsewhere
* const myCache = globalValue(
*   Symbol.for("myCache"),
*   () => new WeakMap<object, number>()
* )
* ```
*
* @since 2.0.0
*/
const globalValue = (id$2, compute) => {
	if (!globalStore) {
		globalThis[globalStoreId] ??= /* @__PURE__ */ new Map();
		globalStore = globalThis[globalStoreId];
	}
	if (!globalStore.has(id$2)) globalStore.set(id$2, compute());
	return globalStore.get(id$2);
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Predicate.js
/**
* A refinement that checks if a value is a `string`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isString } from "effect/Predicate"
*
* assert.strictEqual(isString("hello"), true)
* assert.strictEqual(isString(""), true)
*
* assert.strictEqual(isString(123), false)
* assert.strictEqual(isString(null), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isString = (input) => typeof input === "string";
/**
* A refinement that checks if a value is a `number`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isNumber } from "effect/Predicate"
*
* assert.strictEqual(isNumber(123), true)
* assert.strictEqual(isNumber(0), true)
* assert.strictEqual(isNumber(-1.5), true)
* assert.strictEqual(isNumber(NaN), true)
*
* assert.strictEqual(isNumber("123"), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isNumber = (input) => typeof input === "number";
/**
* A refinement that checks if a value is a `boolean`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isBoolean } from "effect/Predicate"
*
* assert.strictEqual(isBoolean(true), true)
* assert.strictEqual(isBoolean(false), true)
*
* assert.strictEqual(isBoolean("true"), false)
* assert.strictEqual(isBoolean(0), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isBoolean$1 = (input) => typeof input === "boolean";
/**
* A refinement that checks if a value is a `bigint`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isBigInt } from "effect/Predicate"
*
* assert.strictEqual(isBigInt(1n), true)
*
* assert.strictEqual(isBigInt(1), false)
* assert.strictEqual(isBigInt("1"), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isBigInt = (input) => typeof input === "bigint";
/**
* A refinement that checks if a value is a `symbol`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isSymbol } from "effect/Predicate"
*
* assert.strictEqual(isSymbol(Symbol.for("a")), true)
*
* assert.strictEqual(isSymbol("a"), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isSymbol = (input) => typeof input === "symbol";
/**
* A refinement that checks if a value is a `Function`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isFunction } from "effect/Predicate"
*
* assert.strictEqual(isFunction(() => {}), true)
* assert.strictEqual(isFunction(isFunction), true)
*
* assert.strictEqual(isFunction("function"), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isFunction = isFunction$1;
/**
* A refinement that checks if a value is `undefined`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isUndefined } from "effect/Predicate"
*
* assert.strictEqual(isUndefined(undefined), true)
*
* assert.strictEqual(isUndefined(null), false)
* assert.strictEqual(isUndefined("undefined"), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isUndefined = (input) => input === void 0;
/**
* A refinement that always returns `false`. The type is narrowed to `never`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isNever } from "effect/Predicate"
*
* assert.strictEqual(isNever(1), false)
* assert.strictEqual(isNever(null), false)
* assert.strictEqual(isNever({}), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isNever = (_$1) => false;
/**
* Checks if the input is an object or an array.
* @internal
*/
const isRecordOrArray = (input) => typeof input === "object" && input !== null;
/**
* A refinement that checks if a value is an `object`. Note that in JavaScript,
* arrays and functions are also considered objects.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isObject } from "effect/Predicate"
*
* assert.strictEqual(isObject({}), true)
* assert.strictEqual(isObject([]), true)
* assert.strictEqual(isObject(() => {}), true)
*
* assert.strictEqual(isObject(null), false)
* assert.strictEqual(isObject("hello"), false)
* ```
*
* @category guards
* @since 2.0.0
* @see isRecord to check for plain objects (excluding arrays and functions).
*/
const isObject = (input) => isRecordOrArray(input) || isFunction(input);
/**
* A refinement that checks if a value is an object-like value and has a specific property key.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { hasProperty } from "effect/Predicate"
*
* assert.strictEqual(hasProperty({ a: 1 }, "a"), true)
* assert.strictEqual(hasProperty({ a: 1 }, "b"), false)
*
* const value: unknown = { name: "Alice" };
* if (hasProperty(value, "name")) {
*   // The type of `value` is narrowed to `{ name: unknown }`
*   // and we can safely access `value.name`
*   console.log(value.name)
* }
* ```
*
* @category guards
* @since 2.0.0
*/
const hasProperty = /* @__PURE__ */ dual$1(2, (self, property) => isObject(self) && property in self);
/**
* A refinement that checks if a value is an object with a `_tag` property
* that matches the given tag. This is a powerful tool for working with
* discriminated union types.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isTagged } from "effect/Predicate"
*
* type Shape = { _tag: "circle"; radius: number } | { _tag: "square"; side: number }
*
* const isCircle = isTagged("circle")
*
* const shape1: Shape = { _tag: "circle", radius: 10 }
* const shape2: Shape = { _tag: "square", side: 5 }
*
* assert.strictEqual(isCircle(shape1), true)
* assert.strictEqual(isCircle(shape2), false)
*
* if (isCircle(shape1)) {
*   // shape1 is now narrowed to { _tag: "circle"; radius: number }
*   assert.strictEqual(shape1.radius, 10)
* }
* ```
*
* @category guards
* @since 2.0.0
*/
const isTagged = /* @__PURE__ */ dual$1(2, (self, tag$1) => hasProperty(self, "_tag") && self["_tag"] === tag$1);
/**
* A refinement that checks if a value is either `null` or `undefined`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isNullable } from "effect/Predicate"
*
* assert.strictEqual(isNullable(null), true)
* assert.strictEqual(isNullable(undefined), true)
*
* assert.strictEqual(isNullable(0), false)
* assert.strictEqual(isNullable(""), false)
* ```
*
* @category guards
* @since 2.0.0
* @see isNotNullable
*/
const isNullable = (input) => input === null || input === void 0;
/**
* A refinement that checks if a value is neither `null` nor `undefined`.
* The type is narrowed to `NonNullable<A>`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isNotNullable } from "effect/Predicate"
*
* assert.strictEqual(isNotNullable(0), true)
* assert.strictEqual(isNotNullable("hello"), true)
*
* assert.strictEqual(isNotNullable(null), false)
* assert.strictEqual(isNotNullable(undefined), false)
* ```
*
* @category guards
* @since 2.0.0
* @see isNullable
*/
const isNotNullable = (input) => input !== null && input !== void 0;
/**
* A refinement that checks if a value is a `Uint8Array`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isUint8Array } from "effect/Predicate"
*
* assert.strictEqual(isUint8Array(new Uint8Array()), true)
*
* assert.strictEqual(isUint8Array(new Uint16Array()), false)
* assert.strictEqual(isUint8Array([1, 2, 3]), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isUint8Array = (input) => input instanceof Uint8Array;
/**
* A refinement that checks if a value is a `Date` object.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isDate } from "effect/Predicate"
*
* assert.strictEqual(isDate(new Date()), true)
*
* assert.strictEqual(isDate(Date.now()), false) // `Date.now()` returns a number
* assert.strictEqual(isDate("2023-01-01"), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isDate = (input) => input instanceof Date;
/**
* A refinement that checks if a value is an `Iterable`.
* Many built-in types are iterable, such as `Array`, `string`, `Map`, and `Set`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isIterable } from "effect/Predicate"
*
* assert.strictEqual(isIterable([]), true)
* assert.strictEqual(isIterable("hello"), true)
* assert.strictEqual(isIterable(new Set()), true)
*
* assert.strictEqual(isIterable({}), false)
* assert.strictEqual(isIterable(123), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isIterable = (input) => typeof input === "string" || hasProperty(input, Symbol.iterator);
/**
* A refinement that checks if a value is a record (i.e., a plain object).
* This check returns `false` for arrays, `null`, and functions.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isRecord } from "effect/Predicate"
*
* assert.strictEqual(isRecord({}), true)
* assert.strictEqual(isRecord({ a: 1 }), true)
*
* assert.strictEqual(isRecord([]), false)
* assert.strictEqual(isRecord(new Date()), false)
* assert.strictEqual(isRecord(null), false)
* assert.strictEqual(isRecord(() => null), false)
* ```
*
* @category guards
* @since 2.0.0
* @see isObject
*/
const isRecord = (input) => isRecordOrArray(input) && !Array.isArray(input);
/**
* A refinement that checks if a value is `PromiseLike`. It performs a duck-typing
* check for a `.then` method.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isPromiseLike } from "effect/Predicate"
*
* assert.strictEqual(isPromiseLike(Promise.resolve(1)), true)
* assert.strictEqual(isPromiseLike({ then: () => {} }), true)
*
* assert.strictEqual(isPromiseLike({}), false)
* ```
*
* @category guards
* @since 2.0.0
* @see isPromise
*/
const isPromiseLike = (input) => hasProperty(input, "then") && isFunction(input.then);
/**
* A refinement that checks if a value is a `RegExp`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Predicate } from "effect"
*
* assert.strictEqual(Predicate.isRegExp(/a/), true)
* assert.strictEqual(Predicate.isRegExp(new RegExp("a")), true)
*
* assert.strictEqual(Predicate.isRegExp("/a/"), false)
* ```
*
* @category guards
* @since 3.9.0
*/
const isRegExp$1 = (input) => input instanceof RegExp;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/errors.js
/**
* @since 2.0.0
*/
/** @internal */
const getBugErrorMessage = (message) => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Utils.js
/**
* @category symbols
* @since 2.0.0
*/
const GenKindTypeId = /* @__PURE__ */ Symbol.for("effect/Gen/GenKind");
/**
* @category constructors
* @since 2.0.0
*/
var GenKindImpl = class {
	value;
	constructor(value) {
		this.value = value;
	}
	/**
	* @since 2.0.0
	*/
	get _F() {
		return identity$2;
	}
	/**
	* @since 2.0.0
	*/
	get _R() {
		return (_$1) => _$1;
	}
	/**
	* @since 2.0.0
	*/
	get _O() {
		return (_$1) => _$1;
	}
	/**
	* @since 2.0.0
	*/
	get _E() {
		return (_$1) => _$1;
	}
	/**
	* @since 2.0.0
	*/
	[GenKindTypeId] = GenKindTypeId;
	/**
	* @since 2.0.0
	*/
	[Symbol.iterator]() {
		return new SingleShotGen(this);
	}
};
/**
* @category constructors
* @since 2.0.0
*/
var SingleShotGen = class SingleShotGen {
	self;
	called = false;
	constructor(self) {
		this.self = self;
	}
	/**
	* @since 2.0.0
	*/
	next(a$1) {
		return this.called ? {
			value: a$1,
			done: true
		} : (this.called = true, {
			value: this.self,
			done: false
		});
	}
	/**
	* @since 2.0.0
	*/
	return(a$1) {
		return {
			value: a$1,
			done: true
		};
	}
	/**
	* @since 2.0.0
	*/
	throw(e) {
		throw e;
	}
	/**
	* @since 2.0.0
	*/
	[Symbol.iterator]() {
		return new SingleShotGen(this.self);
	}
};
const defaultIncHi = 335903614;
const defaultIncLo = 4150755663;
const MUL_HI = 1481765933;
const MUL_LO = 1284865837;
const BIT_53 = 9007199254740992;
const BIT_27 = 134217728;
/**
* PCG is a family of simple fast space-efficient statistically good algorithms
* for random number generation. Unlike many general-purpose RNGs, they are also
* hard to predict.
*
* @category model
* @since 2.0.0
*/
var PCGRandom = class {
	_state;
	constructor(seedHi, seedLo, incHi, incLo) {
		if (isNullable(seedLo) && isNullable(seedHi)) {
			seedLo = Math.random() * 4294967295 >>> 0;
			seedHi = 0;
		} else if (isNullable(seedLo)) {
			seedLo = seedHi;
			seedHi = 0;
		}
		if (isNullable(incLo) && isNullable(incHi)) {
			incLo = this._state ? this._state[3] : defaultIncLo;
			incHi = this._state ? this._state[2] : defaultIncHi;
		} else if (isNullable(incLo)) {
			incLo = incHi;
			incHi = 0;
		}
		this._state = new Int32Array([
			0,
			0,
			incHi >>> 0,
			((incLo || 0) | 1) >>> 0
		]);
		this._next();
		add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
		this._next();
		return this;
	}
	/**
	* Returns a copy of the internal state of this random number generator as a
	* JavaScript Array.
	*
	* @category getters
	* @since 2.0.0
	*/
	getState() {
		return [
			this._state[0],
			this._state[1],
			this._state[2],
			this._state[3]
		];
	}
	/**
	* Restore state previously retrieved using `getState()`.
	*
	* @since 2.0.0
	*/
	setState(state) {
		this._state[0] = state[0];
		this._state[1] = state[1];
		this._state[2] = state[2];
		this._state[3] = state[3] | 1;
	}
	/**
	* Get a uniformly distributed 32 bit integer between [0, max).
	*
	* @category getter
	* @since 2.0.0
	*/
	integer(max$4) {
		return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max$4;
	}
	/**
	* Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with
	* 53 bits of precision (every bit of the mantissa is randomized).
	*
	* @category getters
	* @since 2.0.0
	*/
	number() {
		const hi = (this._next() & 67108863) * 1;
		const lo = (this._next() & 134217727) * 1;
		return (hi * BIT_27 + lo) / BIT_53;
	}
	/** @internal */
	_next() {
		const oldHi = this._state[0] >>> 0;
		const oldLo = this._state[1] >>> 0;
		mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
		add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
		let xsHi = oldHi >>> 18;
		let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
		xsHi = (xsHi ^ oldHi) >>> 0;
		xsLo = (xsLo ^ oldLo) >>> 0;
		const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
		const rot = oldHi >>> 27;
		const rot2 = (-rot >>> 0 & 31) >>> 0;
		return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
	}
};
function mul64(out, aHi, aLo, bHi, bLo) {
	let c1 = (aLo >>> 16) * (bLo & 65535) >>> 0;
	let c0 = (aLo & 65535) * (bLo >>> 16) >>> 0;
	let lo = (aLo & 65535) * (bLo & 65535) >>> 0;
	let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
	c0 = c0 << 16 >>> 0;
	lo = lo + c0 >>> 0;
	if (lo >>> 0 < c0 >>> 0) hi = hi + 1 >>> 0;
	c1 = c1 << 16 >>> 0;
	lo = lo + c1 >>> 0;
	if (lo >>> 0 < c1 >>> 0) hi = hi + 1 >>> 0;
	hi = hi + Math.imul(aLo, bHi) >>> 0;
	hi = hi + Math.imul(aHi, bLo) >>> 0;
	out[0] = hi;
	out[1] = lo;
}
function add64(out, aHi, aLo, bHi, bLo) {
	let hi = aHi + bHi >>> 0;
	const lo = aLo + bLo >>> 0;
	if (lo >>> 0 < aLo >>> 0) hi = hi + 1 | 0;
	out[0] = hi;
	out[1] = lo;
}
/**
* @since 3.0.6
*/
const YieldWrapTypeId = /* @__PURE__ */ Symbol.for("effect/Utils/YieldWrap");
/**
* @since 3.0.6
*/
var YieldWrap = class {
	/**
	* @since 3.0.6
	*/
	#value;
	constructor(value) {
		this.#value = value;
	}
	/**
	* @since 3.0.6
	*/
	[YieldWrapTypeId]() {
		return this.#value;
	}
};
/**
* @since 3.0.6
*/
function yieldWrapGet(self) {
	if (typeof self === "object" && self !== null && YieldWrapTypeId in self) return self[YieldWrapTypeId]();
	throw new Error(getBugErrorMessage("yieldWrapGet"));
}
/**
* Note: this is an experimental feature made available to allow custom matchers in tests, not to be directly used yet in user code
*
* @since 3.1.1
* @status experimental
* @category modifiers
*/
const structuralRegionState = /* @__PURE__ */ globalValue("effect/Utils/isStructuralRegion", () => ({
	enabled: false,
	tester: void 0
}));
const standard = { effect_internal_function: (body) => {
	return body();
} };
const forced = { effect_internal_function: (body) => {
	try {
		return body();
	} finally {}
} };
const isNotOptimizedAway = /* @__PURE__ */ standard.effect_internal_function(() => (/* @__PURE__ */ new Error()).stack)?.includes("effect_internal_function") === true;
/**
* @since 3.2.2
* @status experimental
* @category tracing
*/
const internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function;
const genConstructor = function* () {}.constructor;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Hash.js
/** @internal */
const randomHashCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Hash/randomHashCache"), () => /* @__PURE__ */ new WeakMap());
/**
* @since 2.0.0
* @category symbols
*/
const symbol$1 = /* @__PURE__ */ Symbol.for("effect/Hash");
/**
* @since 2.0.0
* @category hashing
*/
const hash = (self) => {
	if (structuralRegionState.enabled === true) return 0;
	switch (typeof self) {
		case "number": return number$1(self);
		case "bigint": return string(self.toString(10));
		case "boolean": return string(String(self));
		case "symbol": return string(String(self));
		case "string": return string(self);
		case "undefined": return string("undefined");
		case "function":
		case "object": if (self === null) return string("null");
		else if (self instanceof Date) return hash(self.toISOString());
		else if (self instanceof URL) return hash(self.href);
		else if (isHash(self)) return self[symbol$1]();
		else return random$2(self);
		default: throw new Error(`BUG: unhandled typeof ${typeof self} - please report an issue at https://github.com/Effect-TS/effect/issues`);
	}
};
/**
* @since 2.0.0
* @category hashing
*/
const random$2 = (self) => {
	if (!randomHashCache.has(self)) randomHashCache.set(self, number$1(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
	return randomHashCache.get(self);
};
/**
* @since 2.0.0
* @category hashing
*/
const combine$11 = (b$1) => (self) => self * 53 ^ b$1;
/**
* @since 2.0.0
* @category hashing
*/
const optimize = (n$1) => n$1 & 3221225471 | n$1 >>> 1 & 1073741824;
/**
* @since 2.0.0
* @category guards
*/
const isHash = (u$1) => hasProperty(u$1, symbol$1);
/**
* @since 2.0.0
* @category hashing
*/
const number$1 = (n$1) => {
	if (n$1 !== n$1 || n$1 === Infinity) return 0;
	let h = n$1 | 0;
	if (h !== n$1) h ^= n$1 * 4294967295;
	while (n$1 > 4294967295) h ^= n$1 /= 4294967295;
	return optimize(h);
};
/**
* @since 2.0.0
* @category hashing
*/
const string = (str) => {
	let h = 5381, i$1 = str.length;
	while (i$1) h = h * 33 ^ str.charCodeAt(--i$1);
	return optimize(h);
};
/**
* @since 2.0.0
* @category hashing
*/
const structureKeys = (o$1, keys$5) => {
	let h = 12289;
	for (let i$1 = 0; i$1 < keys$5.length; i$1++) h ^= pipe$3(string(keys$5[i$1]), combine$11(hash(o$1[keys$5[i$1]])));
	return optimize(h);
};
/**
* @since 2.0.0
* @category hashing
*/
const structure = (o$1) => structureKeys(o$1, Object.keys(o$1));
/**
* @since 2.0.0
* @category hashing
*/
const array$1 = (arr) => {
	let h = 6151;
	for (let i$1 = 0; i$1 < arr.length; i$1++) h = pipe$3(h, combine$11(hash(arr[i$1])));
	return optimize(h);
};
/**
* @since 2.0.0
* @category hashing
*/
const cached$2 = function() {
	if (arguments.length === 1) {
		const self$1 = arguments[0];
		return function(hash$2) {
			Object.defineProperty(self$1, symbol$1, {
				value() {
					return hash$2;
				},
				enumerable: false
			});
			return hash$2;
		};
	}
	const self = arguments[0];
	const hash$1 = arguments[1];
	Object.defineProperty(self, symbol$1, {
		value() {
			return hash$1;
		},
		enumerable: false
	});
	return hash$1;
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Equal.js
/**
* @since 2.0.0
* @category symbols
*/
const symbol = /* @__PURE__ */ Symbol.for("effect/Equal");
function equals() {
	if (arguments.length === 1) return (self) => compareBoth(self, arguments[0]);
	return compareBoth(arguments[0], arguments[1]);
}
function compareBoth(self, that) {
	if (self === that) return true;
	const selfType = typeof self;
	if (selfType !== typeof that) return false;
	if (selfType === "object" || selfType === "function") {
		if (self !== null && that !== null) {
			if (isEqual(self) && isEqual(that)) if (hash(self) === hash(that) && self[symbol](that)) return true;
			else return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
			else if (self instanceof Date && that instanceof Date) return self.toISOString() === that.toISOString();
			else if (self instanceof URL && that instanceof URL) return self.href === that.href;
		}
		if (structuralRegionState.enabled) {
			if (Array.isArray(self) && Array.isArray(that)) return self.length === that.length && self.every((v, i$1) => compareBoth(v, that[i$1]));
			if (Object.getPrototypeOf(self) === Object.prototype && Object.getPrototypeOf(self) === Object.prototype) {
				const keysSelf = Object.keys(self);
				const keysThat = Object.keys(that);
				if (keysSelf.length === keysThat.length) {
					for (const key of keysSelf) if (!(key in that && compareBoth(self[key], that[key]))) return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
					return true;
				}
			}
			return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
		}
	}
	return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
}
/**
* @since 2.0.0
* @category guards
*/
const isEqual = (u$1) => hasProperty(u$1, symbol);
/**
* @since 2.0.0
* @category instances
*/
const equivalence = () => equals;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Inspectable.js
/**
* @since 2.0.0
* @category symbols
*/
const NodeInspectSymbol = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
/**
* @since 2.0.0
*/
const toJSON = (x) => {
	try {
		if (hasProperty(x, "toJSON") && isFunction(x["toJSON"]) && x["toJSON"].length === 0) return x.toJSON();
		else if (Array.isArray(x)) return x.map(toJSON);
	} catch {
		return {};
	}
	return redact(x);
};
/**
* @since 2.0.0
*/
const format = (x) => JSON.stringify(x, null, 2);
/**
* @since 2.0.0
*/
const BaseProto = {
	toJSON() {
		return toJSON(this);
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	toString() {
		return format(this.toJSON());
	}
};
/**
* @since 2.0.0
*/
var Class$4 = class {
	/**
	* @since 2.0.0
	*/
	[NodeInspectSymbol]() {
		return this.toJSON();
	}
	/**
	* @since 2.0.0
	*/
	toString() {
		return format(this.toJSON());
	}
};
/**
* @since 2.0.0
*/
const toStringUnknown = (u$1, whitespace = 2) => {
	if (typeof u$1 === "string") return u$1;
	try {
		return typeof u$1 === "object" ? stringifyCircular(u$1, whitespace) : String(u$1);
	} catch {
		return String(u$1);
	}
};
/**
* @since 2.0.0
*/
const stringifyCircular = (obj, whitespace) => {
	let cache = [];
	const retVal = JSON.stringify(obj, (_key, value) => typeof value === "object" && value !== null ? cache.includes(value) ? void 0 : cache.push(value) && (redactableState.fiberRefs !== void 0 && isRedactable(value) ? value[symbolRedactable](redactableState.fiberRefs) : value) : value, whitespace);
	cache = void 0;
	return retVal;
};
/**
* @since 3.10.0
* @category redactable
*/
const symbolRedactable = /* @__PURE__ */ Symbol.for("effect/Inspectable/Redactable");
/**
* @since 3.10.0
* @category redactable
*/
const isRedactable = (u$1) => typeof u$1 === "object" && u$1 !== null && symbolRedactable in u$1;
const redactableState = /* @__PURE__ */ globalValue("effect/Inspectable/redactableState", () => ({ fiberRefs: void 0 }));
/**
* @since 3.10.0
* @category redactable
*/
const withRedactableContext = (context$2, f$1) => {
	const prev = redactableState.fiberRefs;
	redactableState.fiberRefs = context$2;
	try {
		return f$1();
	} finally {
		redactableState.fiberRefs = prev;
	}
};
/**
* @since 3.10.0
* @category redactable
*/
const redact = (u$1) => {
	if (isRedactable(u$1) && redactableState.fiberRefs !== void 0) return u$1[symbolRedactable](redactableState.fiberRefs);
	return u$1;
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Pipeable.js
/**
* @since 2.0.0
*/
/**
* @since 2.0.0
*/
const pipeArguments = (self, args$2) => {
	switch (args$2.length) {
		case 0: return self;
		case 1: return args$2[0](self);
		case 2: return args$2[1](args$2[0](self));
		case 3: return args$2[2](args$2[1](args$2[0](self)));
		case 4: return args$2[3](args$2[2](args$2[1](args$2[0](self))));
		case 5: return args$2[4](args$2[3](args$2[2](args$2[1](args$2[0](self)))));
		case 6: return args$2[5](args$2[4](args$2[3](args$2[2](args$2[1](args$2[0](self))))));
		case 7: return args$2[6](args$2[5](args$2[4](args$2[3](args$2[2](args$2[1](args$2[0](self)))))));
		case 8: return args$2[7](args$2[6](args$2[5](args$2[4](args$2[3](args$2[2](args$2[1](args$2[0](self))))))));
		case 9: return args$2[8](args$2[7](args$2[6](args$2[5](args$2[4](args$2[3](args$2[2](args$2[1](args$2[0](self)))))))));
		default: {
			let ret = self;
			for (let i$1 = 0, len = args$2.length; i$1 < len; i$1++) ret = args$2[i$1](ret);
			return ret;
		}
	}
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/opCodes/effect.js
/** @internal */
const OP_ASYNC = "Async";
/** @internal */
const OP_COMMIT = "Commit";
/** @internal */
const OP_FAILURE = "Failure";
/** @internal */
const OP_ON_FAILURE = "OnFailure";
/** @internal */
const OP_ON_SUCCESS = "OnSuccess";
/** @internal */
const OP_ON_SUCCESS_AND_FAILURE = "OnSuccessAndFailure";
/** @internal */
const OP_SUCCESS = "Success";
/** @internal */
const OP_SYNC = "Sync";
/** @internal */
const OP_TAG = "Tag";
/** @internal */
const OP_UPDATE_RUNTIME_FLAGS = "UpdateRuntimeFlags";
/** @internal */
const OP_WHILE = "While";
/** @internal */
const OP_ITERATOR = "Iterator";
/** @internal */
const OP_WITH_RUNTIME = "WithRuntime";
/** @internal */
const OP_YIELD = "Yield";
/** @internal */
const OP_REVERT_FLAGS = "RevertFlags";

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/version.js
let moduleVersion = "3.18.4";
const getCurrentVersion = () => moduleVersion;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/effectable.js
/** @internal */
const EffectTypeId$3 = /* @__PURE__ */ Symbol.for("effect/Effect");
/** @internal */
const StreamTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Stream");
/** @internal */
const SinkTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Sink");
/** @internal */
const ChannelTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Channel");
/** @internal */
const effectVariance = {
	_R: (_$1) => _$1,
	_E: (_$1) => _$1,
	_A: (_$1) => _$1,
	_V: /* @__PURE__ */ getCurrentVersion()
};
const sinkVariance = {
	_A: (_$1) => _$1,
	_In: (_$1) => _$1,
	_L: (_$1) => _$1,
	_E: (_$1) => _$1,
	_R: (_$1) => _$1
};
const channelVariance = {
	_Env: (_$1) => _$1,
	_InErr: (_$1) => _$1,
	_InElem: (_$1) => _$1,
	_InDone: (_$1) => _$1,
	_OutErr: (_$1) => _$1,
	_OutElem: (_$1) => _$1,
	_OutDone: (_$1) => _$1
};
/** @internal */
const EffectPrototype$1 = {
	[EffectTypeId$3]: effectVariance,
	[StreamTypeId$1]: effectVariance,
	[SinkTypeId$1]: sinkVariance,
	[ChannelTypeId$1]: channelVariance,
	[symbol](that) {
		return this === that;
	},
	[symbol$1]() {
		return cached$2(this, random$2(this));
	},
	[Symbol.iterator]() {
		return new SingleShotGen(new YieldWrap(this));
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const StructuralPrototype = {
	[symbol$1]() {
		return cached$2(this, structure(this));
	},
	[symbol](that) {
		const selfKeys = Object.keys(this);
		const thatKeys = Object.keys(that);
		if (selfKeys.length !== thatKeys.length) return false;
		for (const key of selfKeys) if (!(key in that && equals(this[key], that[key]))) return false;
		return true;
	}
};
/** @internal */
const CommitPrototype$1 = {
	...EffectPrototype$1,
	_op: OP_COMMIT
};
/** @internal */
const StructuralCommitPrototype$1 = {
	...CommitPrototype$1,
	...StructuralPrototype
};
/** @internal */
const Base$1 = /* @__PURE__ */ function() {
	function Base$2() {}
	Base$2.prototype = CommitPrototype$1;
	return Base$2;
}();
/** @internal */
const StructuralBase$1 = /* @__PURE__ */ function() {
	function Base$2() {}
	Base$2.prototype = StructuralCommitPrototype$1;
	return Base$2;
}();

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/option.js
const TypeId$19 = /* @__PURE__ */ Symbol.for("effect/Option");
const CommonProto$1 = {
	...EffectPrototype$1,
	[TypeId$19]: { _A: (_$1) => _$1 },
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	toString() {
		return format(this.toJSON());
	}
};
const SomeProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto$1), {
	_tag: "Some",
	_op: "Some",
	[symbol](that) {
		return isOption$1(that) && isSome$1(that) && equals(this.value, that.value);
	},
	[symbol$1]() {
		return cached$2(this, combine$11(hash(this._tag))(hash(this.value)));
	},
	toJSON() {
		return {
			_id: "Option",
			_tag: this._tag,
			value: toJSON(this.value)
		};
	}
});
const NoneHash = /* @__PURE__ */ hash("None");
const NoneProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto$1), {
	_tag: "None",
	_op: "None",
	[symbol](that) {
		return isOption$1(that) && isNone$3(that);
	},
	[symbol$1]() {
		return NoneHash;
	},
	toJSON() {
		return {
			_id: "Option",
			_tag: this._tag
		};
	}
});
/** @internal */
const isOption$1 = (input) => hasProperty(input, TypeId$19);
/** @internal */
const isNone$3 = (fa) => fa._tag === "None";
/** @internal */
const isSome$1 = (fa) => fa._tag === "Some";
/** @internal */
const none$8 = /* @__PURE__ */ Object.create(NoneProto);
/** @internal */
const some$5 = (value) => {
	const a$1 = Object.create(SomeProto);
	a$1.value = value;
	return a$1;
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/either.js
/**
* @internal
*/
const TypeId$18 = /* @__PURE__ */ Symbol.for("effect/Either");
const CommonProto = {
	...EffectPrototype$1,
	[TypeId$18]: { _R: (_$1) => _$1 },
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	toString() {
		return format(this.toJSON());
	}
};
const RightProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
	_tag: "Right",
	_op: "Right",
	[symbol](that) {
		return isEither$2(that) && isRight$1(that) && equals(this.right, that.right);
	},
	[symbol$1]() {
		return combine$11(hash(this._tag))(hash(this.right));
	},
	toJSON() {
		return {
			_id: "Either",
			_tag: this._tag,
			right: toJSON(this.right)
		};
	}
});
const LeftProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
	_tag: "Left",
	_op: "Left",
	[symbol](that) {
		return isEither$2(that) && isLeft$1(that) && equals(this.left, that.left);
	},
	[symbol$1]() {
		return combine$11(hash(this._tag))(hash(this.left));
	},
	toJSON() {
		return {
			_id: "Either",
			_tag: this._tag,
			left: toJSON(this.left)
		};
	}
});
/** @internal */
const isEither$2 = (input) => hasProperty(input, TypeId$18);
/** @internal */
const isLeft$1 = (ma) => ma._tag === "Left";
/** @internal */
const isRight$1 = (ma) => ma._tag === "Right";
/** @internal */
const left$1 = (left$2) => {
	const a$1 = Object.create(LeftProto);
	a$1.left = left$2;
	return a$1;
};
/** @internal */
const right$1 = (right$2) => {
	const a$1 = Object.create(RightProto);
	a$1.right = right$2;
	return a$1;
};
/** @internal */
const getLeft$2 = (self) => isRight$1(self) ? none$8 : some$5(self.left);
/** @internal */
const getRight$2 = (self) => isLeft$1(self) ? none$8 : some$5(self.right);
/** @internal */
const fromOption$4 = /* @__PURE__ */ dual$1(2, (self, onNone) => isNone$3(self) ? left$1(onNone()) : right$1(self.value));

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Either.js
/**
* @category symbols
* @since 2.0.0
*/
const TypeId$17 = TypeId$18;
/**
* Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias
* of this structure.
*
* @category constructors
* @since 2.0.0
*/
const right = right$1;
/**
* Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this
* structure.
*
* @category constructors
* @since 2.0.0
*/
const left = left$1;
/**
* @example
* ```ts
* import * as assert from "node:assert"
* import { Either, Option } from "effect"
*
* assert.deepStrictEqual(Either.fromOption(Option.some(1), () => 'error'), Either.right(1))
* assert.deepStrictEqual(Either.fromOption(Option.none(), () => 'error'), Either.left('error'))
* ```
*
* @category constructors
* @since 2.0.0
*/
const fromOption$3 = fromOption$4;
const try_$2 = (evaluate$1) => {
	if (isFunction(evaluate$1)) try {
		return right(evaluate$1());
	} catch (e) {
		return left(e);
	}
	else try {
		return right(evaluate$1.try());
	} catch (e) {
		return left(evaluate$1.catch(e));
	}
};
/**
* Tests if a value is a `Either`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Either } from "effect"
*
* assert.deepStrictEqual(Either.isEither(Either.right(1)), true)
* assert.deepStrictEqual(Either.isEither(Either.left("a")), true)
* assert.deepStrictEqual(Either.isEither({ right: 1 }), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isEither$1 = isEither$2;
/**
* Determine if a `Either` is a `Left`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Either } from "effect"
*
* assert.deepStrictEqual(Either.isLeft(Either.right(1)), false)
* assert.deepStrictEqual(Either.isLeft(Either.left("a")), true)
* ```
*
* @category guards
* @since 2.0.0
*/
const isLeft = isLeft$1;
/**
* Determine if a `Either` is a `Right`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Either } from "effect"
*
* assert.deepStrictEqual(Either.isRight(Either.right(1)), true)
* assert.deepStrictEqual(Either.isRight(Either.left("a")), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isRight = isRight$1;
/**
* Converts a `Either` to an `Option` discarding the `Left`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Either, Option } from "effect"
*
* assert.deepStrictEqual(Either.getRight(Either.right('ok')), Option.some('ok'))
* assert.deepStrictEqual(Either.getRight(Either.left('err')), Option.none())
* ```
*
* @category getters
* @since 2.0.0
*/
const getRight$1 = getRight$2;
/**
* Converts a `Either` to an `Option` discarding the value.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Either, Option } from "effect"
*
* assert.deepStrictEqual(Either.getLeft(Either.right('ok')), Option.none())
* assert.deepStrictEqual(Either.getLeft(Either.left('err')), Option.some('err'))
* ```
*
* @category getters
* @since 2.0.0
*/
const getLeft$1 = getLeft$2;
/**
* Maps the `Left` side of an `Either` value to a new `Either` value.
*
* @category mapping
* @since 2.0.0
*/
const mapLeft = /* @__PURE__ */ dual$1(2, (self, f$1) => isLeft(self) ? left(f$1(self.left)) : right(self.right));
/**
* Maps the `Right` side of an `Either` value to a new `Either` value.
*
* @category mapping
* @since 2.0.0
*/
const map$17 = /* @__PURE__ */ dual$1(2, (self, f$1) => isRight(self) ? right(f$1(self.right)) : left(self.left));
/**
* Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the `onLeft function,
* if the value is a `Right` the inner value is applied to the `onRight` function.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { pipe, Either } from "effect"
*
* const onLeft  = (strings: ReadonlyArray<string>): string => `strings: ${strings.join(', ')}`
*
* const onRight = (value: number): string => `Ok: ${value}`
*
* assert.deepStrictEqual(pipe(Either.right(1), Either.match({ onLeft, onRight })), 'Ok: 1')
* assert.deepStrictEqual(
*   pipe(Either.left(['string 1', 'string 2']), Either.match({ onLeft, onRight })),
*   'strings: string 1, string 2'
* )
* ```
*
* @category pattern matching
* @since 2.0.0
*/
const match$12 = /* @__PURE__ */ dual$1(2, (self, { onLeft, onRight }) => isLeft(self) ? onLeft(self.left) : onRight(self.right));
/**
* @category getters
* @since 2.0.0
*/
const merge$6 = /* @__PURE__ */ match$12({
	onLeft: identity$2,
	onRight: identity$2
});
/**
* Extracts the value of an `Either` or throws if the `Either` is `Left`.
*
* If a default error is sufficient for your use case and you don't need to configure the thrown error, see {@link getOrThrow}.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Either } from "effect"
*
* assert.deepStrictEqual(
*   Either.getOrThrowWith(Either.right(1), () => new Error('Unexpected Left')),
*   1
* )
* assert.throws(() => Either.getOrThrowWith(Either.left("error"), () => new Error('Unexpected Left')))
* ```
*
* @category getters
* @since 2.0.0
*/
const getOrThrowWith$1 = /* @__PURE__ */ dual$1(2, (self, onLeft) => {
	if (isRight(self)) return self.right;
	throw onLeft(self.left);
});
/**
* Extracts the value of an `Either` or throws if the `Either` is `Left`.
*
* The thrown error is a default error. To configure the error thrown, see  {@link getOrThrowWith}.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Either } from "effect"
*
* assert.deepStrictEqual(Either.getOrThrow(Either.right(1)), 1)
* assert.throws(() => Either.getOrThrow(Either.left("error")))
* ```
*
* @throws `Error("getOrThrow called on a Left")`
*
* @category getters
* @since 2.0.0
*/
const getOrThrow$1 = /* @__PURE__ */ getOrThrowWith$1(() => /* @__PURE__ */ new Error("getOrThrow called on a Left"));

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/array.js
/**
* @since 2.0.0
*/
/** @internal */
const isNonEmptyArray$1 = (self) => self.length > 0;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Order.js
/**
* @category constructors
* @since 2.0.0
*/
const make$47 = (compare$1) => (self, that) => self === that ? 0 : compare$1(self, that);
/**
* @category instances
* @since 2.0.0
*/
const number = /* @__PURE__ */ make$47((self, that) => self < that ? -1 : 1);
/**
* @category instances
* @since 2.0.0
*/
const boolean = /* @__PURE__ */ make$47((self, that) => self < that ? -1 : 1);
/**
* @category mapping
* @since 2.0.0
*/
const mapInput = /* @__PURE__ */ dual$1(2, (self, f$1) => make$47((b1, b2) => self(f$1(b1), f$1(b2))));
/**
* @category combining
* @since 2.0.0
*/
const all$4 = (collection) => {
	return make$47((x, y$1) => {
		const len = Math.min(x.length, y$1.length);
		let collectionLength = 0;
		for (const O$1 of collection) {
			if (collectionLength >= len) break;
			const o$1 = O$1(x[collectionLength], y$1[collectionLength]);
			if (o$1 !== 0) return o$1;
			collectionLength++;
		}
		return 0;
	});
};
/**
* Similar to `Promise.all` but operates on `Order`s.
*
* ```
* [Order<A>, Order<B>, ...] -> Order<[A, B, ...]>
* ```
*
* This function creates and returns a new `Order` for a tuple of values based on the given `Order`s for each element in the tuple.
* The returned `Order` compares two tuples of the same type by applying the corresponding `Order` to each element in the tuple.
* It is useful when you need to compare two tuples of the same type and you have a specific way of comparing each element
* of the tuple.
*
* @category combinators
* @since 2.0.0
*/
const tuple = (...elements) => all$4(elements);
/**
* This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.
* The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.
* If all elements are equal, the arrays are then compared based on their length.
* It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.
*
* @category combinators
* @since 2.0.0
*/
const array = (O$1) => make$47((self, that) => {
	const aLen = self.length;
	const bLen = that.length;
	const len = Math.min(aLen, bLen);
	for (let i$1 = 0; i$1 < len; i$1++) {
		const o$1 = O$1(self[i$1], that[i$1]);
		if (o$1 !== 0) return o$1;
	}
	return number(aLen, bLen);
});
/**
* Test whether one value is _strictly greater than_ another.
*
* @since 2.0.0
*/
const greaterThan$3 = (O$1) => dual$1(2, (self, that) => O$1(self, that) === 1);

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Option.js
/**
* Represents the absence of a value by creating an empty `Option`.
*
* `Option.none` returns an `Option<never>`, which is a subtype of `Option<A>`.
* This means you can use it in place of any `Option<A>` regardless of the type
* `A`.
*
* **Example** (Creating an Option with No Value)
*
* ```ts
* import { Option } from "effect"
*
* // An Option holding no value
* //
* //      ┌─── Option<never>
* //      ▼
* const noValue = Option.none()
*
* console.log(noValue)
* // Output: { _id: 'Option', _tag: 'None' }
* ```
*
* @see {@link some} for the opposite operation.
*
* @category Constructors
* @since 2.0.0
*/
const none$7 = () => none$8;
/**
* Wraps the given value into an `Option` to represent its presence.
*
* **Example** (Creating an Option with a Value)
*
* ```ts
* import { Option } from "effect"
*
* // An Option holding the number 1
* //
* //      ┌─── Option<number>
* //      ▼
* const value = Option.some(1)
*
* console.log(value)
* // Output: { _id: 'Option', _tag: 'Some', value: 1 }
* ```
*
* @see {@link none} for the opposite operation.
*
* @category Constructors
* @since 2.0.0
*/
const some$4 = some$5;
/**
* Determines whether the given value is an `Option`.
*
* **Details**
*
* This function checks if a value is an instance of `Option`. It returns `true`
* if the value is either `Option.some` or `Option.none`, and `false` otherwise.
* This is particularly useful when working with unknown values or when you need
* to ensure type safety in your code.
*
* @example
* ```ts
* import { Option } from "effect"
*
* console.log(Option.isOption(Option.some(1)))
* // Output: true
*
* console.log(Option.isOption(Option.none()))
* // Output: true
*
* console.log(Option.isOption({}))
* // Output: false
* ```
*
* @category Guards
* @since 2.0.0
*/
const isOption = isOption$1;
/**
* Checks whether an `Option` represents the absence of a value (`None`).
*
* @example
* ```ts
* import { Option } from "effect"
*
* console.log(Option.isNone(Option.some(1)))
* // Output: false
*
* console.log(Option.isNone(Option.none()))
* // Output: true
* ```
*
* @see {@link isSome} for the opposite check.
*
* @category Guards
* @since 2.0.0
*/
const isNone$2 = isNone$3;
/**
* Checks whether an `Option` contains a value (`Some`).
*
* @example
* ```ts
* import { Option } from "effect"
*
* console.log(Option.isSome(Option.some(1)))
* // Output: true
*
* console.log(Option.isSome(Option.none()))
* // Output: false
* ```
*
* @see {@link isNone} for the opposite check.
*
* @category Guards
* @since 2.0.0
*/
const isSome = isSome$1;
/**
* Performs pattern matching on an `Option` to handle both `Some` and `None`
* cases.
*
* **Details**
*
* This function allows you to match against an `Option` and handle both
* scenarios: when the `Option` is `None` (i.e., contains no value), and when
* the `Option` is `Some` (i.e., contains a value). It executes one of the
* provided functions based on the case:
*
* - If the `Option` is `None`, the `onNone` function is executed and its result
*   is returned.
* - If the `Option` is `Some`, the `onSome` function is executed with the
*   contained value, and its result is returned.
*
* This function provides a concise and functional way to handle optional values
* without resorting to `if` or manual checks, making your code more declarative
* and readable.
*
* **Example** (Pattern Matching with Option)
*
* ```ts
* import { Option } from "effect"
*
* const foo = Option.some(1)
*
* const message = Option.match(foo, {
*   onNone: () => "Option is empty",
*   onSome: (value) => `Option has a value: ${value}`
* })
*
* console.log(message)
* // Output: "Option has a value: 1"
* ```
*
* @category Pattern matching
* @since 2.0.0
*/
const match$11 = /* @__PURE__ */ dual$1(2, (self, { onNone, onSome }) => isNone$2(self) ? onNone() : onSome(self.value));
/**
* Converts an `Either` into an `Option` by discarding the error and extracting
* the right value.
*
* **Details**
*
* This function takes an `Either` and returns an `Option` based on its value:
*
* - If the `Either` is a `Right`, its value is wrapped in a `Some` and
*   returned.
* - If the `Either` is a `Left`, the error is discarded, and `None` is
*   returned.
*
* This is particularly useful when you only care about the success case
* (`Right`) of an `Either` and want to handle the result using `Option`. By
* using this function, you can convert `Either` into a simpler structure for
* cases where error handling is not required.
*
* @example
* ```ts
* import { Either, Option } from "effect"
*
* console.log(Option.getRight(Either.right("ok")))
* // Output: { _id: 'Option', _tag: 'Some', value: 'ok' }
*
* console.log(Option.getRight(Either.left("err")))
* // Output: { _id: 'Option', _tag: 'None' }
* ```
*
* @see {@link getLeft} for the opposite operation.
*
* @category Conversions
* @since 2.0.0
*/
const getRight = getRight$2;
/**
* Converts an `Either` into an `Option` by discarding the right value and
* extracting the left value.
*
* **Details**
*
* This function transforms an `Either` into an `Option` as follows:
*
* - If the `Either` is a `Left`, its value is wrapped in a `Some` and returned.
* - If the `Either` is a `Right`, the value is discarded, and `None` is
*   returned.
*
* This utility is useful when you only care about the error case (`Left`) of an
* `Either` and want to handle it as an `Option`. By discarding the right value,
* it simplifies error-focused workflows.
*
* @example
* ```ts
* import { Either, Option } from "effect"
*
* console.log(Option.getLeft(Either.right("ok")))
* // Output: { _id: 'Option', _tag: 'None' }
*
* console.log(Option.getLeft(Either.left("err")))
* // Output: { _id: 'Option', _tag: 'Some', value: 'err' }
* ```
*
* @see {@link getRight} for the opposite operation.
*
* @category Conversions
* @since 2.0.0
*/
const getLeft = getLeft$2;
/**
* Returns the value contained in the `Option` if it is `Some`, otherwise
* evaluates and returns the result of `onNone`.
*
* **Details**
*
* This function allows you to provide a fallback value or computation for when
* an `Option` is `None`. If the `Option` contains a value (`Some`), that value
* is returned. If it is empty (`None`), the `onNone` function is executed, and
* its result is returned instead.
*
* This utility is helpful for safely handling `Option` values by ensuring you
* always receive a meaningful result, whether or not the `Option` contains a
* value. It is particularly useful for providing default values or alternative
* logic when working with optional values.
*
* @example
* ```ts
* import { Option } from "effect"
*
* console.log(Option.some(1).pipe(Option.getOrElse(() => 0)))
* // Output: 1
*
* console.log(Option.none().pipe(Option.getOrElse(() => 0)))
* // Output: 0
* ```
*
* @see {@link getOrNull} for a version that returns `null` instead of executing a function.
* @see {@link getOrUndefined} for a version that returns `undefined` instead of executing a function.
*
* @category Getters
* @since 2.0.0
*/
const getOrElse$5 = /* @__PURE__ */ dual$1(2, (self, onNone) => isNone$2(self) ? onNone() : self.value);
/**
* Returns the provided `Option` `that` if the current `Option` (`self`) is
* `None`; otherwise, it returns `self`.
*
* **Details**
*
* This function provides a fallback mechanism for `Option` values. If the
* current `Option` is `None` (i.e., it contains no value), the `that` function
* is evaluated, and its resulting `Option` is returned. If the current `Option`
* is `Some` (i.e., it contains a value), the original `Option` is returned
* unchanged.
*
* This is particularly useful for chaining fallback values or computations,
* allowing you to provide alternative `Option` values when the first one is
* empty.
*
* @example
* ```ts
* import { Option } from "effect"
*
* console.log(Option.none().pipe(Option.orElse(() => Option.none())))
* // Output: { _id: 'Option', _tag: 'None' }
*
* console.log(Option.some("a").pipe(Option.orElse(() => Option.none())))
* // Output: { _id: 'Option', _tag: 'Some', value: 'a' }
*
* console.log(Option.none().pipe(Option.orElse(() => Option.some("b"))))
* // Output: { _id: 'Option', _tag: 'Some', value: 'b' }
*
* console.log(Option.some("a").pipe(Option.orElse(() => Option.some("b"))))
* // Output: { _id: 'Option', _tag: 'Some', value: 'a' }
* ```
*
* @category Error handling
* @since 2.0.0
*/
const orElse$5 = /* @__PURE__ */ dual$1(2, (self, that) => isNone$2(self) ? that() : self);
/**
* Returns the provided default value wrapped in `Some` if the current `Option`
* (`self`) is `None`; otherwise, returns `self`.
*
* **Details**
*
* This function provides a way to supply a default value for cases where an
* `Option` is `None`. If the current `Option` is empty (`None`), the `onNone`
* function is executed to compute the default value, which is then wrapped in a
* `Some`. If the current `Option` contains a value (`Some`), it is returned as
* is.
*
* This is particularly useful for handling optional values where a fallback
* default needs to be provided explicitly in case of absence.
*
* @example
* ```ts
* import { Option } from "effect"
*
* console.log(Option.none().pipe(Option.orElseSome(() => "b")))
* // Output: { _id: 'Option', _tag: 'Some', value: 'b' }
*
* console.log(Option.some("a").pipe(Option.orElseSome(() => "b")))
* // Output: { _id: 'Option', _tag: 'Some', value: 'a' }
* ```
*
* @category Error handling
* @since 2.0.0
*/
const orElseSome = /* @__PURE__ */ dual$1(2, (self, onNone) => isNone$2(self) ? some$4(onNone()) : self);
/**
* Converts a nullable value into an `Option`. Returns `None` if the value is
* `null` or `undefined`, otherwise wraps the value in a `Some`.
*
* @example
* ```ts
* import { Option } from "effect"
*
* console.log(Option.fromNullable(undefined))
* // Output: { _id: 'Option', _tag: 'None' }
*
* console.log(Option.fromNullable(null))
* // Output: { _id: 'Option', _tag: 'None' }
*
* console.log(Option.fromNullable(1))
* // Output: { _id: 'Option', _tag: 'Some', value: 1 }
* ```
*
* @category Conversions
* @since 2.0.0
*/
const fromNullable$2 = (nullableValue) => nullableValue == null ? none$7() : some$4(nullableValue);
/**
* Returns the value contained in the `Option` if it is `Some`; otherwise,
* returns `undefined`.
*
* **Details**
*
* This function provides a way to extract the value of an `Option` while
* falling back to `undefined` if the `Option` is `None`.
*
* It is particularly useful in scenarios where `undefined` is an acceptable
* placeholder for the absence of a value, such as when interacting with APIs or
* systems that use `undefined` as a default for missing values.
*
* @example
* ```ts
* import { Option } from "effect"
*
* console.log(Option.getOrUndefined(Option.some(1)))
* // Output: 1
*
* console.log(Option.getOrUndefined(Option.none()))
* // Output: undefined
* ```
*
* @category Getters
* @since 2.0.0
*/
const getOrUndefined = /* @__PURE__ */ getOrElse$5(constUndefined$1);
/**
* Lifts a function that throws exceptions into a function that returns an
* `Option`.
*
* **Details**
*
* This utility function takes a function `f` that might throw an exception and
* transforms it into a safer function that returns an `Option`. If the original
* function executes successfully, the result is wrapped in a `Some`. If an
* exception is thrown, the result is `None`, allowing the developer to handle
* errors in a functional, type-safe way.
*
* @example
* ```ts
* import { Option } from "effect"
*
* const parse = Option.liftThrowable(JSON.parse)
*
* console.log(parse("1"))
* // Output: { _id: 'Option', _tag: 'Some', value: 1 }
*
* console.log(parse(""))
* // Output: { _id: 'Option', _tag: 'None' }
* ```
*
* @category Conversions
* @since 2.0.0
*/
const liftThrowable = (f$1) => (...a$1) => {
	try {
		return some$4(f$1(...a$1));
	} catch {
		return none$7();
	}
};
/**
* Extracts the value of an `Option` or throws an error if the `Option` is
* `None`, using a custom error factory.
*
* **Details**
*
* This function allows you to extract the value of an `Option` when it is
* `Some`. If the `Option` is `None`, it throws an error generated by the
* provided `onNone` function. This utility is particularly useful when you need
* a fail-fast behavior for empty `Option` values and want to provide a custom
* error message or object.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Option } from "effect"
*
* assert.deepStrictEqual(
*   Option.getOrThrowWith(Option.some(1), () => new Error('Unexpected None')),
*   1
* )
* assert.throws(() => Option.getOrThrowWith(Option.none(), () => new Error('Unexpected None')))
* ```
*
* @see {@link getOrThrow} for a version that throws a default error.
*
* @category Conversions
* @since 2.0.0
*/
const getOrThrowWith = /* @__PURE__ */ dual$1(2, (self, onNone) => {
	if (isSome(self)) return self.value;
	throw onNone();
});
/**
* Extracts the value of an `Option` or throws a default error if the `Option`
* is `None`.
*
* **Details**
*
* This function extracts the value from an `Option` if it is `Some`. If the
* `Option` is `None`, it throws a default error. It is useful for fail-fast
* scenarios where the absence of a value is treated as an exceptional case and
* a default error is sufficient.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Option } from "effect"
*
* assert.deepStrictEqual(Option.getOrThrow(Option.some(1)), 1)
* assert.throws(() => Option.getOrThrow(Option.none()))
* ```
*
* @see {@link getOrThrowWith} for a version that allows you to provide a custom error.
*
* @category Conversions
* @since 2.0.0
*/
const getOrThrow = /* @__PURE__ */ getOrThrowWith(() => /* @__PURE__ */ new Error("getOrThrow called on a None"));
/**
* Transforms the value inside a `Some` to a new value using the provided
* function, while leaving `None` unchanged.
*
* **Details**
*
* This function applies a mapping function `f` to the value inside an `Option`
* if it is a `Some`. If the `Option` is `None`, it remains unchanged. The
* result is a new `Option` with the transformed value (if it was a `Some`) or
* still `None`.
*
* This utility is particularly useful for chaining transformations in a
* functional way without needing to manually handle `None` cases.
*
* @example
* ```ts
* import { Option } from "effect"
*
* // Mapping over a `Some`
* const someValue = Option.some(2)
*
* console.log(Option.map(someValue, (n) => n * 2))
* // Output: { _id: 'Option', _tag: 'Some', value: 4 }
*
* // Mapping over a `None`
* const noneValue = Option.none<number>()
*
* console.log(Option.map(noneValue, (n) => n * 2))
* // Output: { _id: 'Option', _tag: 'None' }
* ```
*
* @category Mapping
* @since 2.0.0
*/
const map$16 = /* @__PURE__ */ dual$1(2, (self, f$1) => isNone$2(self) ? none$7() : some$4(f$1(self.value)));
/**
* Applies a function to the value of a `Some` and flattens the resulting
* `Option`. If the input is `None`, it remains `None`.
*
* **Details**
*
* This function allows you to chain computations that return `Option` values.
* If the input `Option` is `Some`, the provided function `f` is applied to the
* contained value, and the resulting `Option` is returned. If the input is
* `None`, the function is not applied, and the result remains `None`.
*
* This utility is particularly useful for sequencing operations that may fail
* or produce optional results, enabling clean and concise workflows for
* handling such cases.
*
* @example
* ```ts
* import { Option } from "effect"
*
* interface Address {
*   readonly city: string
*   readonly street: Option.Option<string>
* }
*
* interface User {
*   readonly id: number
*   readonly username: string
*   readonly email: Option.Option<string>
*   readonly address: Option.Option<Address>
* }
*
* const user: User = {
*   id: 1,
*   username: "john_doe",
*   email: Option.some("john.doe@example.com"),
*   address: Option.some({
*     city: "New York",
*     street: Option.some("123 Main St")
*   })
* }
*
* // Use flatMap to extract the street value
* const street = user.address.pipe(
*   Option.flatMap((address) => address.street)
* )
*
* console.log(street)
* // Output: { _id: 'Option', _tag: 'Some', value: '123 Main St' }
* ```
*
* @category Sequencing
* @since 2.0.0
*/
const flatMap$12 = /* @__PURE__ */ dual$1(2, (self, f$1) => isNone$2(self) ? none$7() : f$1(self.value));
/**
* Combines `flatMap` and `fromNullable`, transforming the value inside a `Some`
* using a function that may return `null` or `undefined`.
*
* **Details**
*
* This function applies a transformation function `f` to the value inside a
* `Some`. The function `f` may return a value, `null`, or `undefined`. If `f`
* returns a value, it is wrapped in a `Some`. If `f` returns `null` or
* `undefined`, the result is `None`. If the input `Option` is `None`, the
* function is not applied, and `None` is returned.
*
* This utility is particularly useful when working with deeply nested optional
* values or chaining computations that may result in `null` or `undefined` at
* some point.
*
* @example
* ```ts
* import { Option } from "effect"
*
* interface Employee {
*   company?: {
*     address?: {
*       street?: {
*         name?: string
*       }
*     }
*   }
* }
*
* const employee1: Employee = { company: { address: { street: { name: "high street" } } } }
*
* // Extracting a deeply nested property
* console.log(
*   Option.some(employee1)
*     .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))
* )
* // Output: { _id: 'Option', _tag: 'Some', value: 'high street' }
*
* const employee2: Employee = { company: { address: { street: {} } } }
*
* // Property does not exist
* console.log(
*   Option.some(employee2)
*     .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))
* )
* // Output: { _id: 'Option', _tag: 'None' }
* ```
*
* @category Sequencing
* @since 2.0.0
*/
const flatMapNullable = /* @__PURE__ */ dual$1(2, (self, f$1) => isNone$2(self) ? none$7() : fromNullable$2(f$1(self.value)));
/**
* Converts an `Option` into an `Array`.
* If the input is `None`, an empty array is returned.
* If the input is `Some`, its value is wrapped in a single-element array.
*
* @example
* ```ts
* import { Option } from "effect"
*
* console.log(Option.toArray(Option.some(1)))
* // Output: [1]
*
* console.log(Option.toArray(Option.none()))
* // Output: []
* ```
*
* @category Conversions
* @since 2.0.0
*/
const toArray$1 = (self) => isNone$2(self) ? [] : [self.value];
/**
* Returns a function that checks if an `Option` contains a specified value,
* using a provided equivalence function.
*
* **Details**
*
* This function allows you to check whether an `Option` contains a specific
* value. It uses an equivalence function `isEquivalent` to compare the value
* inside the `Option` to the provided value. If the `Option` is `Some` and the
* equivalence function returns `true`, the result is `true`. If the `Option` is
* `None` or the values are not equivalent, the result is `false`.
*
* @example
* ```ts
* import { Number, Option } from "effect"
*
* const contains = Option.containsWith(Number.Equivalence)
*
* console.log(Option.some(2).pipe(contains(2)))
* // Output: true
*
* console.log(Option.some(1).pipe(contains(2)))
* // Output: false
*
* console.log(Option.none().pipe(contains(2)))
* // Output: false
* ```
*
* @see {@link contains} for a version that uses the default `Equivalence`.
*
* @category Elements
* @since 2.0.0
*/
const containsWith$2 = (isEquivalent) => dual$1(2, (self, a$1) => isNone$2(self) ? false : isEquivalent(self.value, a$1));
const _equivalence$3 = /* @__PURE__ */ equivalence();
/**
* Returns a function that checks if an `Option` contains a specified value
* using the default `Equivalence`.
*
* **Details**
*
* This function allows you to check whether an `Option` contains a specific
* value. It uses the default `Equivalence` for equality comparison. If the
* `Option` is `Some` and its value is equivalent to the provided value, the
* result is `true`. If the `Option` is `None` or the values are not equivalent,
* the result is `false`.
*
* @example
* ```ts
* import { Option } from "effect"
*
* console.log(Option.some(2).pipe(Option.contains(2)))
* // Output: true
*
* console.log(Option.some(1).pipe(Option.contains(2)))
* // Output: false
*
* console.log(Option.none().pipe(Option.contains(2)))
* // Output: false
* ```
*
* @see {@link containsWith} for a version that allows you to specify a custom equivalence function.
*
* @category Elements
* @since 2.0.0
*/
const contains$4 = /* @__PURE__ */ containsWith$2(_equivalence$3);
/**
* Checks if a value in an `Option` satisfies a given predicate or refinement.
*
* **Details**
*
* This function allows you to check if a value inside a `Some` meets a
* specified condition. If the `Option` is `None`, the result is `false`. If the
* `Option` is `Some`, the provided predicate or refinement is applied to the
* value:
*
* - If the condition is met, the result is `true`.
* - If the condition is not met, the result is `false`.
*
* @example
* ```ts
* import { Option } from "effect"
*
* const isEven = (n: number) => n % 2 === 0
*
* console.log(Option.some(2).pipe(Option.exists(isEven)))
* // Output: true
*
* console.log(Option.some(1).pipe(Option.exists(isEven)))
* // Output: false
*
* console.log(Option.none().pipe(Option.exists(isEven)))
* // Output: false
* ```
*
* @category Elements
* @since 2.0.0
*/
const exists$3 = /* @__PURE__ */ dual$1(2, (self, refinement) => isNone$2(self) ? false : refinement(self.value));
/**
* Merges two optional values, applying a function if both exist.
* Unlike {@link zipWith}, this function returns `None` only if both inputs are `None`.
*
* @internal
*/
const mergeWith = (f$1) => (o1, o2) => {
	if (isNone$2(o1)) return o2;
	else if (isNone$2(o2)) return o1;
	return some$4(f$1(o1.value, o2.value));
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Tuple.js
/**
* Constructs a new tuple from the provided values.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { make } from "effect/Tuple"
*
* assert.deepStrictEqual(make(1, 'hello', true), [1, 'hello', true])
* ```
*
* @category constructors
* @since 2.0.0
*/
const make$46 = (...elements) => elements;
/**
* Given a tuple of `Equivalence`s returns a new `Equivalence` that compares values of a tuple
* by applying each `Equivalence` to the corresponding element of the tuple.
*
* @category combinators
* @since 2.0.0
*/
const getEquivalence$3 = tuple$1;
/**
* This function creates and returns a new `Order` for a tuple of values based on the given `Order`s for each element in the tuple.
* The returned `Order` compares two tuples of the same type by applying the corresponding `Order` to each element in the tuple.
* It is useful when you need to compare two tuples of the same type and you have a specific way of comparing each element
* of the tuple.
*
* @category combinators
* @since 2.0.0
*/
const getOrder$3 = tuple;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Iterable.js
/**
* Returns the first element that satisfies the specified
* predicate, or `None` if no such element exists.
*
* @category elements
* @since 2.0.0
*/
const findFirst$8 = /* @__PURE__ */ dual$1(2, (self, f$1) => {
	let i$1 = 0;
	for (const a$1 of self) {
		const o$1 = f$1(a$1, i$1);
		if (isBoolean$1(o$1)) {
			if (o$1) return some$4(a$1);
		} else if (isSome(o$1)) return o$1;
		i$1++;
	}
	return none$7();
});

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Record.js
/**
* Transforms the values of a record into an `Array` with a custom mapping function.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { collect } from "effect/Record"
*
* const x = { a: 1, b: 2, c: 3 }
* assert.deepStrictEqual(collect(x, (key, n) => [key, n]), [["a", 1], ["b", 2], ["c", 3]])
* ```
*
* @category conversions
* @since 2.0.0
*/
const collect = /* @__PURE__ */ dual$1(2, (self, f$1) => {
	const out = [];
	for (const key of keys$4(self)) out.push(f$1(key, self[key]));
	return out;
});
/**
* Takes a record and returns an array of tuples containing its keys and values.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { toEntries } from "effect/Record"
*
* const x = { a: 1, b: 2, c: 3 }
* assert.deepStrictEqual(toEntries(x), [["a", 1], ["b", 2], ["c", 3]])
* ```
*
* @category conversions
* @since 2.0.0
*/
const toEntries = /* @__PURE__ */ collect((key, value) => [key, value]);
/**
* Retrieve the keys of a given record as an array.
*
* @since 2.0.0
*/
const keys$4 = (self) => Object.keys(self);

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Array.js
/**
* Creates a new `Array` of the specified length.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.allocate<number>(3)
* console.log(result) // [ <3 empty items> ]
* ```
*
* @category constructors
* @since 2.0.0
*/
const allocate = (n$1) => new Array(n$1);
/**
* Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.
*
* **Note**. `n` is normalized to an integer >= 1.
*
* **Example**
*
* ```ts
* import { makeBy } from "effect/Array"
*
* const result = makeBy(5, n => n * 2)
* console.log(result) // [0, 2, 4, 6, 8]
* ```
*
* @category constructors
* @since 2.0.0
*/
const makeBy = /* @__PURE__ */ dual$1(2, (n$1, f$1) => {
	const max$4 = Math.max(1, Math.floor(n$1));
	const out = new Array(max$4);
	for (let i$1 = 0; i$1 < max$4; i$1++) out[i$1] = f$1(i$1);
	return out;
});
/**
* Creates a new `Array` from an iterable collection of values.
* If the input is already an array, it returns the input as-is.
* Otherwise, it converts the iterable collection to an array.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.fromIterable(new Set([1, 2, 3]))
* console.log(result) // [1, 2, 3]
* ```
*
* @category constructors
* @since 2.0.0
*/
const fromIterable$10 = (collection) => Array.isArray(collection) ? collection : Array.from(collection);
/**
* Creates a new `Array` from a value that might not be an iterable.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* console.log(Array.ensure("a")) // ["a"]
* console.log(Array.ensure(["a"])) // ["a"]
* console.log(Array.ensure(["a", "b", "c"])) // ["a", "b", "c"]
* ```
*
* @category constructors
* @since 3.3.0
*/
const ensure = (self) => Array.isArray(self) ? self : [self];
/**
* Takes a record and returns an array of tuples containing its keys and values.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.fromRecord({ a: 1, b: 2, c: 3 })
* console.log(result) // [["a", 1], ["b", 2], ["c", 3]]
* ```
*
* @category conversions
* @since 2.0.0
*/
const fromRecord = toEntries;
/**
* Converts an `Option` to an array.
*
* **Example**
*
* ```ts
* import { Array, Option } from "effect"
*
* console.log(Array.fromOption(Option.some(1))) // [1]
* console.log(Array.fromOption(Option.none())) // []
* ```
*
* @category conversions
* @since 2.0.0
*/
const fromOption$2 = toArray$1;
/**
* Matches the elements of an array from the left, applying functions to cases of empty and non-empty arrays.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const matchLeft = Array.matchLeft({
*   onEmpty: () => "empty",
*   onNonEmpty: (head, tail) => `head: ${head}, tail: ${tail.length}`
* })
* console.log(matchLeft([])) // "empty"
* console.log(matchLeft([1, 2, 3])) // "head: 1, tail: 2"
* ```
*
* @category pattern matching
* @since 2.0.0
*/
const matchLeft = /* @__PURE__ */ dual$1(2, (self, { onEmpty, onNonEmpty }) => isNonEmptyReadonlyArray(self) ? onNonEmpty(headNonEmpty$1(self), tailNonEmpty$1(self)) : onEmpty());
/**
* Prepend an element to the front of an `Iterable`, creating a new `NonEmptyArray`.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.prepend([2, 3, 4], 1)
* console.log(result) // [1, 2, 3, 4]
* ```
*
* @category concatenating
* @since 2.0.0
*/
const prepend$2 = /* @__PURE__ */ dual$1(2, (self, head$4) => [head$4, ...self]);
/**
* Append an element to the end of an `Iterable`, creating a new `NonEmptyArray`.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.append([1, 2, 3], 4);
* console.log(result) // [1, 2, 3, 4]
* ```
*
* @category concatenating
* @since 2.0.0
*/
const append$2 = /* @__PURE__ */ dual$1(2, (self, last$3) => [...self, last$3]);
/**
* Concatenates two arrays (or iterables), combining their elements.
* If either array is non-empty, the result is also a non-empty array.
*
* @category concatenating
* @since 2.0.0
*/
const appendAll$2 = /* @__PURE__ */ dual$1(2, (self, that) => fromIterable$10(self).concat(fromIterable$10(that)));
/**
* Determine if `unknown` is an Array.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* console.log(Array.isArray(null)) // false
* console.log(Array.isArray([1, 2, 3])) // true
* ```
*
* @category guards
* @since 2.0.0
*/
const isArray = Array.isArray;
/**
* Determine if an `Array` is empty narrowing down the type to `[]`.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* console.log(Array.isEmptyArray([])) // true
* console.log(Array.isEmptyArray([1, 2, 3])) // false
* ```
*
* @category guards
* @since 2.0.0
*/
const isEmptyArray = (self) => self.length === 0;
/**
* Determine if a `ReadonlyArray` is empty narrowing down the type to `readonly []`.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* console.log(Array.isEmptyReadonlyArray([])) // true
* console.log(Array.isEmptyReadonlyArray([1, 2, 3])) // false
* ```
*
* @category guards
* @since 2.0.0
*/
const isEmptyReadonlyArray = isEmptyArray;
/**
* Determine if an `Array` is non empty narrowing down the type to `NonEmptyArray`.
*
* An `Array` is considered to be a `NonEmptyArray` if it contains at least one element.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* console.log(Array.isNonEmptyArray([])) // false
* console.log(Array.isNonEmptyArray([1, 2, 3])) // true
* ```
*
* @category guards
* @since 2.0.0
*/
const isNonEmptyArray = isNonEmptyArray$1;
/**
* Determine if a `ReadonlyArray` is non empty narrowing down the type to `NonEmptyReadonlyArray`.
*
* A `ReadonlyArray` is considered to be a `NonEmptyReadonlyArray` if it contains at least one element.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* console.log(Array.isNonEmptyReadonlyArray([])) // false
* console.log(Array.isNonEmptyReadonlyArray([1, 2, 3])) // true
* ```
*
* @category guards
* @since 2.0.0
*/
const isNonEmptyReadonlyArray = isNonEmptyArray$1;
const isOutOfBounds = (i$1, as$6) => i$1 < 0 || i$1 >= as$6.length;
const clamp = (i$1, as$6) => Math.floor(Math.min(Math.max(0, i$1), as$6.length));
/**
* This function provides a safe way to read a value at a particular index from a `ReadonlyArray`.
*
* @category getters
* @since 2.0.0
*/
const get$11 = /* @__PURE__ */ dual$1(2, (self, index) => {
	const i$1 = Math.floor(index);
	return isOutOfBounds(i$1, self) ? none$7() : some$4(self[i$1]);
});
/**
* Gets an element unsafely, will throw on out of bounds.
*
* @since 2.0.0
* @category unsafe
*/
const unsafeGet$5 = /* @__PURE__ */ dual$1(2, (self, index) => {
	const i$1 = Math.floor(index);
	if (isOutOfBounds(i$1, self)) throw new Error(`Index ${i$1} out of bounds`);
	return self[i$1];
});
/**
* Get the first element of a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.
*
* @category getters
* @since 2.0.0
*/
const head$3 = /* @__PURE__ */ get$11(0);
/**
* Get the first element of a non empty array.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.headNonEmpty([1, 2, 3, 4])
* console.log(result) // 1
* ```
*
* @category getters
* @since 2.0.0
*/
const headNonEmpty$1 = /* @__PURE__ */ unsafeGet$5(0);
/**
* Get the last element in a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.
*
* @category getters
* @since 2.0.0
*/
const last$2 = (self) => isNonEmptyReadonlyArray(self) ? some$4(lastNonEmpty(self)) : none$7();
/**
* Get the last element of a non empty array.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.lastNonEmpty([1, 2, 3, 4])
* console.log(result) // 4
* ```
*
* @category getters
* @since 2.0.0
*/
const lastNonEmpty = (self) => self[self.length - 1];
/**
* Get all but the first element of a `NonEmptyReadonlyArray`.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.tailNonEmpty([1, 2, 3, 4])
* console.log(result) // [2, 3, 4]
* ```
*
* @category getters
* @since 2.0.0
*/
const tailNonEmpty$1 = (self) => self.slice(1);
const spanIndex = (self, predicate) => {
	let i$1 = 0;
	for (const a$1 of self) {
		if (!predicate(a$1, i$1)) break;
		i$1++;
	}
	return i$1;
};
/**
* Split an `Iterable` into two parts:
*
* 1. the longest initial subarray for which all elements satisfy the specified predicate
* 2. the remaining elements
*
* @category splitting
* @since 2.0.0
*/
const span = /* @__PURE__ */ dual$1(2, (self, predicate) => splitAt(self, spanIndex(self, predicate)));
/**
* Drop a max number of elements from the start of an `Iterable`, creating a new `Array`.
*
* **Note**. `n` is normalized to a non negative integer.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.drop([1, 2, 3, 4, 5], 2)
* console.log(result) // [3, 4, 5]
* ```
*
* @category getters
* @since 2.0.0
*/
const drop$1 = /* @__PURE__ */ dual$1(2, (self, n$1) => {
	const input = fromIterable$10(self);
	return input.slice(clamp(n$1, input), input.length);
});
/**
* Return the first index for which a predicate holds.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.findFirstIndex([5, 3, 8, 9], x => x > 5)
* console.log(result) // Option.some(2)
* ```
*
* @category elements
* @since 2.0.0
*/
const findFirstIndex$1 = /* @__PURE__ */ dual$1(2, (self, predicate) => {
	let i$1 = 0;
	for (const a$1 of self) {
		if (predicate(a$1, i$1)) return some$4(i$1);
		i$1++;
	}
	return none$7();
});
/**
* Return the last index for which a predicate holds.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.findLastIndex([1, 3, 8, 9], x => x < 5)
* console.log(result) // Option.some(1)
* ```
*
* @category elements
* @since 2.0.0
*/
const findLastIndex$1 = /* @__PURE__ */ dual$1(2, (self, predicate) => {
	const input = fromIterable$10(self);
	for (let i$1 = input.length - 1; i$1 >= 0; i$1--) if (predicate(input[i$1], i$1)) return some$4(i$1);
	return none$7();
});
/**
* Returns the first element that satisfies the specified
* predicate, or `None` if no such element exists.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.findFirst([1, 2, 3, 4, 5], x => x > 3)
* console.log(result) // Option.some(4)
* ```
*
* @category elements
* @since 2.0.0
*/
const findFirst$7 = findFirst$8;
/**
* Finds the last element in an iterable collection that satisfies the given predicate or refinement.
* Returns an `Option` containing the found element, or `Option.none` if no element matches.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.findLast([1, 2, 3, 4, 5], n => n % 2 === 0)
* console.log(result) // Option.some(4)
* ```
*
* @category elements
* @since 2.0.0
*/
const findLast$1 = /* @__PURE__ */ dual$1(2, (self, f$1) => {
	const input = fromIterable$10(self);
	for (let i$1 = input.length - 1; i$1 >= 0; i$1--) {
		const a$1 = input[i$1];
		const o$1 = f$1(a$1, i$1);
		if (isBoolean$1(o$1)) {
			if (o$1) return some$4(a$1);
		} else if (isSome(o$1)) return o$1;
	}
	return none$7();
});
/**
* Reverse an `Iterable`, creating a new `Array`.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.reverse([1, 2, 3, 4])
* console.log(result) // [4, 3, 2, 1]
* ```
*
* @category elements
* @since 2.0.0
*/
const reverse$2 = (self) => Array.from(self).reverse();
/**
* Create a new array with elements sorted in increasing order based on the specified comparator.
* If the input is a `NonEmptyReadonlyArray`, the output will also be a `NonEmptyReadonlyArray`.
*
* @category sorting
* @since 2.0.0
*/
const sort = /* @__PURE__ */ dual$1(2, (self, O$1) => {
	const out = Array.from(self);
	out.sort(O$1);
	return out;
});
/**
* Takes two `Iterable`s and returns an `Array` of corresponding pairs.
* If one input `Iterable` is short, excess elements of the
* longer `Iterable` are discarded.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.zip([1, 2, 3], ['a', 'b'])
* console.log(result) // [[1, 'a'], [2, 'b']]
* ```
*
* @category zipping
* @since 2.0.0
*/
const zip$6 = /* @__PURE__ */ dual$1(2, (self, that) => zipWith$5(self, that, make$46));
/**
* Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results in a new `Array`. If one
* input `Iterable` is short, excess elements of the longer `Iterable` are discarded.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.zipWith([1, 2, 3], [4, 5, 6], (a, b) => a + b)
* console.log(result) // [5, 7, 9]
* ```
*
* @category zipping
* @since 2.0.0
*/
const zipWith$5 = /* @__PURE__ */ dual$1(3, (self, that, f$1) => {
	const as$6 = fromIterable$10(self);
	const bs = fromIterable$10(that);
	if (isNonEmptyReadonlyArray(as$6) && isNonEmptyReadonlyArray(bs)) {
		const out = [f$1(headNonEmpty$1(as$6), headNonEmpty$1(bs))];
		const len = Math.min(as$6.length, bs.length);
		for (let i$1 = 1; i$1 < len; i$1++) out[i$1] = f$1(as$6[i$1], bs[i$1]);
		return out;
	}
	return [];
});
/**
* Returns a function that checks if a `ReadonlyArray` contains a given value using a provided `isEquivalent` function.
*
* **Example**
*
* ```ts
* import { Array, pipe } from "effect"
*
* const isEquivalent = (a: number, b: number) => a === b
* const containsNumber = Array.containsWith(isEquivalent)
* const result = pipe([1, 2, 3, 4], containsNumber(3))
* console.log(result) // true
* ```
*
* @category elements
* @since 2.0.0
*/
const containsWith$1 = (isEquivalent) => dual$1(2, (self, a$1) => {
	for (const i$1 of self) if (isEquivalent(a$1, i$1)) return true;
	return false;
});
const _equivalence$2 = /* @__PURE__ */ equivalence();
/**
* Returns a function that checks if a `ReadonlyArray` contains a given value using the default `Equivalence`.
*
* **Example**
*
* ```ts
* import { Array, pipe } from "effect"
*
* const result = pipe(['a', 'b', 'c', 'd'], Array.contains('c'))
* console.log(result) // true
* ```
*
* @category elements
* @since 2.0.0
*/
const contains$3 = /* @__PURE__ */ containsWith$1(_equivalence$2);
/**
* Splits an `Iterable` into two segments, with the first segment containing a maximum of `n` elements.
* The value of `n` can be `0`.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.splitAt([1, 2, 3, 4, 5], 3)
* console.log(result) // [[1, 2, 3], [4, 5]]
* ```
*
* @category splitting
* @since 2.0.0
*/
const splitAt = /* @__PURE__ */ dual$1(2, (self, n$1) => {
	const input = Array.from(self);
	const _n = Math.floor(n$1);
	if (isNonEmptyReadonlyArray(input)) {
		if (_n >= 1) return splitNonEmptyAt(input, _n);
		return [[], input];
	}
	return [input, []];
});
/**
* Splits a `NonEmptyReadonlyArray` into two segments, with the first segment containing a maximum of `n` elements.
* The value of `n` must be `>= 1`.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.splitNonEmptyAt(["a", "b", "c", "d", "e"], 3)
* console.log(result) // [["a", "b", "c"], ["d", "e"]]
* ```
*
* @category splitting
* @since 2.0.0
*/
const splitNonEmptyAt = /* @__PURE__ */ dual$1(2, (self, n$1) => {
	const _n = Math.max(1, Math.floor(n$1));
	return _n >= self.length ? [copy$2(self), []] : [prepend$2(self.slice(1, _n), headNonEmpty$1(self)), self.slice(_n)];
});
/**
* Copies an array.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.copy([1, 2, 3])
* console.log(result) // [1, 2, 3]
* ```
*
* @since 2.0.0
*/
const copy$2 = (self) => self.slice();
/**
* Calculates the union of two arrays using the provided equivalence relation.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const union = Array.unionWith([1, 2], [2, 3], (a, b) => a === b)
* console.log(union) // [1, 2, 3]
* ```
*
* @since 2.0.0
*/
const unionWith = /* @__PURE__ */ dual$1(3, (self, that, isEquivalent) => {
	const a$1 = fromIterable$10(self);
	const b$1 = fromIterable$10(that);
	if (isNonEmptyReadonlyArray(a$1)) {
		if (isNonEmptyReadonlyArray(b$1)) return dedupeWith(isEquivalent)(appendAll$2(a$1, b$1));
		return a$1;
	}
	return b$1;
});
/**
* Creates a union of two arrays, removing duplicates.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.union([1, 2], [2, 3])
* console.log(result) // [1, 2, 3]
* ```
*
* @since 2.0.0
*/
const union$8 = /* @__PURE__ */ dual$1(2, (self, that) => unionWith(self, that, _equivalence$2));
/**
* @category constructors
* @since 2.0.0
*/
const empty$33 = () => [];
/**
* Constructs a new `NonEmptyArray<A>` from the specified value.
*
* @category constructors
* @since 2.0.0
*/
const of$4 = (a$1) => [a$1];
/**
* @category mapping
* @since 2.0.0
*/
const map$15 = /* @__PURE__ */ dual$1(2, (self, f$1) => self.map(f$1));
/**
* Applies a function to each element in an array and returns a new array containing the concatenated mapped elements.
*
* @category sequencing
* @since 2.0.0
*/
const flatMap$11 = /* @__PURE__ */ dual$1(2, (self, f$1) => {
	if (isEmptyReadonlyArray(self)) return [];
	const out = [];
	for (let i$1 = 0; i$1 < self.length; i$1++) {
		const inner = f$1(self[i$1], i$1);
		for (let j = 0; j < inner.length; j++) out.push(inner[j]);
	}
	return out;
});
/**
* Combines multiple arrays into a single array by concatenating all elements
* from each nested array. This function ensures that the structure of nested
* arrays is collapsed into a single, flat array.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.flatten([[1, 2], [], [3, 4], [], [5, 6]])
* console.log(result) // [1, 2, 3, 4, 5, 6]
* ```
*
* @category sequencing
* @since 2.0.0
*/
const flatten$7 = /* @__PURE__ */ flatMap$11(identity$2);
/**
* Applies a function to each element of the `Iterable` and filters based on the result, keeping the transformed values where the function returns `Some`.
* This method combines filtering and mapping functionalities, allowing transformations and filtering of elements based on a single function pass.
*
* **Example**
*
* ```ts
* import { Array, Option } from "effect"
*
* const evenSquares = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()
*
* const result = Array.filterMap([1, 2, 3, 4, 5], evenSquares);
* console.log(result) // [4, 16]
* ```
*
* @category filtering
* @since 2.0.0
*/
const filterMap$4 = /* @__PURE__ */ dual$1(2, (self, f$1) => {
	const as$6 = fromIterable$10(self);
	const out = [];
	for (let i$1 = 0; i$1 < as$6.length; i$1++) {
		const o$1 = f$1(as$6[i$1], i$1);
		if (isSome(o$1)) out.push(o$1.value);
	}
	return out;
});
/**
* Applies a function to each element of the `Iterable`, categorizing the results into two separate arrays.
* This function is particularly useful for operations where each element can result in two possible types,
* and you want to separate these types into different collections. For instance, separating validation results
* into successes and failures.
*
* **Example**
*
* ```ts
* import { Array, Either } from "effect";
*
* const isEven = (x: number) => x % 2 === 0
*
* const result = Array.partitionMap([1, 2, 3, 4, 5], x =>
*   isEven(x) ? Either.right(x) : Either.left(x)
* )
* console.log(result)
* // [
* //   [1, 3, 5],
* //   [2, 4]
* // ]
* ```
*
* @category filtering
* @since 2.0.0
*/
const partitionMap$1 = /* @__PURE__ */ dual$1(2, (self, f$1) => {
	const left$2 = [];
	const right$2 = [];
	const as$6 = fromIterable$10(self);
	for (let i$1 = 0; i$1 < as$6.length; i$1++) {
		const e = f$1(as$6[i$1], i$1);
		if (isLeft(e)) left$2.push(e.left);
		else right$2.push(e.right);
	}
	return [left$2, right$2];
});
/**
* Retrieves the `Some` values from an `Iterable` of `Option`s, collecting them into an array.
*
* **Example**
*
* ```ts
* import { Array, Option } from "effect"
*
* const result = Array.getSomes([Option.some(1), Option.none(), Option.some(2)])
* console.log(result) // [1, 2]
* ```
*
* @category filtering
* @since 2.0.0
*/
const getSomes = /* @__PURE__ */ filterMap$4(identity$2);
/**
* Reduces an array from the left.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.reduce([1, 2, 3], 0, (acc, n) => acc + n)
* console.log(result) // 6
* ```
*
* @category folding
* @since 2.0.0
*/
const reduce$12 = /* @__PURE__ */ dual$1(3, (self, b$1, f$1) => fromIterable$10(self).reduce((b$2, a$1, i$1) => f$1(b$2, a$1, i$1), b$1));
/**
* Reduces an array from the right.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.reduceRight([1, 2, 3], 0, (acc, n) => acc + n)
* console.log(result) // 6
* ```
*
* @category folding
* @since 2.0.0
*/
const reduceRight$3 = /* @__PURE__ */ dual$1(3, (self, b$1, f$1) => fromIterable$10(self).reduceRight((b$2, a$1, i$1) => f$1(b$2, a$1, i$1), b$1));
/**
* @category constructors
* @since 2.0.0
*/
const unfold$1 = (b$1, f$1) => {
	const out = [];
	let next = b$1;
	let o$1;
	while (isSome(o$1 = f$1(next))) {
		const [a$1, b$2] = o$1.value;
		out.push(a$1);
		next = b$2;
	}
	return out;
};
/**
* This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.
* The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.
* If all elements are equal, the arrays are then compared based on their length.
* It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.
*
* @category instances
* @since 2.0.0
*/
const getOrder$2 = array;
/**
* Creates an equivalence relation for arrays.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const eq = Array.getEquivalence<number>((a, b) => a === b)
* console.log(eq([1, 2, 3], [1, 2, 3])) // true
* ```
*
* @category instances
* @since 2.0.0
*/
const getEquivalence$2 = array$2;
/**
* Remove duplicates from an `Iterable` using the provided `isEquivalent` function,
* preserving the order of the first occurrence of each element.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const result = Array.dedupeWith([1, 2, 2, 3, 3, 3], (a, b) => a === b)
* console.log(result) // [1, 2, 3]
* ```
*
* @since 2.0.0
*/
const dedupeWith = /* @__PURE__ */ dual$1(2, (self, isEquivalent) => {
	const input = fromIterable$10(self);
	if (isNonEmptyReadonlyArray(input)) {
		const out = [headNonEmpty$1(input)];
		const rest = tailNonEmpty$1(input);
		for (const r$1 of rest) if (out.every((a$1) => !isEquivalent(r$1, a$1))) out.push(r$1);
		return out;
	}
	return [];
});
/**
* Remove duplicates from an `Iterable`, preserving the order of the first occurrence of each element.
* The equivalence used to compare elements is provided by `Equal.equivalence()` from the `Equal` module.
*
* @since 2.0.0
*/
const dedupe = (self) => dedupeWith(self, equivalence());
/**
* Joins the elements together with "sep" in the middle.
*
* **Example**
*
* ```ts
* import { Array } from "effect"
*
* const strings = ["a", "b", "c"]
* const joined = Array.join(strings, "-")
* console.log(joined) // "a-b-c"
* ```
*
* @since 2.0.0
* @category folding
*/
const join$3 = /* @__PURE__ */ dual$1(2, (self, sep$1) => fromIterable$10(self).join(sep$1));

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/schema/util.js
/** @internal */
const getKeysForIndexSignature = (input, parameter) => {
	switch (parameter._tag) {
		case "StringKeyword":
		case "TemplateLiteral": return Object.keys(input);
		case "SymbolKeyword": return Object.getOwnPropertySymbols(input);
		case "Refinement": return getKeysForIndexSignature(input, parameter.from);
	}
};
/** @internal */
const memoizeThunk = (f$1) => {
	let done$8 = false;
	let a$1;
	return () => {
		if (done$8) return a$1;
		a$1 = f$1();
		done$8 = true;
		return a$1;
	};
};
/** @internal */
const formatDate = (date) => {
	try {
		return date.toISOString();
	} catch {
		return String(date);
	}
};
const CIRCULAR = "[Circular]";
/** @internal */
function formatUnknown(input, whitespace = 0) {
	const seen = /* @__PURE__ */ new WeakSet();
	const gap = !whitespace ? "" : typeof whitespace === "number" ? " ".repeat(whitespace) : whitespace;
	const ind = (d) => gap.repeat(d);
	const safeToString = (x) => {
		try {
			const s$1 = x.toString();
			return typeof s$1 === "string" ? s$1 : String(s$1);
		} catch {
			return "[toString threw]";
		}
	};
	const wrap = (v, body) => {
		const ctor = v?.constructor;
		return ctor && ctor !== Object.prototype.constructor && ctor.name ? `${ctor.name}(${body})` : body;
	};
	const ownKeys$1 = (o$1) => {
		try {
			return Reflect.ownKeys(o$1);
		} catch {
			return ["[ownKeys threw]"];
		}
	};
	function go$1(v, d = 0) {
		if (Array.isArray(v)) {
			if (seen.has(v)) return CIRCULAR;
			seen.add(v);
			if (!gap || v.length <= 1) return `[${v.map((x) => go$1(x, d)).join(",")}]`;
			const inner = v.map((x) => go$1(x, d + 1)).join(",\n" + ind(d + 1));
			return `[\n${ind(d + 1)}${inner}\n${ind(d)}]`;
		}
		if (isDate(v)) return formatDate(v);
		if (hasProperty(v, "toString") && isFunction(v["toString"]) && v["toString"] !== Object.prototype.toString) return safeToString(v);
		if (isString(v)) return JSON.stringify(v);
		if (isNumber(v) || v == null || isBoolean$1(v) || isSymbol(v)) return String(v);
		if (isBigInt(v)) return String(v) + "n";
		if (v instanceof Set || v instanceof Map) {
			if (seen.has(v)) return CIRCULAR;
			seen.add(v);
			return `${v.constructor.name}(${go$1(Array.from(v), d)})`;
		}
		if (isObject(v)) {
			if (seen.has(v)) return CIRCULAR;
			seen.add(v);
			const keys$5 = ownKeys$1(v);
			if (!gap || keys$5.length <= 1) return wrap(v, `{${keys$5.map((k) => `${formatPropertyKey$1(k)}:${go$1(v[k], d)}`).join(",")}}`);
			return wrap(v, `{\n${keys$5.map((k) => `${ind(d + 1)}${formatPropertyKey$1(k)}: ${go$1(v[k], d + 1)}`).join(",\n")}\n${ind(d)}}`);
		}
		return String(v);
	}
	return go$1(input, 0);
}
/** @internal */
function formatPropertyKey$1(name) {
	return isString(name) ? JSON.stringify(name) : String(name);
}
/** @internal */
const isNonEmpty$5 = (x) => Array.isArray(x);
/** @internal */
const formatPathKey = (key) => `[${formatPropertyKey$1(key)}]`;
/** @internal */
const formatPath = (path) => isNonEmpty$5(path) ? path.map(formatPathKey).join("") : formatPathKey(path);

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/schema/errors.js
const getErrorMessage = (reason, details, path, ast) => {
	let out = reason;
	if (path && isNonEmptyReadonlyArray(path)) out += `\nat path: ${formatPath(path)}`;
	if (details !== void 0) out += `\ndetails: ${details}`;
	if (ast) out += `\nschema (${ast._tag}): ${ast}`;
	return out;
};
/** @internal */
const getASTDuplicateIndexSignatureErrorMessage = (type) => getErrorMessage("Duplicate index signature", `${type} index signature`);
/** @internal */
const getASTIndexSignatureParameterErrorMessage = /* @__PURE__ */ getErrorMessage("Unsupported index signature parameter", "An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types");
/** @internal */
const getASTRequiredElementFollowinAnOptionalElementErrorMessage = /* @__PURE__ */ getErrorMessage("Invalid element", "A required element cannot follow an optional element. ts(1257)");
/** @internal */
const getASTDuplicatePropertySignatureErrorMessage = (key) => getErrorMessage("Duplicate property signature", `Duplicate key ${formatUnknown(key)}`);

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/schema/schemaId.js
/** @internal */
const DateFromSelfSchemaId$1 = /* @__PURE__ */ Symbol.for("effect/SchemaId/DateFromSelf");
/** @internal */
const GreaterThanSchemaId$1 = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThan");
/** @internal */
const GreaterThanOrEqualToSchemaId$1 = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanOrEqualTo");
/** @internal */
const LessThanSchemaId$1 = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThan");
/** @internal */
const LessThanOrEqualToSchemaId$1 = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanOrEqualTo");
/** @internal */
const IntSchemaId$1 = /* @__PURE__ */ Symbol.for("effect/SchemaId/Int");
/** @internal */
const NonNaNSchemaId$1 = /* @__PURE__ */ Symbol.for("effect/SchemaId/NonNaN");
/** @internal */
const FiniteSchemaId$1 = /* @__PURE__ */ Symbol.for("effect/SchemaId/Finite");
/** @internal */
const JsonNumberSchemaId$1 = /* @__PURE__ */ Symbol.for("effect/SchemaId/JsonNumber");
/** @internal */
const BetweenSchemaId$1 = /* @__PURE__ */ Symbol.for("effect/SchemaId/Between");
/** @internal */
const GreaterThanBigintSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanBigint");
/** @internal */
const GreaterThanOrEqualToBigIntSchemaId$1 = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanOrEqualToBigint");
/** @internal */
const LessThanBigIntSchemaId$1 = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanBigint");
/** @internal */
const LessThanOrEqualToBigIntSchemaId$1 = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanOrEqualToBigint");
/** @internal */
const BetweenBigintSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/BetweenBigint");
/** @internal */
const MinLengthSchemaId$1 = /* @__PURE__ */ Symbol.for("effect/SchemaId/MinLength");
/** @internal */
const MaxLengthSchemaId$1 = /* @__PURE__ */ Symbol.for("effect/SchemaId/MaxLength");
/** @internal */
const LengthSchemaId$1 = /* @__PURE__ */ Symbol.for("effect/SchemaId/Length");
/** @internal */
const MinItemsSchemaId$1 = /* @__PURE__ */ Symbol.for("effect/SchemaId/MinItems");
/** @internal */
const MaxItemsSchemaId$1 = /* @__PURE__ */ Symbol.for("effect/SchemaId/MaxItems");
/** @internal */
const ItemsCountSchemaId$1 = /* @__PURE__ */ Symbol.for("effect/SchemaId/ItemsCount");

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Number.js
/**
* Type guard that tests if a value is a member of the set of JavaScript
* numbers.
*
* @memberof Number
* @since 2.0.0
* @category guards
* @example
*
* ```ts
* import * as assert from "node:assert/strict"
* import * as Number from "effect/Number"
*
* // Regular numbers
* assert.equal(Number.isNumber(2), true)
* assert.equal(Number.isNumber(-3.14), true)
* assert.equal(Number.isNumber(0), true)
*
* // Special numeric values
* assert.equal(Number.isNumber(Infinity), true)
* assert.equal(Number.isNumber(NaN), true)
*
* // Non-number values
* assert.equal(Number.isNumber("2"), false)
* assert.equal(Number.isNumber(true), false)
* assert.equal(Number.isNumber(null), false)
* assert.equal(Number.isNumber(undefined), false)
* assert.equal(Number.isNumber({}), false)
* assert.equal(Number.isNumber([]), false)
*
* // Using as a type guard in conditionals
* function processValue(value: unknown): string {
*   if (Number.isNumber(value)) {
*     // TypeScript now knows 'value' is a number
*     return `Numeric value: ${value.toFixed(2)}`
*   }
*   return "Not a number"
* }
*
* assert.strictEqual(processValue(42), "Numeric value: 42.00")
* assert.strictEqual(processValue("hello"), "Not a number")
*
* // Filtering for numbers in an array
* const mixed = [1, "two", 3, false, 5]
* const onlyNumbers = mixed.filter(Number.isNumber)
* assert.equal(onlyNumbers, [1, 3, 5])
* ```
*
* @param input - The value to test for membership in the set of JavaScript
*   numbers
*
* @returns `true` if the input is a JavaScript number, `false` otherwise
*/
const isNumber$1 = isNumber;
/**
* @memberof Number
* @since 2.0.0
* @category instances
*/
const Equivalence$2 = number$2;
/**
* @memberof Number
* @since 2.0.0
* @category instances
*/
const Order$4 = number;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/RegExp.js
/**
* Tests if a value is a `RegExp`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { RegExp } from "effect"
*
* assert.deepStrictEqual(RegExp.isRegExp(/a/), true)
* assert.deepStrictEqual(RegExp.isRegExp("a"), false)
* ```
*
* @category guards
* @since 3.9.0
*/
const isRegExp = isRegExp$1;
/**
* Escapes special characters in a regular expression pattern.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { RegExp } from "effect"
*
* assert.deepStrictEqual(RegExp.escape("a*b"), "a\\*b")
* ```
*
* @since 2.0.0
*/
const escape = (string$1) => string$1.replace(/[/\\^$*+?.()|[\]{}]/g, "\\$&");

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/SchemaAST.js
/**
* @category annotations
* @since 3.10.0
*/
const BrandAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Brand");
/**
* @category annotations
* @since 3.10.0
*/
const SchemaIdAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/SchemaId");
/**
* @category annotations
* @since 3.10.0
*/
const MessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Message");
/**
* @category annotations
* @since 3.10.0
*/
const MissingMessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/MissingMessage");
/**
* @category annotations
* @since 3.10.0
*/
const IdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Identifier");
/**
* @category annotations
* @since 3.10.0
*/
const TitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Title");
/** @internal */
const AutoTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/AutoTitle");
/**
* @category annotations
* @since 3.10.0
*/
const DescriptionAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Description");
/**
* @category annotations
* @since 3.10.0
*/
const ExamplesAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Examples");
/**
* @category annotations
* @since 3.10.0
*/
const DefaultAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Default");
/**
* @category annotations
* @since 3.10.0
*/
const JSONSchemaAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONSchema");
/**
* @category annotations
* @since 3.10.0
*/
const ArbitraryAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Arbitrary");
/**
* @category annotations
* @since 3.10.0
*/
const PrettyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Pretty");
/**
* @category annotations
* @since 3.10.0
*/
const EquivalenceAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Equivalence");
/**
* @category annotations
* @since 3.10.0
*/
const DocumentationAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Documentation");
/**
* @category annotations
* @since 3.10.0
*/
const ConcurrencyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Concurrency");
/**
* @category annotations
* @since 3.10.0
*/
const BatchingAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Batching");
/**
* @category annotations
* @since 3.10.0
*/
const ParseIssueTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseIssueTitle");
/**
* @category annotations
* @since 3.10.0
*/
const ParseOptionsAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseOptions");
/**
* @category annotations
* @since 3.10.0
*/
const DecodingFallbackAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/DecodingFallback");
/**
* @category annotations
* @since 3.10.0
*/
const SurrogateAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Surrogate");
/** @internal */
const StableFilterAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/StableFilter");
/**
* @category annotations
* @since 3.10.0
*/
const getAnnotation = /* @__PURE__ */ dual$1(2, (annotated, key) => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? some$4(annotated.annotations[key]) : none$7());
/**
* @category annotations
* @since 3.10.0
*/
const getBrandAnnotation = /* @__PURE__ */ getAnnotation(BrandAnnotationId);
/**
* @category annotations
* @since 3.10.0
*/
const getMessageAnnotation = /* @__PURE__ */ getAnnotation(MessageAnnotationId);
/**
* @category annotations
* @since 3.10.0
*/
const getMissingMessageAnnotation = /* @__PURE__ */ getAnnotation(MissingMessageAnnotationId);
/**
* @category annotations
* @since 3.10.0
*/
const getTitleAnnotation = /* @__PURE__ */ getAnnotation(TitleAnnotationId);
/** @internal */
const getAutoTitleAnnotation = /* @__PURE__ */ getAnnotation(AutoTitleAnnotationId);
/**
* @category annotations
* @since 3.10.0
*/
const getIdentifierAnnotation = /* @__PURE__ */ getAnnotation(IdentifierAnnotationId);
/**
* @category annotations
* @since 3.10.0
*/
const getDescriptionAnnotation = /* @__PURE__ */ getAnnotation(DescriptionAnnotationId);
/**
* @category annotations
* @since 3.10.0
*/
const getConcurrencyAnnotation = /* @__PURE__ */ getAnnotation(ConcurrencyAnnotationId);
/**
* @category annotations
* @since 3.10.0
*/
const getBatchingAnnotation = /* @__PURE__ */ getAnnotation(BatchingAnnotationId);
/**
* @category annotations
* @since 3.10.0
*/
const getParseIssueTitleAnnotation$1 = /* @__PURE__ */ getAnnotation(ParseIssueTitleAnnotationId);
/**
* @category annotations
* @since 3.10.0
*/
const getParseOptionsAnnotation = /* @__PURE__ */ getAnnotation(ParseOptionsAnnotationId);
/**
* @category annotations
* @since 3.10.0
*/
const getDecodingFallbackAnnotation = /* @__PURE__ */ getAnnotation(DecodingFallbackAnnotationId);
/**
* @category annotations
* @since 3.10.0
*/
const getSurrogateAnnotation = /* @__PURE__ */ getAnnotation(SurrogateAnnotationId);
const getStableFilterAnnotation = /* @__PURE__ */ getAnnotation(StableFilterAnnotationId);
/** @internal */
const hasStableFilter = (annotated) => exists$3(getStableFilterAnnotation(annotated), (b$1) => b$1 === true);
/**
* @category annotations
* @since 3.10.0
*/
const JSONIdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONIdentifier");
/**
* @category annotations
* @since 3.10.0
*/
const getJSONIdentifierAnnotation = /* @__PURE__ */ getAnnotation(JSONIdentifierAnnotationId);
/**
* @category annotations
* @since 3.10.0
*/
const getJSONIdentifier = (annotated) => orElse$5(getJSONIdentifierAnnotation(annotated), () => getIdentifierAnnotation(annotated));
/**
* @category model
* @since 3.10.0
*/
var Declaration = class {
	typeParameters;
	decodeUnknown;
	encodeUnknown;
	annotations;
	/**
	* @since 3.10.0
	*/
	_tag = "Declaration";
	constructor(typeParameters, decodeUnknown$2, encodeUnknown, annotations$1 = {}) {
		this.typeParameters = typeParameters;
		this.decodeUnknown = decodeUnknown$2;
		this.encodeUnknown = encodeUnknown;
		this.annotations = annotations$1;
	}
	/**
	* @since 3.10.0
	*/
	toString() {
		return getOrElse$5(getExpected(this), () => "<declaration schema>");
	}
	/**
	* @since 3.10.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			typeParameters: this.typeParameters.map((ast) => ast.toJSON()),
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
const createASTGuard = (tag$1) => (ast) => ast._tag === tag$1;
/**
* @category model
* @since 3.10.0
*/
var Literal$1 = class {
	literal;
	annotations;
	/**
	* @since 3.10.0
	*/
	_tag = "Literal";
	constructor(literal, annotations$1 = {}) {
		this.literal = literal;
		this.annotations = annotations$1;
	}
	/**
	* @since 3.10.0
	*/
	toString() {
		return getOrElse$5(getExpected(this), () => formatUnknown(this.literal));
	}
	/**
	* @since 3.10.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			literal: isBigInt(this.literal) ? String(this.literal) : this.literal,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category guards
* @since 3.10.0
*/
const isLiteral = /* @__PURE__ */ createASTGuard("Literal");
/**
* @category model
* @since 3.10.0
*/
var UniqueSymbol = class {
	symbol;
	annotations;
	/**
	* @since 3.10.0
	*/
	_tag = "UniqueSymbol";
	constructor(symbol$2, annotations$1 = {}) {
		this.symbol = symbol$2;
		this.annotations = annotations$1;
	}
	/**
	* @since 3.10.0
	*/
	toString() {
		return getOrElse$5(getExpected(this), () => formatUnknown(this.symbol));
	}
	/**
	* @since 3.10.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			symbol: String(this.symbol),
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category model
* @since 3.10.0
*/
var UndefinedKeyword = class {
	annotations;
	/**
	* @since 3.10.0
	*/
	_tag = "UndefinedKeyword";
	constructor(annotations$1 = {}) {
		this.annotations = annotations$1;
	}
	/**
	* @since 3.10.0
	*/
	toString() {
		return formatKeyword(this);
	}
	/**
	* @since 3.10.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category constructors
* @since 3.10.0
*/
const undefinedKeyword = /* @__PURE__ */ new UndefinedKeyword({ [TitleAnnotationId]: "undefined" });
/**
* @category model
* @since 3.10.0
*/
var VoidKeyword = class {
	annotations;
	/**
	* @since 3.10.0
	*/
	_tag = "VoidKeyword";
	constructor(annotations$1 = {}) {
		this.annotations = annotations$1;
	}
	/**
	* @since 3.10.0
	*/
	toString() {
		return formatKeyword(this);
	}
	/**
	* @since 3.10.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category constructors
* @since 3.10.0
*/
const voidKeyword = /* @__PURE__ */ new VoidKeyword({ [TitleAnnotationId]: "void" });
/**
* @category model
* @since 3.10.0
*/
var NeverKeyword = class {
	annotations;
	/**
	* @since 3.10.0
	*/
	_tag = "NeverKeyword";
	constructor(annotations$1 = {}) {
		this.annotations = annotations$1;
	}
	/**
	* @since 3.10.0
	*/
	toString() {
		return formatKeyword(this);
	}
	/**
	* @since 3.10.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category constructors
* @since 3.10.0
*/
const neverKeyword = /* @__PURE__ */ new NeverKeyword({ [TitleAnnotationId]: "never" });
/**
* @category model
* @since 3.10.0
*/
var UnknownKeyword = class {
	annotations;
	/**
	* @since 3.10.0
	*/
	_tag = "UnknownKeyword";
	constructor(annotations$1 = {}) {
		this.annotations = annotations$1;
	}
	/**
	* @since 3.10.0
	*/
	toString() {
		return formatKeyword(this);
	}
	/**
	* @since 3.10.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category constructors
* @since 3.10.0
*/
const unknownKeyword = /* @__PURE__ */ new UnknownKeyword({ [TitleAnnotationId]: "unknown" });
/**
* @category model
* @since 3.10.0
*/
var AnyKeyword = class {
	annotations;
	/**
	* @since 3.10.0
	*/
	_tag = "AnyKeyword";
	constructor(annotations$1 = {}) {
		this.annotations = annotations$1;
	}
	/**
	* @since 3.10.0
	*/
	toString() {
		return formatKeyword(this);
	}
	/**
	* @since 3.10.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category constructors
* @since 3.10.0
*/
const anyKeyword = /* @__PURE__ */ new AnyKeyword({ [TitleAnnotationId]: "any" });
/**
* @category model
* @since 3.10.0
*/
var StringKeyword = class {
	annotations;
	/**
	* @since 3.10.0
	*/
	_tag = "StringKeyword";
	constructor(annotations$1 = {}) {
		this.annotations = annotations$1;
	}
	/**
	* @since 3.10.0
	*/
	toString() {
		return formatKeyword(this);
	}
	/**
	* @since 3.10.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category constructors
* @since 3.10.0
*/
const stringKeyword = /* @__PURE__ */ new StringKeyword({
	[TitleAnnotationId]: "string",
	[DescriptionAnnotationId]: "a string"
});
/**
* @category guards
* @since 3.10.0
*/
const isStringKeyword = /* @__PURE__ */ createASTGuard("StringKeyword");
/**
* @category model
* @since 3.10.0
*/
var NumberKeyword = class {
	annotations;
	/**
	* @since 3.10.0
	*/
	_tag = "NumberKeyword";
	constructor(annotations$1 = {}) {
		this.annotations = annotations$1;
	}
	/**
	* @since 3.10.0
	*/
	toString() {
		return formatKeyword(this);
	}
	/**
	* @since 3.10.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category constructors
* @since 3.10.0
*/
const numberKeyword = /* @__PURE__ */ new NumberKeyword({
	[TitleAnnotationId]: "number",
	[DescriptionAnnotationId]: "a number"
});
/**
* @category model
* @since 3.10.0
*/
var BooleanKeyword = class {
	annotations;
	/**
	* @since 3.10.0
	*/
	_tag = "BooleanKeyword";
	constructor(annotations$1 = {}) {
		this.annotations = annotations$1;
	}
	/**
	* @since 3.10.0
	*/
	toString() {
		return formatKeyword(this);
	}
	/**
	* @since 3.10.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category constructors
* @since 3.10.0
*/
const booleanKeyword = /* @__PURE__ */ new BooleanKeyword({
	[TitleAnnotationId]: "boolean",
	[DescriptionAnnotationId]: "a boolean"
});
/**
* @category model
* @since 3.10.0
*/
var BigIntKeyword = class {
	annotations;
	/**
	* @since 3.10.0
	*/
	_tag = "BigIntKeyword";
	constructor(annotations$1 = {}) {
		this.annotations = annotations$1;
	}
	/**
	* @since 3.10.0
	*/
	toString() {
		return formatKeyword(this);
	}
	/**
	* @since 3.10.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category constructors
* @since 3.10.0
*/
const bigIntKeyword = /* @__PURE__ */ new BigIntKeyword({
	[TitleAnnotationId]: "bigint",
	[DescriptionAnnotationId]: "a bigint"
});
/**
* @category model
* @since 3.10.0
*/
var SymbolKeyword = class {
	annotations;
	/**
	* @since 3.10.0
	*/
	_tag = "SymbolKeyword";
	constructor(annotations$1 = {}) {
		this.annotations = annotations$1;
	}
	/**
	* @since 3.10.0
	*/
	toString() {
		return formatKeyword(this);
	}
	/**
	* @since 3.10.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category constructors
* @since 3.10.0
*/
const symbolKeyword = /* @__PURE__ */ new SymbolKeyword({
	[TitleAnnotationId]: "symbol",
	[DescriptionAnnotationId]: "a symbol"
});
/**
* @category guards
* @since 3.10.0
*/
const isSymbolKeyword = /* @__PURE__ */ createASTGuard("SymbolKeyword");
/**
* @category model
* @since 3.10.0
*/
var ObjectKeyword = class {
	annotations;
	/**
	* @since 3.10.0
	*/
	_tag = "ObjectKeyword";
	constructor(annotations$1 = {}) {
		this.annotations = annotations$1;
	}
	/**
	* @since 3.10.0
	*/
	toString() {
		return formatKeyword(this);
	}
	/**
	* @since 3.10.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category constructors
* @since 3.10.0
*/
const objectKeyword = /* @__PURE__ */ new ObjectKeyword({
	[TitleAnnotationId]: "object",
	[DescriptionAnnotationId]: "an object in the TypeScript meaning, i.e. the `object` type"
});
/**
* @category model
* @since 3.10.0
*/
var Type$1 = class {
	type;
	annotations;
	constructor(type, annotations$1 = {}) {
		this.type = type;
		this.annotations = annotations$1;
	}
	/**
	* @since 3.10.0
	*/
	toJSON() {
		return {
			type: this.type.toJSON(),
			annotations: toJSONAnnotations(this.annotations)
		};
	}
	/**
	* @since 3.10.0
	*/
	toString() {
		return String(this.type);
	}
};
/**
* @category model
* @since 3.10.0
*/
var OptionalType = class extends Type$1 {
	isOptional;
	constructor(type, isOptional, annotations$1 = {}) {
		super(type, annotations$1);
		this.isOptional = isOptional;
	}
	/**
	* @since 3.10.0
	*/
	toJSON() {
		return {
			type: this.type.toJSON(),
			isOptional: this.isOptional,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
	/**
	* @since 3.10.0
	*/
	toString() {
		return String(this.type) + (this.isOptional ? "?" : "");
	}
};
const getRestASTs = (rest) => rest.map((annotatedAST) => annotatedAST.type);
/**
* @category model
* @since 3.10.0
*/
var TupleType = class {
	elements;
	rest;
	isReadonly;
	annotations;
	/**
	* @since 3.10.0
	*/
	_tag = "TupleType";
	constructor(elements, rest, isReadonly, annotations$1 = {}) {
		this.elements = elements;
		this.rest = rest;
		this.isReadonly = isReadonly;
		this.annotations = annotations$1;
		let hasOptionalElement = false;
		let hasIllegalRequiredElement = false;
		for (const e of elements) if (e.isOptional) hasOptionalElement = true;
		else if (hasOptionalElement) {
			hasIllegalRequiredElement = true;
			break;
		}
		if (hasIllegalRequiredElement || hasOptionalElement && rest.length > 1) throw new Error(getASTRequiredElementFollowinAnOptionalElementErrorMessage);
	}
	/**
	* @since 3.10.0
	*/
	toString() {
		return getOrElse$5(getExpected(this), () => formatTuple(this));
	}
	/**
	* @since 3.10.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			elements: this.elements.map((e) => e.toJSON()),
			rest: this.rest.map((ast) => ast.toJSON()),
			isReadonly: this.isReadonly,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
const formatTuple = (ast) => {
	const formattedElements = ast.elements.map(String).join(", ");
	return matchLeft(ast.rest, {
		onEmpty: () => `readonly [${formattedElements}]`,
		onNonEmpty: (head$4, tail) => {
			const formattedHead = String(head$4);
			const wrappedHead = formattedHead.includes(" | ") ? `(${formattedHead})` : formattedHead;
			if (tail.length > 0) {
				const formattedTail = tail.map(String).join(", ");
				if (ast.elements.length > 0) return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`;
				else return `readonly [...${wrappedHead}[], ${formattedTail}]`;
			} else if (ast.elements.length > 0) return `readonly [${formattedElements}, ...${wrappedHead}[]]`;
			else return `ReadonlyArray<${formattedHead}>`;
		}
	});
};
/**
* @category model
* @since 3.10.0
*/
var PropertySignature = class extends OptionalType {
	name;
	isReadonly;
	constructor(name, type, isOptional, isReadonly, annotations$1) {
		super(type, isOptional, annotations$1);
		this.name = name;
		this.isReadonly = isReadonly;
	}
	/**
	* @since 3.10.0
	*/
	toString() {
		return (this.isReadonly ? "readonly " : "") + String(this.name) + (this.isOptional ? "?" : "") + ": " + this.type;
	}
	/**
	* @since 3.10.0
	*/
	toJSON() {
		return {
			name: String(this.name),
			type: this.type.toJSON(),
			isOptional: this.isOptional,
			isReadonly: this.isReadonly,
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @since 3.10.0
*/
const isParameter = (ast) => {
	switch (ast._tag) {
		case "StringKeyword":
		case "SymbolKeyword":
		case "TemplateLiteral": return true;
		case "Refinement": return isParameter(ast.from);
	}
	return false;
};
/**
* @category model
* @since 3.10.0
*/
var IndexSignature = class {
	type;
	isReadonly;
	/**
	* @since 3.10.0
	*/
	parameter;
	constructor(parameter, type, isReadonly) {
		this.type = type;
		this.isReadonly = isReadonly;
		if (isParameter(parameter)) this.parameter = parameter;
		else throw new Error(getASTIndexSignatureParameterErrorMessage);
	}
	/**
	* @since 3.10.0
	*/
	toString() {
		return (this.isReadonly ? "readonly " : "") + `[x: ${this.parameter}]: ${this.type}`;
	}
	/**
	* @since 3.10.0
	*/
	toJSON() {
		return {
			parameter: this.parameter.toJSON(),
			type: this.type.toJSON(),
			isReadonly: this.isReadonly
		};
	}
};
/**
* @category model
* @since 3.10.0
*/
var TypeLiteral = class {
	annotations;
	/**
	* @since 3.10.0
	*/
	_tag = "TypeLiteral";
	/**
	* @since 3.10.0
	*/
	propertySignatures;
	/**
	* @since 3.10.0
	*/
	indexSignatures;
	constructor(propertySignatures, indexSignatures, annotations$1 = {}) {
		this.annotations = annotations$1;
		const keys$5 = {};
		for (let i$1 = 0; i$1 < propertySignatures.length; i$1++) {
			const name = propertySignatures[i$1].name;
			if (Object.prototype.hasOwnProperty.call(keys$5, name)) throw new Error(getASTDuplicatePropertySignatureErrorMessage(name));
			keys$5[name] = null;
		}
		const parameters = {
			string: false,
			symbol: false
		};
		for (let i$1 = 0; i$1 < indexSignatures.length; i$1++) {
			const encodedParameter = getEncodedParameter(indexSignatures[i$1].parameter);
			if (isStringKeyword(encodedParameter)) {
				if (parameters.string) throw new Error(getASTDuplicateIndexSignatureErrorMessage("string"));
				parameters.string = true;
			} else if (isSymbolKeyword(encodedParameter)) {
				if (parameters.symbol) throw new Error(getASTDuplicateIndexSignatureErrorMessage("symbol"));
				parameters.symbol = true;
			}
		}
		this.propertySignatures = propertySignatures;
		this.indexSignatures = indexSignatures;
	}
	/**
	* @since 3.10.0
	*/
	toString() {
		return getOrElse$5(getExpected(this), () => formatTypeLiteral(this));
	}
	/**
	* @since 3.10.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			propertySignatures: this.propertySignatures.map((ps) => ps.toJSON()),
			indexSignatures: this.indexSignatures.map((ps) => ps.toJSON()),
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
const formatIndexSignatures = (iss) => iss.map(String).join("; ");
const formatTypeLiteral = (ast) => {
	if (ast.propertySignatures.length > 0) {
		const pss = ast.propertySignatures.map(String).join("; ");
		if (ast.indexSignatures.length > 0) return `{ ${pss}; ${formatIndexSignatures(ast.indexSignatures)} }`;
		else return `{ ${pss} }`;
	} else if (ast.indexSignatures.length > 0) return `{ ${formatIndexSignatures(ast.indexSignatures)} }`;
	else return "{}";
};
const sortCandidates = /* @__PURE__ */ sort(/* @__PURE__ */ mapInput(Order$4, (ast) => {
	switch (ast._tag) {
		case "AnyKeyword": return 0;
		case "UnknownKeyword": return 1;
		case "ObjectKeyword": return 2;
		case "StringKeyword":
		case "NumberKeyword":
		case "BooleanKeyword":
		case "BigIntKeyword":
		case "SymbolKeyword": return 3;
	}
	return 4;
}));
const literalMap = {
	string: "StringKeyword",
	number: "NumberKeyword",
	boolean: "BooleanKeyword",
	bigint: "BigIntKeyword"
};
/** @internal */
const flatten$6 = (candidates) => flatMap$11(candidates, (ast) => isUnion(ast) ? flatten$6(ast.types) : [ast]);
/** @internal */
const unify = (candidates) => {
	const cs = sortCandidates(candidates);
	const out = [];
	const uniques = {};
	const literals = [];
	for (const ast of cs) switch (ast._tag) {
		case "NeverKeyword": break;
		case "AnyKeyword": return [anyKeyword];
		case "UnknownKeyword": return [unknownKeyword];
		case "ObjectKeyword":
		case "UndefinedKeyword":
		case "VoidKeyword":
		case "StringKeyword":
		case "NumberKeyword":
		case "BooleanKeyword":
		case "BigIntKeyword":
		case "SymbolKeyword":
			if (!uniques[ast._tag]) {
				uniques[ast._tag] = ast;
				out.push(ast);
			}
			break;
		case "Literal": {
			const type = typeof ast.literal;
			switch (type) {
				case "string":
				case "number":
				case "bigint":
				case "boolean":
					if (!uniques[literalMap[type]] && !literals.includes(ast.literal)) {
						literals.push(ast.literal);
						out.push(ast);
					}
					break;
				case "object":
					if (!literals.includes(ast.literal)) {
						literals.push(ast.literal);
						out.push(ast);
					}
					break;
			}
			break;
		}
		case "UniqueSymbol":
			if (!uniques["SymbolKeyword"] && !literals.includes(ast.symbol)) {
				literals.push(ast.symbol);
				out.push(ast);
			}
			break;
		case "TupleType":
			if (!uniques["ObjectKeyword"]) out.push(ast);
			break;
		case "TypeLiteral":
			if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
				if (!uniques["{}"]) {
					uniques["{}"] = ast;
					out.push(ast);
				}
			} else if (!uniques["ObjectKeyword"]) out.push(ast);
			break;
		default: out.push(ast);
	}
	return out;
};
/**
* @category model
* @since 3.10.0
*/
var Union = class Union {
	types;
	annotations;
	static make = (types, annotations$1) => {
		return isMembers(types) ? new Union(types, annotations$1) : types.length === 1 ? types[0] : neverKeyword;
	};
	/** @internal */
	static unify = (candidates, annotations$1) => {
		return Union.make(unify(flatten$6(candidates)), annotations$1);
	};
	/**
	* @since 3.10.0
	*/
	_tag = "Union";
	constructor(types, annotations$1 = {}) {
		this.types = types;
		this.annotations = annotations$1;
	}
	/**
	* @since 3.10.0
	*/
	toString() {
		return getOrElse$5(getExpected(this), () => this.types.map(String).join(" | "));
	}
	/**
	* @since 3.10.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			types: this.types.map((ast) => ast.toJSON()),
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/** @internal */
const mapMembers = (members, f$1) => members.map(f$1);
/** @internal */
const isMembers = (as$6) => as$6.length > 1;
/**
* @category guards
* @since 3.10.0
*/
const isUnion = /* @__PURE__ */ createASTGuard("Union");
const toJSONMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Schema/AST/toJSONMemoMap"), () => /* @__PURE__ */ new WeakMap());
/**
* @category model
* @since 3.10.0
*/
var Suspend = class {
	f;
	annotations;
	/**
	* @since 3.10.0
	*/
	_tag = "Suspend";
	constructor(f$1, annotations$1 = {}) {
		this.f = f$1;
		this.annotations = annotations$1;
		this.f = memoizeThunk(f$1);
	}
	/**
	* @since 3.10.0
	*/
	toString() {
		return getExpected(this).pipe(orElse$5(() => flatMap$12(liftThrowable(this.f)(), (ast) => getExpected(ast))), getOrElse$5(() => "<suspended schema>"));
	}
	/**
	* @since 3.10.0
	*/
	toJSON() {
		const ast = this.f();
		let out = toJSONMemoMap.get(ast);
		if (out) return out;
		toJSONMemoMap.set(ast, { _tag: this._tag });
		out = {
			_tag: this._tag,
			ast: ast.toJSON(),
			annotations: toJSONAnnotations(this.annotations)
		};
		toJSONMemoMap.set(ast, out);
		return out;
	}
};
/**
* @category model
* @since 3.10.0
*/
var Refinement$1 = class {
	from;
	filter;
	annotations;
	/**
	* @since 3.10.0
	*/
	_tag = "Refinement";
	constructor(from, filter$8, annotations$1 = {}) {
		this.from = from;
		this.filter = filter$8;
		this.annotations = annotations$1;
	}
	/**
	* @since 3.10.0
	*/
	toString() {
		return getIdentifierAnnotation(this).pipe(getOrElse$5(() => match$11(getOrElseExpected(this), {
			onNone: () => `{ ${this.from} | filter }`,
			onSome: (expected) => isRefinement$1(this.from) ? String(this.from) + " & " + expected : expected
		})));
	}
	/**
	* @since 3.10.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			from: this.from.toJSON(),
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category guards
* @since 3.10.0
*/
const isRefinement$1 = /* @__PURE__ */ createASTGuard("Refinement");
/**
* @since 3.10.0
*/
const defaultParseOption = {};
/**
* @category model
* @since 3.10.0
*/
var Transformation$1 = class {
	from;
	to;
	transformation;
	annotations;
	/**
	* @since 3.10.0
	*/
	_tag = "Transformation";
	constructor(from, to, transformation, annotations$1 = {}) {
		this.from = from;
		this.to = to;
		this.transformation = transformation;
		this.annotations = annotations$1;
	}
	/**
	* @since 3.10.0
	*/
	toString() {
		return getOrElse$5(getExpected(this), () => `(${String(this.from)} <-> ${String(this.to)})`);
	}
	/**
	* @since 3.10.0
	*/
	toJSON() {
		return {
			_tag: this._tag,
			from: this.from.toJSON(),
			to: this.to.toJSON(),
			annotations: toJSONAnnotations(this.annotations)
		};
	}
};
/**
* @category model
* @since 3.10.0
*/
var FinalTransformation = class {
	decode;
	encode;
	/**
	* @since 3.10.0
	*/
	_tag = "FinalTransformation";
	constructor(decode$4, encode$3) {
		this.decode = decode$4;
		this.encode = encode$3;
	}
};
/**
* Merges a set of new annotations with existing ones, potentially overwriting
* any duplicates.
*
* Any previously existing identifier annotations are deleted.
*
* @since 3.10.0
*/
const annotations = (ast, overrides) => {
	const d = Object.getOwnPropertyDescriptors(ast);
	const base = { ...ast.annotations };
	delete base[IdentifierAnnotationId];
	const value = {
		...base,
		...overrides
	};
	const surrogate = getSurrogateAnnotation(ast);
	if (isSome(surrogate)) value[SurrogateAnnotationId] = annotations(surrogate.value, overrides);
	d.annotations.value = value;
	return Object.create(Object.getPrototypeOf(ast), d);
};
const STRING_KEYWORD_PATTERN = "[\\s\\S]*?";
const NUMBER_KEYWORD_PATTERN = "[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?";
const getTemplateLiteralSpanTypePattern = (type, capture$1) => {
	switch (type._tag) {
		case "Literal": return escape(String(type.literal));
		case "StringKeyword": return STRING_KEYWORD_PATTERN;
		case "NumberKeyword": return NUMBER_KEYWORD_PATTERN;
		case "TemplateLiteral": return getTemplateLiteralPattern(type, capture$1, false);
		case "Union": return type.types.map((type$1) => getTemplateLiteralSpanTypePattern(type$1, capture$1)).join("|");
	}
};
const handleTemplateLiteralSpanTypeParens = (type, s$1, capture$1, top) => {
	if (isUnion(type)) {
		if (capture$1 && !top) return `(?:${s$1})`;
	} else if (!capture$1 || !top) return s$1;
	return `(${s$1})`;
};
const getTemplateLiteralPattern = (ast, capture$1, top) => {
	let pattern = ``;
	if (ast.head !== "") {
		const head$4 = escape(ast.head);
		pattern += capture$1 && top ? `(${head$4})` : head$4;
	}
	for (const span$1 of ast.spans) {
		const spanPattern = getTemplateLiteralSpanTypePattern(span$1.type, capture$1);
		pattern += handleTemplateLiteralSpanTypeParens(span$1.type, spanPattern, capture$1, top);
		if (span$1.literal !== "") {
			const literal = escape(span$1.literal);
			pattern += capture$1 && top ? `(${literal})` : literal;
		}
	}
	return pattern;
};
/**
* Generates a regular expression from a `TemplateLiteral` AST node.
*
* @see {@link getTemplateLiteralCapturingRegExp} for a variant that captures the pattern.
*
* @since 3.10.0
*/
const getTemplateLiteralRegExp = (ast) => /* @__PURE__ */ new RegExp(`^${getTemplateLiteralPattern(ast, false, true)}$`);
/** @internal */
const pickAnnotations = (annotationIds) => (annotated) => {
	let out = void 0;
	for (const id$2 of annotationIds) if (Object.prototype.hasOwnProperty.call(annotated.annotations, id$2)) {
		if (out === void 0) out = {};
		out[id$2] = annotated.annotations[id$2];
	}
	return out;
};
/** @internal */
const omitAnnotations = (annotationIds) => (annotated) => {
	const out = { ...annotated.annotations };
	for (const id$2 of annotationIds) delete out[id$2];
	return out;
};
const preserveTransformationAnnotations = /* @__PURE__ */ pickAnnotations([
	ExamplesAnnotationId,
	DefaultAnnotationId,
	JSONSchemaAnnotationId,
	ArbitraryAnnotationId,
	PrettyAnnotationId,
	EquivalenceAnnotationId
]);
/**
* @since 3.10.0
*/
const typeAST = (ast) => {
	switch (ast._tag) {
		case "Declaration": {
			const typeParameters = changeMap(ast.typeParameters, typeAST);
			return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
		}
		case "TupleType": {
			const elements = changeMap(ast.elements, (e) => {
				const type = typeAST(e.type);
				return type === e.type ? e : new OptionalType(type, e.isOptional);
			});
			const restASTs = getRestASTs(ast.rest);
			const rest = changeMap(restASTs, typeAST);
			return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((type) => new Type$1(type)), ast.isReadonly, ast.annotations);
		}
		case "TypeLiteral": {
			const propertySignatures = changeMap(ast.propertySignatures, (p) => {
				const type = typeAST(p.type);
				return type === p.type ? p : new PropertySignature(p.name, type, p.isOptional, p.isReadonly);
			});
			const indexSignatures = changeMap(ast.indexSignatures, (is) => {
				const type = typeAST(is.type);
				return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly);
			});
			return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
		}
		case "Union": {
			const types = changeMap(ast.types, typeAST);
			return types === ast.types ? ast : Union.make(types, ast.annotations);
		}
		case "Suspend": return new Suspend(() => typeAST(ast.f()), ast.annotations);
		case "Refinement": {
			const from = typeAST(ast.from);
			return from === ast.from ? ast : new Refinement$1(from, ast.filter, ast.annotations);
		}
		case "Transformation": {
			const preserve = preserveTransformationAnnotations(ast);
			return typeAST(preserve !== void 0 ? annotations(ast.to, preserve) : ast.to);
		}
	}
	return ast;
};
function changeMap(as$6, f$1) {
	let changed = false;
	const out = allocate(as$6.length);
	for (let i$1 = 0; i$1 < as$6.length; i$1++) {
		const a$1 = as$6[i$1];
		const fa = f$1(a$1);
		if (fa !== a$1) changed = true;
		out[i$1] = fa;
	}
	return changed ? out : as$6;
}
/**
* Returns the from part of a transformation if it exists
*
* @internal
*/
const getTransformationFrom = (ast) => {
	switch (ast._tag) {
		case "Transformation": return ast.from;
		case "Refinement": return getTransformationFrom(ast.from);
		case "Suspend": return getTransformationFrom(ast.f());
	}
};
const encodedAST_ = (ast, isBound) => {
	switch (ast._tag) {
		case "Declaration": {
			const typeParameters = changeMap(ast.typeParameters, (ast$1) => encodedAST_(ast$1, isBound));
			return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown);
		}
		case "TupleType": {
			const elements = changeMap(ast.elements, (e) => {
				const type = encodedAST_(e.type, isBound);
				return type === e.type ? e : new OptionalType(type, e.isOptional);
			});
			const restASTs = getRestASTs(ast.rest);
			const rest = changeMap(restASTs, (ast$1) => encodedAST_(ast$1, isBound));
			return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((ast$1) => new Type$1(ast$1)), ast.isReadonly);
		}
		case "TypeLiteral": {
			const propertySignatures = changeMap(ast.propertySignatures, (ps) => {
				const type = encodedAST_(ps.type, isBound);
				return type === ps.type ? ps : new PropertySignature(ps.name, type, ps.isOptional, ps.isReadonly);
			});
			const indexSignatures = changeMap(ast.indexSignatures, (is) => {
				const type = encodedAST_(is.type, isBound);
				return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly);
			});
			return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures);
		}
		case "Union": {
			const types = changeMap(ast.types, (ast$1) => encodedAST_(ast$1, isBound));
			return types === ast.types ? ast : Union.make(types);
		}
		case "Suspend": {
			let borrowedAnnotations = void 0;
			const identifier$1 = getJSONIdentifier(ast);
			if (isSome(identifier$1)) {
				const suffix = isBound ? "Bound" : "";
				borrowedAnnotations = { [JSONIdentifierAnnotationId]: `${identifier$1.value}Encoded${suffix}` };
			}
			return new Suspend(() => encodedAST_(ast.f(), isBound), borrowedAnnotations);
		}
		case "Refinement": {
			const from = encodedAST_(ast.from, isBound);
			if (isBound) {
				if (from === ast.from) return ast;
				if (getTransformationFrom(ast.from) === void 0 && hasStableFilter(ast)) return new Refinement$1(from, ast.filter, ast.annotations);
				return from;
			} else return from;
		}
		case "Transformation": return encodedAST_(ast.from, isBound);
	}
	return ast;
};
/**
* @since 3.10.0
*/
const encodedAST = (ast) => encodedAST_(ast, false);
const toJSONAnnotations = (annotations$1) => {
	const out = {};
	for (const k of Object.getOwnPropertySymbols(annotations$1)) out[String(k)] = annotations$1[k];
	return out;
};
/** @internal */
const getEncodedParameter = (ast) => {
	switch (ast._tag) {
		case "StringKeyword":
		case "SymbolKeyword":
		case "TemplateLiteral": return ast;
		case "Refinement": return getEncodedParameter(ast.from);
	}
};
const formatKeyword = (ast) => getOrElse$5(getExpected(ast), () => ast._tag);
function getBrands(ast) {
	return match$11(getBrandAnnotation(ast), {
		onNone: () => "",
		onSome: (brands) => brands.map((brand) => ` & Brand<${formatUnknown(brand)}>`).join("")
	});
}
const getOrElseExpected = (ast) => getTitleAnnotation(ast).pipe(orElse$5(() => getDescriptionAnnotation(ast)), orElse$5(() => getAutoTitleAnnotation(ast)), map$16((s$1) => s$1 + getBrands(ast)));
const getExpected = (ast) => orElse$5(getIdentifierAnnotation(ast), () => getOrElseExpected(ast));

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Boolean.js
/**
* Tests if a value is a `boolean`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { isBoolean } from "effect/Boolean"
*
* assert.deepStrictEqual(isBoolean(true), true)
* assert.deepStrictEqual(isBoolean("true"), false)
* ```
*
* @category guards
* @since 2.0.0
*/
const isBoolean = isBoolean$1;
/**
* @category instances
* @since 2.0.0
*/
const Equivalence$1 = boolean$1;
/**
* @category instances
* @since 2.0.0
*/
const Order$3 = boolean;
/**
* Negates the given boolean: `!self`
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { not } from "effect/Boolean"
*
* assert.deepStrictEqual(not(true), false)
* assert.deepStrictEqual(not(false), true)
* ```
*
* @category combinators
* @since 2.0.0
*/
const not = (self) => !self;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/context.js
/** @internal */
const TagTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Context/Tag");
/** @internal */
const ReferenceTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Context/Reference");
/** @internal */
const STMSymbolKey = "effect/STM";
/** @internal */
const STMTypeId = /* @__PURE__ */ Symbol.for(STMSymbolKey);
/** @internal */
const TagProto = {
	...EffectPrototype$1,
	_op: "Tag",
	[STMTypeId]: effectVariance,
	[TagTypeId$1]: {
		_Service: (_$1) => _$1,
		_Identifier: (_$1) => _$1
	},
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "Tag",
			key: this.key,
			stack: this.stack
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	of(self) {
		return self;
	},
	context(self) {
		return make$45(this, self);
	}
};
const ReferenceProto = {
	...TagProto,
	[ReferenceTypeId$1]: ReferenceTypeId$1
};
/** @internal */
const makeGenericTag = (key) => {
	const limit = Error.stackTraceLimit;
	Error.stackTraceLimit = 2;
	const creationError = /* @__PURE__ */ new Error();
	Error.stackTraceLimit = limit;
	const tag$1 = Object.create(TagProto);
	Object.defineProperty(tag$1, "stack", { get() {
		return creationError.stack;
	} });
	tag$1.key = key;
	return tag$1;
};
/** @internal */
const Tag$1 = (id$2) => () => {
	const limit = Error.stackTraceLimit;
	Error.stackTraceLimit = 2;
	const creationError = /* @__PURE__ */ new Error();
	Error.stackTraceLimit = limit;
	function TagClass() {}
	Object.setPrototypeOf(TagClass, TagProto);
	TagClass.key = id$2;
	Object.defineProperty(TagClass, "stack", { get() {
		return creationError.stack;
	} });
	return TagClass;
};
/** @internal */
const Reference$1 = () => (id$2, options) => {
	const limit = Error.stackTraceLimit;
	Error.stackTraceLimit = 2;
	const creationError = /* @__PURE__ */ new Error();
	Error.stackTraceLimit = limit;
	function ReferenceClass() {}
	Object.setPrototypeOf(ReferenceClass, ReferenceProto);
	ReferenceClass.key = id$2;
	ReferenceClass.defaultValue = options.defaultValue;
	Object.defineProperty(ReferenceClass, "stack", { get() {
		return creationError.stack;
	} });
	return ReferenceClass;
};
/** @internal */
const TypeId$16 = /* @__PURE__ */ Symbol.for("effect/Context");
/** @internal */
const ContextProto = {
	[TypeId$16]: { _Services: (_$1) => _$1 },
	[symbol](that) {
		if (isContext$1(that)) {
			if (this.unsafeMap.size === that.unsafeMap.size) {
				for (const k of this.unsafeMap.keys()) if (!that.unsafeMap.has(k) || !equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) return false;
				return true;
			}
		}
		return false;
	},
	[symbol$1]() {
		return cached$2(this, number$1(this.unsafeMap.size));
	},
	pipe() {
		return pipeArguments(this, arguments);
	},
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "Context",
			services: Array.from(this.unsafeMap).map(toJSON)
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	}
};
/** @internal */
const makeContext = (unsafeMap) => {
	const context$2 = Object.create(ContextProto);
	context$2.unsafeMap = unsafeMap;
	return context$2;
};
const serviceNotFoundError = (tag$1) => {
	const error = /* @__PURE__ */ new Error(`Service not found${tag$1.key ? `: ${String(tag$1.key)}` : ""}`);
	if (tag$1.stack) {
		const lines = tag$1.stack.split("\n");
		if (lines.length > 2) {
			const afterAt = lines[2].match(/at (.*)/);
			if (afterAt) error.message = error.message + ` (defined at ${afterAt[1]})`;
		}
	}
	if (error.stack) {
		const lines = error.stack.split("\n");
		lines.splice(1, 3);
		error.stack = lines.join("\n");
	}
	return error;
};
/** @internal */
const isContext$1 = (u$1) => hasProperty(u$1, TypeId$16);
/** @internal */
const isTag$1 = (u$1) => hasProperty(u$1, TagTypeId$1);
/** @internal */
const isReference$1 = (u$1) => hasProperty(u$1, ReferenceTypeId$1);
const _empty$9 = /* @__PURE__ */ makeContext(/* @__PURE__ */ new Map());
/** @internal */
const empty$32 = () => _empty$9;
/** @internal */
const make$45 = (tag$1, service) => makeContext(new Map([[tag$1.key, service]]));
/** @internal */
const add$4 = /* @__PURE__ */ dual$1(3, (self, tag$1, service) => {
	const map$18 = new Map(self.unsafeMap);
	map$18.set(tag$1.key, service);
	return makeContext(map$18);
});
const defaultValueCache = /* @__PURE__ */ globalValue("effect/Context/defaultValueCache", () => /* @__PURE__ */ new Map());
const getDefaultValue = (tag$1) => {
	if (defaultValueCache.has(tag$1.key)) return defaultValueCache.get(tag$1.key);
	const value = tag$1.defaultValue();
	defaultValueCache.set(tag$1.key, value);
	return value;
};
/** @internal */
const unsafeGetReference = (self, tag$1) => {
	return self.unsafeMap.has(tag$1.key) ? self.unsafeMap.get(tag$1.key) : getDefaultValue(tag$1);
};
/** @internal */
const unsafeGet$4 = /* @__PURE__ */ dual$1(2, (self, tag$1) => {
	if (!self.unsafeMap.has(tag$1.key)) {
		if (ReferenceTypeId$1 in tag$1) return getDefaultValue(tag$1);
		throw serviceNotFoundError(tag$1);
	}
	return self.unsafeMap.get(tag$1.key);
});
/** @internal */
const get$10 = unsafeGet$4;
/** @internal */
const getOrElse$4 = /* @__PURE__ */ dual$1(3, (self, tag$1, orElse$6) => {
	if (!self.unsafeMap.has(tag$1.key)) return isReference$1(tag$1) ? getDefaultValue(tag$1) : orElse$6();
	return self.unsafeMap.get(tag$1.key);
});
/** @internal */
const getOption$1 = /* @__PURE__ */ dual$1(2, (self, tag$1) => {
	if (!self.unsafeMap.has(tag$1.key)) return isReference$1(tag$1) ? some$5(getDefaultValue(tag$1)) : none$8;
	return some$5(self.unsafeMap.get(tag$1.key));
});
/** @internal */
const merge$5 = /* @__PURE__ */ dual$1(2, (self, that) => {
	const map$18 = new Map(self.unsafeMap);
	for (const [tag$1, s$1] of that.unsafeMap) map$18.set(tag$1, s$1);
	return makeContext(map$18);
});
/** @internal */
const mergeAll$4 = (...ctxs) => {
	const map$18 = /* @__PURE__ */ new Map();
	for (const ctx of ctxs) for (const [tag$1, s$1] of ctx.unsafeMap) map$18.set(tag$1, s$1);
	return makeContext(map$18);
};
/** @internal */
const pick$1 = (...tags) => (self) => {
	const tagSet = new Set(tags.map((_$1) => _$1.key));
	const newEnv = /* @__PURE__ */ new Map();
	for (const [tag$1, s$1] of self.unsafeMap.entries()) if (tagSet.has(tag$1)) newEnv.set(tag$1, s$1);
	return makeContext(newEnv);
};
/** @internal */
const omit$1 = (...tags) => (self) => {
	const newEnv = new Map(self.unsafeMap);
	for (const tag$1 of tags) newEnv.delete(tag$1.key);
	return makeContext(newEnv);
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Context.js
/**
* @since 2.0.0
* @category symbol
*/
const TagTypeId = TagTypeId$1;
/**
* @since 3.11.0
* @category symbol
*/
const ReferenceTypeId = ReferenceTypeId$1;
/**
* Creates a new `Tag` instance with an optional key parameter.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Context } from "effect"
*
* assert.strictEqual(Context.GenericTag("PORT").key === Context.GenericTag("PORT").key, true)
* ```
*
* @since 2.0.0
* @category constructors
*/
const GenericTag$1 = makeGenericTag;
TypeId$16;
/**
* @since 2.0.0
* @category constructors
*/
const unsafeMake$9 = makeContext;
/**
* Checks if the provided argument is a `Context`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Context } from "effect"
*
* assert.strictEqual(Context.isContext(Context.empty()), true)
* ```
*
* @since 2.0.0
* @category guards
*/
const isContext = isContext$1;
/**
* Checks if the provided argument is a `Tag`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Context } from "effect"
*
* assert.strictEqual(Context.isTag(Context.GenericTag("Tag")), true)
* ```
*
* @since 2.0.0
* @category guards
*/
const isTag = isTag$1;
/**
* Checks if the provided argument is a `Reference`.
*
* @since 3.11.0
* @category guards
* @experimental
*/
const isReference = isReference$1;
/**
* Returns an empty `Context`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Context } from "effect"
*
* assert.strictEqual(Context.isContext(Context.empty()), true)
* ```
*
* @since 2.0.0
* @category constructors
*/
const empty$31 = empty$32;
/**
* Creates a new `Context` with a single service associated to the tag.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Context } from "effect"
*
* const Port = Context.GenericTag<{ PORT: number }>("Port")
*
* const Services = Context.make(Port, { PORT: 8080 })
*
* assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })
* ```
*
* @since 2.0.0
* @category constructors
*/
const make$44 = make$45;
/**
* Adds a service to a given `Context`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Context, pipe } from "effect"
*
* const Port = Context.GenericTag<{ PORT: number }>("Port")
* const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")
*
* const someContext = Context.make(Port, { PORT: 8080 })
*
* const Services = pipe(
*   someContext,
*   Context.add(Timeout, { TIMEOUT: 5000 })
* )
*
* assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })
* assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })
* ```
*
* @since 2.0.0
*/
const add$3 = add$4;
/**
* Get a service from the context that corresponds to the given tag.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { pipe, Context } from "effect"
*
* const Port = Context.GenericTag<{ PORT: number }>("Port")
* const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")
*
* const Services = pipe(
*   Context.make(Port, { PORT: 8080 }),
*   Context.add(Timeout, { TIMEOUT: 5000 })
* )
*
* assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })
* ```
*
* @since 2.0.0
* @category getters
*/
const get$9 = get$10;
/**
* Get a service from the context that corresponds to the given tag, or
* use the fallback value.
*
* @since 3.7.0
* @category getters
*/
const getOrElse$3 = getOrElse$4;
/**
* Get a service from the context that corresponds to the given tag.
* This function is unsafe because if the tag is not present in the context, a runtime error will be thrown.
*
* For a safer version see {@link getOption}.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Context } from "effect"
*
* const Port = Context.GenericTag<{ PORT: number }>("Port")
* const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")
*
* const Services = Context.make(Port, { PORT: 8080 })
*
* assert.deepStrictEqual(Context.unsafeGet(Services, Port), { PORT: 8080 })
* assert.throws(() => Context.unsafeGet(Services, Timeout))
* ```
*
* @since 2.0.0
* @category unsafe
*/
const unsafeGet$3 = unsafeGet$4;
/**
* Get the value associated with the specified tag from the context wrapped in an `Option` object. If the tag is not
* found, the `Option` object will be `None`.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Context, Option } from "effect"
*
* const Port = Context.GenericTag<{ PORT: number }>("Port")
* const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")
*
* const Services = Context.make(Port, { PORT: 8080 })
*
* assert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))
* assert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())
* ```
*
* @since 2.0.0
* @category getters
*/
const getOption = getOption$1;
/**
* Merges two `Context`s, returning a new `Context` containing the services of both.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Context } from "effect"
*
* const Port = Context.GenericTag<{ PORT: number }>("Port")
* const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")
*
* const firstContext = Context.make(Port, { PORT: 8080 })
* const secondContext = Context.make(Timeout, { TIMEOUT: 5000 })
*
* const Services = Context.merge(firstContext, secondContext)
*
* assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })
* assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })
* ```
*
* @since 2.0.0
*/
const merge$4 = merge$5;
/**
* Merges any number of `Context`s, returning a new `Context` containing the services of all.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Context } from "effect"
*
* const Port = Context.GenericTag<{ PORT: number }>("Port")
* const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")
* const Host = Context.GenericTag<{ HOST: string }>("Host")
*
* const firstContext = Context.make(Port, { PORT: 8080 })
* const secondContext = Context.make(Timeout, { TIMEOUT: 5000 })
* const thirdContext = Context.make(Host, { HOST: "localhost" })
*
* const Services = Context.mergeAll(firstContext, secondContext, thirdContext)
*
* assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })
* assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })
* assert.deepStrictEqual(Context.get(Services, Host), { HOST: "localhost" })
* ```
*
* @since 3.12.0
*/
const mergeAll$3 = mergeAll$4;
/**
* Returns a new `Context` that contains only the specified services.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { pipe, Context, Option } from "effect"
*
* const Port = Context.GenericTag<{ PORT: number }>("Port")
* const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")
*
* const someContext = pipe(
*   Context.make(Port, { PORT: 8080 }),
*   Context.add(Timeout, { TIMEOUT: 5000 })
* )
*
* const Services = pipe(someContext, Context.pick(Port))
*
* assert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))
* assert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())
* ```
*
* @since 2.0.0
*/
const pick = pick$1;
/**
* @since 2.0.0
*/
const omit = omit$1;
/**
* @example
* ```ts
* import * as assert from "node:assert"
* import { Context, Layer } from "effect"
*
* class MyTag extends Context.Tag("MyTag")<
*  MyTag,
*  { readonly myNum: number }
* >() {
*  static Live = Layer.succeed(this, { myNum: 108 })
* }
* ```
*
* @since 2.0.0
* @category constructors
*/
const Tag = Tag$1;
/**
* Creates a context tag with a default value.
*
* **Details**
*
* `Context.Reference` allows you to create a tag that can hold a value. You can
* provide a default value for the service, which will automatically be used
* when the context is accessed, or override it with a custom implementation
* when needed.
*
* **Example** (Declaring a Tag with a default value)
*
* ```ts
* import * as assert from "node:assert"
* import { Context, Effect } from "effect"
*
* class SpecialNumber extends Context.Reference<SpecialNumber>()(
*   "SpecialNumber",
*   { defaultValue: () => 2048 }
* ) {}
*
* //      ┌─── Effect<void, never, never>
* //      ▼
* const program = Effect.gen(function* () {
*   const specialNumber = yield* SpecialNumber
*   console.log(`The special number is ${specialNumber}`)
* })
*
* // No need to provide the SpecialNumber implementation
* Effect.runPromise(program)
* // Output: The special number is 2048
* ```
*
* **Example** (Overriding the default value)
*
* ```ts
* import { Context, Effect } from "effect"
*
* class SpecialNumber extends Context.Reference<SpecialNumber>()(
*   "SpecialNumber",
*   { defaultValue: () => 2048 }
* ) {}
*
* const program = Effect.gen(function* () {
*   const specialNumber = yield* SpecialNumber
*   console.log(`The special number is ${specialNumber}`)
* })
*
* Effect.runPromise(program.pipe(Effect.provideService(SpecialNumber, -1)))
* // Output: The special number is -1
* ```
*
* @since 3.11.0
* @category constructors
* @experimental
*/
const Reference = Reference$1;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Chunk.js
const TypeId$15 = /* @__PURE__ */ Symbol.for("effect/Chunk");
function copy$1(src, srcPos, dest, destPos, len) {
	for (let i$1 = srcPos; i$1 < Math.min(src.length, srcPos + len); i$1++) dest[destPos + i$1 - srcPos] = src[i$1];
	return dest;
}
const emptyArray = [];
/**
* Compares the two chunks of equal length using the specified function
*
* @category equivalence
* @since 2.0.0
*/
const getEquivalence$1 = (isEquivalent) => make$48((self, that) => self.length === that.length && toReadonlyArray(self).every((value, i$1) => isEquivalent(value, unsafeGet$2(that, i$1))));
const _equivalence$1 = /* @__PURE__ */ getEquivalence$1(equals);
const ChunkProto = {
	[TypeId$15]: { _A: (_$1) => _$1 },
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "Chunk",
			values: toReadonlyArray(this).map(toJSON)
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	[symbol](that) {
		return isChunk(that) && _equivalence$1(this, that);
	},
	[symbol$1]() {
		return cached$2(this, array$1(toReadonlyArray(this)));
	},
	[Symbol.iterator]() {
		switch (this.backing._tag) {
			case "IArray": return this.backing.array[Symbol.iterator]();
			case "IEmpty": return emptyArray[Symbol.iterator]();
			default: return toReadonlyArray(this)[Symbol.iterator]();
		}
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const makeChunk = (backing) => {
	const chunk$2 = Object.create(ChunkProto);
	chunk$2.backing = backing;
	switch (backing._tag) {
		case "IEmpty":
			chunk$2.length = 0;
			chunk$2.depth = 0;
			chunk$2.left = chunk$2;
			chunk$2.right = chunk$2;
			break;
		case "IConcat":
			chunk$2.length = backing.left.length + backing.right.length;
			chunk$2.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
			chunk$2.left = backing.left;
			chunk$2.right = backing.right;
			break;
		case "IArray":
			chunk$2.length = backing.array.length;
			chunk$2.depth = 0;
			chunk$2.left = _empty$8;
			chunk$2.right = _empty$8;
			break;
		case "ISingleton":
			chunk$2.length = 1;
			chunk$2.depth = 0;
			chunk$2.left = _empty$8;
			chunk$2.right = _empty$8;
			break;
		case "ISlice":
			chunk$2.length = backing.length;
			chunk$2.depth = backing.chunk.depth + 1;
			chunk$2.left = _empty$8;
			chunk$2.right = _empty$8;
			break;
	}
	return chunk$2;
};
/**
* Checks if `u` is a `Chunk<unknown>`
*
* @category constructors
* @since 2.0.0
*/
const isChunk = (u$1) => hasProperty(u$1, TypeId$15);
const _empty$8 = /* @__PURE__ */ makeChunk({ _tag: "IEmpty" });
/**
* @category constructors
* @since 2.0.0
*/
const empty$30 = () => _empty$8;
/**
* Builds a `NonEmptyChunk` from an non-empty collection of elements.
*
* @category constructors
* @since 2.0.0
*/
const make$43 = (...as$6) => unsafeFromNonEmptyArray(as$6);
/**
* Builds a `NonEmptyChunk` from a single element.
*
* @category constructors
* @since 2.0.0
*/
const of$3 = (a$1) => makeChunk({
	_tag: "ISingleton",
	a: a$1
});
/**
* Creates a new `Chunk` from an iterable collection of values.
*
* @category constructors
* @since 2.0.0
*/
const fromIterable$9 = (self) => isChunk(self) ? self : unsafeFromArray(fromIterable$10(self));
const copyToArray = (self, array$3, initial) => {
	switch (self.backing._tag) {
		case "IArray":
			copy$1(self.backing.array, 0, array$3, initial, self.length);
			break;
		case "IConcat":
			copyToArray(self.left, array$3, initial);
			copyToArray(self.right, array$3, initial + self.left.length);
			break;
		case "ISingleton":
			array$3[initial] = self.backing.a;
			break;
		case "ISlice": {
			let i$1 = 0;
			let j = initial;
			while (i$1 < self.length) {
				array$3[j] = unsafeGet$2(self, i$1);
				i$1 += 1;
				j += 1;
			}
			break;
		}
	}
};
const toReadonlyArray_ = (self) => {
	switch (self.backing._tag) {
		case "IEmpty": return emptyArray;
		case "IArray": return self.backing.array;
		default: {
			const arr = new Array(self.length);
			copyToArray(self, arr, 0);
			self.backing = {
				_tag: "IArray",
				array: arr
			};
			self.left = _empty$8;
			self.right = _empty$8;
			self.depth = 0;
			return arr;
		}
	}
};
/**
* Converts a `Chunk` into a `ReadonlyArray`. If the provided `Chunk` is
* non-empty (`NonEmptyChunk`), the function will return a
* `NonEmptyReadonlyArray`, ensuring the non-empty property is preserved.
*
* @category conversions
* @since 2.0.0
*/
const toReadonlyArray = toReadonlyArray_;
const reverseChunk = (self) => {
	switch (self.backing._tag) {
		case "IEmpty":
		case "ISingleton": return self;
		case "IArray": return makeChunk({
			_tag: "IArray",
			array: reverse$2(self.backing.array)
		});
		case "IConcat": return makeChunk({
			_tag: "IConcat",
			left: reverse$1(self.backing.right),
			right: reverse$1(self.backing.left)
		});
		case "ISlice": return unsafeFromArray(reverse$2(toReadonlyArray(self)));
	}
};
/**
* Reverses the order of elements in a `Chunk`.
* Importantly, if the input chunk is a `NonEmptyChunk`, the reversed chunk will also be a `NonEmptyChunk`.
*
* **Example**
*
* ```ts
* import { Chunk } from "effect"
*
* const chunk = Chunk.make(1, 2, 3)
* const result = Chunk.reverse(chunk)
*
* console.log(result)
* // { _id: 'Chunk', values: [ 3, 2, 1 ] }
* ```
*
* @since 2.0.0
* @category elements
*/
const reverse$1 = reverseChunk;
/**
* This function provides a safe way to read a value at a particular index from a `Chunk`.
*
* @category elements
* @since 2.0.0
*/
const get$8 = /* @__PURE__ */ dual$1(2, (self, index) => index < 0 || index >= self.length ? none$7() : some$4(unsafeGet$2(self, index)));
/**
* Wraps an array into a chunk without copying, unsafe on mutable arrays
*
* @since 2.0.0
* @category unsafe
*/
const unsafeFromArray = (self) => self.length === 0 ? empty$30() : self.length === 1 ? of$3(self[0]) : makeChunk({
	_tag: "IArray",
	array: self
});
/**
* Wraps an array into a chunk without copying, unsafe on mutable arrays
*
* @since 2.0.0
* @category unsafe
*/
const unsafeFromNonEmptyArray = (self) => unsafeFromArray(self);
/**
* Gets an element unsafely, will throw on out of bounds
*
* @since 2.0.0
* @category unsafe
*/
const unsafeGet$2 = /* @__PURE__ */ dual$1(2, (self, index) => {
	switch (self.backing._tag) {
		case "IEmpty": throw new Error(`Index out of bounds`);
		case "ISingleton":
			if (index !== 0) throw new Error(`Index out of bounds`);
			return self.backing.a;
		case "IArray":
			if (index >= self.length || index < 0) throw new Error(`Index out of bounds`);
			return self.backing.array[index];
		case "IConcat": return index < self.left.length ? unsafeGet$2(self.left, index) : unsafeGet$2(self.right, index - self.left.length);
		case "ISlice": return unsafeGet$2(self.backing.chunk, index + self.backing.offset);
	}
});
/**
* Appends the specified element to the end of the `Chunk`.
*
* @category concatenating
* @since 2.0.0
*/
const append$1 = /* @__PURE__ */ dual$1(2, (self, a$1) => appendAll$1(self, of$3(a$1)));
/**
* Prepend an element to the front of a `Chunk`, creating a new `NonEmptyChunk`.
*
* @category concatenating
* @since 2.0.0
*/
const prepend$1 = /* @__PURE__ */ dual$1(2, (self, elem) => appendAll$1(of$3(elem), self));
/**
* Drops the first up to `n` elements from the chunk
*
* @since 2.0.0
*/
const drop = /* @__PURE__ */ dual$1(2, (self, n$1) => {
	if (n$1 <= 0) return self;
	else if (n$1 >= self.length) return _empty$8;
	else switch (self.backing._tag) {
		case "ISlice": return makeChunk({
			_tag: "ISlice",
			chunk: self.backing.chunk,
			offset: self.backing.offset + n$1,
			length: self.backing.length - n$1
		});
		case "IConcat":
			if (n$1 > self.left.length) return drop(self.right, n$1 - self.left.length);
			return makeChunk({
				_tag: "IConcat",
				left: drop(self.left, n$1),
				right: self.right
			});
		default: return makeChunk({
			_tag: "ISlice",
			chunk: self,
			offset: n$1,
			length: self.length - n$1
		});
	}
});
/**
* Concatenates two chunks, combining their elements.
* If either chunk is non-empty, the result is also a non-empty chunk.
*
* **Example**
*
* ```ts
* import { Chunk } from "effect"
*
* const result = Chunk.make(1, 2).pipe(Chunk.appendAll(Chunk.make("a", "b")), Chunk.toArray)
*
* console.log(result)
* // [ 1, 2, "a", "b" ]
* ```
*
* @category concatenating
* @since 2.0.0
*/
const appendAll$1 = /* @__PURE__ */ dual$1(2, (self, that) => {
	if (self.backing._tag === "IEmpty") return that;
	if (that.backing._tag === "IEmpty") return self;
	const diff$10 = that.depth - self.depth;
	if (Math.abs(diff$10) <= 1) return makeChunk({
		_tag: "IConcat",
		left: self,
		right: that
	});
	else if (diff$10 < -1) if (self.left.depth >= self.right.depth) {
		const nr = appendAll$1(self.right, that);
		return makeChunk({
			_tag: "IConcat",
			left: self.left,
			right: nr
		});
	} else {
		const nrr = appendAll$1(self.right.right, that);
		if (nrr.depth === self.depth - 3) {
			const nr = makeChunk({
				_tag: "IConcat",
				left: self.right.left,
				right: nrr
			});
			return makeChunk({
				_tag: "IConcat",
				left: self.left,
				right: nr
			});
		} else return makeChunk({
			_tag: "IConcat",
			left: makeChunk({
				_tag: "IConcat",
				left: self.left,
				right: self.right.left
			}),
			right: nrr
		});
	}
	else if (that.right.depth >= that.left.depth) return makeChunk({
		_tag: "IConcat",
		left: appendAll$1(self, that.left),
		right: that.right
	});
	else {
		const nll = appendAll$1(self, that.left.left);
		if (nll.depth === that.depth - 3) return makeChunk({
			_tag: "IConcat",
			left: makeChunk({
				_tag: "IConcat",
				left: nll,
				right: that.left.right
			}),
			right: that.right
		});
		else return makeChunk({
			_tag: "IConcat",
			left: nll,
			right: makeChunk({
				_tag: "IConcat",
				left: that.left.right,
				right: that.right
			})
		});
	}
});
/**
* Determines if the chunk is empty.
*
* @since 2.0.0
* @category elements
*/
const isEmpty$9 = (self) => self.length === 0;
/**
* Determines if the chunk is not empty.
*
* @since 2.0.0
* @category elements
*/
const isNonEmpty$4 = (self) => self.length > 0;
/**
* Returns the first element of this chunk if it exists.
*
* @since 2.0.0
* @category elements
*/
const head$2 = /* @__PURE__ */ get$8(0);
/**
* Returns the first element of this chunk.
*
* It will throw an error if the chunk is empty.
*
* @since 2.0.0
* @category unsafe
*/
const unsafeHead = (self) => unsafeGet$2(self, 0);
/**
* Returns the first element of this non empty chunk.
*
* @since 2.0.0
* @category elements
*/
const headNonEmpty = unsafeHead;
/**
* Returns every elements after the first.
*
* @since 2.0.0
* @category elements
*/
const tailNonEmpty = (self) => drop(self, 1);
/**
* Returns a function that checks if a `Chunk` contains a given value using the default `Equivalence`.
*
* @category elements
* @since 2.0.0
*/
const contains$2 = contains$3;
/**
* Returns a function that checks if a `Chunk` contains a given value using a provided `isEquivalent` function.
*
* @category elements
* @since 2.0.0
*/
const containsWith = containsWith$1;
/**
* Returns the first element that satisfies the specified
* predicate, or `None` if no such element exists.
*
* @category elements
* @since 2.0.0
*/
const findFirst$6 = findFirst$7;
/**
* Return the first index for which a predicate holds.
*
* @category elements
* @since 2.0.0
*/
const findFirstIndex = findFirstIndex$1;
/**
* Find the last element for which a predicate holds.
*
* @category elements
* @since 2.0.0
*/
const findLast = findLast$1;
/**
* Return the last index for which a predicate holds.
*
* @category elements
* @since 2.0.0
*/
const findLastIndex = findLastIndex$1;
/**
* Joins the elements together with "sep" in the middle.
*
* @category folding
* @since 2.0.0
*/
const join$2 = join$3;
/**
* @category folding
* @since 2.0.0
*/
const reduce$11 = reduce$12;
/**
* @category folding
* @since 2.0.0
*/
const reduceRight$2 = reduceRight$3;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Duration.js
const TypeId$14 = /* @__PURE__ */ Symbol.for("effect/Duration");
const bigint0$2 = /* @__PURE__ */ BigInt(0);
const bigint24 = /* @__PURE__ */ BigInt(24);
const bigint60 = /* @__PURE__ */ BigInt(60);
const bigint1e3 = /* @__PURE__ */ BigInt(1e3);
const bigint1e6 = /* @__PURE__ */ BigInt(1e6);
const bigint1e9 = /* @__PURE__ */ BigInt(1e9);
const DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
/**
* @since 2.0.0
*/
const decode$3 = (input) => {
	if (isDuration(input)) return input;
	else if (isNumber(input)) return millis(input);
	else if (isBigInt(input)) return nanos(input);
	else if (Array.isArray(input) && input.length === 2 && input.every(isNumber)) {
		if (input[0] === -Infinity || input[1] === -Infinity || Number.isNaN(input[0]) || Number.isNaN(input[1])) return zero;
		if (input[0] === Infinity || input[1] === Infinity) return infinity;
		return nanos(BigInt(Math.round(input[0] * 1e9)) + BigInt(Math.round(input[1])));
	} else if (isString(input)) {
		const match$13 = DURATION_REGEX.exec(input);
		if (match$13) {
			const [_$1, valueStr, unit] = match$13;
			const value = Number(valueStr);
			switch (unit) {
				case "nano":
				case "nanos": return nanos(BigInt(valueStr));
				case "micro":
				case "micros": return micros(BigInt(valueStr));
				case "milli":
				case "millis": return millis(value);
				case "second":
				case "seconds": return seconds(value);
				case "minute":
				case "minutes": return minutes(value);
				case "hour":
				case "hours": return hours(value);
				case "day":
				case "days": return days(value);
				case "week":
				case "weeks": return weeks(value);
			}
		}
	}
	throw new Error("Invalid DurationInput");
};
const zeroValue = {
	_tag: "Millis",
	millis: 0
};
const infinityValue = { _tag: "Infinity" };
const DurationProto = {
	[TypeId$14]: TypeId$14,
	[symbol$1]() {
		return cached$2(this, structure(this.value));
	},
	[symbol](that) {
		return isDuration(that) && equals$1(this, that);
	},
	toString() {
		return `Duration(${format$2(this)})`;
	},
	toJSON() {
		switch (this.value._tag) {
			case "Millis": return {
				_id: "Duration",
				_tag: "Millis",
				millis: this.value.millis
			};
			case "Nanos": return {
				_id: "Duration",
				_tag: "Nanos",
				hrtime: toHrTime(this)
			};
			case "Infinity": return {
				_id: "Duration",
				_tag: "Infinity"
			};
		}
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const make$42 = (input) => {
	const duration = Object.create(DurationProto);
	if (isNumber(input)) if (isNaN(input) || input <= 0) duration.value = zeroValue;
	else if (!Number.isFinite(input)) duration.value = infinityValue;
	else if (!Number.isInteger(input)) duration.value = {
		_tag: "Nanos",
		nanos: BigInt(Math.round(input * 1e6))
	};
	else duration.value = {
		_tag: "Millis",
		millis: input
	};
	else if (input <= bigint0$2) duration.value = zeroValue;
	else duration.value = {
		_tag: "Nanos",
		nanos: input
	};
	return duration;
};
/**
* @since 2.0.0
* @category guards
*/
const isDuration = (u$1) => hasProperty(u$1, TypeId$14);
/**
* @since 3.5.0
* @category guards
*/
const isZero = (self) => {
	switch (self.value._tag) {
		case "Millis": return self.value.millis === 0;
		case "Nanos": return self.value.nanos === bigint0$2;
		case "Infinity": return false;
	}
};
/**
* @since 2.0.0
* @category constructors
*/
const zero = /* @__PURE__ */ make$42(0);
/**
* @since 2.0.0
* @category constructors
*/
const infinity = /* @__PURE__ */ make$42(Infinity);
/**
* @since 2.0.0
* @category constructors
*/
const nanos = (nanos$1) => make$42(nanos$1);
/**
* @since 2.0.0
* @category constructors
*/
const micros = (micros$1) => make$42(micros$1 * bigint1e3);
/**
* @since 2.0.0
* @category constructors
*/
const millis = (millis$1) => make$42(millis$1);
/**
* @since 2.0.0
* @category constructors
*/
const seconds = (seconds$1) => make$42(seconds$1 * 1e3);
/**
* @since 2.0.0
* @category constructors
*/
const minutes = (minutes$1) => make$42(minutes$1 * 6e4);
/**
* @since 2.0.0
* @category constructors
*/
const hours = (hours$1) => make$42(hours$1 * 36e5);
/**
* @since 2.0.0
* @category constructors
*/
const days = (days$1) => make$42(days$1 * 864e5);
/**
* @since 2.0.0
* @category constructors
*/
const weeks = (weeks$1) => make$42(weeks$1 * 6048e5);
/**
* @since 2.0.0
* @category getters
*/
const toMillis = (self) => match$10(self, {
	onMillis: (millis$1) => millis$1,
	onNanos: (nanos$1) => Number(nanos$1) / 1e6
});
/**
* Get the duration in nanoseconds as a bigint.
*
* If the duration is infinite, it throws an error.
*
* @since 2.0.0
* @category getters
*/
const unsafeToNanos = (self) => {
	const _self = decode$3(self);
	switch (_self.value._tag) {
		case "Infinity": throw new Error("Cannot convert infinite duration to nanos");
		case "Nanos": return _self.value.nanos;
		case "Millis": return BigInt(Math.round(_self.value.millis * 1e6));
	}
};
/**
* @since 2.0.0
* @category getters
*/
const toHrTime = (self) => {
	const _self = decode$3(self);
	switch (_self.value._tag) {
		case "Infinity": return [Infinity, 0];
		case "Nanos": return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];
		case "Millis": return [Math.floor(_self.value.millis / 1e3), Math.round(_self.value.millis % 1e3 * 1e6)];
	}
};
/**
* @since 2.0.0
* @category pattern matching
*/
const match$10 = /* @__PURE__ */ dual$1(2, (self, options) => {
	const _self = decode$3(self);
	switch (_self.value._tag) {
		case "Nanos": return options.onNanos(_self.value.nanos);
		case "Infinity": return options.onMillis(Infinity);
		case "Millis": return options.onMillis(_self.value.millis);
	}
});
/**
* @since 2.0.0
* @category pattern matching
*/
const matchWith = /* @__PURE__ */ dual$1(3, (self, that, options) => {
	const _self = decode$3(self);
	const _that = decode$3(that);
	if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") return options.onMillis(toMillis(_self), toMillis(_that));
	else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
		const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1e6));
		const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1e6));
		return options.onNanos(selfNanos, thatNanos);
	}
	return options.onMillis(_self.value.millis, _that.value.millis);
});
/**
* @category instances
* @since 2.0.0
*/
const Equivalence = (self, that) => matchWith(self, that, {
	onMillis: (self$1, that$1) => self$1 === that$1,
	onNanos: (self$1, that$1) => self$1 === that$1
});
/**
* @since 2.0.0
* @category predicates
*/
const lessThanOrEqualTo = /* @__PURE__ */ dual$1(2, (self, that) => matchWith(self, that, {
	onMillis: (self$1, that$1) => self$1 <= that$1,
	onNanos: (self$1, that$1) => self$1 <= that$1
}));
/**
* @since 2.0.0
* @category predicates
*/
const greaterThanOrEqualTo = /* @__PURE__ */ dual$1(2, (self, that) => matchWith(self, that, {
	onMillis: (self$1, that$1) => self$1 >= that$1,
	onNanos: (self$1, that$1) => self$1 >= that$1
}));
/**
* @since 2.0.0
* @category predicates
*/
const equals$1 = /* @__PURE__ */ dual$1(2, (self, that) => Equivalence(decode$3(self), decode$3(that)));
/**
* Converts a `Duration` to its parts.
*
* @since 3.8.0
* @category conversions
*/
const parts = (self) => {
	const duration = decode$3(self);
	if (duration.value._tag === "Infinity") return {
		days: Infinity,
		hours: Infinity,
		minutes: Infinity,
		seconds: Infinity,
		millis: Infinity,
		nanos: Infinity
	};
	const nanos$1 = unsafeToNanos(duration);
	const ms = nanos$1 / bigint1e6;
	const sec = ms / bigint1e3;
	const min$2 = sec / bigint60;
	const hr = min$2 / bigint60;
	const days$1 = hr / bigint24;
	return {
		days: Number(days$1),
		hours: Number(hr % bigint24),
		minutes: Number(min$2 % bigint60),
		seconds: Number(sec % bigint60),
		millis: Number(ms % bigint1e3),
		nanos: Number(nanos$1 % bigint1e6)
	};
};
/**
* Converts a `Duration` to a human readable string.
*
* @since 2.0.0
* @category conversions
* @example
* ```ts
* import { Duration } from "effect"
*
* Duration.format(Duration.millis(1000)) // "1s"
* Duration.format(Duration.millis(1001)) // "1s 1ms"
* ```
*/
const format$2 = (self) => {
	const duration = decode$3(self);
	if (duration.value._tag === "Infinity") return "Infinity";
	if (isZero(duration)) return "0";
	const fragments = parts(duration);
	const pieces = [];
	if (fragments.days !== 0) pieces.push(`${fragments.days}d`);
	if (fragments.hours !== 0) pieces.push(`${fragments.hours}h`);
	if (fragments.minutes !== 0) pieces.push(`${fragments.minutes}m`);
	if (fragments.seconds !== 0) pieces.push(`${fragments.seconds}s`);
	if (fragments.millis !== 0) pieces.push(`${fragments.millis}ms`);
	if (fragments.nanos !== 0) pieces.push(`${fragments.nanos}ns`);
	return pieces.join(" ");
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/hashMap/config.js
/** @internal */
const SIZE = 5;
/** @internal */
const BUCKET_SIZE = /* @__PURE__ */ Math.pow(2, SIZE);
/** @internal */
const MASK = BUCKET_SIZE - 1;
/** @internal */
const MAX_INDEX_NODE = BUCKET_SIZE / 2;
/** @internal */
const MIN_ARRAY_NODE = BUCKET_SIZE / 4;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/hashMap/bitwise.js
/**
* Hamming weight.
*
* Taken from: http://jsperf.com/hamming-weight
*
* @internal
*/
function popcount(x) {
	x -= x >> 1 & 1431655765;
	x = (x & 858993459) + (x >> 2 & 858993459);
	x = x + (x >> 4) & 252645135;
	x += x >> 8;
	x += x >> 16;
	return x & 127;
}
/** @internal */
function hashFragment(shift$1, h) {
	return h >>> shift$1 & MASK;
}
/** @internal */
function toBitmap(x) {
	return 1 << x;
}
/** @internal */
function fromBitmap(bitmap, bit) {
	return popcount(bitmap & bit - 1);
}

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/stack.js
const make$41 = (value, previous) => ({
	value,
	previous
});

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/hashMap/array.js
/** @internal */
function arrayUpdate(mutate$4, at$2, v, arr) {
	let out = arr;
	if (!mutate$4) {
		const len = arr.length;
		out = new Array(len);
		for (let i$1 = 0; i$1 < len; ++i$1) out[i$1] = arr[i$1];
	}
	out[at$2] = v;
	return out;
}
/** @internal */
function arraySpliceOut(mutate$4, at$2, arr) {
	const newLen = arr.length - 1;
	let i$1 = 0;
	let g$2 = 0;
	let out = arr;
	if (mutate$4) i$1 = g$2 = at$2;
	else {
		out = new Array(newLen);
		while (i$1 < at$2) out[g$2++] = arr[i$1++];
	}
	++i$1;
	while (i$1 <= newLen) out[g$2++] = arr[i$1++];
	if (mutate$4) out.length = newLen;
	return out;
}
/** @internal */
function arraySpliceIn(mutate$4, at$2, v, arr) {
	const len = arr.length;
	if (mutate$4) {
		let i$2 = len;
		while (i$2 >= at$2) arr[i$2--] = arr[i$2];
		arr[at$2] = v;
		return arr;
	}
	let i$1 = 0, g$2 = 0;
	const out = new Array(len + 1);
	while (i$1 < at$2) out[g$2++] = arr[i$1++];
	out[at$2] = v;
	while (i$1 < len) out[++g$2] = arr[i$1++];
	return out;
}

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/hashMap/node.js
/** @internal */
var EmptyNode = class EmptyNode {
	_tag = "EmptyNode";
	modify(edit, _shift, f$1, hash$1, key, size$11) {
		const v = f$1(none$7());
		if (isNone$2(v)) return new EmptyNode();
		++size$11.value;
		return new LeafNode(edit, hash$1, key, v);
	}
};
/** @internal */
function isEmptyNode(a$1) {
	return isTagged(a$1, "EmptyNode");
}
/** @internal */
function isLeafNode(node) {
	return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
/** @internal */
function canEditNode(node, edit) {
	return isEmptyNode(node) ? false : edit === node.edit;
}
/** @internal */
var LeafNode = class LeafNode {
	edit;
	hash;
	key;
	value;
	_tag = "LeafNode";
	constructor(edit, hash$1, key, value) {
		this.edit = edit;
		this.hash = hash$1;
		this.key = key;
		this.value = value;
	}
	modify(edit, shift$1, f$1, hash$1, key, size$11) {
		if (equals(key, this.key)) {
			const v$1 = f$1(this.value);
			if (v$1 === this.value) return this;
			else if (isNone$2(v$1)) {
				--size$11.value;
				return new EmptyNode();
			}
			if (canEditNode(this, edit)) {
				this.value = v$1;
				return this;
			}
			return new LeafNode(edit, hash$1, key, v$1);
		}
		const v = f$1(none$7());
		if (isNone$2(v)) return this;
		++size$11.value;
		return mergeLeaves(edit, shift$1, this.hash, this, hash$1, new LeafNode(edit, hash$1, key, v));
	}
};
/** @internal */
var CollisionNode = class CollisionNode {
	edit;
	hash;
	children;
	_tag = "CollisionNode";
	constructor(edit, hash$1, children$2) {
		this.edit = edit;
		this.hash = hash$1;
		this.children = children$2;
	}
	modify(edit, shift$1, f$1, hash$1, key, size$11) {
		if (hash$1 === this.hash) {
			const canEdit = canEditNode(this, edit);
			const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f$1, key, size$11);
			if (list === this.children) return this;
			return list.length > 1 ? new CollisionNode(edit, this.hash, list) : list[0];
		}
		const v = f$1(none$7());
		if (isNone$2(v)) return this;
		++size$11.value;
		return mergeLeaves(edit, shift$1, this.hash, this, hash$1, new LeafNode(edit, hash$1, key, v));
	}
	updateCollisionList(mutate$4, edit, hash$1, list, f$1, key, size$11) {
		const len = list.length;
		for (let i$1 = 0; i$1 < len; ++i$1) {
			const child = list[i$1];
			if ("key" in child && equals(key, child.key)) {
				const value = child.value;
				const newValue$1 = f$1(value);
				if (newValue$1 === value) return list;
				if (isNone$2(newValue$1)) {
					--size$11.value;
					return arraySpliceOut(mutate$4, i$1, list);
				}
				return arrayUpdate(mutate$4, i$1, new LeafNode(edit, hash$1, key, newValue$1), list);
			}
		}
		const newValue = f$1(none$7());
		if (isNone$2(newValue)) return list;
		++size$11.value;
		return arrayUpdate(mutate$4, len, new LeafNode(edit, hash$1, key, newValue), list);
	}
};
/** @internal */
var IndexedNode = class IndexedNode {
	edit;
	mask;
	children;
	_tag = "IndexedNode";
	constructor(edit, mask, children$2) {
		this.edit = edit;
		this.mask = mask;
		this.children = children$2;
	}
	modify(edit, shift$1, f$1, hash$1, key, size$11) {
		const mask = this.mask;
		const children$2 = this.children;
		const frag = hashFragment(shift$1, hash$1);
		const bit = toBitmap(frag);
		const indx = fromBitmap(mask, bit);
		const exists$4 = mask & bit;
		const canEdit = canEditNode(this, edit);
		if (!exists$4) {
			const _newChild = new EmptyNode().modify(edit, shift$1 + SIZE, f$1, hash$1, key, size$11);
			if (!_newChild) return this;
			return children$2.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children$2) : new IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children$2));
		}
		const current = children$2[indx];
		const child = current.modify(edit, shift$1 + SIZE, f$1, hash$1, key, size$11);
		if (current === child) return this;
		let bitmap = mask;
		let newChildren;
		if (isEmptyNode(child)) {
			bitmap &= ~bit;
			if (!bitmap) return new EmptyNode();
			if (children$2.length <= 2 && isLeafNode(children$2[indx ^ 1])) return children$2[indx ^ 1];
			newChildren = arraySpliceOut(canEdit, indx, children$2);
		} else newChildren = arrayUpdate(canEdit, indx, child, children$2);
		if (canEdit) {
			this.mask = bitmap;
			this.children = newChildren;
			return this;
		}
		return new IndexedNode(edit, bitmap, newChildren);
	}
};
/** @internal */
var ArrayNode = class ArrayNode {
	edit;
	size;
	children;
	_tag = "ArrayNode";
	constructor(edit, size$11, children$2) {
		this.edit = edit;
		this.size = size$11;
		this.children = children$2;
	}
	modify(edit, shift$1, f$1, hash$1, key, size$11) {
		let count = this.size;
		const children$2 = this.children;
		const frag = hashFragment(shift$1, hash$1);
		const child = children$2[frag];
		const newChild = (child || new EmptyNode()).modify(edit, shift$1 + SIZE, f$1, hash$1, key, size$11);
		if (child === newChild) return this;
		const canEdit = canEditNode(this, edit);
		let newChildren;
		if (isEmptyNode(child) && !isEmptyNode(newChild)) {
			++count;
			newChildren = arrayUpdate(canEdit, frag, newChild, children$2);
		} else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
			--count;
			if (count <= MIN_ARRAY_NODE) return pack(edit, count, frag, children$2);
			newChildren = arrayUpdate(canEdit, frag, new EmptyNode(), children$2);
		} else newChildren = arrayUpdate(canEdit, frag, newChild, children$2);
		if (canEdit) {
			this.size = count;
			this.children = newChildren;
			return this;
		}
		return new ArrayNode(edit, count, newChildren);
	}
};
function pack(edit, count, removed, elements) {
	const children$2 = new Array(count - 1);
	let g$2 = 0;
	let bitmap = 0;
	for (let i$1 = 0, len = elements.length; i$1 < len; ++i$1) if (i$1 !== removed) {
		const elem = elements[i$1];
		if (elem && !isEmptyNode(elem)) {
			children$2[g$2++] = elem;
			bitmap |= 1 << i$1;
		}
	}
	return new IndexedNode(edit, bitmap, children$2);
}
function expand(edit, frag, child, bitmap, subNodes) {
	const arr = [];
	let bit = bitmap;
	let count = 0;
	for (let i$1 = 0; bit; ++i$1) {
		if (bit & 1) arr[i$1] = subNodes[count++];
		bit >>>= 1;
	}
	arr[frag] = child;
	return new ArrayNode(edit, count + 1, arr);
}
function mergeLeavesInner(edit, shift$1, h1, n1, h2, n2) {
	if (h1 === h2) return new CollisionNode(edit, h1, [n2, n1]);
	const subH1 = hashFragment(shift$1, h1);
	const subH2 = hashFragment(shift$1, h2);
	if (subH1 === subH2) return (child) => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);
	else {
		const children$2 = subH1 < subH2 ? [n1, n2] : [n2, n1];
		return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children$2);
	}
}
function mergeLeaves(edit, shift$1, h1, n1, h2, n2) {
	let stack = void 0;
	let currentShift = shift$1;
	while (true) {
		const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);
		if (typeof res === "function") {
			stack = make$41(res, stack);
			currentShift = currentShift + SIZE;
		} else {
			let final = res;
			while (stack != null) {
				final = stack.value(final);
				stack = stack.previous;
			}
			return final;
		}
	}
}

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/hashMap.js
const HashMapSymbolKey = "effect/HashMap";
/** @internal */
const HashMapTypeId = /* @__PURE__ */ Symbol.for(HashMapSymbolKey);
const HashMapProto = {
	[HashMapTypeId]: HashMapTypeId,
	[Symbol.iterator]() {
		return new HashMapIterator(this, (k, v) => [k, v]);
	},
	[symbol$1]() {
		let hash$1 = hash(HashMapSymbolKey);
		for (const item of this) hash$1 ^= pipe$3(hash(item[0]), combine$11(hash(item[1])));
		return cached$2(this, hash$1);
	},
	[symbol](that) {
		if (isHashMap$1(that)) {
			if (that._size !== this._size) return false;
			for (const item of this) {
				const elem = pipe$3(that, getHash$1(item[0], hash(item[0])));
				if (isNone$2(elem)) return false;
				else if (!equals(item[1], elem.value)) return false;
			}
			return true;
		}
		return false;
	},
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "HashMap",
			values: Array.from(this).map(toJSON)
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const makeImpl$2 = (editable, edit, root, size$11) => {
	const map$18 = Object.create(HashMapProto);
	map$18._editable = editable;
	map$18._edit = edit;
	map$18._root = root;
	map$18._size = size$11;
	return map$18;
};
var HashMapIterator = class HashMapIterator {
	map;
	f;
	v;
	constructor(map$18, f$1) {
		this.map = map$18;
		this.f = f$1;
		this.v = visitLazy(this.map._root, this.f, void 0);
	}
	next() {
		if (isNone$2(this.v)) return {
			done: true,
			value: void 0
		};
		const v0 = this.v.value;
		this.v = applyCont(v0.cont);
		return {
			done: false,
			value: v0.value
		};
	}
	[Symbol.iterator]() {
		return new HashMapIterator(this.map, this.f);
	}
};
const applyCont = (cont) => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none$7();
const visitLazy = (node, f$1, cont = void 0) => {
	switch (node._tag) {
		case "LeafNode":
			if (isSome(node.value)) return some$4({
				value: f$1(node.key, node.value.value),
				cont
			});
			return applyCont(cont);
		case "CollisionNode":
		case "ArrayNode":
		case "IndexedNode": {
			const children$2 = node.children;
			return visitLazyChildren(children$2.length, children$2, 0, f$1, cont);
		}
		default: return applyCont(cont);
	}
};
const visitLazyChildren = (len, children$2, i$1, f$1, cont) => {
	while (i$1 < len) {
		const child = children$2[i$1++];
		if (child && !isEmptyNode(child)) return visitLazy(child, f$1, [
			len,
			children$2,
			i$1,
			f$1,
			cont
		]);
	}
	return applyCont(cont);
};
const _empty$7 = /* @__PURE__ */ makeImpl$2(false, 0, /* @__PURE__ */ new EmptyNode(), 0);
/** @internal */
const empty$29 = () => _empty$7;
/** @internal */
const make$40 = (...entries$2) => fromIterable$8(entries$2);
/** @internal */
const fromIterable$8 = (entries$2) => {
	const map$18 = beginMutation$3(empty$29());
	for (const entry of entries$2) set$5(map$18, entry[0], entry[1]);
	return endMutation$3(map$18);
};
/** @internal */
const isHashMap$1 = (u$1) => hasProperty(u$1, HashMapTypeId);
/** @internal */
const isEmpty$8 = (self) => self && isEmptyNode(self._root);
/** @internal */
const get$7 = /* @__PURE__ */ dual$1(2, (self, key) => getHash$1(self, key, hash(key)));
/** @internal */
const getHash$1 = /* @__PURE__ */ dual$1(3, (self, key, hash$1) => {
	let node = self._root;
	let shift$1 = 0;
	while (true) switch (node._tag) {
		case "LeafNode": return equals(key, node.key) ? node.value : none$7();
		case "CollisionNode":
			if (hash$1 === node.hash) {
				const children$2 = node.children;
				for (let i$1 = 0, len = children$2.length; i$1 < len; ++i$1) {
					const child = children$2[i$1];
					if ("key" in child && equals(key, child.key)) return child.value;
				}
			}
			return none$7();
		case "IndexedNode": {
			const bit = toBitmap(hashFragment(shift$1, hash$1));
			if (node.mask & bit) {
				node = node.children[fromBitmap(node.mask, bit)];
				shift$1 += SIZE;
				break;
			}
			return none$7();
		}
		case "ArrayNode":
			node = node.children[hashFragment(shift$1, hash$1)];
			if (node) {
				shift$1 += SIZE;
				break;
			}
			return none$7();
		default: return none$7();
	}
});
/** @internal */
const unsafeGet$1 = /* @__PURE__ */ dual$1(2, (self, key) => {
	const element = getHash$1(self, key, hash(key));
	if (isNone$2(element)) throw new Error("Expected map to contain key");
	return element.value;
});
/** @internal */
const has$6 = /* @__PURE__ */ dual$1(2, (self, key) => isSome(getHash$1(self, key, hash(key))));
/** @internal */
const hasHash$1 = /* @__PURE__ */ dual$1(3, (self, key, hash$1) => isSome(getHash$1(self, key, hash$1)));
/** @internal */
const hasBy$1 = /* @__PURE__ */ dual$1(2, (self, predicate) => isSome(findFirst$5(self, predicate)));
/** @internal */
const set$5 = /* @__PURE__ */ dual$1(3, (self, key, value) => modifyAt$1(self, key, () => some$4(value)));
/** @internal */
const setTree = /* @__PURE__ */ dual$1(3, (self, newRoot, newSize) => {
	if (self._editable) {
		self._root = newRoot;
		self._size = newSize;
		return self;
	}
	return newRoot === self._root ? self : makeImpl$2(self._editable, self._edit, newRoot, newSize);
});
/** @internal */
const keys$3 = (self) => new HashMapIterator(self, (key) => key);
/** @internal */
const values$5 = (self) => new HashMapIterator(self, (_$1, value) => value);
/** @internal */
const entries$1 = (self) => new HashMapIterator(self, (key, value) => [key, value]);
/** @internal */
const size$10 = (self) => self._size;
/** @internal */
const countBy$1 = /* @__PURE__ */ dual$1(2, (self, f$1) => {
	let count = 0;
	for (const [k, a$1] of self) if (f$1(a$1, k)) count++;
	return count;
});
/** @internal */
const beginMutation$3 = (self) => makeImpl$2(true, self._edit + 1, self._root, self._size);
/** @internal */
const endMutation$3 = (self) => {
	self._editable = false;
	return self;
};
/** @internal */
const mutate$3 = /* @__PURE__ */ dual$1(2, (self, f$1) => {
	const transient = beginMutation$3(self);
	f$1(transient);
	return endMutation$3(transient);
});
/** @internal */
const modifyAt$1 = /* @__PURE__ */ dual$1(3, (self, key, f$1) => modifyHash$1(self, key, hash(key), f$1));
/** @internal */
const modifyHash$1 = /* @__PURE__ */ dual$1(4, (self, key, hash$1, f$1) => {
	const size$11 = { value: self._size };
	return pipe$3(self, setTree(self._root.modify(self._editable ? self._edit : NaN, 0, f$1, hash$1, key, size$11), size$11.value));
});
/** @internal */
const modify$3 = /* @__PURE__ */ dual$1(3, (self, key, f$1) => modifyAt$1(self, key, map$16(f$1)));
/** @internal */
const union$7 = /* @__PURE__ */ dual$1(2, (self, that) => {
	const result = beginMutation$3(self);
	forEach$8(that, (v, k) => set$5(result, k, v));
	return endMutation$3(result);
});
/** @internal */
const remove$7 = /* @__PURE__ */ dual$1(2, (self, key) => modifyAt$1(self, key, none$7));
/** @internal */
const removeMany$1 = /* @__PURE__ */ dual$1(2, (self, keys$5) => mutate$3(self, (map$18) => {
	for (const key of keys$5) remove$7(key)(map$18);
}));
/**
* Maps over the entries of the `HashMap` using the specified function.
*
* @since 2.0.0
* @category mapping
*/
const map$14 = /* @__PURE__ */ dual$1(2, (self, f$1) => reduce$10(self, empty$29(), (map$18, value, key) => set$5(map$18, key, f$1(value, key))));
/** @internal */
const flatMap$10 = /* @__PURE__ */ dual$1(2, (self, f$1) => reduce$10(self, empty$29(), (zero$1, value, key) => mutate$3(zero$1, (map$18) => forEach$8(f$1(value, key), (value$1, key$1) => set$5(map$18, key$1, value$1)))));
/** @internal */
const forEach$8 = /* @__PURE__ */ dual$1(2, (self, f$1) => reduce$10(self, void 0, (_$1, value, key) => f$1(value, key)));
/** @internal */
const reduce$10 = /* @__PURE__ */ dual$1(3, (self, zero$1, f$1) => {
	const root = self._root;
	if (root._tag === "LeafNode") return isSome(root.value) ? f$1(zero$1, root.value.value, root.key) : zero$1;
	if (root._tag === "EmptyNode") return zero$1;
	const toVisit = [root.children];
	let children$2;
	while (children$2 = toVisit.pop()) for (let i$1 = 0, len = children$2.length; i$1 < len;) {
		const child = children$2[i$1++];
		if (child && !isEmptyNode(child)) if (child._tag === "LeafNode") {
			if (isSome(child.value)) zero$1 = f$1(zero$1, child.value.value, child.key);
		} else toVisit.push(child.children);
	}
	return zero$1;
});
/** @internal */
const filter$7 = /* @__PURE__ */ dual$1(2, (self, f$1) => mutate$3(empty$29(), (map$18) => {
	for (const [k, a$1] of self) if (f$1(a$1, k)) set$5(map$18, k, a$1);
}));
/** @internal */
const compact$1 = (self) => filterMap$3(self, identity$2);
/** @internal */
const filterMap$3 = /* @__PURE__ */ dual$1(2, (self, f$1) => mutate$3(empty$29(), (map$18) => {
	for (const [k, a$1] of self) {
		const option$2 = f$1(a$1, k);
		if (isSome(option$2)) set$5(map$18, k, option$2.value);
	}
}));
/** @internal */
const findFirst$5 = /* @__PURE__ */ dual$1(2, (self, predicate) => {
	for (const ka of self) if (predicate(ka[1], ka[0])) return some$4(ka);
	return none$7();
});
/** @internal */
const some$3 = /* @__PURE__ */ dual$1(2, (self, predicate) => {
	for (const ka of self) if (predicate(ka[1], ka[0])) return true;
	return false;
});
/** @internal */
const every$5 = /* @__PURE__ */ dual$1(2, (self, predicate) => !some$3(self, (a$1, k) => !predicate(a$1, k)));

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/hashSet.js
const HashSetSymbolKey = "effect/HashSet";
/** @internal */
const HashSetTypeId = /* @__PURE__ */ Symbol.for(HashSetSymbolKey);
const HashSetProto = {
	[HashSetTypeId]: HashSetTypeId,
	[Symbol.iterator]() {
		return keys$3(this._keyMap);
	},
	[symbol$1]() {
		return cached$2(this, combine$11(hash(this._keyMap))(hash(HashSetSymbolKey)));
	},
	[symbol](that) {
		if (isHashSet$1(that)) return size$10(this._keyMap) === size$10(that._keyMap) && equals(this._keyMap, that._keyMap);
		return false;
	},
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "HashSet",
			values: Array.from(this).map(toJSON)
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const makeImpl$1 = (keyMap) => {
	const set$6 = Object.create(HashSetProto);
	set$6._keyMap = keyMap;
	return set$6;
};
/** @internal */
const isHashSet$1 = (u$1) => hasProperty(u$1, HashSetTypeId);
const _empty$6 = /* @__PURE__ */ makeImpl$1(/* @__PURE__ */ empty$29());
/** @internal */
const empty$28 = () => _empty$6;
/** @internal */
const fromIterable$7 = (elements) => {
	const set$6 = beginMutation$2(empty$28());
	for (const value of elements) add$2(set$6, value);
	return endMutation$2(set$6);
};
/** @internal */
const make$39 = (...elements) => {
	const set$6 = beginMutation$2(empty$28());
	for (const value of elements) add$2(set$6, value);
	return endMutation$2(set$6);
};
/** @internal */
const has$5 = /* @__PURE__ */ dual$1(2, (self, value) => has$6(self._keyMap, value));
/** @internal */
const some$2 = /* @__PURE__ */ dual$1(2, (self, f$1) => {
	let found = false;
	for (const value of self) {
		found = f$1(value);
		if (found) break;
	}
	return found;
});
/** @internal */
const every$4 = /* @__PURE__ */ dual$1(2, (self, refinement) => !some$2(self, (a$1) => !refinement(a$1)));
/** @internal */
const isSubset$1 = /* @__PURE__ */ dual$1(2, (self, that) => every$4(self, (value) => has$5(that, value)));
/** @internal */
const values$4 = (self) => keys$3(self._keyMap);
/** @internal */
const size$9 = (self) => size$10(self._keyMap);
/** @internal */
const beginMutation$2 = (self) => makeImpl$1(beginMutation$3(self._keyMap));
/** @internal */
const endMutation$2 = (self) => {
	self._keyMap._editable = false;
	return self;
};
/** @internal */
const mutate$2 = /* @__PURE__ */ dual$1(2, (self, f$1) => {
	const transient = beginMutation$2(self);
	f$1(transient);
	return endMutation$2(transient);
});
/** @internal */
const add$2 = /* @__PURE__ */ dual$1(2, (self, value) => self._keyMap._editable ? (set$5(value, true)(self._keyMap), self) : makeImpl$1(set$5(value, true)(self._keyMap)));
/** @internal */
const remove$6 = /* @__PURE__ */ dual$1(2, (self, value) => self._keyMap._editable ? (remove$7(value)(self._keyMap), self) : makeImpl$1(remove$7(value)(self._keyMap)));
/** @internal */
const difference$1 = /* @__PURE__ */ dual$1(2, (self, that) => mutate$2(self, (set$6) => {
	for (const value of that) remove$6(set$6, value);
}));
/** @internal */
const intersection$1 = /* @__PURE__ */ dual$1(2, (self, that) => mutate$2(empty$28(), (set$6) => {
	for (const value of that) if (has$5(value)(self)) add$2(value)(set$6);
}));
/** @internal */
const union$6 = /* @__PURE__ */ dual$1(2, (self, that) => mutate$2(empty$28(), (set$6) => {
	forEach$7(self, (value) => add$2(set$6, value));
	for (const value of that) add$2(set$6, value);
}));
/** @internal */
const toggle$1 = /* @__PURE__ */ dual$1(2, (self, value) => has$5(self, value) ? remove$6(self, value) : add$2(self, value));
/** @internal */
const map$13 = /* @__PURE__ */ dual$1(2, (self, f$1) => mutate$2(empty$28(), (set$6) => {
	forEach$7(self, (a$1) => {
		const b$1 = f$1(a$1);
		if (!has$5(set$6, b$1)) add$2(set$6, b$1);
	});
}));
/** @internal */
const flatMap$9 = /* @__PURE__ */ dual$1(2, (self, f$1) => mutate$2(empty$28(), (set$6) => {
	forEach$7(self, (a$1) => {
		for (const b$1 of f$1(a$1)) if (!has$5(set$6, b$1)) add$2(set$6, b$1);
	});
}));
/** @internal */
const forEach$7 = /* @__PURE__ */ dual$1(2, (self, f$1) => forEach$8(self._keyMap, (_$1, k) => f$1(k)));
/** @internal */
const reduce$9 = /* @__PURE__ */ dual$1(3, (self, zero$1, f$1) => reduce$10(self._keyMap, zero$1, (z, _$1, a$1) => f$1(z, a$1)));
/** @internal */
const filter$6 = /* @__PURE__ */ dual$1(2, (self, f$1) => {
	return mutate$2(empty$28(), (set$6) => {
		const iterator = values$4(self);
		let next;
		while (!(next = iterator.next()).done) {
			const value = next.value;
			if (f$1(value)) add$2(set$6, value);
		}
	});
});
/** @internal */
const partition$3 = /* @__PURE__ */ dual$1(2, (self, predicate) => {
	const iterator = values$4(self);
	let next;
	const right$2 = beginMutation$2(empty$28());
	const left$2 = beginMutation$2(empty$28());
	while (!(next = iterator.next()).done) {
		const value = next.value;
		if (predicate(value)) add$2(right$2, value);
		else add$2(left$2, value);
	}
	return [endMutation$2(left$2), endMutation$2(right$2)];
});

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/HashSet.js
HashSetTypeId;
/**
* @memberof HashSet
* @since 2.0.0
* @category refinements
*/
const isHashSet = isHashSet$1;
/**
* Creates an empty `HashSet`.
*
* Time complexity: **`O(1)`**
*
* @memberof HashSet
* @since 2.0.0
* @category constructors
* @example
*
* ```ts
* import { HashSet, pipe } from "effect"
*
* console.log(
*   pipe(
*     // Provide a type argument to create a HashSet of a specific type
*     HashSet.empty<number>(),
*     HashSet.add(1),
*     HashSet.add(1), // Notice the duplicate
*     HashSet.add(2),
*     HashSet.toValues
*   )
* ) // Output: [1, 2]
* ```
*
* @see Other `HashSet` constructors are {@link module:HashSet.make} {@link module:HashSet.fromIterable}
*/
const empty$27 = empty$28;
/**
* Creates a new `HashSet` from an iterable collection of values.
*
* Time complexity: **`O(n)`** where n is the number of elements in the iterable
*
* @memberof HashSet
* @since 2.0.0
* @category constructors
* @example
*
* ```ts
* // Creating a HashSet from an Array
* import { HashSet, pipe } from "effect"
*
* console.log(
*   pipe(
*     [1, 2, 3, 4, 5, 1, 2, 3], // Array<number> is an Iterable<number>;  Note the duplicates.
*     HashSet.fromIterable,
*     HashSet.toValues
*   )
* ) // Output: [1, 2, 3, 4, 5]
* ```
*
* @example
*
* ```ts
* // Creating a HashSet from a Set
* import { HashSet, pipe } from "effect"
*
* console.log(
*   pipe(
*     new Set(["apple", "banana", "orange", "apple"]), // Set<string> is an Iterable<string>
*     HashSet.fromIterable,
*     HashSet.toValues
*   )
* ) // Output: ["apple", "banana", "orange"]
* ```
*
* @example
*
* ```ts
* // Creating a HashSet from a Generator
* import { HashSet } from "effect"
*
* // Generator functions return iterables
* function* fibonacci(n: number): Generator<number, void, unknown> {
*   let [a, b] = [0, 1]
*   for (let i = 0; i < n; i++) {
*     yield a
*     ;[a, b] = [b, a + b]
*   }
* }
*
* // Create a HashSet from the first 10 Fibonacci numbers
* const fibonacciSet = HashSet.fromIterable(fibonacci(10))
*
* console.log(HashSet.toValues(fibonacciSet))
* // Outputs: [0, 1, 2, 3, 5, 8, 13, 21, 34] but in unsorted order
* ```
*
* @example
*
* ```ts
* //  Creating a HashSet from another HashSet
* import { HashSet, pipe } from "effect"
*
* console.log(
*   pipe(
*     // since HashSet implements the Iterable interface, we can use it to create a new HashSet
*     HashSet.make(1, 2, 3, 4),
*     HashSet.fromIterable,
*     HashSet.toValues // turns the HashSet back into an array
*   )
* ) // Output: [1, 2, 3, 4]
* ```
*
* @example
*
* ```ts
* // Creating a HashSet from other Effect's data structures like Chunk
* import { Chunk, HashSet, pipe } from "effect"
*
* console.log(
*   pipe(
*     Chunk.make(1, 2, 3, 4), // Iterable<number>
*     HashSet.fromIterable,
*     HashSet.toValues // turns the HashSet back into an array
*   )
* ) // Outputs: [1, 2, 3, 4]
* ```
*
* @see Other `HashSet` constructors are {@link module:HashSet.empty} {@link module:HashSet.make}
*/
const fromIterable$6 = fromIterable$7;
/**
* Construct a new `HashSet` from a variable number of values.
*
* Time complexity: **`O(n)`** where n is the number of elements
*
* @memberof HashSet
* @since 2.0.0
* @category constructors
* @example
*
* ```ts
* import { Equal, Hash, HashSet, pipe } from "effect"
* import assert from "node:assert/strict"
*
* class Character implements Equal.Equal {
*   readonly name: string
*   readonly trait: string
*
*   constructor(name: string, trait: string) {
*     this.name = name
*     this.trait = trait
*   }
*
*   // Define equality based on name, and trait
*   [Equal.symbol](that: Equal.Equal): boolean {
*     if (that instanceof Character) {
*       return (
*         Equal.equals(this.name, that.name) &&
*         Equal.equals(this.trait, that.trait)
*       )
*     }
*     return false
*   }
*
*   // Generate a hash code based on the sum of the character's name and trait
*   [Hash.symbol](): number {
*     return Hash.hash(this.name + this.trait)
*   }
*
*   static readonly of = (name: string, trait: string): Character => {
*     return new Character(name, trait)
*   }
* }
*
* assert.strictEqual(
*   Equal.equals(
*     HashSet.make(
*       Character.of("Alice", "Curious"),
*       Character.of("Alice", "Curious"),
*       Character.of("White Rabbit", "Always late"),
*       Character.of("Mad Hatter", "Tea enthusiast")
*     ),
*     // Is the same as adding each character to an empty set
*     pipe(
*       HashSet.empty(),
*       HashSet.add(Character.of("Alice", "Curious")),
*       HashSet.add(Character.of("Alice", "Curious")), // Alice tried to attend twice!
*       HashSet.add(Character.of("White Rabbit", "Always late")),
*       HashSet.add(Character.of("Mad Hatter", "Tea enthusiast"))
*     )
*   ),
*   true,
*   "`HashSet.make` and `HashSet.empty() + HashSet.add()` should be equal"
* )
*
* assert.strictEqual(
*   Equal.equals(
*     HashSet.make(
*       Character.of("Alice", "Curious"),
*       Character.of("Alice", "Curious"),
*       Character.of("White Rabbit", "Always late"),
*       Character.of("Mad Hatter", "Tea enthusiast")
*     ),
*     HashSet.fromIterable([
*       Character.of("Alice", "Curious"),
*       Character.of("Alice", "Curious"),
*       Character.of("White Rabbit", "Always late"),
*       Character.of("Mad Hatter", "Tea enthusiast")
*     ])
*   ),
*   true,
*   "`HashSet.make` and `HashSet.fromIterable` should be equal"
* )
* ```
*
* @see Other `HashSet` constructors are {@link module:HashSet.fromIterable} {@link module:HashSet.empty}
*/
const make$38 = make$39;
/**
* Checks if the specified value exists in the `HashSet`.
*
* Time complexity: **`O(1)`** average
*
* @memberof HashSet
* @since 2.0.0
* @category elements
* @example
*
* ```ts
* // Syntax
* import { HashSet, pipe } from "effect"
*
* // with `data-last`, a.k.a. `pipeable` API
* pipe(HashSet.make(0, 1, 2), HashSet.has(3)) // false
*
* // or piped with the pipe function
* HashSet.make(0, 1, 2).pipe(HashSet.has(3)) // false
*
* // or with `data-first` API
* HashSet.has(HashSet.make(0, 1, 2), 3) // false
* ```
*
* @returns A `boolean` signaling the presence of the value in the HashSet
* @see Other `HashSet` elements are {@link module:HashSet.some} {@link module:HashSet.every} {@link module:HashSet.isSubset}
*/
const has$4 = has$5;
/**
* Check if a predicate holds true for some `HashSet` element.
*
* Time complexity: **`O(n)`** where n is the number of elements in the set
*
* @memberof HashSet
* @since 2.0.0
* @category elements
* @example
*
* ```ts
* // Syntax
* import { HashSet, pipe } from "effect"
*
* const set: HashSet.HashSet<number> = HashSet.make(0, 1, 2)
*
* // with `data-last`, a.k.a. `pipeable` API
* pipe(
*   set,
*   HashSet.some((n) => n > 0)
* ) // true
*
* // or piped with the pipe function
* set.pipe(HashSet.some((n) => n > 0)) // true
*
* // or with `data-first` API
* HashSet.some(set, (n) => n > 0) // true
* ```
*
* @see Other `HashSet` elements are {@link module:HashSet.has} {@link module:HashSet.every} {@link module:HashSet.isSubset}
*/
const some$1 = some$2;
/**
* Check if a predicate holds true for every `HashSet` element.
*
* Time complexity is **`O(n)`** as it needs to traverse the whole HashSet
* collection
*
* @memberof HashSet
* @since 2.0.0
* @category elements
* @example
*
* ```ts
* // Syntax with Refinement
* import { HashSet, pipe, Predicate } from "effect"
*
* const numberOrString = HashSet.make(1, "1", "one", "uno")
*
* // with `data-last`, a.k.a. `pipeable` API and `Refinement`
* pipe(
*   numberOrString, // HashSet.HashSet<number | string>
*   HashSet.every(Predicate.isString)
* ) // HashSet.HashSet<string>
*
* // or piped with the pipe function and  `Refinement`
* numberOrString // HashSet.HashSet<number | string>
*   .pipe(HashSet.every(Predicate.isString)) // HashSet.HashSet<string>
*
* // or with `data-first` API and `Refinement`
* HashSet.every(
*   numberOrString, // HashSet.HashSet<number | string>
*   Predicate.isString
* ) // HashSet.HashSet<string>
* ```
*
* @example
*
* ```ts
* // Syntax with Predicate
* import { HashSet, pipe } from "effect"
*
* const set = HashSet.make(1, 2, 3)
*
* // with `data-last`, a.k.a. `pipeable` API
* pipe(
*   set,
*   HashSet.every((n) => n >= 0)
* ) // true
*
* // or piped with the pipe function
* set.pipe(HashSet.every((n) => n >= 0)) // true
*
* // or with `data-first` API
* HashSet.every(set, (n) => n >= 0) // true
* ```
*
* @returns A boolean once it has evaluated that whole collection fulfill the
*   Predicate function
* @see Other `HashSet` elements are {@link module:HashSet.has} {@link module:HashSet.some} {@link module:HashSet.isSubset}
*/
const every$3 = every$4;
/**
* Returns `true` if and only if every element in the this `HashSet` is an
* element of the second set,
*
* **NOTE**: the hash and equal of both sets must be the same.
*
* Time complexity analysis is of **`O(n)`**
*
* @memberof HashSet
* @since 2.0.0
* @category elements
* @example
*
* ```ts
* // Syntax
* import { HashSet, pipe } from "effect"
*
* const set1 = HashSet.make(0, 1)
* const set2 = HashSet.make(1, 2)
* const set3 = HashSet.make(0, 1, 2)
*
* // with `data-last`, a.k.a. `pipeable` API
* pipe(set1, HashSet.isSubset(set2)) // false
* pipe(set1, HashSet.isSubset(set3)) // true
*
* // or piped with the pipe function
* set1.pipe(HashSet.isSubset(set2)) // false
* set1.pipe(HashSet.isSubset(set3)) // true
*
* // or with `data-first` API
* HashSet.isSubset(set1, set2) // false
* HashSet.isSubset(set1, set3) // true)
* ```
*
* @see Other `HashSet` elements are {@link module:HashSet.has} {@link module:HashSet.some} {@link module:HashSet.every}
*/
const isSubset = isSubset$1;
/**
* Returns an `IterableIterator` of the values in the `HashSet`.
*
* Time complexity: **`O(1)`**
*
* @memberof HashSet
* @since 2.0.0
* @category getters
* @example
*
* ```ts
* import { HashSet, pipe } from "effect"
*
* const numberIterable = pipe(
*   HashSet.make(0, 1, 1, 2), // HashSet.HashSet<number>
*   HashSet.values // takes an HashSet<A> and returns an IterableIterator<A>
* )
*
* for (const number of numberIterable) {
*   console.log(number) // it will logs: 0, 1, 2
* }
* ```
*
* @see Other `HashSet` getters are {@link module:HashSet.toValues} {@link module:HashSet.size}
*/
const values$3 = values$4;
/**
* Calculates the number of values in the `HashSet`.
*
* Time complexity: **`O(1)`**
*
* @memberof HashSet
* @since 2.0.0
* @category getters
* @example
*
* ```ts
* import { HashSet, pipe } from "effect"
* import assert from "node:assert/strict"
*
* assert.deepStrictEqual(pipe(HashSet.empty(), HashSet.size), 0)
*
* assert.deepStrictEqual(
*   pipe(HashSet.make(1, 2, 2, 3, 4, 3), HashSet.size),
*   4
* )
* ```
*
* @see Other `HashSet` getters are {@link module:HashSet.values} {@link module:HashSet.toValues}
*/
const size$8 = size$9;
/**
* Creates a new mutable version of the `HashSet`
*
* When a `HashSet` is mutable, operations like {@link add} and {@link remove}
* modify the data structure in place instead of creating a new one, which is
* more efficient when performing multiple operations.
*
* @memberof HashSet
* @since 2.0.0
* @example
*
* ```ts
* import { HashSet } from "effect"
* import assert from "node:assert/strict"
*
* const UPPER_BOUND = 10_000
*
* const immutableSet = HashSet.empty<number>().pipe(HashSet.add(0))
*
* // Create a mutable version of the immutableSet
* const mutableSet = HashSet.beginMutation(immutableSet)
*
* for (let i = 1; i < UPPER_BOUND; i++) {
*   // Operations now modify the set in place instead of creating new instances
*   // This is more efficient when making multiple changes
*   const pointerToMutableSet = HashSet.add(mutableSet, i)
*
*   // the two sets have the same identity, hence `add` is mutating mutableSet and not returning a new HashSet instance
*   assert(Object.is(mutableSet, pointerToMutableSet))
*   assert.equal(HashSet.has(mutableSet, i), true) // `i` is in the mutableSet
*   assert.equal(HashSet.has(immutableSet, i), false) // `i` is not in the immutableSet
* }
*
* const next = UPPER_BOUND + 1
* // When done, mark the set as immutable again
* HashSet.endMutation(mutableSet).pipe(
*   HashSet.add(next) // since this returns a new HashSet, it will not be logged as part of the mutableSet
* )
* assert.equal(HashSet.has(mutableSet, next), false)
*
* console.log(HashSet.toValues(immutableSet)) // [0]
* console.log(HashSet.toValues(mutableSet).sort((a, b) => a - b)) // [0, 1, 2, 3, ...rest]
* ```
*
* @see Other `HashSet` mutations are {@link module:HashSet.add} {@link module:HashSet.remove} {@link module:HashSet.toggle} {@link module:HashSet.endMutation} {@link module:HashSet.mutate}
*/
const beginMutation$1 = beginMutation$2;
/**
* Makes the `HashSet` immutable again.
*
* After calling `endMutation`, operations like {@link add} and {@link remove}
* will create new instances of the `HashSet` instead of modifying the existing
* one.
*
* @memberof HashSet
* @since 2.0.0
* @example
*
* ```ts
* import { HashSet } from "effect"
* import assert from "node:assert/strict"
*
* // Create a mutable set
* const mutableSet = HashSet.beginMutation(HashSet.empty<number>())
*
* // Add some elements to the mutable set
* HashSet.add(mutableSet, 1)
* HashSet.add(mutableSet, 2)
*
* // Before endMutation, operations modify the set in place
* const sameSet = HashSet.add(mutableSet, 3)
* assert(Object.is(mutableSet, sameSet)) // true - same object reference
* assert.deepStrictEqual(HashSet.toValues(mutableSet).sort(), [1, 2, 3])
*
* // Make the set immutable again
* const immutableSet = HashSet.endMutation(mutableSet)
*
* // endMutation returns the same set instance, now made immutable
* assert(Object.is(mutableSet, immutableSet)) // true - same object reference
*
* // After endMutation, operations create new instances
* const newSet = HashSet.add(immutableSet, 4)
* assert(!Object.is(immutableSet, newSet)) // false - different object references
*
* // The original set remains unchanged
* assert.deepStrictEqual(HashSet.toValues(immutableSet).sort(), [1, 2, 3])
*
* // The new set contains the added element
* assert.deepStrictEqual(HashSet.toValues(newSet).sort(), [1, 2, 3, 4])
* ```
*
* @see Other `HashSet` mutations are {@link module:HashSet.add} {@link module:HashSet.remove} {@link module:HashSet.toggle} {@link module:HashSet.beginMutation} {@link module:HashSet.mutate}
*/
const endMutation$1 = endMutation$2;
/**
* Mutates the `HashSet` within the context of the provided function.
*
* You can consider it a functional abstraction on top of the lower-level
* mutation primitives of {@link module:HashSet.beginMutation} `->` `mutable
* context` `->` {@link HashSet.endMutation}.
*
* @memberof HashSet
* @since 2.0.0
* @example
*
* ```ts
* // Syntax
* import { HashSet, pipe } from "effect"
*
* // with data-last, a.k.a. pipeable API
* pipe(
*   HashSet.make(1, 2, 3),
*   HashSet.mutate((set) => {
*     HashSet.add(set, 4)
*     HashSet.remove(set, 1)
*   })
* )
*
* // or piped with the pipe function
* HashSet.make(1, 2, 3).pipe(
*   HashSet.mutate((set) => {
*     HashSet.add(set, 4)
*     HashSet.remove(set, 1)
*   })
* )
*
* // or with data-first API
* HashSet.mutate(HashSet.make(1, 2, 3), (set) => {
*   HashSet.add(set, 4)
*   HashSet.remove(set, 1)
* })
* ```
*
* @see Other `HashSet` mutations are {@link module:HashSet.add} {@link module:HashSet.remove} {@link module:HashSet.toggle} {@link module:HashSet.beginMutation} {@link module:HashSet.endMutation}
*/
const mutate$1 = mutate$2;
/**
* Adds a value to the `HashSet`.
*
* Time complexity: **`O(1)`** average
*
* @remarks
* Remember that a `HashSet` is a collection of unique values, so adding a value
* that already exists in the `HashSet` will not add a duplicate.
*
* Remember that HashSet is an immutable data structure, so the `add` function,
* like all other functions that modify the HashSet, will return a new HashSet
* with the added value.
* @memberof HashSet
* @since 2.0.0
* @example
*
* ```ts
* // Syntax
* import { HashSet, pipe } from "effect"
*
* // with data-last, a.k.a. pipeable API
* pipe(HashSet.empty(), HashSet.add(0), HashSet.add(0))
*
* // or piped with the pipe function
* HashSet.empty().pipe(HashSet.add(0))
*
* // or with data-first API
* HashSet.add(HashSet.empty(), 0)
* ```
*
* @see Other `HashSet` mutations are {@link module:HashSet.remove} {@link module:HashSet.toggle} {@link module:HashSet.beginMutation} {@link module:HashSet.endMutation} {@link module:HashSet.mutate}
*/
const add$1 = add$2;
/**
* Removes a value from the `HashSet`.
*
* Time complexity: **`O(1)`** average
*
* @memberof HashSet
* @since 2.0.0
* @example
*
* ```ts
* // Syntax
* import { HashSet, pipe } from "effect"
*
* // with `data-last`, a.k.a. `pipeable` API
* pipe(HashSet.make(0, 1, 2), HashSet.remove(0))
*
* // or piped with the pipe function
* HashSet.make(0, 1, 2).pipe(HashSet.remove(0))
*
* // or with `data-first` API
* HashSet.remove(HashSet.make(0, 1, 2), 0)
* ```
*
* @see Other `HashSet` mutations are {@link module:HashSet.add} {@link module:HashSet.toggle} {@link module:HashSet.beginMutation} {@link module:HashSet.endMutation} {@link module:HashSet.mutate}
*/
const remove$5 = remove$6;
/**
* Computes the set difference `(A - B)` between this `HashSet` and the
* specified `Iterable<A>`.
*
* Time complexity: **`O(n)`** where n is the number of elements in the set
*
* **NOTE**: the hash and equal of the values in both the set and the iterable
* must be the same; meaning we cannot compute a difference between a `HashSet
* of bananas` and a `HashSet of elephants` as they are not the same type and
* won't implement the Equal trait in the same way.
*
* @memberof HashSet
* @since 2.0.0
* @example
*
* ```ts
* // Syntax
* import { HashSet, pipe } from "effect"
*
* // with data-last, a.k.a. pipeable API
* pipe(HashSet.make(1, 2, 3), HashSet.difference(HashSet.make(3, 4, 5)))
*
* // or piped with the pipe function
* HashSet.make(1, 2, 3).pipe(HashSet.difference(HashSet.make(3, 4, 5)))
*
* // or with data-first API
* HashSet.difference(HashSet.make(1, 2, 3), HashSet.make(3, 4, 5))
* ```
*
* @see Other `HashSet` operations are {@link module:HashSet.intersection} {@link module:HashSet.union}
*/
const difference = difference$1;
/**
* Returns a `HashSet` of values which are present in both this set and that
* `Iterable<A>`. Computes set intersection (A ∩ B)
*
* Time complexity: **`O(n)`** where n is the number of elements in the smaller
* set
*
* **NOTE**: the hash and equal of the values in both the set and the iterable
* must be the same.
*
* @memberof HashSet
* @since 2.0.0
* @example
*
* ```ts
* // Syntax
* import { HashSet, pipe } from "effect"
*
* // with data-last, a.k.a. pipeable API
* pipe(HashSet.make(1, 2, 3), HashSet.intersection(HashSet.make(2, 3, 4)))
*
* // or piped with the pipe function
* HashSet.make(1, 2, 3).pipe(HashSet.intersection(HashSet.make(2, 3, 4)))
*
* // or with data-first API
* HashSet.intersection(HashSet.make(1, 2, 3), HashSet.make(2, 3, 4))
* ```
*
* @see Other `HashSet` operations are {@link module:HashSet.difference} {@link module:HashSet.union}
*/
const intersection = intersection$1;
/**
* Computes the set union `( self ∪ that )` between this `HashSet` and the
* specified `Iterable<A>`.
*
* Time complexity: **`O(n)`** where n is the number of elements in the set
*
* **NOTE**: the hash and equal of the values in both the set and the iterable
* must be the same.
*
* @memberof HashSet
* @since 2.0.0
* @example
*
* ```ts
* // Syntax
* import { HashSet, pipe } from "effect"
*
* // with data-last, a.k.a. pipeable API
* pipe(HashSet.make(1, 2, 3), HashSet.union(HashSet.make(3, 4, 5)))
*
* // or piped with the pipe function
* HashSet.make(1, 2, 3).pipe(HashSet.union(HashSet.make(3, 4, 5)))
*
* // or with data-first API
* HashSet.union(HashSet.make(1, 2, 3), HashSet.make(3, 4, 5))
* ```
*
* @see Other `HashSet` operations are {@link module:HashSet.difference} {@link module:HashSet.intersection}
*/
const union$5 = union$6;
/**
* Checks if a value is present in the `HashSet`. If it is present, the value
* will be removed from the `HashSet`, otherwise the value will be added to the
* `HashSet`.
*
* Time complexity: **`O(1)`** average
*
* @memberof HashSet
* @since 2.0.0
* @example
*
* ```ts
* // Syntax
* import { HashSet, pipe } from "effect"
*
* // with `data-last`, a.k.a. `pipeable` API
* pipe(HashSet.make(0, 1, 2), HashSet.toggle(0))
*
* // or piped with the pipe function
* HashSet.make(0, 1, 2).pipe(HashSet.toggle(0))
*
* // or with `data-first` API
* HashSet.toggle(HashSet.make(0, 1, 2), 0)
* ```
*
* @returns A new `HashSet` where the toggled value is being either added or
*   removed based on the initial `HashSet` state.
* @see Other `HashSet` mutations are {@link module:HashSet.add} {@link module:HashSet.remove} {@link module:HashSet.beginMutation} {@link module:HashSet.endMutation} {@link module:HashSet.mutate}
*/
const toggle = toggle$1;
/**
* Maps over the values of the `HashSet` using the specified function.
*
* The time complexity is of **`O(n)`**.
*
* @memberof HashSet
* @since 2.0.0
* @category mapping
* @example
*
* ```ts
* // Syntax
* import { HashSet, pipe } from "effect"
*
* // with `data-last`, a.k.a. `pipeable` API
* pipe(
*   HashSet.make(0, 1, 2), // HashSet.HashSet<number>
*   HashSet.map(String) // HashSet.HashSet<string>
* )
*
* // or piped with the pipe method
* HashSet.make(0, 1, 2).pipe(HashSet.map(String))
*
* // or with `data-first` API
* HashSet.map(HashSet.make(0, 1, 2), String)
* ```
*/
const map$12 = map$13;
/**
* Chains over the values of the `HashSet` using the specified function.
*
* The time complexity is of **`O(n)`**.
*
* @memberof HashSet
* @since 2.0.0
* @category sequencing
* @example
*
* ```ts
* // Syntax
* import { HashSet, pipe } from "effect"
*
* // with `data-last`, a.k.a. `pipeable` API
* pipe(
*   HashSet.make(0, 1, 2), // HashSet.HashSet<number>
*   HashSet.flatMap((n) => Array.of(String(n))) // HashSet.HashSet<string>
* )
*
* // or piped with the pipe method
* HashSet.make(0, 1, 2) // HashSet.HashSet<number>
*   .pipe(
*     HashSet.flatMap((n) => Array.of(String(n))) // HashSet.HashSet<string>
*   )
*
* // or with `data-first` API
* HashSet.flatMap(HashSet.make(0, 1, 2), (n) => Array.of(String(n)))
* ```
*/
const flatMap$8 = flatMap$9;
/**
* Applies the specified function to the values of the `HashSet`.
*
* The time complexity is of **`O(n)`**.
*
* @memberof HashSet
* @since 2.0.0
* @category traversing
* @example
*
* ```ts
* // Syntax
* import { HashSet, pipe } from "effect"
*
* // with `data-last`, a.k.a. `pipeable` API
* pipe(HashSet.make(0, 1, 2), HashSet.forEach(console.log)) // logs: 0 1 2
*
* // or piped with the pipe method
* HashSet.make(0, 1, 2).pipe(HashSet.forEach(console.log)) // logs: 0 1 2
*
* // or with `data-first` API
* HashSet.forEach(HashSet.make(0, 1, 2), console.log) // logs: 0 1 2
* ```
*/
const forEach$6 = forEach$7;
/**
* Reduces the specified state over the values of the `HashSet`.
*
* The time complexity is of **`O(n)`**.
*
* @memberof HashSet
* @since 2.0.0
* @category folding
* @example
*
* ```ts
* // Syntax
* import { HashSet, pipe } from "effect"
*
* const sum = (a: number, b: number): number => a + b
*
* // with `data-last`, a.k.a. `pipeable` API
* pipe(HashSet.make(0, 1, 2), HashSet.reduce(0, sum))
*
* // or with the pipe method
* HashSet.make(0, 1, 2).pipe(HashSet.reduce(0, sum))
*
* // or with `data-first` API
* HashSet.reduce(HashSet.make(0, 1, 2), 0, sum)
* ```
*/
const reduce$8 = reduce$9;
/**
* Filters values out of a `HashSet` using the specified predicate.
*
* The time complexity is of **`O(n)`**.
*
* @memberof HashSet
* @since 2.0.0
* @category filtering
* @example
*
* ```ts
* // Syntax with  Predicate
* import { HashSet, type Predicate, pipe } from "effect"
*
* const filterPositiveNumbers: Predicate.Predicate<number> = (n) => n > 0
*
* // with `data-last`, a.k.a. `pipeable` API
* pipe(
*   HashSet.make(-2, -1, 0, 1, 2),
*   HashSet.filter(filterPositiveNumbers)
* )
*
* // or with the pipe method
* HashSet.make(-2, -1, 0, 1, 2).pipe(HashSet.filter(filterPositiveNumbers))
*
* // or with `data-first` API
* HashSet.filter(HashSet.make(-2, -1, 0, 1, 2), filterPositiveNumbers)
* ```
*
* @example
*
* ```ts
* /// Syntax with Refinement
* import { HashSet, pipe } from "effect"
*
* const stringRefinement = (value: unknown): value is string =>
*   typeof value === "string"
*
* // with `data-last`, a.k.a. `pipeable` API
* pipe(
*   HashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier"), // // HashSet.HashSet<number | string>
*   HashSet.filter(stringRefinement)
* ) // HashSet.HashSet<string>
*
* // or with the pipe method
* HashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier") // HashSet.HashSet<number | string>
*   .pipe(HashSet.filter(stringRefinement)) // HashSet.HashSet<string>
*
* // or with `data-first` API
* HashSet.filter(
*   HashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier"), // HashSet.HashSet<number | string>
*   stringRefinement
* ) // HashSet.HashSet<string>
* ```
*/
const filter$5 = filter$6;
/**
* Partition the values of a `HashSet` using the specified predicate.
*
* If a value matches the predicate, it will be placed into the `HashSet` on the
* right side of the resulting `Tuple`, otherwise the value will be placed into
* the left side.
*
* Time complexity is of **`O(n)`**.
*
* @memberof HashSet
* @since 2.0.0
* @category partitioning
* @example
*
* ```ts
* // Syntax with Predicate
* import { HashSet, pipe, Predicate } from "effect"
*
* // with `data-last`, a.k.a. `pipeable` API
* pipe(
*   HashSet.make(0, 1, 2, 3, 4, 5),
*   HashSet.partition((n) => n % 2 === 0)
* )
*
* // or with the pipe method
* HashSet.make(0, 1, 2, 3, 4, 5).pipe(
*   HashSet.partition((n) => n % 2 === 0)
* )
*
* // or with `data-first` API
* HashSet.partition(HashSet.make(0, 1, 2, 3, 4, 5), (n) => n % 2 === 0)
* ```
*
* @example
*
* ```ts
* // Syntax with Refinement
* import { HashSet, pipe, Predicate } from "effect"
*
* const stringRefinement: Predicate.Refinement<string | number, string> = (
*   value
* ) => typeof value === "string"
*
* // with `data-last`, a.k.a. `pipeable` API
* pipe(
*   HashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier"),
*   HashSet.partition(stringRefinement)
* )
*
* // or with the pipe method
* HashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier").pipe(
*   HashSet.partition(stringRefinement)
* )
*
* // or with `data-first` API
* HashSet.partition(
*   HashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier"),
*   stringRefinement
* )
* ```
*/
const partition$2 = partition$3;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/MutableRef.js
const TypeId$13 = /* @__PURE__ */ Symbol.for("effect/MutableRef");
const MutableRefProto = {
	[TypeId$13]: TypeId$13,
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "MutableRef",
			current: toJSON(this.current)
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/**
* @since 2.0.0
* @category constructors
*/
const make$37 = (value) => {
	const ref = Object.create(MutableRefProto);
	ref.current = value;
	return ref;
};
/**
* @since 2.0.0
* @category general
*/
const compareAndSet = /* @__PURE__ */ dual$1(3, (self, oldValue, newValue) => {
	if (equals(oldValue, self.current)) {
		self.current = newValue;
		return true;
	}
	return false;
});
/**
* @since 2.0.0
* @category general
*/
const get$6 = (self) => self.current;
/**
* @since 2.0.0
* @category general
*/
const set$4 = /* @__PURE__ */ dual$1(2, (self, value) => {
	self.current = value;
	return self;
});

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/fiberId.js
/** @internal */
const FiberIdSymbolKey = "effect/FiberId";
/** @internal */
const FiberIdTypeId$1 = /* @__PURE__ */ Symbol.for(FiberIdSymbolKey);
/** @internal */
const OP_NONE = "None";
/** @internal */
const OP_RUNTIME = "Runtime";
/** @internal */
const OP_COMPOSITE = "Composite";
const emptyHash = /* @__PURE__ */ string(`${FiberIdSymbolKey}-${OP_NONE}`);
/** @internal */
var None$2 = class {
	[FiberIdTypeId$1] = FiberIdTypeId$1;
	_tag = OP_NONE;
	id = -1;
	startTimeMillis = -1;
	[symbol$1]() {
		return emptyHash;
	}
	[symbol](that) {
		return isFiberId$1(that) && that._tag === OP_NONE;
	}
	toString() {
		return format(this.toJSON());
	}
	toJSON() {
		return {
			_id: "FiberId",
			_tag: this._tag
		};
	}
	[NodeInspectSymbol]() {
		return this.toJSON();
	}
};
/** @internal */
var Runtime = class {
	id;
	startTimeMillis;
	[FiberIdTypeId$1] = FiberIdTypeId$1;
	_tag = OP_RUNTIME;
	constructor(id$2, startTimeMillis) {
		this.id = id$2;
		this.startTimeMillis = startTimeMillis;
	}
	[symbol$1]() {
		return cached$2(this, string(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));
	}
	[symbol](that) {
		return isFiberId$1(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;
	}
	toString() {
		return format(this.toJSON());
	}
	toJSON() {
		return {
			_id: "FiberId",
			_tag: this._tag,
			id: this.id,
			startTimeMillis: this.startTimeMillis
		};
	}
	[NodeInspectSymbol]() {
		return this.toJSON();
	}
};
/** @internal */
var Composite$1 = class {
	left;
	right;
	[FiberIdTypeId$1] = FiberIdTypeId$1;
	_tag = OP_COMPOSITE;
	constructor(left$2, right$2) {
		this.left = left$2;
		this.right = right$2;
	}
	_hash;
	[symbol$1]() {
		return pipe$3(string(`${FiberIdSymbolKey}-${this._tag}`), combine$11(hash(this.left)), combine$11(hash(this.right)), cached$2(this));
	}
	[symbol](that) {
		return isFiberId$1(that) && that._tag === OP_COMPOSITE && equals(this.left, that.left) && equals(this.right, that.right);
	}
	toString() {
		return format(this.toJSON());
	}
	toJSON() {
		return {
			_id: "FiberId",
			_tag: this._tag,
			left: toJSON(this.left),
			right: toJSON(this.right)
		};
	}
	[NodeInspectSymbol]() {
		return this.toJSON();
	}
};
/** @internal */
const none$1 = /* @__PURE__ */ new None$2();
/** @internal */
const runtime$3 = (id$2, startTimeMillis) => {
	return new Runtime(id$2, startTimeMillis);
};
/** @internal */
const composite$1 = (left$2, right$2) => {
	return new Composite$1(left$2, right$2);
};
/** @internal */
const isFiberId$1 = (self) => hasProperty(self, FiberIdTypeId$1);
/** @internal */
const isNone$1 = (self) => {
	return self._tag === OP_NONE || pipe$3(toSet$3(self), every$3((id$2) => isNone$1(id$2)));
};
/** @internal */
const isRuntime$1 = (self) => {
	return self._tag === OP_RUNTIME;
};
/** @internal */
const isComposite$2 = (self) => {
	return self._tag === OP_COMPOSITE;
};
/** @internal */
const combine$10 = /* @__PURE__ */ dual$1(2, (self, that) => {
	if (self._tag === OP_NONE) return that;
	if (that._tag === OP_NONE) return self;
	return new Composite$1(self, that);
});
/** @internal */
const combineAll$1 = (fiberIds) => {
	return pipe$3(fiberIds, reduce$8(none$1, (a$1, b$1) => combine$10(b$1)(a$1)));
};
/** @internal */
const getOrElse$2 = /* @__PURE__ */ dual$1(2, (self, that) => isNone$1(self) ? that : self);
/** @internal */
const ids$1 = (self) => {
	switch (self._tag) {
		case OP_NONE: return empty$27();
		case OP_RUNTIME: return make$38(self.id);
		case OP_COMPOSITE: return pipe$3(ids$1(self.left), union$5(ids$1(self.right)));
	}
};
const _fiberCounter = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Fiber/Id/_fiberCounter"), () => make$37(0));
/** @internal */
const make$36 = (id$2, startTimeSeconds) => {
	return new Runtime(id$2, startTimeSeconds);
};
/** @internal */
const threadName$1 = (self) => {
	return Array.from(ids$1(self)).map((n$1) => `#${n$1}`).join(",");
};
/** @internal */
const toOption$1 = (self) => {
	const fiberIds = toSet$3(self);
	if (size$8(fiberIds) === 0) return none$7();
	let first$2 = true;
	let acc;
	for (const fiberId$2 of fiberIds) if (first$2) {
		acc = fiberId$2;
		first$2 = false;
	} else acc = pipe$3(acc, combine$10(fiberId$2));
	return some$4(acc);
};
/** @internal */
const toSet$3 = (self) => {
	switch (self._tag) {
		case OP_NONE: return empty$27();
		case OP_RUNTIME: return make$38(self);
		case OP_COMPOSITE: return pipe$3(toSet$3(self.left), union$5(toSet$3(self.right)));
	}
};
/** @internal */
const unsafeMake$8 = () => {
	const id$2 = get$6(_fiberCounter);
	pipe$3(_fiberCounter, set$4(id$2 + 1));
	return new Runtime(id$2, Date.now());
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/FiberId.js
/**
* @since 2.0.0
* @category symbols
*/
const FiberIdTypeId = FiberIdTypeId$1;
/**
* @since 2.0.0
* @category constructors
*/
const none$6 = none$1;
/**
* @since 2.0.0
* @category constructors
*/
const runtime$2 = runtime$3;
/**
* @since 2.0.0
* @category constructors
*/
const composite = composite$1;
/**
* Returns `true` if the specified unknown value is a `FiberId`, `false`
* otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isFiberId = isFiberId$1;
/**
* Returns `true` if the `FiberId` is a `None`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isNone = isNone$1;
/**
* Returns `true` if the `FiberId` is a `Runtime`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isRuntime = isRuntime$1;
/**
* Returns `true` if the `FiberId` is a `Composite`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isComposite$1 = isComposite$2;
/**
* Combine two `FiberId`s.
*
* @since 2.0.0
* @category constructors
*/
const combine$9 = combine$10;
/**
* Combines a set of `FiberId`s into a single `FiberId`.
*
* @since 2.0.0
* @category constructors
*/
const combineAll = combineAll$1;
/**
* Returns this `FiberId` if it is not `None`, otherwise returns that `FiberId`.
*
* @since 2.0.0
* @category utils
*/
const getOrElse$1 = getOrElse$2;
/**
* Get the set of identifiers for this `FiberId`.
*
* @since 2.0.0
* @category destructors
*/
const ids = ids$1;
/**
* Creates a new `FiberId`.
*
* @since 2.0.0
* @category constructors
*/
const make$35 = make$36;
/**
* Creates a string representing the name of the current thread of execution
* represented by the specified `FiberId`.
*
* @since 2.0.0
* @category destructors
*/
const threadName = threadName$1;
/**
* Convert a `FiberId` into an `Option<FiberId>`.
*
* @since 2.0.0
* @category destructors
*/
const toOption = toOption$1;
/**
* Convert a `FiberId` into a `HashSet<FiberId>`.
*
* @since 2.0.0
* @category destructors
*/
const toSet$2 = toSet$3;
/**
* Unsafely creates a new `FiberId`.
*
* @since 2.0.0
* @category unsafe
*/
const unsafeMake$7 = unsafeMake$8;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/hashMap/keySet.js
/** @internal */
function keySet$1(self) {
	return makeImpl$1(self);
}

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/HashMap.js
HashMapTypeId;
/**
* @since 2.0.0
* @category refinements
*/
const isHashMap = isHashMap$1;
/**
* Creates a new `HashMap`.
*
* @since 2.0.0
* @category constructors
*/
const empty$26 = empty$29;
/**
* Constructs a new `HashMap` from an array of key/value pairs.
*
* @since 2.0.0
* @category constructors
*/
const make$34 = make$40;
/**
* Creates a new `HashMap` from an iterable collection of key/value pairs.
*
* @since 2.0.0
* @category constructors
*/
const fromIterable$5 = fromIterable$8;
/**
* Checks if the `HashMap` contains any entries.
*
* @since 2.0.0
* @category elements
*/
const isEmpty$7 = isEmpty$8;
/**
* Safely lookup the value for the specified key in the `HashMap` using the
* internal hashing function.
*
* @since 2.0.0
* @category elements
*/
const get$5 = get$7;
/**
* Lookup the value for the specified key in the `HashMap` using a custom hash.
*
* @since 2.0.0
* @category elements
*/
const getHash = getHash$1;
/**
* Unsafely lookup the value for the specified key in the `HashMap` using the
* internal hashing function.
*
* @since 2.0.0
* @category unsafe
*/
const unsafeGet = unsafeGet$1;
/**
* Checks if the specified key has an entry in the `HashMap`.
*
* @since 2.0.0
* @category elements
*/
const has$3 = has$6;
/**
* Checks if the specified key has an entry in the `HashMap` using a custom
* hash.
*
* @since 2.0.0
* @category elements
*/
const hasHash = hasHash$1;
/**
* Checks if an element matching the given predicate exists in the given `HashMap`.
*
* @example
* ```ts
* import { HashMap } from "effect"
*
* const hm = HashMap.make([1, 'a'])
* HashMap.hasBy(hm, (value, key) => value === 'a' && key === 1); // -> true
* HashMap.hasBy(hm, (value) => value === 'b'); // -> false
*
* ```
*
* @since 3.16.0
* @category elements
*/
const hasBy = hasBy$1;
/**
* Sets the specified key to the specified value using the internal hashing
* function.
*
* @since 2.0.0
*/
const set$3 = set$5;
/**
* Returns an `IterableIterator` of the keys within the `HashMap`.
*
* @since 2.0.0
* @category getters
*/
const keys$2 = keys$3;
/**
* Returns a `HashSet` of keys within the `HashMap`.
*
* @since 2.0.0
* @category getter
*/
const keySet = keySet$1;
/**
* Returns an `IterableIterator` of the values within the `HashMap`.
*
* @since 2.0.0
* @category getters
*/
const values$2 = values$5;
/**
* Returns an `IterableIterator` of the entries within the `HashMap`.
*
* @since 2.0.0
* @category getters
*/
const entries = entries$1;
/**
* Returns the number of entries within the `HashMap`.
*
* @since 2.0.0
* @category getters
*/
const size$7 = size$10;
/**
* Counts all the element of the given HashMap that pass the given predicate
*
* **Example**
*
* ```ts
* import { HashMap } from "effect"
*
* const map = HashMap.make([1, "a"], [2, "b"], [3, "c"])
* const result = HashMap.countBy(map, (_v, key) => key % 2 === 1)
* console.log(result) // 2
* ```
*
* @since 3.17.0
* @category folding
*/
const countBy = countBy$1;
/**
* Marks the `HashMap` as mutable.
*
* @since 2.0.0
*/
const beginMutation = beginMutation$3;
/**
* Marks the `HashMap` as immutable.
*
* @since 2.0.0
*/
const endMutation = endMutation$3;
/**
* Mutates the `HashMap` within the context of the provided function.
*
* @since 2.0.0
*/
const mutate = mutate$3;
/**
* Set or remove the specified key in the `HashMap` using the specified
* update function. The value of the specified key will be computed using the
* provided hash.
*
* The update function will be invoked with the current value of the key if it
* exists, or `None` if no such value exists.
*
* @since 2.0.0
*/
const modifyAt = modifyAt$1;
/**
* Alter the value of the specified key in the `HashMap` using the specified
* update function. The value of the specified key will be computed using the
* provided hash.
*
* The update function will be invoked with the current value of the key if it
* exists, or `None` if no such value exists.
*
* This function will always either update or insert a value into the `HashMap`.
*
* @since 2.0.0
*/
const modifyHash = modifyHash$1;
/**
* Updates the value of the specified key within the `HashMap` if it exists.
*
* @since 2.0.0
*/
const modify$2 = modify$3;
/**
* Performs a union of this `HashMap` and that `HashMap`.
*
* @since 2.0.0
*/
const union$4 = union$7;
/**
* Remove the entry for the specified key in the `HashMap` using the internal
* hashing function.
*
* @since 2.0.0
*/
const remove$4 = remove$7;
/**
* Removes all entries in the `HashMap` which have the specified keys.
*
* @since 2.0.0
*/
const removeMany = removeMany$1;
/**
* Maps over the entries of the `HashMap` using the specified function.
*
* @since 2.0.0
* @category mapping
*/
const map$11 = map$14;
/**
* Chains over the entries of the `HashMap` using the specified function.
*
* **NOTE**: the hash and equal of both maps have to be the same.
*
* @since 2.0.0
* @category sequencing
*/
const flatMap$7 = flatMap$10;
/**
* Applies the specified function to the entries of the `HashMap`.
*
* @since 2.0.0
* @category traversing
*/
const forEach$5 = forEach$8;
/**
* Reduces the specified state over the entries of the `HashMap`.
*
* @since 2.0.0
* @category folding
*/
const reduce$7 = reduce$10;
/**
* Filters entries out of a `HashMap` using the specified predicate.
*
* @since 2.0.0
* @category filtering
*/
const filter$4 = filter$7;
/**
* Filters out `None` values from a `HashMap` of `Options`s.
*
* @since 2.0.0
* @category filtering
*/
const compact = compact$1;
/**
* Maps over the entries of the `HashMap` using the specified partial function
* and filters out `None` values.
*
* @since 2.0.0
* @category filtering
*/
const filterMap$2 = filterMap$3;
/**
* Returns the first element that satisfies the specified
* predicate, or `None` if no such element exists.
*
* @category elements
* @since 2.0.0
*/
const findFirst$4 = findFirst$5;
/**
* Checks if any entry in a hashmap meets a specific condition.
*
* @since 3.13.0
* @category elements
*/
const some = some$3;
/**
* Checks if all entries in a hashmap meets a specific condition.
*
* @param self - The hashmap to check.
* @param predicate - The condition to test entries (value, key).
*
* @since 3.14.0
* @category elements
*/
const every$2 = every$5;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/List.js
/**
* @since 2.0.0
* @category symbol
*/
const TypeId$12 = /* @__PURE__ */ Symbol.for("effect/List");
/**
* Converts the specified `List` to an `Array`.
*
* @category conversions
* @since 2.0.0
*/
const toArray = (self) => fromIterable$10(self);
/**
* @category equivalence
* @since 2.0.0
*/
const getEquivalence = (isEquivalent) => mapInput$1(getEquivalence$2(isEquivalent), toArray);
const _equivalence = /* @__PURE__ */ getEquivalence(equals);
const ConsProto = {
	[TypeId$12]: TypeId$12,
	_tag: "Cons",
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "List",
			_tag: "Cons",
			values: toArray(this).map(toJSON)
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	[symbol](that) {
		return isList(that) && this._tag === that._tag && _equivalence(this, that);
	},
	[symbol$1]() {
		return cached$2(this, array$1(toArray(this)));
	},
	[Symbol.iterator]() {
		let done$8 = false;
		let self = this;
		return {
			next() {
				if (done$8) return this.return();
				if (self._tag === "Nil") {
					done$8 = true;
					return this.return();
				}
				const value = self.head;
				self = self.tail;
				return {
					done: done$8,
					value
				};
			},
			return(value) {
				if (!done$8) done$8 = true;
				return {
					done: true,
					value
				};
			}
		};
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const makeCons = (head$4, tail) => {
	const cons$1 = Object.create(ConsProto);
	cons$1.head = head$4;
	cons$1.tail = tail;
	return cons$1;
};
const NilHash = /* @__PURE__ */ string("Nil");
const NilProto = {
	[TypeId$12]: TypeId$12,
	_tag: "Nil",
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "List",
			_tag: "Nil"
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	[symbol$1]() {
		return NilHash;
	},
	[symbol](that) {
		return isList(that) && this._tag === that._tag;
	},
	[Symbol.iterator]() {
		return { next() {
			return {
				done: true,
				value: void 0
			};
		} };
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const _Nil = /* @__PURE__ */ Object.create(NilProto);
/**
* Returns `true` if the specified value is a `List`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isList = (u$1) => hasProperty(u$1, TypeId$12);
/**
* Returns `true` if the specified value is a `List.Nil<A>`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isNil = (self) => self._tag === "Nil";
/**
* Returns `true` if the specified value is a `List.Cons<A>`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isCons = (self) => self._tag === "Cons";
/**
* Constructs a new empty `List<A>`.
*
* @since 2.0.0
* @category constructors
*/
const nil = () => _Nil;
/**
* Constructs a new `List.Cons<A>` from the specified `head` and `tail` values.
*
* @since 2.0.0
* @category constructors
*/
const cons = (head$4, tail) => makeCons(head$4, tail);
/**
* Constructs a new empty `List<A>`.
*
* Alias of {@link nil}.
*
* @since 2.0.0
* @category constructors
*/
const empty$25 = nil;
/**
* Constructs a new `List<A>` from the specified value.
*
* @since 2.0.0
* @category constructors
*/
const of$2 = (value) => makeCons(value, _Nil);
/**
* Concatenates two lists, combining their elements.
* If either list is non-empty, the result is also a non-empty list.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { List } from "effect"
*
* assert.deepStrictEqual(
*   List.make(1, 2).pipe(List.appendAll(List.make("a", "b")), List.toArray),
*   [1, 2, "a", "b"]
* )
* ```
*
* @category concatenating
* @since 2.0.0
*/
const appendAll = /* @__PURE__ */ dual$1(2, (self, that) => prependAll(that, self));
/**
* Prepends the specified element to the beginning of the list.
*
* @category concatenating
* @since 2.0.0
*/
const prepend = /* @__PURE__ */ dual$1(2, (self, element) => cons(element, self));
/**
* Prepends the specified prefix list to the beginning of the specified list.
* If either list is non-empty, the result is also a non-empty list.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { List } from "effect"
*
* assert.deepStrictEqual(
*   List.make(1, 2).pipe(List.prependAll(List.make("a", "b")), List.toArray),
*   ["a", "b", 1, 2]
* )
* ```
*
* @category concatenating
* @since 2.0.0
*/
const prependAll = /* @__PURE__ */ dual$1(2, (self, prefix) => {
	if (isNil(self)) return prefix;
	else if (isNil(prefix)) return self;
	else {
		const result = makeCons(prefix.head, self);
		let curr = result;
		let that = prefix.tail;
		while (!isNil(that)) {
			const temp = makeCons(that.head, self);
			curr.tail = temp;
			curr = temp;
			that = that.tail;
		}
		return result;
	}
});
/**
* Folds over the elements of the list using the specified function, using the
* specified initial value.
*
* @since 2.0.0
* @category folding
*/
const reduce$6 = /* @__PURE__ */ dual$1(3, (self, zero$1, f$1) => {
	let acc = zero$1;
	let these = self;
	while (!isNil(these)) {
		acc = f$1(acc, these.head);
		these = these.tail;
	}
	return acc;
});
/**
* Returns a new list with the elements of the specified list in reverse order.
*
* @since 2.0.0
* @category elements
*/
const reverse = (self) => {
	let result = empty$25();
	let these = self;
	while (!isNil(these)) {
		result = prepend(result, these.head);
		these = these.tail;
	}
	return result;
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/data.js
/** @internal */
const ArrayProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(Array.prototype), {
	[symbol$1]() {
		return cached$2(this, array$1(this));
	},
	[symbol](that) {
		if (Array.isArray(that) && this.length === that.length) return this.every((v, i$1) => equals(v, that[i$1]));
		else return false;
	}
});
/** @internal */
const Structural$1 = /* @__PURE__ */ function() {
	function Structural$2(args$2) {
		if (args$2) Object.assign(this, args$2);
	}
	Structural$2.prototype = StructuralPrototype;
	return Structural$2;
}();
/** @internal */
const struct$1 = (as$6) => Object.assign(Object.create(StructuralPrototype), as$6);

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/differ/chunkPatch.js
/** @internal */
const ChunkPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferChunkPatch");
function variance$7(a$1) {
	return a$1;
}
const PatchProto$5 = {
	...Structural$1.prototype,
	[ChunkPatchTypeId]: {
		_Value: variance$7,
		_Patch: variance$7
	}
};
const EmptyProto$5 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$5), { _tag: "Empty" });
const _empty$5 = /* @__PURE__ */ Object.create(EmptyProto$5);
/**
* @internal
*/
const empty$24 = () => _empty$5;
const AndThenProto$5 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$5), { _tag: "AndThen" });
const makeAndThen$5 = (first$2, second) => {
	const o$1 = Object.create(AndThenProto$5);
	o$1.first = first$2;
	o$1.second = second;
	return o$1;
};
const AppendProto$1 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$5), { _tag: "Append" });
const makeAppend$1 = (values$6) => {
	const o$1 = Object.create(AppendProto$1);
	o$1.values = values$6;
	return o$1;
};
const SliceProto$1 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$5), { _tag: "Slice" });
const makeSlice$1 = (from, until) => {
	const o$1 = Object.create(SliceProto$1);
	o$1.from = from;
	o$1.until = until;
	return o$1;
};
const UpdateProto$2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$5), { _tag: "Update" });
const makeUpdate$2 = (index, patch$11) => {
	const o$1 = Object.create(UpdateProto$2);
	o$1.index = index;
	o$1.patch = patch$11;
	return o$1;
};
/** @internal */
const diff$9 = (options) => {
	let i$1 = 0;
	let patch$11 = empty$24();
	while (i$1 < options.oldValue.length && i$1 < options.newValue.length) {
		const oldElement = unsafeGet$2(i$1)(options.oldValue);
		const newElement = unsafeGet$2(i$1)(options.newValue);
		const valuePatch = options.differ.diff(oldElement, newElement);
		if (!equals(valuePatch, options.differ.empty)) patch$11 = pipe$3(patch$11, combine$8(makeUpdate$2(i$1, valuePatch)));
		i$1 = i$1 + 1;
	}
	if (i$1 < options.oldValue.length) patch$11 = pipe$3(patch$11, combine$8(makeSlice$1(0, i$1)));
	if (i$1 < options.newValue.length) patch$11 = pipe$3(patch$11, combine$8(makeAppend$1(drop(i$1)(options.newValue))));
	return patch$11;
};
/** @internal */
const combine$8 = /* @__PURE__ */ dual$1(2, (self, that) => makeAndThen$5(self, that));
/** @internal */
const patch$10 = /* @__PURE__ */ dual$1(3, (self, oldValue, differ$2) => {
	if (self._tag === "Empty") return oldValue;
	let chunk$2 = oldValue;
	let patches = of$3(self);
	while (isNonEmpty$4(patches)) {
		const head$4 = headNonEmpty(patches);
		const tail = tailNonEmpty(patches);
		switch (head$4._tag) {
			case "Empty":
				patches = tail;
				break;
			case "AndThen":
				patches = prepend$1(head$4.first)(prepend$1(head$4.second)(tail));
				break;
			case "Append":
				chunk$2 = appendAll$1(head$4.values)(chunk$2);
				patches = tail;
				break;
			case "Slice": {
				const array$3 = toReadonlyArray(chunk$2);
				chunk$2 = unsafeFromArray(array$3.slice(head$4.from, head$4.until));
				patches = tail;
				break;
			}
			case "Update": {
				const array$3 = toReadonlyArray(chunk$2);
				array$3[head$4.index] = differ$2.patch(head$4.patch, array$3[head$4.index]);
				chunk$2 = unsafeFromArray(array$3);
				patches = tail;
				break;
			}
		}
	}
	return chunk$2;
});

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/differ/contextPatch.js
/** @internal */
const ContextPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferContextPatch");
function variance$6(a$1) {
	return a$1;
}
/** @internal */
const PatchProto$4 = {
	...Structural$1.prototype,
	[ContextPatchTypeId]: {
		_Value: variance$6,
		_Patch: variance$6
	}
};
const EmptyProto$4 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$4), { _tag: "Empty" });
const _empty$4 = /* @__PURE__ */ Object.create(EmptyProto$4);
/**
* @internal
*/
const empty$23 = () => _empty$4;
const AndThenProto$4 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$4), { _tag: "AndThen" });
const makeAndThen$4 = (first$2, second) => {
	const o$1 = Object.create(AndThenProto$4);
	o$1.first = first$2;
	o$1.second = second;
	return o$1;
};
const AddServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$4), { _tag: "AddService" });
const makeAddService = (key, service) => {
	const o$1 = Object.create(AddServiceProto);
	o$1.key = key;
	o$1.service = service;
	return o$1;
};
const RemoveServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$4), { _tag: "RemoveService" });
const makeRemoveService = (key) => {
	const o$1 = Object.create(RemoveServiceProto);
	o$1.key = key;
	return o$1;
};
const UpdateServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$4), { _tag: "UpdateService" });
const makeUpdateService = (key, update$5) => {
	const o$1 = Object.create(UpdateServiceProto);
	o$1.key = key;
	o$1.update = update$5;
	return o$1;
};
/** @internal */
const diff$8 = (oldValue, newValue) => {
	const missingServices = new Map(oldValue.unsafeMap);
	let patch$11 = empty$23();
	for (const [tag$1, newService] of newValue.unsafeMap.entries()) if (missingServices.has(tag$1)) {
		const old = missingServices.get(tag$1);
		missingServices.delete(tag$1);
		if (!equals(old, newService)) patch$11 = combine$7(makeUpdateService(tag$1, () => newService))(patch$11);
	} else {
		missingServices.delete(tag$1);
		patch$11 = combine$7(makeAddService(tag$1, newService))(patch$11);
	}
	for (const [tag$1] of missingServices.entries()) patch$11 = combine$7(makeRemoveService(tag$1))(patch$11);
	return patch$11;
};
/** @internal */
const combine$7 = /* @__PURE__ */ dual$1(2, (self, that) => makeAndThen$4(self, that));
/** @internal */
const patch$9 = /* @__PURE__ */ dual$1(2, (self, context$2) => {
	if (self._tag === "Empty") return context$2;
	let wasServiceUpdated = false;
	let patches = of$3(self);
	const updatedContext = new Map(context$2.unsafeMap);
	while (isNonEmpty$4(patches)) {
		const head$4 = headNonEmpty(patches);
		const tail = tailNonEmpty(patches);
		switch (head$4._tag) {
			case "Empty":
				patches = tail;
				break;
			case "AddService":
				updatedContext.set(head$4.key, head$4.service);
				patches = tail;
				break;
			case "AndThen":
				patches = prepend$1(prepend$1(tail, head$4.second), head$4.first);
				break;
			case "RemoveService":
				updatedContext.delete(head$4.key);
				patches = tail;
				break;
			case "UpdateService":
				updatedContext.set(head$4.key, head$4.update(updatedContext.get(head$4.key)));
				wasServiceUpdated = true;
				patches = tail;
				break;
		}
	}
	if (!wasServiceUpdated) return makeContext(updatedContext);
	const map$18 = /* @__PURE__ */ new Map();
	for (const [tag$1] of context$2.unsafeMap) if (updatedContext.has(tag$1)) {
		map$18.set(tag$1, updatedContext.get(tag$1));
		updatedContext.delete(tag$1);
	}
	for (const [tag$1, s$1] of updatedContext) map$18.set(tag$1, s$1);
	return makeContext(map$18);
});

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/differ/hashMapPatch.js
/** @internal */
const HashMapPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferHashMapPatch");
function variance$5(a$1) {
	return a$1;
}
/** @internal */
const PatchProto$3 = {
	...Structural$1.prototype,
	[HashMapPatchTypeId]: {
		_Value: variance$5,
		_Key: variance$5,
		_Patch: variance$5
	}
};
const EmptyProto$3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$3), { _tag: "Empty" });
const _empty$3 = /* @__PURE__ */ Object.create(EmptyProto$3);
/** @internal */
const empty$22 = () => _empty$3;
const AndThenProto$3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$3), { _tag: "AndThen" });
const makeAndThen$3 = (first$2, second) => {
	const o$1 = Object.create(AndThenProto$3);
	o$1.first = first$2;
	o$1.second = second;
	return o$1;
};
const AddProto$1 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$3), { _tag: "Add" });
const makeAdd$1 = (key, value) => {
	const o$1 = Object.create(AddProto$1);
	o$1.key = key;
	o$1.value = value;
	return o$1;
};
const RemoveProto$1 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$3), { _tag: "Remove" });
const makeRemove$1 = (key) => {
	const o$1 = Object.create(RemoveProto$1);
	o$1.key = key;
	return o$1;
};
const UpdateProto$1 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$3), { _tag: "Update" });
const makeUpdate$1 = (key, patch$11) => {
	const o$1 = Object.create(UpdateProto$1);
	o$1.key = key;
	o$1.patch = patch$11;
	return o$1;
};
/** @internal */
const diff$7 = (options) => {
	const [removed, patch$11] = reduce$7([options.oldValue, empty$22()], ([map$18, patch$12], newValue, key) => {
		const option$2 = get$5(key)(map$18);
		switch (option$2._tag) {
			case "Some": {
				const valuePatch = options.differ.diff(option$2.value, newValue);
				if (equals(valuePatch, options.differ.empty)) return [remove$4(key)(map$18), patch$12];
				return [remove$4(key)(map$18), combine$6(makeUpdate$1(key, valuePatch))(patch$12)];
			}
			case "None": return [map$18, combine$6(makeAdd$1(key, newValue))(patch$12)];
		}
	})(options.newValue);
	return reduce$7(patch$11, (patch$12, _$1, key) => combine$6(makeRemove$1(key))(patch$12))(removed);
};
/** @internal */
const combine$6 = /* @__PURE__ */ dual$1(2, (self, that) => makeAndThen$3(self, that));
/** @internal */
const patch$8 = /* @__PURE__ */ dual$1(3, (self, oldValue, differ$2) => {
	if (self._tag === "Empty") return oldValue;
	let map$18 = oldValue;
	let patches = of$3(self);
	while (isNonEmpty$4(patches)) {
		const head$4 = headNonEmpty(patches);
		const tail = tailNonEmpty(patches);
		switch (head$4._tag) {
			case "Empty":
				patches = tail;
				break;
			case "AndThen":
				patches = prepend$1(head$4.first)(prepend$1(head$4.second)(tail));
				break;
			case "Add":
				map$18 = set$3(head$4.key, head$4.value)(map$18);
				patches = tail;
				break;
			case "Remove":
				map$18 = remove$4(head$4.key)(map$18);
				patches = tail;
				break;
			case "Update": {
				const option$2 = get$5(head$4.key)(map$18);
				if (option$2._tag === "Some") map$18 = set$3(head$4.key, differ$2.patch(head$4.patch, option$2.value))(map$18);
				patches = tail;
				break;
			}
		}
	}
	return map$18;
});

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/differ/hashSetPatch.js
/** @internal */
const HashSetPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferHashSetPatch");
function variance$4(a$1) {
	return a$1;
}
/** @internal */
const PatchProto$2 = {
	...Structural$1.prototype,
	[HashSetPatchTypeId]: {
		_Value: variance$4,
		_Key: variance$4,
		_Patch: variance$4
	}
};
const EmptyProto$2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$2), { _tag: "Empty" });
const _empty$2 = /* @__PURE__ */ Object.create(EmptyProto$2);
/** @internal */
const empty$21 = () => _empty$2;
const AndThenProto$2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$2), { _tag: "AndThen" });
/** @internal */
const makeAndThen$2 = (first$2, second) => {
	const o$1 = Object.create(AndThenProto$2);
	o$1.first = first$2;
	o$1.second = second;
	return o$1;
};
const AddProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$2), { _tag: "Add" });
/** @internal */
const makeAdd = (value) => {
	const o$1 = Object.create(AddProto);
	o$1.value = value;
	return o$1;
};
const RemoveProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$2), { _tag: "Remove" });
/** @internal */
const makeRemove = (value) => {
	const o$1 = Object.create(RemoveProto);
	o$1.value = value;
	return o$1;
};
/** @internal */
const diff$6 = (oldValue, newValue) => {
	const [removed, patch$11] = reduce$8([oldValue, empty$21()], ([set$6, patch$12], value) => {
		if (has$4(value)(set$6)) return [remove$5(value)(set$6), patch$12];
		return [set$6, combine$5(makeAdd(value))(patch$12)];
	})(newValue);
	return reduce$8(patch$11, (patch$12, value) => combine$5(makeRemove(value))(patch$12))(removed);
};
/** @internal */
const combine$5 = /* @__PURE__ */ dual$1(2, (self, that) => makeAndThen$2(self, that));
/** @internal */
const patch$7 = /* @__PURE__ */ dual$1(2, (self, oldValue) => {
	if (self._tag === "Empty") return oldValue;
	let set$6 = oldValue;
	let patches = of$3(self);
	while (isNonEmpty$4(patches)) {
		const head$4 = headNonEmpty(patches);
		const tail = tailNonEmpty(patches);
		switch (head$4._tag) {
			case "Empty":
				patches = tail;
				break;
			case "AndThen":
				patches = prepend$1(head$4.first)(prepend$1(head$4.second)(tail));
				break;
			case "Add":
				set$6 = add$1(head$4.value)(set$6);
				patches = tail;
				break;
			case "Remove":
				set$6 = remove$5(head$4.value)(set$6);
				patches = tail;
		}
	}
	return set$6;
});

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/differ/orPatch.js
/** @internal */
const OrPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferOrPatch");
function variance$3(a$1) {
	return a$1;
}
/** @internal */
const PatchProto$1 = {
	...Structural$1.prototype,
	[OrPatchTypeId]: {
		_Value: variance$3,
		_Key: variance$3,
		_Patch: variance$3
	}
};
const EmptyProto$1 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$1), { _tag: "Empty" });
const _empty$1 = /* @__PURE__ */ Object.create(EmptyProto$1);
/** @internal */
const empty$20 = () => _empty$1;
const AndThenProto$1 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$1), { _tag: "AndThen" });
/** @internal */
const makeAndThen$1 = (first$2, second) => {
	const o$1 = Object.create(AndThenProto$1);
	o$1.first = first$2;
	o$1.second = second;
	return o$1;
};
const SetLeftProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$1), { _tag: "SetLeft" });
/** @internal */
const makeSetLeft = (value) => {
	const o$1 = Object.create(SetLeftProto);
	o$1.value = value;
	return o$1;
};
const SetRightProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$1), { _tag: "SetRight" });
/** @internal */
const makeSetRight = (value) => {
	const o$1 = Object.create(SetRightProto);
	o$1.value = value;
	return o$1;
};
const UpdateLeftProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$1), { _tag: "UpdateLeft" });
/** @internal */
const makeUpdateLeft = (patch$11) => {
	const o$1 = Object.create(UpdateLeftProto);
	o$1.patch = patch$11;
	return o$1;
};
const UpdateRightProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$1), { _tag: "UpdateRight" });
/** @internal */
const makeUpdateRight = (patch$11) => {
	const o$1 = Object.create(UpdateRightProto);
	o$1.patch = patch$11;
	return o$1;
};
/** @internal */
const diff$5 = (options) => {
	switch (options.oldValue._tag) {
		case "Left": switch (options.newValue._tag) {
			case "Left": {
				const valuePatch = options.left.diff(options.oldValue.left, options.newValue.left);
				if (equals(valuePatch, options.left.empty)) return empty$20();
				return makeUpdateLeft(valuePatch);
			}
			case "Right": return makeSetRight(options.newValue.right);
		}
		case "Right": switch (options.newValue._tag) {
			case "Left": return makeSetLeft(options.newValue.left);
			case "Right": {
				const valuePatch = options.right.diff(options.oldValue.right, options.newValue.right);
				if (equals(valuePatch, options.right.empty)) return empty$20();
				return makeUpdateRight(valuePatch);
			}
		}
	}
};
/** @internal */
const combine$4 = /* @__PURE__ */ dual$1(2, (self, that) => makeAndThen$1(self, that));
/** @internal */
const patch$6 = /* @__PURE__ */ dual$1(2, (self, { left: left$2, oldValue, right: right$2 }) => {
	if (self._tag === "Empty") return oldValue;
	let patches = of$3(self);
	let result = oldValue;
	while (isNonEmpty$4(patches)) {
		const head$4 = headNonEmpty(patches);
		const tail = tailNonEmpty(patches);
		switch (head$4._tag) {
			case "Empty":
				patches = tail;
				break;
			case "AndThen":
				patches = prepend$1(head$4.first)(prepend$1(head$4.second)(tail));
				break;
			case "UpdateLeft":
				if (result._tag === "Left") result = left(left$2.patch(head$4.patch, result.left));
				patches = tail;
				break;
			case "UpdateRight":
				if (result._tag === "Right") result = right(right$2.patch(head$4.patch, result.right));
				patches = tail;
				break;
			case "SetLeft":
				result = left(head$4.value);
				patches = tail;
				break;
			case "SetRight":
				result = right(head$4.value);
				patches = tail;
				break;
		}
	}
	return result;
});

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/differ/readonlyArrayPatch.js
/** @internal */
const ReadonlyArrayPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferReadonlyArrayPatch");
function variance$2(a$1) {
	return a$1;
}
const PatchProto = {
	...Structural$1.prototype,
	[ReadonlyArrayPatchTypeId]: {
		_Value: variance$2,
		_Patch: variance$2
	}
};
const EmptyProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), { _tag: "Empty" });
const _empty = /* @__PURE__ */ Object.create(EmptyProto);
/**
* @internal
*/
const empty$19 = () => _empty;
const AndThenProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), { _tag: "AndThen" });
const makeAndThen = (first$2, second) => {
	const o$1 = Object.create(AndThenProto);
	o$1.first = first$2;
	o$1.second = second;
	return o$1;
};
const AppendProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), { _tag: "Append" });
const makeAppend = (values$6) => {
	const o$1 = Object.create(AppendProto);
	o$1.values = values$6;
	return o$1;
};
const SliceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), { _tag: "Slice" });
const makeSlice = (from, until) => {
	const o$1 = Object.create(SliceProto);
	o$1.from = from;
	o$1.until = until;
	return o$1;
};
const UpdateProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), { _tag: "Update" });
const makeUpdate = (index, patch$11) => {
	const o$1 = Object.create(UpdateProto);
	o$1.index = index;
	o$1.patch = patch$11;
	return o$1;
};
/** @internal */
const diff$4 = (options) => {
	let i$1 = 0;
	let patch$11 = empty$19();
	while (i$1 < options.oldValue.length && i$1 < options.newValue.length) {
		const oldElement = options.oldValue[i$1];
		const newElement = options.newValue[i$1];
		const valuePatch = options.differ.diff(oldElement, newElement);
		if (!equals(valuePatch, options.differ.empty)) patch$11 = combine$3(patch$11, makeUpdate(i$1, valuePatch));
		i$1 = i$1 + 1;
	}
	if (i$1 < options.oldValue.length) patch$11 = combine$3(patch$11, makeSlice(0, i$1));
	if (i$1 < options.newValue.length) patch$11 = combine$3(patch$11, makeAppend(drop$1(i$1)(options.newValue)));
	return patch$11;
};
/** @internal */
const combine$3 = /* @__PURE__ */ dual$1(2, (self, that) => makeAndThen(self, that));
/** @internal */
const patch$5 = /* @__PURE__ */ dual$1(3, (self, oldValue, differ$2) => {
	if (self._tag === "Empty") return oldValue;
	let readonlyArray$2 = oldValue.slice();
	let patches = of$4(self);
	while (isNonEmptyArray(patches)) {
		const head$4 = headNonEmpty$1(patches);
		const tail = tailNonEmpty$1(patches);
		switch (head$4._tag) {
			case "Empty":
				patches = tail;
				break;
			case "AndThen":
				tail.unshift(head$4.first, head$4.second);
				patches = tail;
				break;
			case "Append":
				for (const value of head$4.values) readonlyArray$2.push(value);
				patches = tail;
				break;
			case "Slice":
				readonlyArray$2 = readonlyArray$2.slice(head$4.from, head$4.until);
				patches = tail;
				break;
			case "Update":
				readonlyArray$2[head$4.index] = differ$2.patch(head$4.patch, readonlyArray$2[head$4.index]);
				patches = tail;
				break;
		}
	}
	return readonlyArray$2;
});

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/differ.js
/** @internal */
const DifferTypeId = /* @__PURE__ */ Symbol.for("effect/Differ");
/** @internal */
const DifferProto = {
	[DifferTypeId]: {
		_P: identity$2,
		_V: identity$2
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const make$33 = (params$1) => {
	const differ$2 = Object.create(DifferProto);
	differ$2.empty = params$1.empty;
	differ$2.diff = params$1.diff;
	differ$2.combine = params$1.combine;
	differ$2.patch = params$1.patch;
	return differ$2;
};
/** @internal */
const environment$1 = () => make$33({
	empty: empty$23(),
	combine: (first$2, second) => combine$7(second)(first$2),
	diff: (oldValue, newValue) => diff$8(oldValue, newValue),
	patch: (patch$11, oldValue) => patch$9(oldValue)(patch$11)
});
/** @internal */
const chunk$1 = (differ$2) => make$33({
	empty: empty$24(),
	combine: (first$2, second) => combine$8(second)(first$2),
	diff: (oldValue, newValue) => diff$9({
		oldValue,
		newValue,
		differ: differ$2
	}),
	patch: (patch$11, oldValue) => patch$10(oldValue, differ$2)(patch$11)
});
/** @internal */
const hashMap$1 = (differ$2) => make$33({
	empty: empty$22(),
	combine: (first$2, second) => combine$6(second)(first$2),
	diff: (oldValue, newValue) => diff$7({
		oldValue,
		newValue,
		differ: differ$2
	}),
	patch: (patch$11, oldValue) => patch$8(oldValue, differ$2)(patch$11)
});
/** @internal */
const hashSet$1 = () => make$33({
	empty: empty$21(),
	combine: (first$2, second) => combine$5(second)(first$2),
	diff: (oldValue, newValue) => diff$6(oldValue, newValue),
	patch: (patch$11, oldValue) => patch$7(oldValue)(patch$11)
});
/** @internal */
const orElseEither$3 = /* @__PURE__ */ dual$1(2, (self, that) => make$33({
	empty: empty$20(),
	combine: (first$2, second) => combine$4(first$2, second),
	diff: (oldValue, newValue) => diff$5({
		oldValue,
		newValue,
		left: self,
		right: that
	}),
	patch: (patch$11, oldValue) => patch$6(patch$11, {
		oldValue,
		left: self,
		right: that
	})
}));
/** @internal */
const readonlyArray$1 = (differ$2) => make$33({
	empty: empty$19(),
	combine: (first$2, second) => combine$3(first$2, second),
	diff: (oldValue, newValue) => diff$4({
		oldValue,
		newValue,
		differ: differ$2
	}),
	patch: (patch$11, oldValue) => patch$5(patch$11, oldValue, differ$2)
});
/** @internal */
const transform$1 = /* @__PURE__ */ dual$1(2, (self, { toNew, toOld }) => make$33({
	empty: self.empty,
	combine: (first$2, second) => self.combine(first$2, second),
	diff: (oldValue, newValue) => self.diff(toOld(oldValue), toOld(newValue)),
	patch: (patch$11, oldValue) => toNew(self.patch(patch$11, toOld(oldValue)))
}));
/** @internal */
const update$4 = () => updateWith$1((_$1, a$1) => a$1);
/** @internal */
const updateWith$1 = (f$1) => make$33({
	empty: identity$2,
	combine: (first$2, second) => {
		if (first$2 === identity$2) return second;
		if (second === identity$2) return first$2;
		return (a$1) => second(first$2(a$1));
	},
	diff: (oldValue, newValue) => {
		if (equals(oldValue, newValue)) return identity$2;
		return constant(newValue);
	},
	patch: (patch$11, oldValue) => f$1(oldValue, patch$11(oldValue))
});
/** @internal */
const zip$5 = /* @__PURE__ */ dual$1(2, (self, that) => make$33({
	empty: [self.empty, that.empty],
	combine: (first$2, second) => [self.combine(first$2[0], second[0]), that.combine(first$2[1], second[1])],
	diff: (oldValue, newValue) => [self.diff(oldValue[0], newValue[0]), that.diff(oldValue[1], newValue[1])],
	patch: (patch$11, oldValue) => [self.patch(patch$11[0], oldValue[0]), that.patch(patch$11[1], oldValue[1])]
}));

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/runtimeFlagsPatch.js
/** @internal */
const BIT_MASK = 255;
/** @internal */
const BIT_SHIFT = 8;
/** @internal */
const active = (patch$11) => patch$11 & BIT_MASK;
/** @internal */
const enabled = (patch$11) => patch$11 >> BIT_SHIFT & BIT_MASK;
/** @internal */
const make$32 = (active$1, enabled$1) => (active$1 & BIT_MASK) + ((enabled$1 & active$1 & BIT_MASK) << BIT_SHIFT);
/** @internal */
const empty$18 = /* @__PURE__ */ make$32(0, 0);
/** @internal */
const enable$2 = (flag) => make$32(flag, flag);
/** @internal */
const disable$2 = (flag) => make$32(flag, 0);
/** @internal */
const isEmpty$6 = (patch$11) => patch$11 === 0;
/** @internal */
const isActive$1 = /* @__PURE__ */ dual$1(2, (self, flag) => (active(self) & flag) !== 0);
/** @internal */
const isEnabled$2 = /* @__PURE__ */ dual$1(2, (self, flag) => (enabled(self) & flag) !== 0);
/** @internal */
const isDisabled$1 = /* @__PURE__ */ dual$1(2, (self, flag) => (active(self) & flag) !== 0 && (enabled(self) & flag) === 0);
/** @internal */
const exclude$1 = /* @__PURE__ */ dual$1(2, (self, flag) => make$32(active(self) & ~flag, enabled(self)));
/** @internal */
const both$1 = /* @__PURE__ */ dual$1(2, (self, that) => make$32(active(self) | active(that), enabled(self) & enabled(that)));
/** @internal */
const either$3 = /* @__PURE__ */ dual$1(2, (self, that) => make$32(active(self) | active(that), enabled(self) | enabled(that)));
/** @internal */
const andThen$5 = /* @__PURE__ */ dual$1(2, (self, that) => self | that);
/** @internal */
const inverse$1 = (patch$11) => make$32(enabled(patch$11), invert(active(patch$11)));
/** @internal */
const invert = (n$1) => ~n$1 >>> 0 & BIT_MASK;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/runtimeFlags.js
/** @internal */
const None$1 = 0;
/** @internal */
const Interruption = 1;
/** @internal */
const OpSupervision = 2;
/** @internal */
const RuntimeMetrics = 4;
/** @internal */
const WindDown = 16;
/** @internal */
const CooperativeYielding = 32;
/** @internal */
const allFlags = [
	None$1,
	Interruption,
	OpSupervision,
	RuntimeMetrics,
	WindDown,
	CooperativeYielding
];
const print = (flag) => {
	switch (flag) {
		case CooperativeYielding: return "CooperativeYielding";
		case WindDown: return "WindDown";
		case RuntimeMetrics: return "RuntimeMetrics";
		case OpSupervision: return "OpSupervision";
		case Interruption: return "Interruption";
		case None$1: return "None";
	}
};
/** @internal */
const cooperativeYielding = (self) => isEnabled$1(self, CooperativeYielding);
/** @internal */
const disable$1 = /* @__PURE__ */ dual$1(2, (self, flag) => self & ~flag);
/** @internal */
const enable$1 = /* @__PURE__ */ dual$1(2, (self, flag) => self | flag);
/** @internal */
const interruptible$3 = (self) => interruption(self) && !windDown(self);
/** @internal */
const interruption = (self) => isEnabled$1(self, Interruption);
/** @internal */
const isEnabled$1 = /* @__PURE__ */ dual$1(2, (self, flag) => (self & flag) !== 0);
/** @internal */
const make$31 = (...flags) => flags.reduce((a$1, b$1) => a$1 | b$1, 0);
/** @internal */
const none$5 = /* @__PURE__ */ make$31(None$1);
/** @internal */
const runtimeMetrics = (self) => isEnabled$1(self, RuntimeMetrics);
/** @internal */
const toSet$1 = (self) => new Set(allFlags.filter((flag) => isEnabled$1(self, flag)));
const windDown = (self) => isEnabled$1(self, WindDown);
/** @internal */
const enabledSet$1 = (self) => toSet$1(active(self) & enabled(self));
/** @internal */
const disabledSet$1 = (self) => toSet$1(active(self) & ~enabled(self));
/** @internal */
const diff$3 = /* @__PURE__ */ dual$1(2, (self, that) => make$32(self ^ that, that));
/** @internal */
const patch$4 = /* @__PURE__ */ dual$1(2, (self, patch$11) => self & (invert(active(patch$11)) | enabled(patch$11)) | active(patch$11) & enabled(patch$11));
/** @internal */
const renderPatch = (self) => {
	return `RuntimeFlagsPatch(enabled = (${Array.from(enabledSet$1(self)).map((flag) => print(flag)).join(", ")}), disabled = (${Array.from(disabledSet$1(self)).map((flag) => print(flag)).join(", ")}))`;
};
/** @internal */
const differ$1 = /* @__PURE__ */ make$33({
	empty: empty$18,
	diff: (oldValue, newValue) => diff$3(oldValue, newValue),
	combine: (first$2, second) => andThen$5(second)(first$2),
	patch: (_patch, oldValue) => patch$4(oldValue, _patch)
});

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/RuntimeFlagsPatch.js
/**
* The empty `RuntimeFlagsPatch`.
*
* @since 2.0.0
* @category constructors
*/
const empty$17 = empty$18;
/**
* @since 2.0.0
* @category constructors
*/
const make$30 = make$32;
/**
* Creates a `RuntimeFlagsPatch` describing enabling the provided `RuntimeFlag`.
*
* @since 2.0.0
* @category constructors
*/
const enable = enable$2;
/**
* Creates a `RuntimeFlagsPatch` describing disabling the provided `RuntimeFlag`.
*
* @since 2.0.0
* @category constructors
*/
const disable = disable$2;
/**
* Returns `true` if the specified `RuntimeFlagsPatch` is empty.
*
* @since 2.0.0
* @category getters
*/
const isEmpty$5 = isEmpty$6;
/**
* Returns `true` if the `RuntimeFlagsPatch` describes the specified
* `RuntimeFlag` as active.
*
* @since 2.0.0
* @category elements
*/
const isActive = isActive$1;
/**
* Returns `true` if the `RuntimeFlagsPatch` describes the specified
* `RuntimeFlag` as enabled.
*
* @since 2.0.0
* @category elements
*/
const isEnabled = isEnabled$2;
/**
* Returns `true` if the `RuntimeFlagsPatch` describes the specified
* `RuntimeFlag` as disabled.
*
* @since 2.0.0
* @category elements
*/
const isDisabled = isDisabled$1;
/**
* Returns `true` if the `RuntimeFlagsPatch` includes the specified
* `RuntimeFlag`, `false` otherwise.
*
* @since 2.0.0
* @category elements
*/
const includes = isActive$1;
/**
* Creates a `RuntimeFlagsPatch` describing the application of the `self` patch,
* followed by `that` patch.
*
* @since 2.0.0
* @category utils
*/
const andThen$4 = andThen$5;
/**
* Creates a `RuntimeFlagsPatch` describing application of both the `self` patch
* and `that` patch.
*
* @since 2.0.0
* @category utils
*/
const both = both$1;
/**
* Creates a `RuntimeFlagsPatch` describing application of either the `self`
* patch or `that` patch.
*
* @since 2.0.0
* @category utils
*/
const either$2 = either$3;
/**
* Creates a `RuntimeFlagsPatch` which describes exclusion of the specified
* `RuntimeFlag` from the set of `RuntimeFlags`.
*
* @category utils
* @since 2.0.0
*/
const exclude = exclude$1;
/**
* Creates a `RuntimeFlagsPatch` which describes the inverse of the patch
* specified by the provided `RuntimeFlagsPatch`.
*
* @since 2.0.0
* @category utils
*/
const inverse = inverse$1;
/**
* Returns a `ReadonlySet<number>` containing the `RuntimeFlags` described as
* enabled by the specified `RuntimeFlagsPatch`.
*
* @since 2.0.0
* @category destructors
*/
const enabledSet = enabledSet$1;
/**
* Returns a `ReadonlySet<number>` containing the `RuntimeFlags` described as
* disabled by the specified `RuntimeFlagsPatch`.
*
* @since 2.0.0
* @category destructors
*/
const disabledSet = disabledSet$1;
/**
* Renders the provided `RuntimeFlagsPatch` to a string.
*
* @since 2.0.0
* @category destructors
*/
const render$2 = renderPatch;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/blockedRequests.js
/** @internal */
const empty$16 = { _tag: "Empty" };
/**
* Combines this collection of blocked requests with the specified collection
* of blocked requests, in parallel.
*
* @internal
*/
const par = (self, that) => ({
	_tag: "Par",
	left: self,
	right: that
});
/**
* Combines this collection of blocked requests with the specified collection
* of blocked requests, in sequence.
*
* @internal
*/
const seq = (self, that) => ({
	_tag: "Seq",
	left: self,
	right: that
});
/**
* Constructs a collection of blocked requests from the specified blocked
* request and data source.
*
* @internal
*/
const single = (dataSource, blockedRequest) => ({
	_tag: "Single",
	dataSource,
	blockedRequest
});
/**
* Flattens a collection of blocked requests into a collection of pipelined
* and batched requests that can be submitted for execution.
*
* @internal
*/
const flatten$5 = (self) => {
	let current = of$2(self);
	let updated = empty$25();
	while (1) {
		const [parallel$4, sequential$4] = reduce$6(current, [parallelCollectionEmpty(), empty$25()], ([parallel$5, sequential$5], blockedRequest) => {
			const [par$1, seq$1] = step$2(blockedRequest);
			return [parallelCollectionCombine(parallel$5, par$1), appendAll(sequential$5, seq$1)];
		});
		updated = merge$3(updated, parallel$4);
		if (isNil(sequential$4)) return reverse(updated);
		current = sequential$4;
	}
	throw new Error("BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues");
};
/**
* Takes one step in evaluating a collection of blocked requests, returning a
* collection of blocked requests that can be performed in parallel and a list
* of blocked requests that must be performed sequentially after those
* requests.
*/
const step$2 = (requests) => {
	let current = requests;
	let parallel$4 = parallelCollectionEmpty();
	let stack = empty$25();
	let sequential$4 = empty$25();
	while (1) switch (current._tag) {
		case "Empty":
			if (isNil(stack)) return [parallel$4, sequential$4];
			current = stack.head;
			stack = stack.tail;
			break;
		case "Par":
			stack = cons(current.right, stack);
			current = current.left;
			break;
		case "Seq": {
			const left$2 = current.left;
			const right$2 = current.right;
			switch (left$2._tag) {
				case "Empty":
					current = right$2;
					break;
				case "Par": {
					const l$1 = left$2.left;
					const r$1 = left$2.right;
					current = par(seq(l$1, right$2), seq(r$1, right$2));
					break;
				}
				case "Seq": {
					const l$1 = left$2.left;
					const r$1 = left$2.right;
					current = seq(l$1, seq(r$1, right$2));
					break;
				}
				case "Single":
					current = left$2;
					sequential$4 = cons(right$2, sequential$4);
					break;
			}
			break;
		}
		case "Single":
			parallel$4 = parallelCollectionAdd(parallel$4, current);
			if (isNil(stack)) return [parallel$4, sequential$4];
			current = stack.head;
			stack = stack.tail;
			break;
	}
	throw new Error("BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues");
};
/**
* Merges a collection of requests that must be executed sequentially with a
* collection of requests that can be executed in parallel. If the collections
* are both from the same single data source then the requests can be
* pipelined while preserving ordering guarantees.
*/
const merge$3 = (sequential$4, parallel$4) => {
	if (isNil(sequential$4)) return of$2(parallelCollectionToSequentialCollection(parallel$4));
	if (parallelCollectionIsEmpty(parallel$4)) return sequential$4;
	const seqHeadKeys = sequentialCollectionKeys(sequential$4.head);
	const parKeys = parallelCollectionKeys(parallel$4);
	if (seqHeadKeys.length === 1 && parKeys.length === 1 && equals(seqHeadKeys[0], parKeys[0])) return cons(sequentialCollectionCombine(sequential$4.head, parallelCollectionToSequentialCollection(parallel$4)), sequential$4.tail);
	return cons(parallelCollectionToSequentialCollection(parallel$4), sequential$4);
};
/** @internal */
const EntryTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/Entry");
/** @internal */
var EntryImpl = class {
	request;
	result;
	listeners;
	ownerId;
	state;
	[EntryTypeId] = blockedRequestVariance;
	constructor(request$1, result, listeners, ownerId, state) {
		this.request = request$1;
		this.result = result;
		this.listeners = listeners;
		this.ownerId = ownerId;
		this.state = state;
	}
};
const blockedRequestVariance = { _R: (_$1) => _$1 };
/** @internal */
const isEntry$1 = (u$1) => hasProperty(u$1, EntryTypeId);
/** @internal */
const makeEntry$1 = (options) => new EntryImpl(options.request, options.result, options.listeners, options.ownerId, options.state);
/** @internal */
const RequestBlockParallelTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockParallel");
const parallelVariance = { _R: (_$1) => _$1 };
var ParallelImpl = class {
	map;
	[RequestBlockParallelTypeId] = parallelVariance;
	constructor(map$18) {
		this.map = map$18;
	}
};
/** @internal */
const parallelCollectionEmpty = () => new ParallelImpl(empty$26());
/** @internal */
const parallelCollectionAdd = (self, blockedRequest) => new ParallelImpl(modifyAt(self.map, blockedRequest.dataSource, (_$1) => orElseSome(map$16(_$1, append$1(blockedRequest.blockedRequest)), () => of$3(blockedRequest.blockedRequest))));
/** @internal */
const parallelCollectionCombine = (self, that) => new ParallelImpl(reduce$7(self.map, that.map, (map$18, value, key) => set$3(map$18, key, match$11(get$5(map$18, key), {
	onNone: () => value,
	onSome: (other) => appendAll$1(value, other)
}))));
/** @internal */
const parallelCollectionIsEmpty = (self) => isEmpty$7(self.map);
/** @internal */
const parallelCollectionKeys = (self) => Array.from(keys$2(self.map));
/** @internal */
const parallelCollectionToSequentialCollection = (self) => sequentialCollectionMake(map$11(self.map, (x) => of$3(x)));
/** @internal */
const SequentialCollectionTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockSequential");
const sequentialVariance = { _R: (_$1) => _$1 };
var SequentialImpl = class {
	map;
	[SequentialCollectionTypeId] = sequentialVariance;
	constructor(map$18) {
		this.map = map$18;
	}
};
/** @internal */
const sequentialCollectionMake = (map$18) => new SequentialImpl(map$18);
/** @internal */
const sequentialCollectionCombine = (self, that) => new SequentialImpl(reduce$7(that.map, self.map, (map$18, value, key) => set$3(map$18, key, match$11(get$5(map$18, key), {
	onNone: () => empty$30(),
	onSome: (a$1) => appendAll$1(a$1, value)
}))));
/** @internal */
const sequentialCollectionKeys = (self) => Array.from(keys$2(self.map));
/** @internal */
const sequentialCollectionToChunk = (self) => Array.from(self.map);

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/opCodes/cause.js
/** @internal */
const OP_DIE = "Die";
/** @internal */
const OP_EMPTY$2 = "Empty";
/** @internal */
const OP_FAIL$1 = "Fail";
/** @internal */
const OP_INTERRUPT = "Interrupt";
/** @internal */
const OP_PARALLEL$1 = "Parallel";
/** @internal */
const OP_SEQUENTIAL$1 = "Sequential";

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/cause.js
/** @internal */
const CauseSymbolKey = "effect/Cause";
/** @internal */
const CauseTypeId$1 = /* @__PURE__ */ Symbol.for(CauseSymbolKey);
const variance$1 = { _E: (_$1) => _$1 };
/** @internal */
const proto$3 = {
	[CauseTypeId$1]: variance$1,
	[symbol$1]() {
		return pipe$3(hash(CauseSymbolKey), combine$11(hash(flattenCause(this))), cached$2(this));
	},
	[symbol](that) {
		return isCause$1(that) && causeEquals(this, that);
	},
	pipe() {
		return pipeArguments(this, arguments);
	},
	toJSON() {
		switch (this._tag) {
			case "Empty": return {
				_id: "Cause",
				_tag: this._tag
			};
			case "Die": return {
				_id: "Cause",
				_tag: this._tag,
				defect: toJSON(this.defect)
			};
			case "Interrupt": return {
				_id: "Cause",
				_tag: this._tag,
				fiberId: this.fiberId.toJSON()
			};
			case "Fail": return {
				_id: "Cause",
				_tag: this._tag,
				failure: toJSON(this.error)
			};
			case "Sequential":
			case "Parallel": return {
				_id: "Cause",
				_tag: this._tag,
				left: toJSON(this.left),
				right: toJSON(this.right)
			};
		}
	},
	toString() {
		return pretty$3(this);
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	}
};
/** @internal */
const empty$15 = /* @__PURE__ */ (() => {
	const o$1 = /* @__PURE__ */ Object.create(proto$3);
	o$1._tag = OP_EMPTY$2;
	return o$1;
})();
/** @internal */
const fail$10 = (error) => {
	const o$1 = Object.create(proto$3);
	o$1._tag = OP_FAIL$1;
	o$1.error = error;
	return o$1;
};
/** @internal */
const die$5 = (defect) => {
	const o$1 = Object.create(proto$3);
	o$1._tag = OP_DIE;
	o$1.defect = defect;
	return o$1;
};
/** @internal */
const interrupt$6 = (fiberId$2) => {
	const o$1 = Object.create(proto$3);
	o$1._tag = OP_INTERRUPT;
	o$1.fiberId = fiberId$2;
	return o$1;
};
/** @internal */
const parallel$3 = (left$2, right$2) => {
	const o$1 = Object.create(proto$3);
	o$1._tag = OP_PARALLEL$1;
	o$1.left = left$2;
	o$1.right = right$2;
	return o$1;
};
/** @internal */
const sequential$3 = (left$2, right$2) => {
	const o$1 = Object.create(proto$3);
	o$1._tag = OP_SEQUENTIAL$1;
	o$1.left = left$2;
	o$1.right = right$2;
	return o$1;
};
/** @internal */
const isCause$1 = (u$1) => hasProperty(u$1, CauseTypeId$1);
/** @internal */
const isEmptyType$1 = (self) => self._tag === OP_EMPTY$2;
/** @internal */
const isFailType$1 = (self) => self._tag === OP_FAIL$1;
/** @internal */
const isDieType$1 = (self) => self._tag === OP_DIE;
/** @internal */
const isInterruptType$1 = (self) => self._tag === OP_INTERRUPT;
/** @internal */
const isSequentialType$1 = (self) => self._tag === OP_SEQUENTIAL$1;
/** @internal */
const isParallelType$1 = (self) => self._tag === OP_PARALLEL$1;
/** @internal */
const size$6 = (self) => reduceWithContext$1(self, void 0, SizeCauseReducer);
/** @internal */
const isEmpty$4 = (self) => {
	if (self._tag === OP_EMPTY$2) return true;
	return reduce$5(self, true, (acc, cause$2) => {
		switch (cause$2._tag) {
			case OP_EMPTY$2: return some$4(acc);
			case OP_DIE:
			case OP_FAIL$1:
			case OP_INTERRUPT: return some$4(false);
			default: return none$7();
		}
	});
};
/** @internal */
const isFailure$4 = (self) => isSome(failureOption$1(self));
/** @internal */
const isDie$1 = (self) => isSome(dieOption$1(self));
/** @internal */
const isInterrupted$2 = (self) => isSome(interruptOption$1(self));
/** @internal */
const isInterruptedOnly$1 = (self) => reduceWithContext$1(void 0, IsInterruptedOnlyCauseReducer)(self);
/** @internal */
const failures$1 = (self) => reverse$1(reduce$5(self, empty$30(), (list, cause$2) => cause$2._tag === OP_FAIL$1 ? some$4(pipe$3(list, prepend$1(cause$2.error))) : none$7()));
/** @internal */
const defects$1 = (self) => reverse$1(reduce$5(self, empty$30(), (list, cause$2) => cause$2._tag === OP_DIE ? some$4(pipe$3(list, prepend$1(cause$2.defect))) : none$7()));
/** @internal */
const interruptors$1 = (self) => reduce$5(self, empty$27(), (set$6, cause$2) => cause$2._tag === OP_INTERRUPT ? some$4(pipe$3(set$6, add$1(cause$2.fiberId))) : none$7());
/** @internal */
const failureOption$1 = (self) => find$1(self, (cause$2) => cause$2._tag === OP_FAIL$1 ? some$4(cause$2.error) : none$7());
/** @internal */
const failureOrCause$1 = (self) => {
	const option$2 = failureOption$1(self);
	switch (option$2._tag) {
		case "None": return right(self);
		case "Some": return left(option$2.value);
	}
};
/** @internal */
const dieOption$1 = (self) => find$1(self, (cause$2) => cause$2._tag === OP_DIE ? some$4(cause$2.defect) : none$7());
/** @internal */
const flipCauseOption$1 = (self) => match$9(self, {
	onEmpty: some$4(empty$15),
	onFail: map$16(fail$10),
	onDie: (defect) => some$4(die$5(defect)),
	onInterrupt: (fiberId$2) => some$4(interrupt$6(fiberId$2)),
	onSequential: mergeWith(sequential$3),
	onParallel: mergeWith(parallel$3)
});
/** @internal */
const interruptOption$1 = (self) => find$1(self, (cause$2) => cause$2._tag === OP_INTERRUPT ? some$4(cause$2.fiberId) : none$7());
/** @internal */
const keepDefects$1 = (self) => match$9(self, {
	onEmpty: none$7(),
	onFail: () => none$7(),
	onDie: (defect) => some$4(die$5(defect)),
	onInterrupt: () => none$7(),
	onSequential: mergeWith(sequential$3),
	onParallel: mergeWith(parallel$3)
});
/** @internal */
const keepDefectsAndElectFailures = (self) => match$9(self, {
	onEmpty: none$7(),
	onFail: (failure) => some$4(die$5(failure)),
	onDie: (defect) => some$4(die$5(defect)),
	onInterrupt: () => none$7(),
	onSequential: mergeWith(sequential$3),
	onParallel: mergeWith(parallel$3)
});
/** @internal */
const linearize$1 = (self) => match$9(self, {
	onEmpty: empty$27(),
	onFail: (error) => make$38(fail$10(error)),
	onDie: (defect) => make$38(die$5(defect)),
	onInterrupt: (fiberId$2) => make$38(interrupt$6(fiberId$2)),
	onSequential: (leftSet, rightSet) => flatMap$8(leftSet, (leftCause) => map$12(rightSet, (rightCause) => sequential$3(leftCause, rightCause))),
	onParallel: (leftSet, rightSet) => flatMap$8(leftSet, (leftCause) => map$12(rightSet, (rightCause) => parallel$3(leftCause, rightCause)))
});
/** @internal */
const stripFailures$1 = (self) => match$9(self, {
	onEmpty: empty$15,
	onFail: () => empty$15,
	onDie: die$5,
	onInterrupt: interrupt$6,
	onSequential: sequential$3,
	onParallel: parallel$3
});
/** @internal */
const electFailures = (self) => match$9(self, {
	onEmpty: empty$15,
	onFail: die$5,
	onDie: die$5,
	onInterrupt: interrupt$6,
	onSequential: sequential$3,
	onParallel: parallel$3
});
/** @internal */
const stripSomeDefects$1 = /* @__PURE__ */ dual$1(2, (self, pf) => match$9(self, {
	onEmpty: some$4(empty$15),
	onFail: (error) => some$4(fail$10(error)),
	onDie: (defect) => {
		const option$2 = pf(defect);
		return isSome(option$2) ? none$7() : some$4(die$5(defect));
	},
	onInterrupt: (fiberId$2) => some$4(interrupt$6(fiberId$2)),
	onSequential: mergeWith(sequential$3),
	onParallel: mergeWith(parallel$3)
}));
/** @internal */
const as$5 = /* @__PURE__ */ dual$1(2, (self, error) => map$10(self, () => error));
/** @internal */
const map$10 = /* @__PURE__ */ dual$1(2, (self, f$1) => flatMap$6(self, (e) => fail$10(f$1(e))));
/** @internal */
const flatMap$6 = /* @__PURE__ */ dual$1(2, (self, f$1) => match$9(self, {
	onEmpty: empty$15,
	onFail: (error) => f$1(error),
	onDie: (defect) => die$5(defect),
	onInterrupt: (fiberId$2) => interrupt$6(fiberId$2),
	onSequential: (left$2, right$2) => sequential$3(left$2, right$2),
	onParallel: (left$2, right$2) => parallel$3(left$2, right$2)
}));
/** @internal */
const flatten$4 = (self) => flatMap$6(self, identity$2);
/** @internal */
const andThen$3 = /* @__PURE__ */ dual$1(2, (self, f$1) => isFunction(f$1) ? flatMap$6(self, f$1) : flatMap$6(self, () => f$1));
/** @internal */
const contains$1 = /* @__PURE__ */ dual$1(2, (self, that) => {
	if (that._tag === OP_EMPTY$2 || self === that) return true;
	return reduce$5(self, false, (accumulator, cause$2) => {
		return some$4(accumulator || causeEquals(cause$2, that));
	});
});
/** @internal */
const causeEquals = (left$2, right$2) => {
	let leftStack = of$3(left$2);
	let rightStack = of$3(right$2);
	while (isNonEmpty$4(leftStack) && isNonEmpty$4(rightStack)) {
		const [leftParallel, leftSequential] = pipe$3(headNonEmpty(leftStack), reduce$5([empty$27(), empty$30()], ([parallel$4, sequential$4], cause$2) => {
			const [par$1, seq$1] = evaluateCause(cause$2);
			return some$4([pipe$3(parallel$4, union$5(par$1)), pipe$3(sequential$4, appendAll$1(seq$1))]);
		}));
		const [rightParallel, rightSequential] = pipe$3(headNonEmpty(rightStack), reduce$5([empty$27(), empty$30()], ([parallel$4, sequential$4], cause$2) => {
			const [par$1, seq$1] = evaluateCause(cause$2);
			return some$4([pipe$3(parallel$4, union$5(par$1)), pipe$3(sequential$4, appendAll$1(seq$1))]);
		}));
		if (!equals(leftParallel, rightParallel)) return false;
		leftStack = leftSequential;
		rightStack = rightSequential;
	}
	return true;
};
/**
* Flattens a cause to a sequence of sets of causes, where each set represents
* causes that fail in parallel and sequential sets represent causes that fail
* after each other.
*
* @internal
*/
const flattenCause = (cause$2) => {
	return flattenCauseLoop(of$3(cause$2), empty$30());
};
/** @internal */
const flattenCauseLoop = (causes, flattened) => {
	while (1) {
		const [parallel$4, sequential$4] = pipe$3(causes, reduce$12([empty$27(), empty$30()], ([parallel$5, sequential$5], cause$2) => {
			const [par$1, seq$1] = evaluateCause(cause$2);
			return [pipe$3(parallel$5, union$5(par$1)), pipe$3(sequential$5, appendAll$1(seq$1))];
		}));
		const updated = size$8(parallel$4) > 0 ? pipe$3(flattened, prepend$1(parallel$4)) : flattened;
		if (isEmpty$9(sequential$4)) return reverse$1(updated);
		causes = sequential$4;
		flattened = updated;
	}
	throw new Error(getBugErrorMessage("Cause.flattenCauseLoop"));
};
/** @internal */
const find$1 = /* @__PURE__ */ dual$1(2, (self, pf) => {
	const stack = [self];
	while (stack.length > 0) {
		const item = stack.pop();
		const option$2 = pf(item);
		switch (option$2._tag) {
			case "None":
				switch (item._tag) {
					case OP_SEQUENTIAL$1:
					case OP_PARALLEL$1:
						stack.push(item.right);
						stack.push(item.left);
						break;
				}
				break;
			case "Some": return option$2;
		}
	}
	return none$7();
});
/** @internal */
const filter$3 = /* @__PURE__ */ dual$1(2, (self, predicate) => reduceWithContext$1(self, void 0, FilterCauseReducer(predicate)));
/**
* Takes one step in evaluating a cause, returning a set of causes that fail
* in parallel and a list of causes that fail sequentially after those causes.
*
* @internal
*/
const evaluateCause = (self) => {
	let cause$2 = self;
	const stack = [];
	let _parallel = empty$27();
	let _sequential = empty$30();
	while (cause$2 !== void 0) switch (cause$2._tag) {
		case OP_EMPTY$2:
			if (stack.length === 0) return [_parallel, _sequential];
			cause$2 = stack.pop();
			break;
		case OP_FAIL$1:
			_parallel = add$1(_parallel, make$43(cause$2._tag, cause$2.error));
			if (stack.length === 0) return [_parallel, _sequential];
			cause$2 = stack.pop();
			break;
		case OP_DIE:
			_parallel = add$1(_parallel, make$43(cause$2._tag, cause$2.defect));
			if (stack.length === 0) return [_parallel, _sequential];
			cause$2 = stack.pop();
			break;
		case OP_INTERRUPT:
			_parallel = add$1(_parallel, make$43(cause$2._tag, cause$2.fiberId));
			if (stack.length === 0) return [_parallel, _sequential];
			cause$2 = stack.pop();
			break;
		case OP_SEQUENTIAL$1:
			switch (cause$2.left._tag) {
				case OP_EMPTY$2:
					cause$2 = cause$2.right;
					break;
				case OP_SEQUENTIAL$1:
					cause$2 = sequential$3(cause$2.left.left, sequential$3(cause$2.left.right, cause$2.right));
					break;
				case OP_PARALLEL$1:
					cause$2 = parallel$3(sequential$3(cause$2.left.left, cause$2.right), sequential$3(cause$2.left.right, cause$2.right));
					break;
				default:
					_sequential = prepend$1(_sequential, cause$2.right);
					cause$2 = cause$2.left;
					break;
			}
			break;
		case OP_PARALLEL$1:
			stack.push(cause$2.right);
			cause$2 = cause$2.left;
			break;
	}
	throw new Error(getBugErrorMessage("Cause.evaluateCauseLoop"));
};
/** @internal */
const SizeCauseReducer = {
	emptyCase: () => 0,
	failCase: () => 1,
	dieCase: () => 1,
	interruptCase: () => 1,
	sequentialCase: (_$1, left$2, right$2) => left$2 + right$2,
	parallelCase: (_$1, left$2, right$2) => left$2 + right$2
};
/** @internal */
const IsInterruptedOnlyCauseReducer = {
	emptyCase: constTrue,
	failCase: constFalse,
	dieCase: constFalse,
	interruptCase: constTrue,
	sequentialCase: (_$1, left$2, right$2) => left$2 && right$2,
	parallelCase: (_$1, left$2, right$2) => left$2 && right$2
};
/** @internal */
const FilterCauseReducer = (predicate) => ({
	emptyCase: () => empty$15,
	failCase: (_$1, error) => fail$10(error),
	dieCase: (_$1, defect) => die$5(defect),
	interruptCase: (_$1, fiberId$2) => interrupt$6(fiberId$2),
	sequentialCase: (_$1, left$2, right$2) => {
		if (predicate(left$2)) {
			if (predicate(right$2)) return sequential$3(left$2, right$2);
			return left$2;
		}
		if (predicate(right$2)) return right$2;
		return empty$15;
	},
	parallelCase: (_$1, left$2, right$2) => {
		if (predicate(left$2)) {
			if (predicate(right$2)) return parallel$3(left$2, right$2);
			return left$2;
		}
		if (predicate(right$2)) return right$2;
		return empty$15;
	}
});
const OP_SEQUENTIAL_CASE = "SequentialCase";
const OP_PARALLEL_CASE = "ParallelCase";
/** @internal */
const match$9 = /* @__PURE__ */ dual$1(2, (self, { onDie, onEmpty, onFail, onInterrupt: onInterrupt$2, onParallel, onSequential }) => {
	return reduceWithContext$1(self, void 0, {
		emptyCase: () => onEmpty,
		failCase: (_$1, error) => onFail(error),
		dieCase: (_$1, defect) => onDie(defect),
		interruptCase: (_$1, fiberId$2) => onInterrupt$2(fiberId$2),
		sequentialCase: (_$1, left$2, right$2) => onSequential(left$2, right$2),
		parallelCase: (_$1, left$2, right$2) => onParallel(left$2, right$2)
	});
});
/** @internal */
const reduce$5 = /* @__PURE__ */ dual$1(3, (self, zero$1, pf) => {
	let accumulator = zero$1;
	let cause$2 = self;
	const causes = [];
	while (cause$2 !== void 0) {
		const option$2 = pf(accumulator, cause$2);
		accumulator = isSome(option$2) ? option$2.value : accumulator;
		switch (cause$2._tag) {
			case OP_SEQUENTIAL$1:
				causes.push(cause$2.right);
				cause$2 = cause$2.left;
				break;
			case OP_PARALLEL$1:
				causes.push(cause$2.right);
				cause$2 = cause$2.left;
				break;
			default:
				cause$2 = void 0;
				break;
		}
		if (cause$2 === void 0 && causes.length > 0) cause$2 = causes.pop();
	}
	return accumulator;
});
/** @internal */
const reduceWithContext$1 = /* @__PURE__ */ dual$1(3, (self, context$2, reducer) => {
	const input = [self];
	const output = [];
	while (input.length > 0) {
		const cause$2 = input.pop();
		switch (cause$2._tag) {
			case OP_EMPTY$2:
				output.push(right(reducer.emptyCase(context$2)));
				break;
			case OP_FAIL$1:
				output.push(right(reducer.failCase(context$2, cause$2.error)));
				break;
			case OP_DIE:
				output.push(right(reducer.dieCase(context$2, cause$2.defect)));
				break;
			case OP_INTERRUPT:
				output.push(right(reducer.interruptCase(context$2, cause$2.fiberId)));
				break;
			case OP_SEQUENTIAL$1:
				input.push(cause$2.right);
				input.push(cause$2.left);
				output.push(left({ _tag: OP_SEQUENTIAL_CASE }));
				break;
			case OP_PARALLEL$1:
				input.push(cause$2.right);
				input.push(cause$2.left);
				output.push(left({ _tag: OP_PARALLEL_CASE }));
				break;
		}
	}
	const accumulator = [];
	while (output.length > 0) {
		const either$4 = output.pop();
		switch (either$4._tag) {
			case "Left":
				switch (either$4.left._tag) {
					case OP_SEQUENTIAL_CASE: {
						const left$2 = accumulator.pop();
						const right$2 = accumulator.pop();
						const value = reducer.sequentialCase(context$2, left$2, right$2);
						accumulator.push(value);
						break;
					}
					case OP_PARALLEL_CASE: {
						const left$2 = accumulator.pop();
						const right$2 = accumulator.pop();
						const value = reducer.parallelCase(context$2, left$2, right$2);
						accumulator.push(value);
						break;
					}
				}
				break;
			case "Right":
				accumulator.push(either$4.right);
				break;
		}
	}
	if (accumulator.length === 0) throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
	return accumulator.pop();
});
/** @internal */
const pretty$3 = (cause$2, options) => {
	if (isInterruptedOnly$1(cause$2)) return "All fibers interrupted without errors.";
	return prettyErrors$1(cause$2).map(function(e) {
		if (options?.renderErrorCause !== true || e.cause === void 0) return e.stack;
		return `${e.stack} {\n${renderErrorCause(e.cause, "  ")}\n}`;
	}).join("\n");
};
const renderErrorCause = (cause$2, prefix) => {
	const lines = cause$2.stack.split("\n");
	let stack = `${prefix}[cause]: ${lines[0]}`;
	for (let i$1 = 1, len = lines.length; i$1 < len; i$1++) stack += `\n${prefix}${lines[i$1]}`;
	if (cause$2.cause) stack += ` {\n${renderErrorCause(cause$2.cause, `${prefix}  `)}\n${prefix}}`;
	return stack;
};
/** @internal */
var PrettyError = class PrettyError extends globalThis.Error {
	span = void 0;
	constructor(originalError$1) {
		const originalErrorIsObject = typeof originalError$1 === "object" && originalError$1 !== null;
		const prevLimit = Error.stackTraceLimit;
		Error.stackTraceLimit = 1;
		super(prettyErrorMessage(originalError$1), originalErrorIsObject && "cause" in originalError$1 && typeof originalError$1.cause !== "undefined" ? { cause: new PrettyError(originalError$1.cause) } : void 0);
		if (this.message === "") this.message = "An error has occurred";
		Error.stackTraceLimit = prevLimit;
		this.name = originalError$1 instanceof Error ? originalError$1.name : "Error";
		if (originalErrorIsObject) {
			if (spanSymbol in originalError$1) this.span = originalError$1[spanSymbol];
			Object.keys(originalError$1).forEach((key) => {
				if (!(key in this)) this[key] = originalError$1[key];
			});
		}
		this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError$1 instanceof Error && originalError$1.stack ? originalError$1.stack : "", this.span);
	}
};
/**
* A utility function for generating human-readable error messages from a generic error of type `unknown`.
*
* Rules:
*
* 1) If the input `u` is already a string, it's considered a message.
* 2) If `u` is an Error instance with a message defined, it uses the message.
* 3) If `u` has a user-defined `toString()` method, it uses that method.
* 4) Otherwise, it uses `Inspectable.stringifyCircular` to produce a string representation and uses it as the error message,
*   with "Error" added as a prefix.
*
* @internal
*/
const prettyErrorMessage = (u$1) => {
	if (typeof u$1 === "string") return u$1;
	if (typeof u$1 === "object" && u$1 !== null && u$1 instanceof Error) return u$1.message;
	try {
		if (hasProperty(u$1, "toString") && isFunction(u$1["toString"]) && u$1["toString"] !== Object.prototype.toString && u$1["toString"] !== globalThis.Array.prototype.toString) return u$1["toString"]();
	} catch {}
	return stringifyCircular(u$1);
};
const locationRegex = /\((.*)\)/g;
/** @internal */
const spanToTrace = /* @__PURE__ */ globalValue("effect/Tracer/spanToTrace", () => /* @__PURE__ */ new WeakMap());
const prettyErrorStack = (message, stack, span$1) => {
	const out = [message];
	const lines = stack.startsWith(message) ? stack.slice(message.length).split("\n") : stack.split("\n");
	for (let i$1 = 1; i$1 < lines.length; i$1++) {
		if (lines[i$1].includes(" at new BaseEffectError") || lines[i$1].includes(" at new YieldableError")) {
			i$1++;
			continue;
		}
		if (lines[i$1].includes("Generator.next")) break;
		if (lines[i$1].includes("effect_internal_function")) break;
		out.push(lines[i$1].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1").replace(/EffectPrimitive\.\w+/, "<anonymous>"));
	}
	if (span$1) {
		let current = span$1;
		let i$1 = 0;
		while (current && current._tag === "Span" && i$1 < 10) {
			const stackFn = spanToTrace.get(current);
			if (typeof stackFn === "function") {
				const stack$1 = stackFn();
				if (typeof stack$1 === "string") {
					const locationMatchAll = stack$1.matchAll(locationRegex);
					let match$13 = false;
					for (const [, location] of locationMatchAll) {
						match$13 = true;
						out.push(`    at ${current.name} (${location})`);
					}
					if (!match$13) out.push(`    at ${current.name} (${stack$1.replace(/^at /, "")})`);
				} else out.push(`    at ${current.name}`);
			} else out.push(`    at ${current.name}`);
			current = getOrUndefined(current.parent);
			i$1++;
		}
	}
	return out.join("\n");
};
/** @internal */
const spanSymbol = /* @__PURE__ */ Symbol.for("effect/SpanAnnotation");
/** @internal */
const prettyErrors$1 = (cause$2) => reduceWithContext$1(cause$2, void 0, {
	emptyCase: () => [],
	dieCase: (_$1, unknownError) => {
		return [new PrettyError(unknownError)];
	},
	failCase: (_$1, error) => {
		return [new PrettyError(error)];
	},
	interruptCase: () => [],
	parallelCase: (_$1, l$1, r$1) => [...l$1, ...r$1],
	sequentialCase: (_$1, l$1, r$1) => [...l$1, ...r$1]
});

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/opCodes/deferred.js
/** @internal */
const OP_STATE_PENDING = "Pending";
/** @internal */
const OP_STATE_DONE = "Done";

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/deferred.js
/** @internal */
const DeferredSymbolKey = "effect/Deferred";
/** @internal */
const DeferredTypeId$1 = /* @__PURE__ */ Symbol.for(DeferredSymbolKey);
/** @internal */
const deferredVariance = {
	_E: (_$1) => _$1,
	_A: (_$1) => _$1
};
/** @internal */
const pending$1 = (joiners) => {
	return {
		_tag: OP_STATE_PENDING,
		joiners
	};
};
/** @internal */
const done$7 = (effect) => {
	return {
		_tag: OP_STATE_DONE,
		effect
	};
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/singleShotGen.js
/** @internal */
var SingleShotGen$1 = class SingleShotGen$1 {
	self;
	called = false;
	constructor(self) {
		this.self = self;
	}
	next(a$1) {
		return this.called ? {
			value: a$1,
			done: true
		} : (this.called = true, {
			value: this.self,
			done: false
		});
	}
	return(a$1) {
		return {
			value: a$1,
			done: true
		};
	}
	throw(e) {
		throw e;
	}
	[Symbol.iterator]() {
		return new SingleShotGen$1(this.self);
	}
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/core.js
/**
* @internal
*/
const blocked$1 = (blockedRequests, _continue$2) => {
	const effect = new EffectPrimitive("Blocked");
	effect.effect_instruction_i0 = blockedRequests;
	effect.effect_instruction_i1 = _continue$2;
	return effect;
};
/**
* @internal
*/
const runRequestBlock$1 = (blockedRequests) => {
	const effect = new EffectPrimitive("RunBlocked");
	effect.effect_instruction_i0 = blockedRequests;
	return effect;
};
/** @internal */
const EffectTypeId$2 = /* @__PURE__ */ Symbol.for("effect/Effect");
/** @internal */
var RevertFlags = class {
	patch;
	op;
	_op = OP_REVERT_FLAGS;
	constructor(patch$11, op) {
		this.patch = patch$11;
		this.op = op;
	}
};
var EffectPrimitive = class {
	_op;
	effect_instruction_i0 = void 0;
	effect_instruction_i1 = void 0;
	effect_instruction_i2 = void 0;
	trace = void 0;
	[EffectTypeId$2] = effectVariance;
	constructor(_op) {
		this._op = _op;
	}
	[symbol](that) {
		return this === that;
	}
	[symbol$1]() {
		return cached$2(this, random$2(this));
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
	toJSON() {
		return {
			_id: "Effect",
			_op: this._op,
			effect_instruction_i0: toJSON(this.effect_instruction_i0),
			effect_instruction_i1: toJSON(this.effect_instruction_i1),
			effect_instruction_i2: toJSON(this.effect_instruction_i2)
		};
	}
	toString() {
		return format(this.toJSON());
	}
	[NodeInspectSymbol]() {
		return this.toJSON();
	}
	[Symbol.iterator]() {
		return new SingleShotGen$1(new YieldWrap(this));
	}
};
/** @internal */
var EffectPrimitiveFailure = class {
	_op;
	effect_instruction_i0 = void 0;
	effect_instruction_i1 = void 0;
	effect_instruction_i2 = void 0;
	trace = void 0;
	[EffectTypeId$2] = effectVariance;
	constructor(_op) {
		this._op = _op;
		this._tag = _op;
	}
	[symbol](that) {
		return exitIsExit(that) && that._op === "Failure" && equals(this.effect_instruction_i0, that.effect_instruction_i0);
	}
	[symbol$1]() {
		return pipe$3(string(this._tag), combine$11(hash(this.effect_instruction_i0)), cached$2(this));
	}
	get cause() {
		return this.effect_instruction_i0;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
	toJSON() {
		return {
			_id: "Exit",
			_tag: this._op,
			cause: this.cause.toJSON()
		};
	}
	toString() {
		return format(this.toJSON());
	}
	[NodeInspectSymbol]() {
		return this.toJSON();
	}
	[Symbol.iterator]() {
		return new SingleShotGen$1(new YieldWrap(this));
	}
};
/** @internal */
var EffectPrimitiveSuccess = class {
	_op;
	effect_instruction_i0 = void 0;
	effect_instruction_i1 = void 0;
	effect_instruction_i2 = void 0;
	trace = void 0;
	[EffectTypeId$2] = effectVariance;
	constructor(_op) {
		this._op = _op;
		this._tag = _op;
	}
	[symbol](that) {
		return exitIsExit(that) && that._op === "Success" && equals(this.effect_instruction_i0, that.effect_instruction_i0);
	}
	[symbol$1]() {
		return pipe$3(string(this._tag), combine$11(hash(this.effect_instruction_i0)), cached$2(this));
	}
	get value() {
		return this.effect_instruction_i0;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
	toJSON() {
		return {
			_id: "Exit",
			_tag: this._op,
			value: toJSON(this.value)
		};
	}
	toString() {
		return format(this.toJSON());
	}
	[NodeInspectSymbol]() {
		return this.toJSON();
	}
	[Symbol.iterator]() {
		return new SingleShotGen$1(new YieldWrap(this));
	}
};
/** @internal */
const isEffect$1 = (u$1) => hasProperty(u$1, EffectTypeId$2);
const withFiberRuntime$1 = (withRuntime) => {
	const effect = new EffectPrimitive(OP_WITH_RUNTIME);
	effect.effect_instruction_i0 = withRuntime;
	return effect;
};
const acquireUseRelease$1 = /* @__PURE__ */ dual$1(3, (acquire, use$1, release) => uninterruptibleMask$2((restore) => flatMap$5(acquire, (a$1) => flatMap$5(exit$2(suspend$3(() => restore(use$1(a$1)))), (exit$3) => {
	return suspend$3(() => release(a$1, exit$3)).pipe(matchCauseEffect$2({
		onFailure: (cause$2) => {
			switch (exit$3._tag) {
				case OP_FAILURE: return failCause$8(sequential$3(exit$3.effect_instruction_i0, cause$2));
				case OP_SUCCESS: return failCause$8(cause$2);
			}
		},
		onSuccess: () => exit$3
	}));
}))));
const as$4 = /* @__PURE__ */ dual$1(2, (self, value) => flatMap$5(self, () => succeed$9(value)));
const asVoid$3 = (self) => as$4(self, void 0);
const custom$1 = function() {
	const wrapper = new EffectPrimitive(OP_COMMIT);
	switch (arguments.length) {
		case 2:
			wrapper.effect_instruction_i0 = arguments[0];
			wrapper.commit = arguments[1];
			break;
		case 3:
			wrapper.effect_instruction_i0 = arguments[0];
			wrapper.effect_instruction_i1 = arguments[1];
			wrapper.commit = arguments[2];
			break;
		case 4:
			wrapper.effect_instruction_i0 = arguments[0];
			wrapper.effect_instruction_i1 = arguments[1];
			wrapper.effect_instruction_i2 = arguments[2];
			wrapper.commit = arguments[3];
			break;
		default: throw new Error(getBugErrorMessage("you're not supposed to end up here"));
	}
	return wrapper;
};
const unsafeAsync = (register, blockingOn = none$6) => {
	const effect = new EffectPrimitive(OP_ASYNC);
	let cancelerRef = void 0;
	effect.effect_instruction_i0 = (resume$1) => {
		cancelerRef = register(resume$1);
	};
	effect.effect_instruction_i1 = blockingOn;
	return onInterrupt$1(effect, (_$1) => isEffect$1(cancelerRef) ? cancelerRef : void_$4);
};
const asyncInterrupt = (register, blockingOn = none$6) => suspend$3(() => unsafeAsync(register, blockingOn));
const async_ = (resume$1, blockingOn = none$6) => {
	return custom$1(resume$1, function() {
		let backingResume = void 0;
		let pendingEffect = void 0;
		function proxyResume(effect$1) {
			if (backingResume) backingResume(effect$1);
			else if (pendingEffect === void 0) pendingEffect = effect$1;
		}
		const effect = new EffectPrimitive(OP_ASYNC);
		effect.effect_instruction_i0 = (resume$2) => {
			backingResume = resume$2;
			if (pendingEffect) resume$2(pendingEffect);
		};
		effect.effect_instruction_i1 = blockingOn;
		let cancelerRef = void 0;
		let controllerRef = void 0;
		if (this.effect_instruction_i0.length !== 1) {
			controllerRef = new AbortController();
			cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef.signal));
		} else cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume));
		return cancelerRef || controllerRef ? onInterrupt$1(effect, (_$1) => {
			if (controllerRef) controllerRef.abort();
			return cancelerRef ?? void_$4;
		}) : effect;
	});
};
const catchAllCause$1 = /* @__PURE__ */ dual$1(2, (self, f$1) => {
	const effect = new EffectPrimitive(OP_ON_FAILURE);
	effect.effect_instruction_i0 = self;
	effect.effect_instruction_i1 = f$1;
	return effect;
});
const catchAll$1 = /* @__PURE__ */ dual$1(2, (self, f$1) => matchEffect$2(self, {
	onFailure: f$1,
	onSuccess: succeed$9
}));
const catchIf$1 = /* @__PURE__ */ dual$1(3, (self, predicate, f$1) => catchAllCause$1(self, (cause$2) => {
	const either$4 = failureOrCause$1(cause$2);
	switch (either$4._tag) {
		case "Left": return predicate(either$4.left) ? f$1(either$4.left) : failCause$8(cause$2);
		case "Right": return failCause$8(either$4.right);
	}
}));
const catchSome$1 = /* @__PURE__ */ dual$1(2, (self, pf) => catchAllCause$1(self, (cause$2) => {
	const either$4 = failureOrCause$1(cause$2);
	switch (either$4._tag) {
		case "Left": return pipe$3(pf(either$4.left), getOrElse$5(() => failCause$8(cause$2)));
		case "Right": return failCause$8(either$4.right);
	}
}));
const checkInterruptible$1 = (f$1) => withFiberRuntime$1((_$1, status$2) => f$1(interruption(status$2.runtimeFlags)));
const originalSymbol = /* @__PURE__ */ Symbol.for("effect/OriginalAnnotation");
const originalInstance = (obj) => {
	if (hasProperty(obj, originalSymbol)) return obj[originalSymbol];
	return obj;
};
const capture = (obj, span$1) => {
	if (isSome(span$1)) return new Proxy(obj, {
		has(target, p) {
			return p === spanSymbol || p === originalSymbol || p in target;
		},
		get(target, p) {
			if (p === spanSymbol) return span$1.value;
			if (p === originalSymbol) return obj;
			return target[p];
		}
	});
	return obj;
};
const die$4 = (defect) => isObject(defect) && !(spanSymbol in defect) ? withFiberRuntime$1((fiber) => failCause$8(die$5(capture(defect, currentSpanFromFiber(fiber))))) : failCause$8(die$5(defect));
const dieMessage$1 = (message) => failCauseSync$2(() => die$5(new RuntimeException$1(message)));
const dieSync$2 = (evaluate$1) => flatMap$5(sync$3(evaluate$1), die$4);
const either$1 = (self) => matchEffect$2(self, {
	onFailure: (e) => succeed$9(left(e)),
	onSuccess: (a$1) => succeed$9(right(a$1))
});
const exit$2 = (self) => matchCause$2(self, {
	onFailure: exitFailCause$1,
	onSuccess: exitSucceed$1
});
const fail$9 = (error) => isObject(error) && !(spanSymbol in error) ? withFiberRuntime$1((fiber) => failCause$8(fail$10(capture(error, currentSpanFromFiber(fiber))))) : failCause$8(fail$10(error));
const failSync$2 = (evaluate$1) => flatMap$5(sync$3(evaluate$1), fail$9);
const failCause$8 = (cause$2) => {
	const effect = new EffectPrimitiveFailure(OP_FAILURE);
	effect.effect_instruction_i0 = cause$2;
	return effect;
};
const failCauseSync$2 = (evaluate$1) => flatMap$5(sync$3(evaluate$1), failCause$8);
const fiberId$1 = /* @__PURE__ */ withFiberRuntime$1((state) => succeed$9(state.id()));
const fiberIdWith$1 = (f$1) => withFiberRuntime$1((state) => f$1(state.id()));
const flatMap$5 = /* @__PURE__ */ dual$1(2, (self, f$1) => {
	const effect = new EffectPrimitive(OP_ON_SUCCESS);
	effect.effect_instruction_i0 = self;
	effect.effect_instruction_i1 = f$1;
	return effect;
});
const andThen$2 = /* @__PURE__ */ dual$1(2, (self, f$1) => flatMap$5(self, (a$1) => {
	const b$1 = typeof f$1 === "function" ? f$1(a$1) : f$1;
	if (isEffect$1(b$1)) return b$1;
	else if (isPromiseLike(b$1)) return unsafeAsync((resume$1) => {
		b$1.then((a$2) => resume$1(succeed$9(a$2)), (e) => resume$1(fail$9(new UnknownException$1(e, "An unknown error occurred in Effect.andThen"))));
	});
	return succeed$9(b$1);
}));
const step$1 = (self) => {
	const effect = new EffectPrimitive("OnStep");
	effect.effect_instruction_i0 = self;
	return effect;
};
const flatten$3 = (self) => flatMap$5(self, identity$2);
const flip$1 = (self) => matchEffect$2(self, {
	onFailure: succeed$9,
	onSuccess: fail$9
});
const matchCause$2 = /* @__PURE__ */ dual$1(2, (self, options) => matchCauseEffect$2(self, {
	onFailure: (cause$2) => succeed$9(options.onFailure(cause$2)),
	onSuccess: (a$1) => succeed$9(options.onSuccess(a$1))
}));
const matchCauseEffect$2 = /* @__PURE__ */ dual$1(2, (self, options) => {
	const effect = new EffectPrimitive(OP_ON_SUCCESS_AND_FAILURE);
	effect.effect_instruction_i0 = self;
	effect.effect_instruction_i1 = options.onFailure;
	effect.effect_instruction_i2 = options.onSuccess;
	return effect;
});
const matchEffect$2 = /* @__PURE__ */ dual$1(2, (self, options) => matchCauseEffect$2(self, {
	onFailure: (cause$2) => {
		if (defects$1(cause$2).length > 0) return failCause$8(electFailures(cause$2));
		const failures$2 = failures$1(cause$2);
		if (failures$2.length > 0) return options.onFailure(unsafeHead(failures$2));
		return failCause$8(cause$2);
	},
	onSuccess: options.onSuccess
}));
const forEachSequential = /* @__PURE__ */ dual$1(2, (self, f$1) => suspend$3(() => {
	const arr = fromIterable$10(self);
	const ret = allocate(arr.length);
	let i$1 = 0;
	return as$4(whileLoop$2({
		while: () => i$1 < arr.length,
		body: () => f$1(arr[i$1], i$1),
		step: (b$1) => {
			ret[i$1++] = b$1;
		}
	}), ret);
}));
const forEachSequentialDiscard = /* @__PURE__ */ dual$1(2, (self, f$1) => suspend$3(() => {
	const arr = fromIterable$10(self);
	let i$1 = 0;
	return whileLoop$2({
		while: () => i$1 < arr.length,
		body: () => f$1(arr[i$1], i$1),
		step: () => {
			i$1++;
		}
	});
}));
const if_$1 = /* @__PURE__ */ dual$1((args$2) => typeof args$2[0] === "boolean" || isEffect$1(args$2[0]), (self, options) => isEffect$1(self) ? flatMap$5(self, (b$1) => b$1 ? options.onTrue() : options.onFalse()) : self ? options.onTrue() : options.onFalse());
const interrupt$5 = /* @__PURE__ */ flatMap$5(fiberId$1, (fiberId$2) => interruptWith$2(fiberId$2));
const interruptWith$2 = (fiberId$2) => failCause$8(interrupt$6(fiberId$2));
const interruptible$2 = (self) => {
	const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
	effect.effect_instruction_i0 = enable(Interruption);
	effect.effect_instruction_i1 = () => self;
	return effect;
};
const interruptibleMask$1 = (f$1) => custom$1(f$1, function() {
	const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
	effect.effect_instruction_i0 = enable(Interruption);
	effect.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible$2)) : internalCall(() => this.effect_instruction_i0(uninterruptible$1));
	return effect;
});
const intoDeferred$1 = /* @__PURE__ */ dual$1(2, (self, deferred) => uninterruptibleMask$2((restore) => flatMap$5(exit$2(restore(self)), (exit$3) => deferredDone(deferred, exit$3))));
const map$9 = /* @__PURE__ */ dual$1(2, (self, f$1) => flatMap$5(self, (a$1) => sync$3(() => f$1(a$1))));
const mapBoth$2 = /* @__PURE__ */ dual$1(2, (self, options) => matchEffect$2(self, {
	onFailure: (e) => failSync$2(() => options.onFailure(e)),
	onSuccess: (a$1) => sync$3(() => options.onSuccess(a$1))
}));
const mapError$3 = /* @__PURE__ */ dual$1(2, (self, f$1) => matchCauseEffect$2(self, {
	onFailure: (cause$2) => {
		const either$4 = failureOrCause$1(cause$2);
		switch (either$4._tag) {
			case "Left": return failSync$2(() => f$1(either$4.left));
			case "Right": return failCause$8(either$4.right);
		}
	},
	onSuccess: succeed$9
}));
const onError$1 = /* @__PURE__ */ dual$1(2, (self, cleanup) => onExit$2(self, (exit$3) => exitIsSuccess(exit$3) ? void_$4 : cleanup(exit$3.effect_instruction_i0)));
const onExit$2 = /* @__PURE__ */ dual$1(2, (self, cleanup) => uninterruptibleMask$2((restore) => matchCauseEffect$2(restore(self), {
	onFailure: (cause1) => {
		const result = exitFailCause$1(cause1);
		return matchCauseEffect$2(cleanup(result), {
			onFailure: (cause2) => exitFailCause$1(sequential$3(cause1, cause2)),
			onSuccess: () => result
		});
	},
	onSuccess: (success) => {
		const result = exitSucceed$1(success);
		return zipRight$3(cleanup(result), result);
	}
})));
const onInterrupt$1 = /* @__PURE__ */ dual$1(2, (self, cleanup) => onExit$2(self, exitMatch({
	onFailure: (cause$2) => isInterruptedOnly$1(cause$2) ? asVoid$3(cleanup(interruptors$1(cause$2))) : void_$4,
	onSuccess: () => void_$4
})));
const orElse$4 = /* @__PURE__ */ dual$1(2, (self, that) => attemptOrElse(self, that, succeed$9));
const orDie$1 = (self) => orDieWith$1(self, identity$2);
const orDieWith$1 = /* @__PURE__ */ dual$1(2, (self, f$1) => matchEffect$2(self, {
	onFailure: (e) => die$4(f$1(e)),
	onSuccess: succeed$9
}));
const partitionMap = partitionMap$1;
const runtimeFlags = /* @__PURE__ */ withFiberRuntime$1((_$1, status$2) => succeed$9(status$2.runtimeFlags));
const succeed$9 = (value) => {
	const effect = new EffectPrimitiveSuccess(OP_SUCCESS);
	effect.effect_instruction_i0 = value;
	return effect;
};
const suspend$3 = (evaluate$1) => {
	const effect = new EffectPrimitive(OP_COMMIT);
	effect.commit = evaluate$1;
	return effect;
};
const sync$3 = (thunk) => {
	const effect = new EffectPrimitive(OP_SYNC);
	effect.effect_instruction_i0 = thunk;
	return effect;
};
const tap$1 = /* @__PURE__ */ dual$1((args$2) => args$2.length === 3 || args$2.length === 2 && !(isObject(args$2[1]) && "onlyEffect" in args$2[1]), (self, f$1) => flatMap$5(self, (a$1) => {
	const b$1 = typeof f$1 === "function" ? f$1(a$1) : f$1;
	if (isEffect$1(b$1)) return as$4(b$1, a$1);
	else if (isPromiseLike(b$1)) return unsafeAsync((resume$1) => {
		b$1.then((_$1) => resume$1(succeed$9(a$1)), (e) => resume$1(fail$9(new UnknownException$1(e, "An unknown error occurred in Effect.tap"))));
	});
	return succeed$9(a$1);
}));
const transplant$1 = (f$1) => withFiberRuntime$1((state) => {
	const scope$2 = pipe$3(state.getFiberRef(currentForkScopeOverride), getOrElse$5(() => state.scope()));
	return f$1(fiberRefLocally(currentForkScopeOverride, some$4(scope$2)));
});
const attemptOrElse = /* @__PURE__ */ dual$1(3, (self, that, onSuccess) => matchCauseEffect$2(self, {
	onFailure: (cause$2) => {
		if (defects$1(cause$2).length > 0) return failCause$8(getOrThrow(keepDefectsAndElectFailures(cause$2)));
		return that();
	},
	onSuccess
}));
const uninterruptible$1 = (self) => {
	const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
	effect.effect_instruction_i0 = disable(Interruption);
	effect.effect_instruction_i1 = () => self;
	return effect;
};
const uninterruptibleMask$2 = (f$1) => custom$1(f$1, function() {
	const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
	effect.effect_instruction_i0 = disable(Interruption);
	effect.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible$2)) : internalCall(() => this.effect_instruction_i0(uninterruptible$1));
	return effect;
});
const void_$4 = /* @__PURE__ */ succeed$9(void 0);
const updateRuntimeFlags = (patch$11) => {
	const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
	effect.effect_instruction_i0 = patch$11;
	effect.effect_instruction_i1 = void 0;
	return effect;
};
const whenEffect$1 = /* @__PURE__ */ dual$1(2, (self, condition) => flatMap$5(condition, (b$1) => {
	if (b$1) return pipe$3(self, map$9(some$4));
	return succeed$9(none$7());
}));
const whileLoop$2 = (options) => {
	const effect = new EffectPrimitive(OP_WHILE);
	effect.effect_instruction_i0 = options.while;
	effect.effect_instruction_i1 = options.body;
	effect.effect_instruction_i2 = options.step;
	return effect;
};
const fromIterator = (iterator) => suspend$3(() => {
	const effect = new EffectPrimitive(OP_ITERATOR);
	effect.effect_instruction_i0 = iterator();
	return effect;
});
const gen$1 = function() {
	const f$1 = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0]);
	return fromIterator(() => f$1(pipe$3));
};
/** @internal */
const fnUntraced$1 = (body, ...pipeables) => Object.defineProperty(pipeables.length === 0 ? function(...args$2) {
	return fromIterator(() => body.apply(this, args$2));
} : function(...args$2) {
	let effect = fromIterator(() => body.apply(this, args$2));
	for (const x of pipeables) effect = x(effect, ...args$2);
	return effect;
}, "length", {
	value: body.length,
	configurable: true
});
const withConcurrency$1 = /* @__PURE__ */ dual$1(2, (self, concurrency) => fiberRefLocally(self, currentConcurrency, concurrency));
const withRequestBatching$1 = /* @__PURE__ */ dual$1(2, (self, requestBatching) => fiberRefLocally(self, currentRequestBatching, requestBatching));
const withRuntimeFlags = /* @__PURE__ */ dual$1(2, (self, update$5) => {
	const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
	effect.effect_instruction_i0 = update$5;
	effect.effect_instruction_i1 = () => self;
	return effect;
});
/** @internal */
const withTracerEnabled$1 = /* @__PURE__ */ dual$1(2, (effect, enabled$1) => fiberRefLocally(effect, currentTracerEnabled, enabled$1));
/** @internal */
const withTracerTiming$1 = /* @__PURE__ */ dual$1(2, (effect, enabled$1) => fiberRefLocally(effect, currentTracerTimingEnabled, enabled$1));
const yieldNow$3 = (options) => {
	const effect = new EffectPrimitive(OP_YIELD);
	return typeof options?.priority !== "undefined" ? withSchedulingPriority$1(effect, options.priority) : effect;
};
const zip$4 = /* @__PURE__ */ dual$1(2, (self, that) => flatMap$5(self, (a$1) => map$9(that, (b$1) => [a$1, b$1])));
const zipLeft$3 = /* @__PURE__ */ dual$1(2, (self, that) => flatMap$5(self, (a$1) => as$4(that, a$1)));
const zipRight$3 = /* @__PURE__ */ dual$1(2, (self, that) => flatMap$5(self, () => that));
const zipWith$4 = /* @__PURE__ */ dual$1(3, (self, that, f$1) => flatMap$5(self, (a$1) => map$9(that, (b$1) => f$1(a$1, b$1))));
const never$3 = /* @__PURE__ */ asyncInterrupt(() => {
	const interval = setInterval(() => {}, 2 ** 31 - 1);
	return sync$3(() => clearInterval(interval));
});
const interruptFiber = (self) => flatMap$5(fiberId$1, (fiberId$2) => pipe$3(self, interruptAsFiber(fiberId$2)));
const interruptAsFiber = /* @__PURE__ */ dual$1(2, (self, fiberId$2) => flatMap$5(self.interruptAsFork(fiberId$2), () => self.await));
/** @internal */
const logLevelAll = {
	_tag: "All",
	syslog: 0,
	label: "ALL",
	ordinal: Number.MIN_SAFE_INTEGER,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const logLevelFatal = {
	_tag: "Fatal",
	syslog: 2,
	label: "FATAL",
	ordinal: 5e4,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const logLevelError = {
	_tag: "Error",
	syslog: 3,
	label: "ERROR",
	ordinal: 4e4,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const logLevelWarning = {
	_tag: "Warning",
	syslog: 4,
	label: "WARN",
	ordinal: 3e4,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const logLevelInfo = {
	_tag: "Info",
	syslog: 6,
	label: "INFO",
	ordinal: 2e4,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const logLevelDebug = {
	_tag: "Debug",
	syslog: 7,
	label: "DEBUG",
	ordinal: 1e4,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const logLevelTrace = {
	_tag: "Trace",
	syslog: 7,
	label: "TRACE",
	ordinal: 0,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const logLevelNone = {
	_tag: "None",
	syslog: 7,
	label: "OFF",
	ordinal: Number.MAX_SAFE_INTEGER,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const allLogLevels = [
	logLevelAll,
	logLevelTrace,
	logLevelDebug,
	logLevelInfo,
	logLevelWarning,
	logLevelError,
	logLevelFatal,
	logLevelNone
];
/** @internal */
const FiberRefSymbolKey = "effect/FiberRef";
/** @internal */
const FiberRefTypeId = /* @__PURE__ */ Symbol.for(FiberRefSymbolKey);
const fiberRefVariance = { _A: (_$1) => _$1 };
const fiberRefGet = (self) => withFiberRuntime$1((fiber) => exitSucceed$1(fiber.getFiberRef(self)));
const fiberRefGetWith = /* @__PURE__ */ dual$1(2, (self, f$1) => flatMap$5(fiberRefGet(self), f$1));
const fiberRefSet = /* @__PURE__ */ dual$1(2, (self, value) => fiberRefModify(self, () => [void 0, value]));
const fiberRefModify = /* @__PURE__ */ dual$1(2, (self, f$1) => withFiberRuntime$1((state) => {
	const [b$1, a$1] = f$1(state.getFiberRef(self));
	state.setFiberRef(self, a$1);
	return succeed$9(b$1);
}));
/** @internal */
const RequestResolverSymbolKey = "effect/RequestResolver";
/** @internal */
const RequestResolverTypeId = /* @__PURE__ */ Symbol.for(RequestResolverSymbolKey);
const requestResolverVariance = {
	_A: (_$1) => _$1,
	_R: (_$1) => _$1
};
/** @internal */
var RequestResolverImpl = class RequestResolverImpl {
	runAll;
	target;
	[RequestResolverTypeId] = requestResolverVariance;
	constructor(runAll, target) {
		this.runAll = runAll;
		this.target = target;
	}
	[symbol$1]() {
		return cached$2(this, this.target ? hash(this.target) : random$2(this));
	}
	[symbol](that) {
		return this.target ? isRequestResolver(that) && equals(this.target, that.target) : this === that;
	}
	identified(...ids$2) {
		return new RequestResolverImpl(this.runAll, fromIterable$9(ids$2));
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const isRequestResolver = (u$1) => hasProperty(u$1, RequestResolverTypeId);
const fiberRefLocally = /* @__PURE__ */ dual$1(3, (use$1, self, value) => acquireUseRelease$1(zipLeft$3(fiberRefGet(self), fiberRefSet(self, value)), () => use$1, (oldValue) => fiberRefSet(self, oldValue)));
const fiberRefLocallyWith = /* @__PURE__ */ dual$1(3, (use$1, self, f$1) => fiberRefGetWith(self, (a$1) => fiberRefLocally(use$1, self, f$1(a$1))));
/** @internal */
const fiberRefUnsafeMake = (initial, options) => fiberRefUnsafeMakePatch(initial, {
	differ: update$4(),
	fork: options?.fork ?? identity$2,
	join: options?.join
});
/** @internal */
const fiberRefUnsafeMakeHashSet = (initial) => {
	const differ$2 = hashSet$1();
	return fiberRefUnsafeMakePatch(initial, {
		differ: differ$2,
		fork: differ$2.empty
	});
};
/** @internal */
const fiberRefUnsafeMakeReadonlyArray = (initial) => {
	const differ$2 = readonlyArray$1(update$4());
	return fiberRefUnsafeMakePatch(initial, {
		differ: differ$2,
		fork: differ$2.empty
	});
};
/** @internal */
const fiberRefUnsafeMakeContext = (initial) => {
	const differ$2 = environment$1();
	return fiberRefUnsafeMakePatch(initial, {
		differ: differ$2,
		fork: differ$2.empty
	});
};
/** @internal */
const fiberRefUnsafeMakePatch = (initial, options) => {
	return {
		...CommitPrototype$1,
		[FiberRefTypeId]: fiberRefVariance,
		initial,
		commit() {
			return fiberRefGet(this);
		},
		diff: (oldValue, newValue) => options.differ.diff(oldValue, newValue),
		combine: (first$2, second) => options.differ.combine(first$2, second),
		patch: (patch$11) => (oldValue) => options.differ.patch(patch$11, oldValue),
		fork: options.fork,
		join: options.join ?? ((_$1, n$1) => n$1)
	};
};
/** @internal */
const fiberRefUnsafeMakeRuntimeFlags = (initial) => fiberRefUnsafeMakePatch(initial, {
	differ: differ$1,
	fork: differ$1.empty
});
/** @internal */
const currentContext = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentContext"), () => fiberRefUnsafeMakeContext(empty$31()));
/** @internal */
const currentSchedulingPriority = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentSchedulingPriority"), () => fiberRefUnsafeMake(0));
/** @internal */
const currentMaxOpsBeforeYield = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"), () => fiberRefUnsafeMake(2048));
/** @internal */
const currentLogAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogAnnotation"), () => fiberRefUnsafeMake(empty$26()));
/** @internal */
const currentLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogLevel"), () => fiberRefUnsafeMake(logLevelInfo));
/** @internal */
const currentLogSpan = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogSpan"), () => fiberRefUnsafeMake(empty$25()));
/** @internal */
const withSchedulingPriority$1 = /* @__PURE__ */ dual$1(2, (self, scheduler) => fiberRefLocally(self, currentSchedulingPriority, scheduler));
/** @internal */
const withMaxOpsBeforeYield$1 = /* @__PURE__ */ dual$1(2, (self, scheduler) => fiberRefLocally(self, currentMaxOpsBeforeYield, scheduler));
/** @internal */
const currentConcurrency = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentConcurrency"), () => fiberRefUnsafeMake("unbounded"));
/**
* @internal
*/
const currentRequestBatching = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestBatching"), () => fiberRefUnsafeMake(true));
/** @internal */
const currentUnhandledErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"), () => fiberRefUnsafeMake(some$4(logLevelDebug)));
/** @internal */
const currentVersionMismatchErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/versionMismatchErrorLogLevel"), () => fiberRefUnsafeMake(some$4(logLevelWarning)));
/** @internal */
const withUnhandledErrorLogLevel$1 = /* @__PURE__ */ dual$1(2, (self, level) => fiberRefLocally(self, currentUnhandledErrorLogLevel, level));
/** @internal */
const currentMetricLabels = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMetricLabels"), () => fiberRefUnsafeMakeReadonlyArray(empty$33()));
const metricLabels$1 = /* @__PURE__ */ fiberRefGet(currentMetricLabels);
/** @internal */
const currentForkScopeOverride = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentForkScopeOverride"), () => fiberRefUnsafeMake(none$7(), {
	fork: () => none$7(),
	join: (parent, _$1) => parent
}));
/** @internal */
const currentInterruptedCause = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentInterruptedCause"), () => fiberRefUnsafeMake(empty$15, {
	fork: () => empty$15,
	join: (parent, _$1) => parent
}));
/** @internal */
const currentTracerEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerEnabled"), () => fiberRefUnsafeMake(true));
/** @internal */
const currentTracerTimingEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerTiming"), () => fiberRefUnsafeMake(true));
/** @internal */
const currentTracerSpanAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanAnnotations"), () => fiberRefUnsafeMake(empty$26()));
/** @internal */
const currentTracerSpanLinks = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanLinks"), () => fiberRefUnsafeMake(empty$30()));
/** @internal */
const ScopeTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Scope");
/** @internal */
const CloseableScopeTypeId$1 = /* @__PURE__ */ Symbol.for("effect/CloseableScope");
const scopeAddFinalizer = (self, finalizer) => self.addFinalizer(() => asVoid$3(finalizer));
const scopeAddFinalizerExit = (self, finalizer) => self.addFinalizer(finalizer);
const scopeClose = (self, exit$3) => self.close(exit$3);
const scopeFork = (self, strategy) => self.fork(strategy);
/** @internal */
const causeSquash = (self) => {
	return causeSquashWith(identity$2)(self);
};
/** @internal */
const causeSquashWith = /* @__PURE__ */ dual$1(2, (self, f$1) => {
	const option$2 = pipe$3(self, failureOption$1, map$16(f$1));
	switch (option$2._tag) {
		case "None": return pipe$3(defects$1(self), head$2, match$11({
			onNone: () => {
				const interrupts = fromIterable$10(interruptors$1(self)).flatMap((fiberId$2) => fromIterable$10(ids(fiberId$2)).map((id$2) => `#${id$2}`));
				return new InterruptedException$1(interrupts ? `Interrupted by fibers: ${interrupts.join(", ")}` : void 0);
			},
			onSome: identity$2
		}));
		case "Some": return option$2.value;
	}
});
/** @internal */
const YieldableError$1 = /* @__PURE__ */ function() {
	class YieldableError$2 extends globalThis.Error {
		commit() {
			return fail$9(this);
		}
		toJSON() {
			const obj = { ...this };
			if (this.message) obj.message = this.message;
			if (this.cause) obj.cause = this.cause;
			return obj;
		}
		[NodeInspectSymbol]() {
			if (this.toString !== globalThis.Error.prototype.toString) return this.stack ? `${this.toString()}\n${this.stack.split("\n").slice(1).join("\n")}` : this.toString();
			else if ("Bun" in globalThis) return pretty$3(fail$10(this), { renderErrorCause: true });
			return this;
		}
	}
	Object.assign(YieldableError$2.prototype, StructuralCommitPrototype$1);
	return YieldableError$2;
}();
const makeException = (proto$4, tag$1) => {
	class Base$2 extends YieldableError$1 {
		_tag = tag$1;
	}
	Object.assign(Base$2.prototype, proto$4);
	Base$2.prototype.name = tag$1;
	return Base$2;
};
/** @internal */
const RuntimeExceptionTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Cause/errors/RuntimeException");
/** @internal */
const RuntimeException$1 = /* @__PURE__ */ makeException({ [RuntimeExceptionTypeId$1]: RuntimeExceptionTypeId$1 }, "RuntimeException");
/** @internal */
const isRuntimeException$1 = (u$1) => hasProperty(u$1, RuntimeExceptionTypeId$1);
/** @internal */
const InterruptedExceptionTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InterruptedException");
/** @internal */
const InterruptedException$1 = /* @__PURE__ */ makeException({ [InterruptedExceptionTypeId$1]: InterruptedExceptionTypeId$1 }, "InterruptedException");
/** @internal */
const isInterruptedException$1 = (u$1) => hasProperty(u$1, InterruptedExceptionTypeId$1);
/** @internal */
const IllegalArgumentExceptionTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Cause/errors/IllegalArgument");
/** @internal */
const IllegalArgumentException$1 = /* @__PURE__ */ makeException({ [IllegalArgumentExceptionTypeId$1]: IllegalArgumentExceptionTypeId$1 }, "IllegalArgumentException");
/** @internal */
const isIllegalArgumentException$1 = (u$1) => hasProperty(u$1, IllegalArgumentExceptionTypeId$1);
/** @internal */
const NoSuchElementExceptionTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Cause/errors/NoSuchElement");
/** @internal */
const NoSuchElementException$1 = /* @__PURE__ */ makeException({ [NoSuchElementExceptionTypeId$1]: NoSuchElementExceptionTypeId$1 }, "NoSuchElementException");
/** @internal */
const isNoSuchElementException$1 = (u$1) => hasProperty(u$1, NoSuchElementExceptionTypeId$1);
/** @internal */
const InvalidPubSubCapacityExceptionTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InvalidPubSubCapacityException");
/** @internal */
const InvalidPubSubCapacityException = /* @__PURE__ */ makeException({ [InvalidPubSubCapacityExceptionTypeId$1]: InvalidPubSubCapacityExceptionTypeId$1 }, "InvalidPubSubCapacityException");
/** @internal */
const ExceededCapacityExceptionTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Cause/errors/ExceededCapacityException");
/** @internal */
const ExceededCapacityException$1 = /* @__PURE__ */ makeException({ [ExceededCapacityExceptionTypeId$1]: ExceededCapacityExceptionTypeId$1 }, "ExceededCapacityException");
/** @internal */
const isExceededCapacityException$1 = (u$1) => hasProperty(u$1, ExceededCapacityExceptionTypeId$1);
/** @internal */
const TimeoutExceptionTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Cause/errors/Timeout");
/** @internal */
const TimeoutException$1 = /* @__PURE__ */ makeException({ [TimeoutExceptionTypeId$1]: TimeoutExceptionTypeId$1 }, "TimeoutException");
/** @internal */
const timeoutExceptionFromDuration = (duration) => new TimeoutException$1(`Operation timed out after '${format$2(duration)}'`);
/** @internal */
const isTimeoutException$1 = (u$1) => hasProperty(u$1, TimeoutExceptionTypeId$1);
/** @internal */
const UnknownExceptionTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Cause/errors/UnknownException");
/** @internal */
const UnknownException$1 = /* @__PURE__ */ function() {
	class UnknownException$2 extends YieldableError$1 {
		_tag = "UnknownException";
		error;
		constructor(cause$2, message) {
			super(message ?? "An unknown error occurred", { cause: cause$2 });
			this.error = cause$2;
		}
	}
	Object.assign(UnknownException$2.prototype, {
		[UnknownExceptionTypeId$1]: UnknownExceptionTypeId$1,
		name: "UnknownException"
	});
	return UnknownException$2;
}();
/** @internal */
const isUnknownException$1 = (u$1) => hasProperty(u$1, UnknownExceptionTypeId$1);
/** @internal */
const exitIsExit = (u$1) => isEffect$1(u$1) && "_tag" in u$1 && (u$1._tag === "Success" || u$1._tag === "Failure");
/** @internal */
const exitIsFailure = (self) => self._tag === "Failure";
/** @internal */
const exitIsSuccess = (self) => self._tag === "Success";
/** @internal */
const exitIsInterrupted = (self) => {
	switch (self._tag) {
		case OP_FAILURE: return isInterrupted$2(self.effect_instruction_i0);
		case OP_SUCCESS: return false;
	}
};
/** @internal */
const exitAs = /* @__PURE__ */ dual$1(2, (self, value) => {
	switch (self._tag) {
		case OP_FAILURE: return exitFailCause$1(self.effect_instruction_i0);
		case OP_SUCCESS: return exitSucceed$1(value);
	}
});
/** @internal */
const exitAsVoid = (self) => exitAs(self, void 0);
/** @internal */
const exitCauseOption = (self) => {
	switch (self._tag) {
		case OP_FAILURE: return some$4(self.effect_instruction_i0);
		case OP_SUCCESS: return none$7();
	}
};
/** @internal */
const exitCollectAll = (exits, options) => exitCollectAllInternal(exits, options?.parallel ? parallel$3 : sequential$3);
/** @internal */
const exitDie$1 = (defect) => exitFailCause$1(die$5(defect));
/** @internal */
const exitExists = /* @__PURE__ */ dual$1(2, (self, refinement) => {
	switch (self._tag) {
		case OP_FAILURE: return false;
		case OP_SUCCESS: return refinement(self.effect_instruction_i0);
	}
});
/** @internal */
const exitFail = (error) => exitFailCause$1(fail$10(error));
/** @internal */
const exitFailCause$1 = (cause$2) => {
	const effect = new EffectPrimitiveFailure(OP_FAILURE);
	effect.effect_instruction_i0 = cause$2;
	return effect;
};
/** @internal */
const exitFlatMap = /* @__PURE__ */ dual$1(2, (self, f$1) => {
	switch (self._tag) {
		case OP_FAILURE: return exitFailCause$1(self.effect_instruction_i0);
		case OP_SUCCESS: return f$1(self.effect_instruction_i0);
	}
});
/** @internal */
const exitFlatMapEffect = /* @__PURE__ */ dual$1(2, (self, f$1) => {
	switch (self._tag) {
		case OP_FAILURE: return succeed$9(exitFailCause$1(self.effect_instruction_i0));
		case OP_SUCCESS: return f$1(self.effect_instruction_i0);
	}
});
/** @internal */
const exitFlatten = (self) => pipe$3(self, exitFlatMap(identity$2));
/** @internal */
const exitForEachEffect = /* @__PURE__ */ dual$1(2, (self, f$1) => {
	switch (self._tag) {
		case OP_FAILURE: return succeed$9(exitFailCause$1(self.effect_instruction_i0));
		case OP_SUCCESS: return exit$2(f$1(self.effect_instruction_i0));
	}
});
/** @internal */
const exitFromEither = (either$4) => {
	switch (either$4._tag) {
		case "Left": return exitFail(either$4.left);
		case "Right": return exitSucceed$1(either$4.right);
	}
};
/** @internal */
const exitFromOption = (option$2) => {
	switch (option$2._tag) {
		case "None": return exitFail(void 0);
		case "Some": return exitSucceed$1(option$2.value);
	}
};
/** @internal */
const exitGetOrElse = /* @__PURE__ */ dual$1(2, (self, orElse$6) => {
	switch (self._tag) {
		case OP_FAILURE: return orElse$6(self.effect_instruction_i0);
		case OP_SUCCESS: return self.effect_instruction_i0;
	}
});
/** @internal */
const exitInterrupt$1 = (fiberId$2) => exitFailCause$1(interrupt$6(fiberId$2));
/** @internal */
const exitMap = /* @__PURE__ */ dual$1(2, (self, f$1) => {
	switch (self._tag) {
		case OP_FAILURE: return exitFailCause$1(self.effect_instruction_i0);
		case OP_SUCCESS: return exitSucceed$1(f$1(self.effect_instruction_i0));
	}
});
/** @internal */
const exitMapBoth = /* @__PURE__ */ dual$1(2, (self, { onFailure, onSuccess }) => {
	switch (self._tag) {
		case OP_FAILURE: return exitFailCause$1(pipe$3(self.effect_instruction_i0, map$10(onFailure)));
		case OP_SUCCESS: return exitSucceed$1(onSuccess(self.effect_instruction_i0));
	}
});
/** @internal */
const exitMapError = /* @__PURE__ */ dual$1(2, (self, f$1) => {
	switch (self._tag) {
		case OP_FAILURE: return exitFailCause$1(pipe$3(self.effect_instruction_i0, map$10(f$1)));
		case OP_SUCCESS: return exitSucceed$1(self.effect_instruction_i0);
	}
});
/** @internal */
const exitMapErrorCause = /* @__PURE__ */ dual$1(2, (self, f$1) => {
	switch (self._tag) {
		case OP_FAILURE: return exitFailCause$1(f$1(self.effect_instruction_i0));
		case OP_SUCCESS: return exitSucceed$1(self.effect_instruction_i0);
	}
});
/** @internal */
const exitMatch = /* @__PURE__ */ dual$1(2, (self, { onFailure, onSuccess }) => {
	switch (self._tag) {
		case OP_FAILURE: return onFailure(self.effect_instruction_i0);
		case OP_SUCCESS: return onSuccess(self.effect_instruction_i0);
	}
});
/** @internal */
const exitMatchEffect = /* @__PURE__ */ dual$1(2, (self, { onFailure, onSuccess }) => {
	switch (self._tag) {
		case OP_FAILURE: return onFailure(self.effect_instruction_i0);
		case OP_SUCCESS: return onSuccess(self.effect_instruction_i0);
	}
});
/** @internal */
const exitSucceed$1 = (value) => {
	const effect = new EffectPrimitiveSuccess(OP_SUCCESS);
	effect.effect_instruction_i0 = value;
	return effect;
};
/** @internal */
const exitVoid$1 = /* @__PURE__ */ exitSucceed$1(void 0);
/** @internal */
const exitZip = /* @__PURE__ */ dual$1(2, (self, that) => exitZipWith(self, that, {
	onSuccess: (a$1, a2) => [a$1, a2],
	onFailure: sequential$3
}));
/** @internal */
const exitZipLeft = /* @__PURE__ */ dual$1(2, (self, that) => exitZipWith(self, that, {
	onSuccess: (a$1, _$1) => a$1,
	onFailure: sequential$3
}));
/** @internal */
const exitZipRight = /* @__PURE__ */ dual$1(2, (self, that) => exitZipWith(self, that, {
	onSuccess: (_$1, a2) => a2,
	onFailure: sequential$3
}));
/** @internal */
const exitZipPar = /* @__PURE__ */ dual$1(2, (self, that) => exitZipWith(self, that, {
	onSuccess: (a$1, a2) => [a$1, a2],
	onFailure: parallel$3
}));
/** @internal */
const exitZipParLeft = /* @__PURE__ */ dual$1(2, (self, that) => exitZipWith(self, that, {
	onSuccess: (a$1, _$1) => a$1,
	onFailure: parallel$3
}));
/** @internal */
const exitZipParRight = /* @__PURE__ */ dual$1(2, (self, that) => exitZipWith(self, that, {
	onSuccess: (_$1, a2) => a2,
	onFailure: parallel$3
}));
/** @internal */
const exitZipWith = /* @__PURE__ */ dual$1(3, (self, that, { onFailure, onSuccess }) => {
	switch (self._tag) {
		case OP_FAILURE: switch (that._tag) {
			case OP_SUCCESS: return exitFailCause$1(self.effect_instruction_i0);
			case OP_FAILURE: return exitFailCause$1(onFailure(self.effect_instruction_i0, that.effect_instruction_i0));
		}
		case OP_SUCCESS: switch (that._tag) {
			case OP_SUCCESS: return exitSucceed$1(onSuccess(self.effect_instruction_i0, that.effect_instruction_i0));
			case OP_FAILURE: return exitFailCause$1(that.effect_instruction_i0);
		}
	}
});
const exitCollectAllInternal = (exits, combineCauses) => {
	const list = fromIterable$9(exits);
	if (!isNonEmpty$4(list)) return none$7();
	return pipe$3(tailNonEmpty(list), reduce$12(pipe$3(headNonEmpty(list), exitMap(of$3)), (accumulator, current) => pipe$3(accumulator, exitZipWith(current, {
		onSuccess: (list$1, value) => pipe$3(list$1, prepend$1(value)),
		onFailure: combineCauses
	}))), exitMap(reverse$1), exitMap((chunk$2) => toReadonlyArray(chunk$2)), some$4);
};
/** @internal */
const deferredUnsafeMake = (fiberId$2) => {
	return {
		...CommitPrototype$1,
		[DeferredTypeId$1]: deferredVariance,
		state: make$37(pending$1([])),
		commit() {
			return deferredAwait(this);
		},
		blockingOn: fiberId$2
	};
};
const deferredMake = () => flatMap$5(fiberId$1, (id$2) => deferredMakeAs(id$2));
const deferredMakeAs = (fiberId$2) => sync$3(() => deferredUnsafeMake(fiberId$2));
const deferredAwait = (self) => asyncInterrupt((resume$1) => {
	const state = get$6(self.state);
	switch (state._tag) {
		case OP_STATE_DONE: return resume$1(state.effect);
		case OP_STATE_PENDING:
			state.joiners.push(resume$1);
			return deferredInterruptJoiner(self, resume$1);
	}
}, self.blockingOn);
const deferredComplete = /* @__PURE__ */ dual$1(2, (self, effect) => intoDeferred$1(effect, self));
const deferredCompleteWith = /* @__PURE__ */ dual$1(2, (self, effect) => sync$3(() => {
	const state = get$6(self.state);
	switch (state._tag) {
		case OP_STATE_DONE: return false;
		case OP_STATE_PENDING:
			set$4(self.state, done$7(effect));
			for (let i$1 = 0, len = state.joiners.length; i$1 < len; i$1++) state.joiners[i$1](effect);
			return true;
	}
}));
const deferredDone = /* @__PURE__ */ dual$1(2, (self, exit$3) => deferredCompleteWith(self, exit$3));
const deferredFail = /* @__PURE__ */ dual$1(2, (self, error) => deferredCompleteWith(self, fail$9(error)));
const deferredFailSync = /* @__PURE__ */ dual$1(2, (self, evaluate$1) => deferredCompleteWith(self, failSync$2(evaluate$1)));
const deferredFailCause = /* @__PURE__ */ dual$1(2, (self, cause$2) => deferredCompleteWith(self, failCause$8(cause$2)));
const deferredFailCauseSync = /* @__PURE__ */ dual$1(2, (self, evaluate$1) => deferredCompleteWith(self, failCauseSync$2(evaluate$1)));
const deferredDie = /* @__PURE__ */ dual$1(2, (self, defect) => deferredCompleteWith(self, die$4(defect)));
const deferredDieSync = /* @__PURE__ */ dual$1(2, (self, evaluate$1) => deferredCompleteWith(self, dieSync$2(evaluate$1)));
const deferredInterrupt = (self) => flatMap$5(fiberId$1, (fiberId$2) => deferredCompleteWith(self, interruptWith$2(fiberId$2)));
const deferredInterruptWith = /* @__PURE__ */ dual$1(2, (self, fiberId$2) => deferredCompleteWith(self, interruptWith$2(fiberId$2)));
const deferredIsDone = (self) => sync$3(() => get$6(self.state)._tag === OP_STATE_DONE);
const deferredPoll = (self) => sync$3(() => {
	const state = get$6(self.state);
	switch (state._tag) {
		case OP_STATE_DONE: return some$4(state.effect);
		case OP_STATE_PENDING: return none$7();
	}
});
const deferredSucceed = /* @__PURE__ */ dual$1(2, (self, value) => deferredCompleteWith(self, succeed$9(value)));
const deferredSync = /* @__PURE__ */ dual$1(2, (self, evaluate$1) => deferredCompleteWith(self, sync$3(evaluate$1)));
/** @internal */
const deferredUnsafeDone = (self, effect) => {
	const state = get$6(self.state);
	if (state._tag === OP_STATE_PENDING) {
		set$4(self.state, done$7(effect));
		for (let i$1 = 0, len = state.joiners.length; i$1 < len; i$1++) state.joiners[i$1](effect);
	}
};
const deferredInterruptJoiner = (self, joiner) => sync$3(() => {
	const state = get$6(self.state);
	if (state._tag === OP_STATE_PENDING) {
		const index = state.joiners.indexOf(joiner);
		if (index >= 0) state.joiners.splice(index, 1);
	}
});
const constContext = /* @__PURE__ */ withFiberRuntime$1((fiber) => exitSucceed$1(fiber.currentContext));
const context$1 = () => constContext;
const contextWithEffect$1 = (f$1) => flatMap$5(context$1(), f$1);
const provideContext$1 = /* @__PURE__ */ dual$1(2, (self, context$2) => fiberRefLocally(currentContext, context$2)(self));
const provideSomeContext = /* @__PURE__ */ dual$1(2, (self, context$2) => fiberRefLocallyWith(currentContext, (parent) => merge$4(parent, context$2))(self));
const mapInputContext$1 = /* @__PURE__ */ dual$1(2, (self, f$1) => contextWithEffect$1((context$2) => provideContext$1(self, f$1(context$2))));
/** @internal */
const filterEffectOrElse$1 = /* @__PURE__ */ dual$1(2, (self, options) => flatMap$5(self, (a$1) => flatMap$5(options.predicate(a$1), (pass) => pass ? succeed$9(a$1) : options.orElse(a$1))));
/** @internal */
const filterEffectOrFail$1 = /* @__PURE__ */ dual$1(2, (self, options) => filterEffectOrElse$1(self, {
	predicate: options.predicate,
	orElse: (a$1) => fail$9(options.orFailWith(a$1))
}));
/** @internal */
const currentSpanFromFiber = (fiber) => {
	const span$1 = fiber.currentSpan;
	return span$1 !== void 0 && span$1._tag === "Span" ? some$4(span$1) : none$7();
};
const NoopSpanProto = {
	_tag: "Span",
	spanId: "noop",
	traceId: "noop",
	sampled: false,
	status: {
		_tag: "Ended",
		startTime: /* @__PURE__ */ BigInt(0),
		endTime: /* @__PURE__ */ BigInt(0),
		exit: exitVoid$1
	},
	attributes: /* @__PURE__ */ new Map(),
	links: [],
	kind: "internal",
	attribute() {},
	event() {},
	end() {},
	addLinks() {}
};
/** @internal */
const noopSpan = (options) => Object.assign(Object.create(NoopSpanProto), options);

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Deferred.js
/**
* @since 2.0.0
* @category symbols
*/
const DeferredTypeId = DeferredTypeId$1;
/**
* Creates a new `Deferred`.
*
* @since 2.0.0
* @category constructors
*/
const make$29 = deferredMake;
/**
* Creates a new `Deferred` from the specified `FiberId`.
*
* @since 2.0.0
* @category constructors
*/
const makeAs = deferredMakeAs;
const _await$2 = deferredAwait;
/**
* Completes the deferred with the result of the specified effect. If the
* deferred has already been completed, the method will produce false.
*
* Note that `Deferred.completeWith` will be much faster, so consider using
* that if you do not need to memoize the result of the specified effect.
*
* @since 2.0.0
* @category utils
*/
const complete$3 = deferredComplete;
/**
* Completes the deferred with the result of the specified effect. If the
* deferred has already been completed, the method will produce false.
*
* @since 2.0.0
* @category utils
*/
const completeWith = deferredCompleteWith;
/**
* Exits the `Deferred` with the specified `Exit` value, which will be
* propagated to all fibers waiting on the value of the `Deferred`.
*
* @since 2.0.0
* @category utils
*/
const done$6 = deferredDone;
/**
* Fails the `Deferred` with the specified error, which will be propagated to
* all fibers waiting on the value of the `Deferred`.
*
* @since 2.0.0
* @category utils
*/
const fail$8 = deferredFail;
/**
* Fails the `Deferred` with the specified error, which will be propagated to
* all fibers waiting on the value of the `Deferred`.
*
* @since 2.0.0
* @category utils
*/
const failSync$1 = deferredFailSync;
/**
* Fails the `Deferred` with the specified `Cause`, which will be propagated to
* all fibers waiting on the value of the `Deferred`.
*
* @since 2.0.0
* @category utils
*/
const failCause$7 = deferredFailCause;
/**
* Fails the `Deferred` with the specified `Cause`, which will be propagated to
* all fibers waiting on the value of the `Deferred`.
*
* @since 2.0.0
* @category utils
*/
const failCauseSync$1 = deferredFailCauseSync;
/**
* Kills the `Deferred` with the specified defect, which will be propagated to
* all fibers waiting on the value of the `Deferred`.
*
* @since 2.0.0
* @category utils
*/
const die$3 = deferredDie;
/**
* Kills the `Deferred` with the specified defect, which will be propagated to
* all fibers waiting on the value of the `Deferred`.
*
* @since 2.0.0
* @category utils
*/
const dieSync$1 = deferredDieSync;
/**
* Completes the `Deferred` with interruption. This will interrupt all fibers
* waiting on the value of the `Deferred` with the `FiberId` of the fiber
* calling this method.
*
* @since 2.0.0
* @category utils
*/
const interrupt$4 = deferredInterrupt;
/**
* Completes the `Deferred` with interruption. This will interrupt all fibers
* waiting on the value of the `Deferred` with the specified `FiberId`.
*
* @since 2.0.0
* @category utils
*/
const interruptWith$1 = deferredInterruptWith;
/**
* Returns `true` if this `Deferred` has already been completed with a value or
* an error, `false` otherwise.
*
* @since 2.0.0
* @category getters
*/
const isDone$4 = deferredIsDone;
/**
* Returns a `Some<Effect<A, E, R>>` from the `Deferred` if this `Deferred` has
* already been completed, `None` otherwise.
*
* @since 2.0.0
* @category getters
*/
const poll$3 = deferredPoll;
/**
* Completes the `Deferred` with the specified value.
*
* @since 2.0.0
* @category utils
*/
const succeed$8 = deferredSucceed;
/**
* Completes the `Deferred` with the specified lazily evaluated value.
*
* @since 2.0.0
* @category utils
*/
const sync$2 = deferredSync;
/**
* Unsafely creates a new `Deferred` from the specified `FiberId`.
*
* @since 2.0.0
* @category unsafe
*/
const unsafeMake$6 = deferredUnsafeMake;
/**
* Unsafely exits the `Deferred` with the specified `Exit` value, which will be
* propagated to all fibers waiting on the value of the `Deferred`.
*
* @since 2.0.0
* @category unsafe
*/
const unsafeDone = deferredUnsafeDone;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Exit.js
/**
* Returns `true` if the specified value is an `Exit`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isExit = exitIsExit;
/**
* Returns `true` if the specified `Exit` is a `Failure`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isFailure$3 = exitIsFailure;
/**
* Returns `true` if the specified `Exit` is a `Success`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isSuccess$2 = exitIsSuccess;
/**
* Returns `true` if the specified exit is a `Failure` **and** the `Cause` of
* the failure was due to interruption, `false` otherwise.
*
* @since 2.0.0
* @category getters
*/
const isInterrupted$1 = exitIsInterrupted;
/**
* Maps the `Success` value of the specified exit to the provided constant
* value.
*
* @since 2.0.0
* @category mapping
*/
const as$3 = exitAs;
/**
* Maps the `Success` value of the specified exit to a void.
*
* @since 2.0.0
* @category mapping
*/
const asVoid$2 = exitAsVoid;
/**
* Returns a `Some<Cause<E>>` if the specified exit is a `Failure`, `None`
* otherwise.
*
* @since 2.0.0
* @category getters
*/
const causeOption = exitCauseOption;
/**
* Collects all of the specified exit values into a `Some<Exit<List<A>, E>>`. If
* the provided iterable contains no elements, `None` will be returned.
*
* @since 2.0.0
* @category constructors
*/
const all$3 = exitCollectAll;
/**
* Constructs a new `Exit.Failure` from the specified unrecoverable defect.
*
* @since 2.0.0
* @category constructors
*/
const die$2 = exitDie$1;
/**
* Executes the predicate on the value of the specified exit if it is a
* `Success`, otherwise returns `false`.
*
* @since 2.0.0
* @category elements
*/
const exists$2 = exitExists;
/**
* Constructs a new `Exit.Failure` from the specified recoverable error of type
* `E`.
*
* @since 2.0.0
* @category constructors
*/
const fail$7 = exitFail;
/**
* Constructs a new `Exit.Failure` from the specified `Cause` of type `E`.
*
* @since 2.0.0
* @category constructors
*/
const failCause$6 = exitFailCause$1;
/**
* @since 2.0.0
* @category sequencing
*/
const flatMap$4 = exitFlatMap;
/**
* @since 2.0.0
* @category sequencing
*/
const flatMapEffect = exitFlatMapEffect;
/**
* @since 2.0.0
* @category sequencing
*/
const flatten$2 = exitFlatten;
/**
* @since 2.0.0
* @category traversing
*/
const forEachEffect = exitForEachEffect;
/**
* Converts an `Either<R, L>` into an `Exit<R, L>`.
*
* @since 2.0.0
* @category conversions
*/
const fromEither = exitFromEither;
/**
* Converts an `Option<A>` into an `Exit<void, A>`.
*
* @since 2.0.0
* @category conversions
*/
const fromOption$1 = exitFromOption;
/**
* Returns the `A` if specified exit is a `Success`, otherwise returns the
* alternate `A` value computed from the specified function which receives the
* `Cause<E>` of the exit `Failure`.
*
* @since 2.0.0
* @category getters
*/
const getOrElse = exitGetOrElse;
/**
* Constructs a new `Exit.Failure` from the specified `FiberId` indicating that
* the `Fiber` running an `Effect` workflow was terminated due to interruption.
*
* @since 2.0.0
* @category constructors
*/
const interrupt$3 = exitInterrupt$1;
/**
* Maps over the `Success` value of the specified exit using the provided
* function.
*
* @since 2.0.0
* @category mapping
*/
const map$8 = exitMap;
/**
* Maps over the `Success` and `Failure` cases of the specified exit using the
* provided functions.
*
* @since 2.0.0
* @category mapping
*/
const mapBoth$1 = exitMapBoth;
/**
* Maps over the error contained in the `Failure` of the specified exit using
* the provided function.
*
* @since 2.0.0
* @category mapping
*/
const mapError$2 = exitMapError;
/**
* Maps over the `Cause` contained in the `Failure` of the specified exit using
* the provided function.
*
* @since 2.0.0
* @category mapping
*/
const mapErrorCause$2 = exitMapErrorCause;
/**
* @since 2.0.0
* @category folding
*/
const match$8 = exitMatch;
/**
* @since 2.0.0
* @category folding
*/
const matchEffect$1 = exitMatchEffect;
/**
* Constructs a new `Exit.Success` containing the specified value of type `A`.
*
* @since 2.0.0
* @category constructors
*/
const succeed$7 = exitSucceed$1;
const void_$3 = exitVoid$1;
/**
* Sequentially zips the this result with the specified result or else returns
* the failed `Cause<E | E2>`.
*
* @since 2.0.0
* @category zipping
*/
const zip$3 = exitZip;
/**
* Sequentially zips the this result with the specified result discarding the
* second element of the tuple or else returns the failed `Cause<E | E2>`.
*
* @since 2.0.0
* @category zipping
*/
const zipLeft$2 = exitZipLeft;
/**
* Sequentially zips the this result with the specified result discarding the
* first element of the tuple or else returns the failed `Cause<E | E2>`.
*
* @since 2.0.0
* @category zipping
*/
const zipRight$2 = exitZipRight;
/**
* Parallelly zips the this result with the specified result or else returns
* the failed `Cause<E | E2>`.
*
* @since 2.0.0
* @category zipping
*/
const zipPar = exitZipPar;
/**
* Parallelly zips the this result with the specified result discarding the
* second element of the tuple or else returns the failed `Cause<E | E2>`.
*
* @since 2.0.0
* @category zipping
*/
const zipParLeft = exitZipParLeft;
/**
* Parallelly zips the this result with the specified result discarding the
* first element of the tuple or else returns the failed `Cause<E | E2>`.
*
* @since 2.0.0
* @category zipping
*/
const zipParRight = exitZipParRight;
/**
* Zips this exit together with that exit using the specified combination
* functions.
*
* @since 2.0.0
* @category zipping
*/
const zipWith$3 = exitZipWith;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/MutableHashMap.js
const TypeId$11 = /* @__PURE__ */ Symbol.for("effect/MutableHashMap");
const MutableHashMapProto = {
	[TypeId$11]: TypeId$11,
	[Symbol.iterator]() {
		return new MutableHashMapIterator(this);
	},
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "MutableHashMap",
			values: Array.from(this).map(toJSON)
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
var MutableHashMapIterator = class MutableHashMapIterator {
	self;
	referentialIterator;
	bucketIterator;
	constructor(self) {
		this.self = self;
		this.referentialIterator = self.referential[Symbol.iterator]();
	}
	next() {
		if (this.bucketIterator !== void 0) return this.bucketIterator.next();
		const result = this.referentialIterator.next();
		if (result.done) {
			this.bucketIterator = new BucketIterator(this.self.buckets.values());
			return this.next();
		}
		return result;
	}
	[Symbol.iterator]() {
		return new MutableHashMapIterator(this.self);
	}
};
var BucketIterator = class {
	backing;
	constructor(backing) {
		this.backing = backing;
	}
	currentBucket;
	next() {
		if (this.currentBucket === void 0) {
			const result$1 = this.backing.next();
			if (result$1.done) return result$1;
			this.currentBucket = result$1.value[Symbol.iterator]();
		}
		const result = this.currentBucket.next();
		if (result.done) {
			this.currentBucket = void 0;
			return this.next();
		}
		return result;
	}
};
/**
* @since 2.0.0
* @category constructors
*/
const empty$14 = () => {
	const self = Object.create(MutableHashMapProto);
	self.referential = /* @__PURE__ */ new Map();
	self.buckets = /* @__PURE__ */ new Map();
	self.bucketsSize = 0;
	return self;
};
/**
* @since 2.0.0
* @category elements
*/
const get$4 = /* @__PURE__ */ dual$1(2, (self, key) => {
	if (isEqual(key) === false) return self.referential.has(key) ? some$4(self.referential.get(key)) : none$7();
	const hash$1 = key[symbol$1]();
	const bucket = self.buckets.get(hash$1);
	if (bucket === void 0) return none$7();
	return getFromBucket(self, bucket, key);
});
const getFromBucket = (self, bucket, key, remove$8 = false) => {
	for (let i$1 = 0, len = bucket.length; i$1 < len; i$1++) if (key[symbol](bucket[i$1][0])) {
		const value = bucket[i$1][1];
		if (remove$8) {
			bucket.splice(i$1, 1);
			self.bucketsSize--;
		}
		return some$4(value);
	}
	return none$7();
};
/**
* @since 2.0.0
* @category elements
*/
const has$2 = /* @__PURE__ */ dual$1(2, (self, key) => isSome(get$4(self, key)));
/**
* @since 2.0.0
*/
const set$2 = /* @__PURE__ */ dual$1(3, (self, key, value) => {
	if (isEqual(key) === false) {
		self.referential.set(key, value);
		return self;
	}
	const hash$1 = key[symbol$1]();
	const bucket = self.buckets.get(hash$1);
	if (bucket === void 0) {
		self.buckets.set(hash$1, [[key, value]]);
		self.bucketsSize++;
		return self;
	}
	removeFromBucket(self, bucket, key);
	bucket.push([key, value]);
	self.bucketsSize++;
	return self;
});
const removeFromBucket = (self, bucket, key) => {
	for (let i$1 = 0, len = bucket.length; i$1 < len; i$1++) if (key[symbol](bucket[i$1][0])) {
		bucket.splice(i$1, 1);
		self.bucketsSize--;
		return;
	}
};
/**
* @since 2.0.0
*/
const remove$3 = /* @__PURE__ */ dual$1(2, (self, key) => {
	if (isEqual(key) === false) {
		self.referential.delete(key);
		return self;
	}
	const hash$1 = key[symbol$1]();
	const bucket = self.buckets.get(hash$1);
	if (bucket === void 0) return self;
	removeFromBucket(self, bucket, key);
	if (bucket.length === 0) self.buckets.delete(hash$1);
	return self;
});
/**
* @since 2.0.0
* @category elements
*/
const size$5 = (self) => {
	return self.referential.size + self.bucketsSize;
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/MutableList.js
const TypeId$10 = /* @__PURE__ */ Symbol.for("effect/MutableList");
const MutableListProto = {
	[TypeId$10]: TypeId$10,
	[Symbol.iterator]() {
		let done$8 = false;
		let head$4 = this.head;
		return {
			next() {
				if (done$8) return this.return();
				if (head$4 == null) {
					done$8 = true;
					return this.return();
				}
				const value = head$4.value;
				head$4 = head$4.next;
				return {
					done: done$8,
					value
				};
			},
			return(value) {
				if (!done$8) done$8 = true;
				return {
					done: true,
					value
				};
			}
		};
	},
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "MutableList",
			values: Array.from(this).map(toJSON)
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const makeNode = (value) => ({
	value,
	removed: false,
	prev: void 0,
	next: void 0
});
/**
* Creates an empty `MutableList`.
*
* @since 2.0.0
* @category constructors
*/
const empty$13 = () => {
	const list = Object.create(MutableListProto);
	list.head = void 0;
	list.tail = void 0;
	list._length = 0;
	return list;
};
/**
* Returns `true` if the list contains zero elements, `false`, otherwise.
*
* @since 2.0.0
* @category getters
*/
const isEmpty$3 = (self) => length(self) === 0;
/**
* Returns the length of the list.
*
* @since 2.0.0
* @category getters
*/
const length = (self) => self._length;
/**
* Appends the specified element to the end of the `MutableList`.
*
* @category concatenating
* @since 2.0.0
*/
const append = /* @__PURE__ */ dual$1(2, (self, value) => {
	const node = makeNode(value);
	if (self.head === void 0) self.head = node;
	if (self.tail === void 0) self.tail = node;
	else {
		self.tail.next = node;
		node.prev = self.tail;
		self.tail = node;
	}
	self._length += 1;
	return self;
});
/**
* Removes the first value from the list and returns it, if it exists.
*
* @since 0.0.1
*/
const shift = (self) => {
	const head$4 = self.head;
	if (head$4 !== void 0) {
		remove$2(self, head$4);
		return head$4.value;
	}
};
const remove$2 = (self, node) => {
	if (node.removed) return;
	node.removed = true;
	if (node.prev !== void 0 && node.next !== void 0) {
		node.prev.next = node.next;
		node.next.prev = node.prev;
	} else if (node.prev !== void 0) {
		self.tail = node.prev;
		node.prev.next = void 0;
	} else if (node.next !== void 0) {
		self.head = node.next;
		node.next.prev = void 0;
	} else {
		self.tail = void 0;
		self.head = void 0;
	}
	if (self._length > 0) self._length -= 1;
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/MutableQueue.js
const TypeId$9 = /* @__PURE__ */ Symbol.for("effect/MutableQueue");
/**
* @since 2.0.0
* @category symbol
*/
const EmptyMutableQueue = /* @__PURE__ */ Symbol.for("effect/mutable/MutableQueue/Empty");
const MutableQueueProto = {
	[TypeId$9]: TypeId$9,
	[Symbol.iterator]() {
		return Array.from(this.queue)[Symbol.iterator]();
	},
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "MutableQueue",
			values: Array.from(this).map(toJSON)
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const make$28 = (capacity) => {
	const queue$1 = Object.create(MutableQueueProto);
	queue$1.queue = empty$13();
	queue$1.capacity = capacity;
	return queue$1;
};
/**
* Creates a new unbounded `MutableQueue`.
*
* @since 2.0.0
* @category constructors
*/
const unbounded = () => make$28(void 0);
/**
* Offers an element to the queue.
*
* Returns whether the enqueue was successful or not.
*
* @since 2.0.0
*/
const offer = /* @__PURE__ */ dual$1(2, (self, value) => {
	const queueLength = length(self.queue);
	if (self.capacity !== void 0 && queueLength === self.capacity) return false;
	append(value)(self.queue);
	return true;
});
/**
* Dequeues an element from the queue.
*
* Returns either an element from the queue, or the `def` param.
*
* **Note**: if there is no meaningful default for your type, you can always
* use `poll(MutableQueue.EmptyMutableQueue)`.
*
* @since 2.0.0
*/
const poll$2 = /* @__PURE__ */ dual$1(2, (self, def) => {
	if (isEmpty$3(self.queue)) return def;
	return shift(self.queue);
});

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/clock.js
/** @internal */
const ClockSymbolKey = "effect/Clock";
/** @internal */
const ClockTypeId$1 = /* @__PURE__ */ Symbol.for(ClockSymbolKey);
/** @internal */
const clockTag = /* @__PURE__ */ GenericTag$1("effect/Clock");
/** @internal */
const MAX_TIMER_MILLIS = 2 ** 31 - 1;
/** @internal */
const globalClockScheduler = { unsafeSchedule(task, duration) {
	const millis$1 = toMillis(duration);
	if (millis$1 > MAX_TIMER_MILLIS) return constFalse;
	let completed = false;
	const handle = setTimeout(() => {
		completed = true;
		task();
	}, millis$1);
	return () => {
		clearTimeout(handle);
		return !completed;
	};
} };
const performanceNowNanos = /* @__PURE__ */ function() {
	const bigint1e6$1 = /* @__PURE__ */ BigInt(1e6);
	if (typeof performance === "undefined") return () => BigInt(Date.now()) * bigint1e6$1;
	let origin;
	return () => {
		if (origin === void 0) origin = BigInt(Date.now()) * bigint1e6$1 - BigInt(Math.round(performance.now() * 1e6));
		return origin + BigInt(Math.round(performance.now() * 1e6));
	};
}();
const processOrPerformanceNow = /* @__PURE__ */ function() {
	const processHrtime = typeof process === "object" && "hrtime" in process && typeof process.hrtime.bigint === "function" ? process.hrtime : void 0;
	if (!processHrtime) return performanceNowNanos;
	const origin = /* @__PURE__ */ performanceNowNanos() - /* @__PURE__ */ processHrtime.bigint();
	return () => origin + processHrtime.bigint();
}();
/** @internal */
var ClockImpl = class {
	[ClockTypeId$1] = ClockTypeId$1;
	unsafeCurrentTimeMillis() {
		return Date.now();
	}
	unsafeCurrentTimeNanos() {
		return processOrPerformanceNow();
	}
	currentTimeMillis = /* @__PURE__ */ sync$3(() => this.unsafeCurrentTimeMillis());
	currentTimeNanos = /* @__PURE__ */ sync$3(() => this.unsafeCurrentTimeNanos());
	scheduler() {
		return succeed$9(globalClockScheduler);
	}
	sleep(duration) {
		return async_((resume$1) => {
			const canceler = globalClockScheduler.unsafeSchedule(() => resume$1(void_$4), duration);
			return asVoid$3(sync$3(canceler));
		});
	}
};
/** @internal */
const make$27 = () => new ClockImpl();

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/opCodes/configError.js
/** @internal */
const OP_AND = "And";
/** @internal */
const OP_OR = "Or";
/** @internal */
const OP_INVALID_DATA = "InvalidData";
/** @internal */
const OP_MISSING_DATA = "MissingData";
/** @internal */
const OP_SOURCE_UNAVAILABLE = "SourceUnavailable";
/** @internal */
const OP_UNSUPPORTED = "Unsupported";

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/configError.js
/** @internal */
const ConfigErrorSymbolKey = "effect/ConfigError";
/** @internal */
const ConfigErrorTypeId = /* @__PURE__ */ Symbol.for(ConfigErrorSymbolKey);
/** @internal */
const proto$2 = {
	_tag: "ConfigError",
	[ConfigErrorTypeId]: ConfigErrorTypeId
};
/** @internal */
const And = (self, that) => {
	const error = Object.create(proto$2);
	error._op = OP_AND;
	error.left = self;
	error.right = that;
	Object.defineProperty(error, "toString", {
		enumerable: false,
		value() {
			return `${this.left} and ${this.right}`;
		}
	});
	Object.defineProperty(error, "message", {
		enumerable: false,
		get() {
			return this.toString();
		}
	});
	return error;
};
/** @internal */
const Or = (self, that) => {
	const error = Object.create(proto$2);
	error._op = OP_OR;
	error.left = self;
	error.right = that;
	Object.defineProperty(error, "toString", {
		enumerable: false,
		value() {
			return `${this.left} or ${this.right}`;
		}
	});
	Object.defineProperty(error, "message", {
		enumerable: false,
		get() {
			return this.toString();
		}
	});
	return error;
};
/** @internal */
const InvalidData = (path, message, options = { pathDelim: "." }) => {
	const error = Object.create(proto$2);
	error._op = OP_INVALID_DATA;
	error.path = path;
	error.message = message;
	Object.defineProperty(error, "toString", {
		enumerable: false,
		value() {
			return `(Invalid data at ${pipe$3(this.path, join$3(options.pathDelim))}: "${this.message}")`;
		}
	});
	return error;
};
/** @internal */
const MissingData = (path, message, options = { pathDelim: "." }) => {
	const error = Object.create(proto$2);
	error._op = OP_MISSING_DATA;
	error.path = path;
	error.message = message;
	Object.defineProperty(error, "toString", {
		enumerable: false,
		value() {
			return `(Missing data at ${pipe$3(this.path, join$3(options.pathDelim))}: "${this.message}")`;
		}
	});
	return error;
};
/** @internal */
const SourceUnavailable = (path, message, cause$2, options = { pathDelim: "." }) => {
	const error = Object.create(proto$2);
	error._op = OP_SOURCE_UNAVAILABLE;
	error.path = path;
	error.message = message;
	error.cause = cause$2;
	Object.defineProperty(error, "toString", {
		enumerable: false,
		value() {
			return `(Source unavailable at ${pipe$3(this.path, join$3(options.pathDelim))}: "${this.message}")`;
		}
	});
	return error;
};
/** @internal */
const Unsupported = (path, message, options = { pathDelim: "." }) => {
	const error = Object.create(proto$2);
	error._op = OP_UNSUPPORTED;
	error.path = path;
	error.message = message;
	Object.defineProperty(error, "toString", {
		enumerable: false,
		value() {
			return `(Unsupported operation at ${pipe$3(this.path, join$3(options.pathDelim))}: "${this.message}")`;
		}
	});
	return error;
};
/** @internal */
const prefixed = /* @__PURE__ */ dual$1(2, (self, prefix) => {
	switch (self._op) {
		case OP_AND: return And(prefixed(self.left, prefix), prefixed(self.right, prefix));
		case OP_OR: return Or(prefixed(self.left, prefix), prefixed(self.right, prefix));
		case OP_INVALID_DATA: return InvalidData([...prefix, ...self.path], self.message);
		case OP_MISSING_DATA: return MissingData([...prefix, ...self.path], self.message);
		case OP_SOURCE_UNAVAILABLE: return SourceUnavailable([...prefix, ...self.path], self.message, self.cause);
		case OP_UNSUPPORTED: return Unsupported([...prefix, ...self.path], self.message);
	}
});

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/configProvider/pathPatch.js
/** @internal */
const empty$12 = { _tag: "Empty" };
/** @internal */
const patch$3 = /* @__PURE__ */ dual$1(2, (path, patch$11) => {
	let input = of$2(patch$11);
	let output = path;
	while (isCons(input)) {
		const patch$12 = input.head;
		switch (patch$12._tag) {
			case "Empty":
				input = input.tail;
				break;
			case "AndThen":
				input = cons(patch$12.first, cons(patch$12.second, input.tail));
				break;
			case "MapName":
				output = map$15(output, patch$12.f);
				input = input.tail;
				break;
			case "Nested":
				output = prepend$2(output, patch$12.name);
				input = input.tail;
				break;
			case "Unnested":
				if (pipe$3(head$3(output), contains$4(patch$12.name))) {
					output = tailNonEmpty$1(output);
					input = input.tail;
				} else return left(MissingData(output, `Expected ${patch$12.name} to be in path in ConfigProvider#unnested`));
				break;
		}
	}
	return right(output);
});

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/opCodes/config.js
/** @internal */
const OP_CONSTANT = "Constant";
/** @internal */
const OP_FAIL = "Fail";
/** @internal */
const OP_FALLBACK = "Fallback";
/** @internal */
const OP_DESCRIBED = "Described";
/** @internal */
const OP_LAZY = "Lazy";
/** @internal */
const OP_MAP_OR_FAIL = "MapOrFail";
/** @internal */
const OP_NESTED = "Nested";
/** @internal */
const OP_PRIMITIVE = "Primitive";
/** @internal */
const OP_SEQUENCE = "Sequence";
/** @internal */
const OP_HASHMAP = "HashMap";
/** @internal */
const OP_ZIP_WITH$1 = "ZipWith";

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/configProvider.js
const concat = (l$1, r$1) => [...l$1, ...r$1];
/** @internal */
const ConfigProviderSymbolKey = "effect/ConfigProvider";
/** @internal */
const ConfigProviderTypeId = /* @__PURE__ */ Symbol.for(ConfigProviderSymbolKey);
/** @internal */
const configProviderTag = /* @__PURE__ */ GenericTag$1("effect/ConfigProvider");
/** @internal */
const FlatConfigProviderSymbolKey = "effect/ConfigProviderFlat";
/** @internal */
const FlatConfigProviderTypeId = /* @__PURE__ */ Symbol.for(FlatConfigProviderSymbolKey);
/** @internal */
const make$26 = (options) => ({
	[ConfigProviderTypeId]: ConfigProviderTypeId,
	pipe() {
		return pipeArguments(this, arguments);
	},
	...options
});
/** @internal */
const makeFlat = (options) => ({
	[FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
	patch: options.patch,
	load: (path, config, split = true) => options.load(path, config, split),
	enumerateChildren: options.enumerateChildren
});
/** @internal */
const fromFlat = (flat) => make$26({
	load: (config) => flatMap$5(fromFlatLoop(flat, empty$33(), config, false), (chunk$2) => match$11(head$3(chunk$2), {
		onNone: () => fail$9(MissingData(empty$33(), `Expected a single value having structure: ${config}`)),
		onSome: succeed$9
	})),
	flattened: flat
});
/** @internal */
const fromEnv = (options) => {
	const { pathDelim, seqDelim } = Object.assign({}, {
		pathDelim: "_",
		seqDelim: ","
	}, options);
	const makePathString = (path) => pipe$3(path, join$3(pathDelim));
	const unmakePathString = (pathString) => pathString.split(pathDelim);
	const getEnv = () => typeof process !== "undefined" && "env" in process && typeof process.env === "object" ? process.env : {};
	const load = (path, primitive, split = true) => {
		const pathString = makePathString(path);
		const current = getEnv();
		return pipe$3(pathString in current ? some$4(current[pathString]) : none$7(), mapError$3(() => MissingData(path, `Expected ${pathString} to exist in the process context`)), flatMap$5((value) => parsePrimitive(value, path, primitive, seqDelim, split)));
	};
	const enumerateChildren = (path) => sync$3(() => {
		const current = getEnv();
		const filteredKeyPaths = Object.keys(current).map((value) => unmakePathString(value.toUpperCase())).filter((keyPath) => {
			for (let i$1 = 0; i$1 < path.length; i$1++) {
				const pathComponent = pipe$3(path, unsafeGet$5(i$1));
				const currentElement = keyPath[i$1];
				if (currentElement === void 0 || pathComponent !== currentElement) return false;
			}
			return true;
		}).flatMap((keyPath) => keyPath.slice(path.length, path.length + 1));
		return fromIterable$6(filteredKeyPaths);
	});
	return fromFlat(makeFlat({
		load,
		enumerateChildren,
		patch: empty$12
	}));
};
const extend$1 = (leftDef, rightDef, left$2, right$2) => {
	const leftPad = unfold$1(left$2.length, (index) => index >= right$2.length ? none$7() : some$4([leftDef(index), index + 1]));
	const rightPad = unfold$1(right$2.length, (index) => index >= left$2.length ? none$7() : some$4([rightDef(index), index + 1]));
	return [concat(left$2, leftPad), concat(right$2, rightPad)];
};
const appendConfigPath = (path, config) => {
	let op = config;
	if (op._tag === "Nested") {
		const out = path.slice();
		while (op._tag === "Nested") {
			out.push(op.name);
			op = op.config;
		}
		return out;
	}
	return path;
};
const fromFlatLoop = (flat, prefix, config, split) => {
	const op = config;
	switch (op._tag) {
		case OP_CONSTANT: return succeed$9(of$4(op.value));
		case OP_DESCRIBED: return suspend$3(() => fromFlatLoop(flat, prefix, op.config, split));
		case OP_FAIL: return fail$9(MissingData(prefix, op.message));
		case OP_FALLBACK: return pipe$3(suspend$3(() => fromFlatLoop(flat, prefix, op.first, split)), catchAll$1((error1) => {
			if (op.condition(error1)) return pipe$3(fromFlatLoop(flat, prefix, op.second, split), catchAll$1((error2) => fail$9(Or(error1, error2))));
			return fail$9(error1);
		}));
		case OP_LAZY: return suspend$3(() => fromFlatLoop(flat, prefix, op.config(), split));
		case OP_MAP_OR_FAIL: return suspend$3(() => pipe$3(fromFlatLoop(flat, prefix, op.original, split), flatMap$5(forEachSequential((a$1) => pipe$3(op.mapOrFail(a$1), mapError$3(prefixed(appendConfigPath(prefix, op.original))))))));
		case OP_NESTED: return suspend$3(() => fromFlatLoop(flat, concat(prefix, of$4(op.name)), op.config, split));
		case OP_PRIMITIVE: return pipe$3(patch$3(prefix, flat.patch), flatMap$5((prefix$1) => pipe$3(flat.load(prefix$1, op, split), flatMap$5((values$6) => {
			if (values$6.length === 0) {
				const name = pipe$3(last$2(prefix$1), getOrElse$5(() => "<n/a>"));
				return fail$9(MissingData([], `Expected ${op.description} with name ${name}`));
			}
			return succeed$9(values$6);
		}))));
		case OP_SEQUENCE: return pipe$3(patch$3(prefix, flat.patch), flatMap$5((patchedPrefix) => pipe$3(flat.enumerateChildren(patchedPrefix), flatMap$5(indicesFrom), flatMap$5((indices) => {
			if (indices.length === 0) return suspend$3(() => map$9(fromFlatLoop(flat, prefix, op.config, true), of$4));
			return pipe$3(forEachSequential(indices, (index) => fromFlatLoop(flat, append$2(prefix, `[${index}]`), op.config, true)), map$9((chunkChunk) => {
				const flattened = flatten$7(chunkChunk);
				if (flattened.length === 0) return of$4(empty$33());
				return of$4(flattened);
			}));
		}))));
		case OP_HASHMAP: return suspend$3(() => pipe$3(patch$3(prefix, flat.patch), flatMap$5((prefix$1) => pipe$3(flat.enumerateChildren(prefix$1), flatMap$5((keys$5) => {
			return pipe$3(keys$5, forEachSequential((key) => fromFlatLoop(flat, concat(prefix$1, of$4(key)), op.valueConfig, split)), map$9((matrix) => {
				if (matrix.length === 0) return of$4(empty$26());
				return pipe$3(transpose(matrix), map$15((values$6) => fromIterable$5(zip$6(fromIterable$10(keys$5), values$6))));
			}));
		})))));
		case OP_ZIP_WITH$1: return suspend$3(() => pipe$3(fromFlatLoop(flat, prefix, op.left, split), either$1, flatMap$5((left$2) => pipe$3(fromFlatLoop(flat, prefix, op.right, split), either$1, flatMap$5((right$2) => {
			if (isLeft(left$2) && isLeft(right$2)) return fail$9(And(left$2.left, right$2.left));
			if (isLeft(left$2) && isRight(right$2)) return fail$9(left$2.left);
			if (isRight(left$2) && isLeft(right$2)) return fail$9(right$2.left);
			if (isRight(left$2) && isRight(right$2)) {
				const fail$11 = fromFlatLoopFail(prefix, pipe$3(prefix, join$3(".")));
				const [lefts, rights] = extend$1(fail$11, fail$11, pipe$3(left$2.right, map$15(right)), pipe$3(right$2.right, map$15(right)));
				return pipe$3(lefts, zip$6(rights), forEachSequential(([left$3, right$3]) => pipe$3(zip$4(left$3, right$3), map$9(([left$4, right$4]) => op.zip(left$4, right$4)))));
			}
			throw new Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues");
		})))));
	}
};
const fromFlatLoopFail = (prefix, path) => (index) => left(MissingData(prefix, `The element at index ${index} in a sequence at path "${path}" was missing`));
const splitPathString = (text, delim) => {
	return text.split(/* @__PURE__ */ new RegExp(`\\s*${escape(delim)}\\s*`));
};
const parsePrimitive = (text, path, primitive, delimiter, split) => {
	if (!split) return pipe$3(primitive.parse(text), mapBoth$2({
		onFailure: prefixed(path),
		onSuccess: of$4
	}));
	return pipe$3(splitPathString(text, delimiter), forEachSequential((char) => primitive.parse(char.trim())), mapError$3(prefixed(path)));
};
const transpose = (array$3) => {
	return Object.keys(array$3[0]).map((column) => array$3.map((row) => row[column]));
};
const indicesFrom = (quotedIndices) => pipe$3(forEachSequential(quotedIndices, parseQuotedIndex), mapBoth$2({
	onFailure: () => empty$33(),
	onSuccess: sort(Order$4)
}), either$1, map$9(merge$6));
const QUOTED_INDEX_REGEX = /^(\[(\d+)\])$/;
const parseQuotedIndex = (str) => {
	const match$13 = str.match(QUOTED_INDEX_REGEX);
	if (match$13 !== null) {
		const matchedIndex = match$13[2];
		return pipe$3(matchedIndex !== void 0 && matchedIndex.length > 0 ? some$4(matchedIndex) : none$7(), flatMap$12(parseInteger));
	}
	return none$7();
};
const parseInteger = (str) => {
	const parsedIndex = Number.parseInt(str);
	return Number.isNaN(parsedIndex) ? none$7() : some$4(parsedIndex);
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/defaultServices/console.js
/** @internal */
const TypeId$8 = /* @__PURE__ */ Symbol.for("effect/Console");
/** @internal */
const consoleTag = /* @__PURE__ */ GenericTag$1("effect/Console");
/** @internal */
const defaultConsole = {
	[TypeId$8]: TypeId$8,
	assert(condition, ...args$2) {
		return sync$3(() => {
			console.assert(condition, ...args$2);
		});
	},
	clear: /* @__PURE__ */ sync$3(() => {
		console.clear();
	}),
	count(label) {
		return sync$3(() => {
			console.count(label);
		});
	},
	countReset(label) {
		return sync$3(() => {
			console.countReset(label);
		});
	},
	debug(...args$2) {
		return sync$3(() => {
			console.debug(...args$2);
		});
	},
	dir(item, options) {
		return sync$3(() => {
			console.dir(item, options);
		});
	},
	dirxml(...args$2) {
		return sync$3(() => {
			console.dirxml(...args$2);
		});
	},
	error(...args$2) {
		return sync$3(() => {
			console.error(...args$2);
		});
	},
	group(options) {
		return options?.collapsed ? sync$3(() => console.groupCollapsed(options?.label)) : sync$3(() => console.group(options?.label));
	},
	groupEnd: /* @__PURE__ */ sync$3(() => {
		console.groupEnd();
	}),
	info(...args$2) {
		return sync$3(() => {
			console.info(...args$2);
		});
	},
	log(...args$2) {
		return sync$3(() => {
			console.log(...args$2);
		});
	},
	table(tabularData, properties) {
		return sync$3(() => {
			console.table(tabularData, properties);
		});
	},
	time(label) {
		return sync$3(() => console.time(label));
	},
	timeEnd(label) {
		return sync$3(() => console.timeEnd(label));
	},
	timeLog(label, ...args$2) {
		return sync$3(() => {
			console.timeLog(label, ...args$2);
		});
	},
	trace(...args$2) {
		return sync$3(() => {
			console.trace(...args$2);
		});
	},
	warn(...args$2) {
		return sync$3(() => {
			console.warn(...args$2);
		});
	},
	unsafe: console
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/random.js
/** @internal */
const RandomSymbolKey = "effect/Random";
/** @internal */
const RandomTypeId = /* @__PURE__ */ Symbol.for(RandomSymbolKey);
/** @internal */
const randomTag = /* @__PURE__ */ GenericTag$1("effect/Random");
/** @internal */
var RandomImpl = class {
	seed;
	[RandomTypeId] = RandomTypeId;
	PRNG;
	constructor(seed) {
		this.seed = seed;
		this.PRNG = new PCGRandom(seed);
	}
	get next() {
		return sync$3(() => this.PRNG.number());
	}
	get nextBoolean() {
		return map$9(this.next, (n$1) => n$1 > .5);
	}
	get nextInt() {
		return sync$3(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));
	}
	nextRange(min$2, max$4) {
		return map$9(this.next, (n$1) => (max$4 - min$2) * n$1 + min$2);
	}
	nextIntBetween(min$2, max$4) {
		return sync$3(() => this.PRNG.integer(max$4 - min$2) + min$2);
	}
	shuffle(elements) {
		return shuffleWith(elements, (n$1) => this.nextIntBetween(0, n$1));
	}
};
const shuffleWith = (elements, nextIntBounded) => {
	return suspend$3(() => pipe$3(sync$3(() => Array.from(elements)), flatMap$5((buffer) => {
		const numbers = [];
		for (let i$1 = buffer.length; i$1 >= 2; i$1 = i$1 - 1) numbers.push(i$1);
		return pipe$3(numbers, forEachSequentialDiscard((n$1) => pipe$3(nextIntBounded(n$1), map$9((k) => swap$1(buffer, n$1 - 1, k)))), as$4(fromIterable$9(buffer)));
	})));
};
const swap$1 = (buffer, index1, index2) => {
	const tmp = buffer[index1];
	buffer[index1] = buffer[index2];
	buffer[index2] = tmp;
	return buffer;
};
const make$25 = (seed) => new RandomImpl(hash(seed));
/** @internal */
var FixedRandomImpl = class {
	values;
	[RandomTypeId] = RandomTypeId;
	index = 0;
	constructor(values$6) {
		this.values = values$6;
		if (values$6.length === 0) throw new Error("Requires at least one value");
	}
	getNextValue() {
		const value = this.values[this.index];
		this.index = (this.index + 1) % this.values.length;
		return value;
	}
	get next() {
		return sync$3(() => {
			const value = this.getNextValue();
			if (typeof value === "number") return Math.max(0, Math.min(1, value));
			return hash(value) / 2147483647;
		});
	}
	get nextBoolean() {
		return sync$3(() => {
			const value = this.getNextValue();
			if (typeof value === "boolean") return value;
			return hash(value) % 2 === 0;
		});
	}
	get nextInt() {
		return sync$3(() => {
			const value = this.getNextValue();
			if (typeof value === "number" && Number.isFinite(value)) return Math.round(value);
			return Math.abs(hash(value));
		});
	}
	nextRange(min$2, max$4) {
		return map$9(this.next, (n$1) => (max$4 - min$2) * n$1 + min$2);
	}
	nextIntBetween(min$2, max$4) {
		return sync$3(() => {
			const value = this.getNextValue();
			if (typeof value === "number" && Number.isFinite(value)) return Math.max(min$2, Math.min(max$4 - 1, Math.round(value)));
			return min$2 + Math.abs(hash(value)) % (max$4 - min$2);
		});
	}
	shuffle(elements) {
		return shuffleWith(elements, (n$1) => this.nextIntBetween(0, n$1));
	}
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/tracer.js
/** @internal */
const TracerTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Tracer");
/** @internal */
const make$24 = (options) => ({
	[TracerTypeId$1]: TracerTypeId$1,
	...options
});
/** @internal */
const tracerTag = /* @__PURE__ */ GenericTag$1("effect/Tracer");
/** @internal */
const spanTag = /* @__PURE__ */ GenericTag$1("effect/ParentSpan");
const randomHexString = /* @__PURE__ */ function() {
	const characters = "abcdef0123456789";
	const charactersLength = 16;
	return function(length$1) {
		let result = "";
		for (let i$1 = 0; i$1 < length$1; i$1++) result += characters.charAt(Math.floor(Math.random() * charactersLength));
		return result;
	};
}();
/** @internal */
var NativeSpan = class {
	name;
	parent;
	context;
	startTime;
	kind;
	_tag = "Span";
	spanId;
	traceId = "native";
	sampled = true;
	status;
	attributes;
	events = [];
	links;
	constructor(name, parent, context$2, links, startTime, kind) {
		this.name = name;
		this.parent = parent;
		this.context = context$2;
		this.startTime = startTime;
		this.kind = kind;
		this.status = {
			_tag: "Started",
			startTime
		};
		this.attributes = /* @__PURE__ */ new Map();
		this.traceId = parent._tag === "Some" ? parent.value.traceId : randomHexString(32);
		this.spanId = randomHexString(16);
		this.links = Array.from(links);
	}
	end(endTime, exit$3) {
		this.status = {
			_tag: "Ended",
			endTime,
			exit: exit$3,
			startTime: this.status.startTime
		};
	}
	attribute(key, value) {
		this.attributes.set(key, value);
	}
	event(name, startTime, attributes) {
		this.events.push([
			name,
			startTime,
			attributes ?? {}
		]);
	}
	addLinks(links) {
		this.links.push(...links);
	}
};
/** @internal */
const nativeTracer = /* @__PURE__ */ make$24({
	span: (name, parent, context$2, links, startTime, kind) => new NativeSpan(name, parent, context$2, links, startTime, kind),
	context: (f$1) => f$1()
});
/** @internal */
const externalSpan$1 = (options) => ({
	_tag: "ExternalSpan",
	spanId: options.spanId,
	traceId: options.traceId,
	sampled: options.sampled ?? true,
	context: options.context ?? empty$31()
});
/** @internal */
const addSpanStackTrace = (options) => {
	if (options?.captureStackTrace === false) return options;
	else if (options?.captureStackTrace !== void 0 && typeof options.captureStackTrace !== "boolean") return options;
	const limit = Error.stackTraceLimit;
	Error.stackTraceLimit = 3;
	const traceError = /* @__PURE__ */ new Error();
	Error.stackTraceLimit = limit;
	let cache = false;
	return {
		...options,
		captureStackTrace: () => {
			if (cache !== false) return cache;
			if (traceError.stack !== void 0) {
				const stack = traceError.stack.split("\n");
				if (stack[3] !== void 0) {
					cache = stack[3].trim();
					return cache;
				}
			}
		}
	};
};
/** @internal */
const DisablePropagation$1 = /* @__PURE__ */ Reference()("effect/Tracer/DisablePropagation", { defaultValue: constFalse });

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/defaultServices.js
/** @internal */
const liveServices = /* @__PURE__ */ pipe$3(/* @__PURE__ */ empty$31(), /* @__PURE__ */ add$3(clockTag, /* @__PURE__ */ make$27()), /* @__PURE__ */ add$3(consoleTag, defaultConsole), /* @__PURE__ */ add$3(randomTag, /* @__PURE__ */ make$25(/* @__PURE__ */ Math.random())), /* @__PURE__ */ add$3(configProviderTag, /* @__PURE__ */ fromEnv()), /* @__PURE__ */ add$3(tracerTag, nativeTracer));
/**
* The `FiberRef` holding the default `Effect` services.
*
* @since 2.0.0
* @category fiberRefs
*/
const currentServices = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/DefaultServices/currentServices"), () => fiberRefUnsafeMakeContext(liveServices));
/** @internal */
const sleep$3 = (duration) => {
	const decodedDuration = decode$3(duration);
	return clockWith$3((clock$2) => clock$2.sleep(decodedDuration));
};
/** @internal */
const defaultServicesWith = (f$1) => withFiberRuntime$1((fiber) => f$1(fiber.currentDefaultServices));
/** @internal */
const clockWith$3 = (f$1) => defaultServicesWith((services) => f$1(services.unsafeMap.get(clockTag.key)));
/** @internal */
const currentTimeMillis$1 = /* @__PURE__ */ clockWith$3((clock$2) => clock$2.currentTimeMillis);
/** @internal */
const currentTimeNanos$1 = /* @__PURE__ */ clockWith$3((clock$2) => clock$2.currentTimeNanos);
/** @internal */
const withClock$1 = /* @__PURE__ */ dual$1(2, (effect, c$1) => fiberRefLocallyWith(currentServices, add$3(clockTag, c$1))(effect));
/** @internal */
const withConfigProvider$1 = /* @__PURE__ */ dual$1(2, (self, provider) => fiberRefLocallyWith(currentServices, add$3(configProviderTag, provider))(self));
/** @internal */
const configProviderWith$1 = (f$1) => defaultServicesWith((services) => f$1(services.unsafeMap.get(configProviderTag.key)));
/** @internal */
const randomWith$1 = (f$1) => defaultServicesWith((services) => f$1(services.unsafeMap.get(randomTag.key)));
/** @internal */
const withRandom$1 = /* @__PURE__ */ dual$1(2, (effect, value) => fiberRefLocallyWith(currentServices, add$3(randomTag, value))(effect));
/** @internal */
const tracerWith$3 = (f$1) => defaultServicesWith((services) => f$1(services.unsafeMap.get(tracerTag.key)));
/** @internal */
const withTracer$1 = /* @__PURE__ */ dual$1(2, (effect, value) => fiberRefLocallyWith(currentServices, add$3(tracerTag, value))(effect));

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Clock.js
/**
* @since 2.0.0
* @category symbols
*/
const ClockTypeId = ClockTypeId$1;
/**
* @since 2.0.0
* @category constructors
*/
const make$23 = make$27;
/**
* @since 2.0.0
* @category constructors
*/
const sleep$2 = sleep$3;
/**
* @since 2.0.0
* @category constructors
*/
const currentTimeMillis = currentTimeMillis$1;
/**
* @since 2.0.0
* @category constructors
*/
const currentTimeNanos = currentTimeNanos$1;
/**
* @since 2.0.0
* @category constructors
*/
const clockWith$2 = clockWith$3;
/**
* @since 2.0.0
* @category context
*/
const Clock = clockTag;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/fiberRefs.js
/** @internal */
function unsafeMake$5(fiberRefLocals) {
	return new FiberRefsImpl(fiberRefLocals);
}
/** @internal */
function empty$11() {
	return unsafeMake$5(/* @__PURE__ */ new Map());
}
/** @internal */
const FiberRefsSym$1 = /* @__PURE__ */ Symbol.for("effect/FiberRefs");
/** @internal */
var FiberRefsImpl = class {
	locals;
	[FiberRefsSym$1] = FiberRefsSym$1;
	constructor(locals) {
		this.locals = locals;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const findAncestor = (_ref, _parentStack, _childStack, _childModified = false) => {
	const ref = _ref;
	let parentStack = _parentStack;
	let childStack = _childStack;
	let childModified = _childModified;
	let ret = void 0;
	while (ret === void 0) if (isNonEmptyReadonlyArray(parentStack) && isNonEmptyReadonlyArray(childStack)) {
		const parentFiberId = headNonEmpty$1(parentStack)[0];
		const parentAncestors = tailNonEmpty$1(parentStack);
		const childFiberId = headNonEmpty$1(childStack)[0];
		const childRefValue = headNonEmpty$1(childStack)[1];
		const childAncestors = tailNonEmpty$1(childStack);
		if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {
			childStack = childAncestors;
			childModified = true;
		} else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) parentStack = parentAncestors;
		else if (parentFiberId.id < childFiberId.id) {
			childStack = childAncestors;
			childModified = true;
		} else if (parentFiberId.id > childFiberId.id) parentStack = parentAncestors;
		else ret = [childRefValue, childModified];
	} else ret = [ref.initial, true];
	return ret;
};
/** @internal */
const joinAs$1 = /* @__PURE__ */ dual$1(3, (self, fiberId$2, that) => {
	const parentFiberRefs = new Map(self.locals);
	that.locals.forEach((childStack, fiberRef) => {
		const childValue = childStack[0][1];
		if (!childStack[0][0][symbol](fiberId$2)) {
			if (!parentFiberRefs.has(fiberRef)) {
				if (equals(childValue, fiberRef.initial)) return;
				parentFiberRefs.set(fiberRef, [[fiberId$2, fiberRef.join(fiberRef.initial, childValue)]]);
				return;
			}
			const parentStack = parentFiberRefs.get(fiberRef);
			const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);
			if (wasModified) {
				const patch$11 = fiberRef.diff(ancestor, childValue);
				const oldValue = parentStack[0][1];
				const newValue = fiberRef.join(oldValue, fiberRef.patch(patch$11)(oldValue));
				if (!equals(oldValue, newValue)) {
					let newStack;
					const parentFiberId = parentStack[0][0];
					if (parentFiberId[symbol](fiberId$2)) newStack = [[parentFiberId, newValue], ...parentStack.slice(1)];
					else newStack = [[fiberId$2, newValue], ...parentStack];
					parentFiberRefs.set(fiberRef, newStack);
				}
			}
		}
	});
	return new FiberRefsImpl(parentFiberRefs);
});
/** @internal */
const forkAs$1 = /* @__PURE__ */ dual$1(2, (self, childId) => {
	const map$18 = /* @__PURE__ */ new Map();
	unsafeForkAs(self, map$18, childId);
	return new FiberRefsImpl(map$18);
});
const unsafeForkAs = (self, map$18, fiberId$2) => {
	self.locals.forEach((stack, fiberRef) => {
		const oldValue = stack[0][1];
		const newValue = fiberRef.patch(fiberRef.fork)(oldValue);
		if (equals(oldValue, newValue)) map$18.set(fiberRef, stack);
		else map$18.set(fiberRef, [[fiberId$2, newValue], ...stack]);
	});
};
/** @internal */
const fiberRefs$2 = (self) => fromIterable$6(self.locals.keys());
/** @internal */
const setAll$1 = (self) => forEachSequentialDiscard(fiberRefs$2(self), (fiberRef) => fiberRefSet(fiberRef, getOrDefault$1(self, fiberRef)));
/** @internal */
const delete_$1 = /* @__PURE__ */ dual$1(2, (self, fiberRef) => {
	const locals = new Map(self.locals);
	locals.delete(fiberRef);
	return new FiberRefsImpl(locals);
});
/** @internal */
const get$3 = /* @__PURE__ */ dual$1(2, (self, fiberRef) => {
	if (!self.locals.has(fiberRef)) return none$7();
	return some$4(headNonEmpty$1(self.locals.get(fiberRef))[1]);
});
/** @internal */
const getOrDefault$1 = /* @__PURE__ */ dual$1(2, (self, fiberRef) => pipe$3(get$3(self, fiberRef), getOrElse$5(() => fiberRef.initial)));
/** @internal */
const updateAs$1 = /* @__PURE__ */ dual$1(2, (self, { fiberId: fiberId$2, fiberRef, value }) => {
	if (self.locals.size === 0) return new FiberRefsImpl(new Map([[fiberRef, [[fiberId$2, value]]]]));
	const locals = new Map(self.locals);
	unsafeUpdateAs(locals, fiberId$2, fiberRef, value);
	return new FiberRefsImpl(locals);
});
const unsafeUpdateAs = (locals, fiberId$2, fiberRef, value) => {
	const oldStack = locals.get(fiberRef) ?? [];
	let newStack;
	if (isNonEmptyReadonlyArray(oldStack)) {
		const [currentId, currentValue] = headNonEmpty$1(oldStack);
		if (currentId[symbol](fiberId$2)) if (equals(currentValue, value)) return;
		else newStack = [[fiberId$2, value], ...oldStack.slice(1)];
		else newStack = [[fiberId$2, value], ...oldStack];
	} else newStack = [[fiberId$2, value]];
	locals.set(fiberRef, newStack);
};
/** @internal */
const updateManyAs$1 = /* @__PURE__ */ dual$1(2, (self, { entries: entries$2, forkAs: forkAs$2 }) => {
	if (self.locals.size === 0) return new FiberRefsImpl(new Map(entries$2));
	const locals = new Map(self.locals);
	if (forkAs$2 !== void 0) unsafeForkAs(self, locals, forkAs$2);
	entries$2.forEach(([fiberRef, values$6]) => {
		if (values$6.length === 1) unsafeUpdateAs(locals, values$6[0][0], fiberRef, values$6[0][1]);
		else values$6.forEach(([fiberId$2, value]) => {
			unsafeUpdateAs(locals, fiberId$2, fiberRef, value);
		});
	});
	return new FiberRefsImpl(locals);
});

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/FiberRefs.js
/**
* @since 2.0.0
* @category symbols
*/
const FiberRefsSym = FiberRefsSym$1;
const delete_ = delete_$1;
/**
* Returns a set of each `FiberRef` in this collection.
*
* @since 2.0.0
* @category getters
*/
const fiberRefs$1 = fiberRefs$2;
/**
* Forks this collection of fiber refs as the specified child fiber id. This
* will potentially modify the value of the fiber refs, as determined by the
* individual fiber refs that make up the collection.
*
* @since 2.0.0
* @category utils
*/
const forkAs = forkAs$1;
/**
* Gets the value of the specified `FiberRef` in this collection of `FiberRef`
* values if it exists or `None` otherwise.
*
* @since 2.0.0
* @category getters
*/
const get$2 = get$3;
/**
* Gets the value of the specified `FiberRef` in this collection of `FiberRef`
* values if it exists or the `initial` value of the `FiberRef` otherwise.
*
* @since 2.0.0
* @category getters
*/
const getOrDefault = getOrDefault$1;
/**
* Joins this collection of fiber refs to the specified collection, as the
* specified fiber id. This will perform diffing and merging to ensure
* preservation of maximum information from both child and parent refs.
*
* @since 2.0.0
* @category utils
*/
const joinAs = joinAs$1;
/**
* Set each ref to either its value or its default.
*
* @since 2.0.0
* @category utils
*/
const setAll = setAll$1;
/**
* Updates the value of the specified `FiberRef` using the provided `FiberId`
*
* @since 2.0.0
* @category utils
*/
const updateAs = updateAs$1;
/**
* Updates the values of the specified `FiberRef` & value pairs using the provided `FiberId`
*
* @since 2.0.0
* @category utils
*/
const updateManyAs = updateManyAs$1;
/**
* Note: it will not copy the provided Map, make sure to provide a fresh one.
*
* @since 2.0.0
* @category unsafe
*/
const unsafeMake$4 = unsafeMake$5;
/**
* The empty collection of `FiberRef` values.
*
* @category constructors
* @since 2.0.0
*/
const empty$10 = empty$11;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/LogLevel.js
/**
* @since 2.0.0
* @category constructors
*/
const All = logLevelAll;
/**
* @since 2.0.0
* @category constructors
*/
const Fatal = logLevelFatal;
/**
* @since 2.0.0
* @category constructors
*/
const Error$2 = logLevelError;
/**
* @since 2.0.0
* @category constructors
*/
const Warning = logLevelWarning;
/**
* @since 2.0.0
* @category constructors
*/
const Info = logLevelInfo;
/**
* @since 2.0.0
* @category constructors
*/
const Debug = logLevelDebug;
/**
* @since 2.0.0
* @category constructors
*/
const Trace = logLevelTrace;
/**
* @since 2.0.0
* @category constructors
*/
const None = logLevelNone;
/**
* @since 2.0.0
* @category constructors
*/
const allLevels = allLogLevels;
/**
* @since 2.0.0
* @category instances
*/
const Order$2 = /* @__PURE__ */ pipe$3(Order$4, /* @__PURE__ */ mapInput((level) => level.ordinal));
/**
* @since 2.0.0
* @category ordering
*/
const greaterThan$2 = /* @__PURE__ */ greaterThan$3(Order$2);
/**
* @since 2.0.0
* @category conversions
*/
const fromLiteral = (literal) => {
	switch (literal) {
		case "All": return All;
		case "Debug": return Debug;
		case "Error": return Error$2;
		case "Fatal": return Fatal;
		case "Info": return Info;
		case "Trace": return Trace;
		case "None": return None;
		case "Warning": return Warning;
	}
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/logSpan.js
/** @internal */
const make$22 = (label, startTime) => ({
	label,
	startTime
});
/**
* Sanitize a given string by replacing spaces, equal signs, and double quotes with underscores.
*
* @internal
*/
const formatLabel = (key) => key.replace(/[\s="]/g, "_");
/** @internal */
const render$1 = (now) => (self) => {
	return `${formatLabel(self.label)}=${now - self.startTime}ms`;
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/LogSpan.js
/**
* @since 2.0.0
* @category constructors
*/
const make$21 = make$22;
/**
* @since 2.0.0
* @category destructors
*/
const render = render$1;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Effectable.js
/**
* @since 2.0.0
* @category type ids
*/
const EffectTypeId$1 = EffectTypeId$3;
/**
* @since 2.0.0
* @category type ids
*/
const StreamTypeId = StreamTypeId$1;
/**
* @since 2.0.0
* @category type ids
*/
const SinkTypeId = SinkTypeId$1;
/**
* @since 2.0.0
* @category type ids
*/
const ChannelTypeId = ChannelTypeId$1;
/**
* @since 2.0.0
* @category prototypes
*/
const EffectPrototype = EffectPrototype$1;
/**
* @since 2.0.0
* @category prototypes
*/
const CommitPrototype = CommitPrototype$1;
/**
* @since 2.0.0
* @category prototypes
*/
const StructuralCommitPrototype = StructuralCommitPrototype$1;
const Base = Base$1;
const StructuralBase = StructuralBase$1;
/**
* @since 2.0.0
* @category constructors
*/
var Class$3 = class extends Base {};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Readable.js
/**
* @since 2.0.0
* @category type ids
*/
const TypeId$7 = /* @__PURE__ */ Symbol.for("effect/Readable");
const Proto = {
	[TypeId$7]: TypeId$7,
	pipe() {
		return pipeArguments(this, arguments);
	}
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/ref.js
/** @internal */
const RefTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Ref");
/** @internal */
const refVariance = { _A: (_$1) => _$1 };
var RefImpl = class extends Class$3 {
	ref;
	commit() {
		return this.get;
	}
	[RefTypeId$1] = refVariance;
	[TypeId$7] = TypeId$7;
	constructor(ref) {
		super();
		this.ref = ref;
		this.get = sync$3(() => get$6(this.ref));
	}
	get;
	modify(f$1) {
		return sync$3(() => {
			const current = get$6(this.ref);
			const [b$1, a$1] = f$1(current);
			if (current !== a$1) set$4(a$1)(this.ref);
			return b$1;
		});
	}
};
/** @internal */
const unsafeMake$3 = (value) => new RefImpl(make$37(value));
/** @internal */
const make$20 = (value) => sync$3(() => unsafeMake$3(value));
/** @internal */
const get$1 = (self) => self.get;
/** @internal */
const set$1 = /* @__PURE__ */ dual$1(2, (self, value) => self.modify(() => [void 0, value]));
/** @internal */
const getAndSet$1 = /* @__PURE__ */ dual$1(2, (self, value) => self.modify((a$1) => [a$1, value]));
/** @internal */
const getAndUpdate$1 = /* @__PURE__ */ dual$1(2, (self, f$1) => self.modify((a$1) => [a$1, f$1(a$1)]));
/** @internal */
const getAndUpdateSome$1 = /* @__PURE__ */ dual$1(2, (self, pf) => self.modify((value) => {
	const option$2 = pf(value);
	switch (option$2._tag) {
		case "None": return [value, value];
		case "Some": return [value, option$2.value];
	}
}));
/** @internal */
const setAndGet$1 = /* @__PURE__ */ dual$1(2, (self, value) => self.modify(() => [value, value]));
/** @internal */
const modify$1 = /* @__PURE__ */ dual$1(2, (self, f$1) => self.modify(f$1));
/** @internal */
const modifySome$1 = /* @__PURE__ */ dual$1(3, (self, fallback, pf) => self.modify((value) => {
	const option$2 = pf(value);
	switch (option$2._tag) {
		case "None": return [fallback, value];
		case "Some": return option$2.value;
	}
}));
/** @internal */
const update$3 = /* @__PURE__ */ dual$1(2, (self, f$1) => self.modify((a$1) => [void 0, f$1(a$1)]));
/** @internal */
const updateAndGet$1 = /* @__PURE__ */ dual$1(2, (self, f$1) => self.modify((a$1) => {
	const result = f$1(a$1);
	return [result, result];
}));
/** @internal */
const updateSome$1 = /* @__PURE__ */ dual$1(2, (self, f$1) => self.modify((a$1) => [void 0, match$11(f$1(a$1), {
	onNone: () => a$1,
	onSome: (b$1) => b$1
})]));
/** @internal */
const updateSomeAndGet$1 = /* @__PURE__ */ dual$1(2, (self, pf) => self.modify((value) => {
	const option$2 = pf(value);
	switch (option$2._tag) {
		case "None": return [value, value];
		case "Some": return [option$2.value, option$2.value];
	}
}));

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Ref.js
/**
* @since 2.0.0
* @category symbols
*/
const RefTypeId = RefTypeId$1;
/**
* @since 2.0.0
* @category constructors
*/
const make$19 = make$20;
/**
* @since 2.0.0
* @category getters
*/
const get = get$1;
/**
* @since 2.0.0
* @category utils
*/
const getAndSet = getAndSet$1;
/**
* @since 2.0.0
* @category utils
*/
const getAndUpdate = getAndUpdate$1;
/**
* @since 2.0.0
* @category utils
*/
const getAndUpdateSome = getAndUpdateSome$1;
/**
* @since 2.0.0
* @category utils
*/
const modify = modify$1;
/**
* @since 2.0.0
* @category utils
*/
const modifySome = modifySome$1;
/**
* @since 2.0.0
* @category utils
*/
const set = set$1;
/**
* @since 2.0.0
* @category utils
*/
const setAndGet = setAndGet$1;
/**
* @since 2.0.0
* @category utils
*/
const update$2 = update$3;
/**
* @since 2.0.0
* @category utils
*/
const updateAndGet = updateAndGet$1;
/**
* @since 2.0.0
* @category utils
*/
const updateSome = updateSome$1;
/**
* @since 2.0.0
* @category utils
*/
const updateSomeAndGet = updateSomeAndGet$1;
/**
* @since 2.0.0
* @category unsafe
*/
const unsafeMake$2 = unsafeMake$3;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Tracer.js
/**
* @since 2.0.0
*/
const TracerTypeId = TracerTypeId$1;
/**
* @since 2.0.0
* @category tags
*/
const ParentSpan = spanTag;
/**
* @since 2.0.0
* @category tags
*/
const Tracer = tracerTag;
/**
* @since 2.0.0
* @category constructors
*/
const make$18 = make$24;
/**
* @since 2.0.0
* @category constructors
*/
const externalSpan = externalSpan$1;
/**
* @since 2.0.0
* @category constructors
*/
const tracerWith$2 = tracerWith$3;
/**
* @since 3.12.0
* @category annotations
*/
const DisablePropagation = DisablePropagation$1;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/fiberRefs/patch.js
/** @internal */
const OP_EMPTY$1 = "Empty";
/** @internal */
const OP_ADD = "Add";
/** @internal */
const OP_REMOVE = "Remove";
/** @internal */
const OP_UPDATE = "Update";
/** @internal */
const OP_AND_THEN$1 = "AndThen";
/** @internal */
const empty$9 = { _tag: OP_EMPTY$1 };
/** @internal */
const diff$2 = (oldValue, newValue) => {
	const missingLocals = new Map(oldValue.locals);
	let patch$11 = empty$9;
	for (const [fiberRef, pairs] of newValue.locals.entries()) {
		const newValue$1 = headNonEmpty$1(pairs)[1];
		const old = missingLocals.get(fiberRef);
		if (old !== void 0) {
			const oldValue$1 = headNonEmpty$1(old)[1];
			if (!equals(oldValue$1, newValue$1)) patch$11 = combine$2({
				_tag: OP_UPDATE,
				fiberRef,
				patch: fiberRef.diff(oldValue$1, newValue$1)
			})(patch$11);
		} else patch$11 = combine$2({
			_tag: OP_ADD,
			fiberRef,
			value: newValue$1
		})(patch$11);
		missingLocals.delete(fiberRef);
	}
	for (const [fiberRef] of missingLocals.entries()) patch$11 = combine$2({
		_tag: OP_REMOVE,
		fiberRef
	})(patch$11);
	return patch$11;
};
/** @internal */
const combine$2 = /* @__PURE__ */ dual$1(2, (self, that) => ({
	_tag: OP_AND_THEN$1,
	first: self,
	second: that
}));
/** @internal */
const patch$2 = /* @__PURE__ */ dual$1(3, (self, fiberId$2, oldValue) => {
	let fiberRefs$3 = oldValue;
	let patches = of$4(self);
	while (isNonEmptyReadonlyArray(patches)) {
		const head$4 = headNonEmpty$1(patches);
		const tail = tailNonEmpty$1(patches);
		switch (head$4._tag) {
			case OP_EMPTY$1:
				patches = tail;
				break;
			case OP_ADD:
				fiberRefs$3 = updateAs$1(fiberRefs$3, {
					fiberId: fiberId$2,
					fiberRef: head$4.fiberRef,
					value: head$4.value
				});
				patches = tail;
				break;
			case OP_REMOVE:
				fiberRefs$3 = delete_$1(fiberRefs$3, head$4.fiberRef);
				patches = tail;
				break;
			case OP_UPDATE: {
				const value = getOrDefault$1(fiberRefs$3, head$4.fiberRef);
				fiberRefs$3 = updateAs$1(fiberRefs$3, {
					fiberId: fiberId$2,
					fiberRef: head$4.fiberRef,
					value: head$4.fiberRef.patch(head$4.patch)(value)
				});
				patches = tail;
				break;
			}
			case OP_AND_THEN$1:
				patches = prepend$2(head$4.first)(prepend$2(head$4.second)(tail));
				break;
		}
	}
	return fiberRefs$3;
});

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/metric/label.js
/** @internal */
const MetricLabelSymbolKey = "effect/MetricLabel";
/** @internal */
const MetricLabelTypeId = /* @__PURE__ */ Symbol.for(MetricLabelSymbolKey);
/** @internal */
var MetricLabelImpl = class {
	key;
	value;
	[MetricLabelTypeId] = MetricLabelTypeId;
	_hash;
	constructor(key, value) {
		this.key = key;
		this.value = value;
		this._hash = string(MetricLabelSymbolKey + this.key + this.value);
	}
	[symbol$1]() {
		return this._hash;
	}
	[symbol](that) {
		return isMetricLabel(that) && this.key === that.key && this.value === that.value;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const make$17 = (key, value) => {
	return new MetricLabelImpl(key, value);
};
/** @internal */
const isMetricLabel = (u$1) => hasProperty(u$1, MetricLabelTypeId);

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/core-effect.js
const annotateLogs$1 = /* @__PURE__ */ dual$1((args$2) => isEffect$1(args$2[0]), function() {
	const args$2 = arguments;
	return fiberRefLocallyWith(args$2[0], currentLogAnnotations, typeof args$2[1] === "string" ? set$3(args$2[1], args$2[2]) : (annotations$1) => Object.entries(args$2[1]).reduce((acc, [key, value]) => set$3(acc, key, value), annotations$1));
});
const asSome$1 = (self) => map$9(self, some$4);
const asSomeError$1 = (self) => mapError$3(self, some$4);
const try_$1 = (arg) => {
	let evaluate$1;
	let onFailure = void 0;
	if (typeof arg === "function") evaluate$1 = arg;
	else {
		evaluate$1 = arg.try;
		onFailure = arg.catch;
	}
	return suspend$3(() => {
		try {
			return succeed$9(internalCall(evaluate$1));
		} catch (error) {
			return fail$9(onFailure ? internalCall(() => onFailure(error)) : new UnknownException$1(error, "An unknown error occurred in Effect.try"));
		}
	});
};
const _catch$1 = /* @__PURE__ */ dual$1(3, (self, tag$1, options) => catchAll$1(self, (e) => {
	if (hasProperty(e, tag$1) && e[tag$1] === options.failure) return options.onFailure(e);
	return fail$9(e);
}));
const catchAllDefect$1 = /* @__PURE__ */ dual$1(2, (self, f$1) => catchAllCause$1(self, (cause$2) => {
	const option$2 = find$1(cause$2, (_$1) => isDieType$1(_$1) ? some$4(_$1) : none$7());
	switch (option$2._tag) {
		case "None": return failCause$8(cause$2);
		case "Some": return f$1(option$2.value.defect);
	}
}));
const catchSomeCause$1 = /* @__PURE__ */ dual$1(2, (self, f$1) => matchCauseEffect$2(self, {
	onFailure: (cause$2) => {
		const option$2 = f$1(cause$2);
		switch (option$2._tag) {
			case "None": return failCause$8(cause$2);
			case "Some": return option$2.value;
		}
	},
	onSuccess: succeed$9
}));
const catchSomeDefect$1 = /* @__PURE__ */ dual$1(2, (self, pf) => catchAllCause$1(self, (cause$2) => {
	const option$2 = find$1(cause$2, (_$1) => isDieType$1(_$1) ? some$4(_$1) : none$7());
	switch (option$2._tag) {
		case "None": return failCause$8(cause$2);
		case "Some": {
			const optionEffect = pf(option$2.value.defect);
			return optionEffect._tag === "Some" ? optionEffect.value : failCause$8(cause$2);
		}
	}
}));
const catchTag$1 = /* @__PURE__ */ dual$1((args$2) => isEffect$1(args$2[0]), (self, ...args$2) => {
	const f$1 = args$2[args$2.length - 1];
	let predicate;
	if (args$2.length === 2) predicate = isTagged(args$2[0]);
	else predicate = (e) => {
		const tag$1 = hasProperty(e, "_tag") ? e["_tag"] : void 0;
		if (!tag$1) return false;
		for (let i$1 = 0; i$1 < args$2.length - 1; i$1++) if (args$2[i$1] === tag$1) return true;
		return false;
	};
	return catchIf$1(self, predicate, f$1);
});
/** @internal */
const catchTags$1 = /* @__PURE__ */ dual$1(2, (self, cases) => {
	let keys$5;
	return catchIf$1(self, (e) => {
		keys$5 ??= Object.keys(cases);
		return hasProperty(e, "_tag") && isString(e["_tag"]) && keys$5.includes(e["_tag"]);
	}, (e) => cases[e["_tag"]](e));
});
const cause$1 = (self) => matchCause$2(self, {
	onFailure: identity$2,
	onSuccess: () => empty$15
});
const clockWith$1 = clockWith$2;
const clock$1 = /* @__PURE__ */ clockWith$1(succeed$9);
const delay$1 = /* @__PURE__ */ dual$1(2, (self, duration) => zipRight$3(sleep$2(duration), self));
const descriptorWith$1 = (f$1) => withFiberRuntime$1((state, status$2) => f$1({
	id: state.id(),
	status: status$2,
	interruptors: interruptors$1(state.getFiberRef(currentInterruptedCause))
}));
const allowInterrupt$1 = /* @__PURE__ */ descriptorWith$1((descriptor$2) => size$8(descriptor$2.interruptors) > 0 ? interrupt$5 : void_$4);
const descriptor$1 = /* @__PURE__ */ descriptorWith$1(succeed$9);
const diffFiberRefs$1 = (self) => summarized$1(self, fiberRefs, diff$2);
const diffFiberRefsAndRuntimeFlags = (self) => summarized$1(self, zip$4(fiberRefs, runtimeFlags), ([refs, flags], [refsNew, flagsNew]) => [diff$2(refs, refsNew), diff$3(flags, flagsNew)]);
const Do$1 = /* @__PURE__ */ succeed$9({});
const bind$1 = /* @__PURE__ */ bind$2(map$9, flatMap$5);
const bindTo$1 = /* @__PURE__ */ bindTo$2(map$9);
const let_$1 = /* @__PURE__ */ let_$2(map$9);
const dropUntil$1 = /* @__PURE__ */ dual$1(2, (elements, predicate) => suspend$3(() => {
	const iterator = elements[Symbol.iterator]();
	const builder = [];
	let next;
	let dropping = succeed$9(false);
	let i$1 = 0;
	while ((next = iterator.next()) && !next.done) {
		const a$1 = next.value;
		const index = i$1++;
		dropping = flatMap$5(dropping, (bool) => {
			if (bool) {
				builder.push(a$1);
				return succeed$9(true);
			}
			return predicate(a$1, index);
		});
	}
	return map$9(dropping, () => builder);
}));
const dropWhile$1 = /* @__PURE__ */ dual$1(2, (elements, predicate) => suspend$3(() => {
	const iterator = elements[Symbol.iterator]();
	const builder = [];
	let next;
	let dropping = succeed$9(true);
	let i$1 = 0;
	while ((next = iterator.next()) && !next.done) {
		const a$1 = next.value;
		const index = i$1++;
		dropping = flatMap$5(dropping, (d) => map$9(d ? predicate(a$1, index) : succeed$9(false), (b$1) => {
			if (!b$1) builder.push(a$1);
			return b$1;
		}));
	}
	return map$9(dropping, () => builder);
}));
const contextWith$1 = (f$1) => map$9(context$1(), f$1);
const eventually$1 = (self) => orElse$4(self, () => flatMap$5(yieldNow$3(), () => eventually$1(self)));
const filterMap$1 = /* @__PURE__ */ dual$1(2, (elements, pf) => map$9(forEachSequential(elements, identity$2), filterMap$4(pf)));
const filterOrDie$1 = /* @__PURE__ */ dual$1(3, (self, predicate, orDieWith$2) => filterOrElse$1(self, predicate, (a$1) => dieSync$2(() => orDieWith$2(a$1))));
const filterOrDieMessage$1 = /* @__PURE__ */ dual$1(3, (self, predicate, message) => filterOrElse$1(self, predicate, () => dieMessage$1(message)));
const filterOrElse$1 = /* @__PURE__ */ dual$1(3, (self, predicate, orElse$6) => flatMap$5(self, (a$1) => predicate(a$1) ? succeed$9(a$1) : orElse$6(a$1)));
/** @internal */
const liftPredicate$1 = /* @__PURE__ */ dual$1(3, (self, predicate, orFailWith) => suspend$3(() => predicate(self) ? succeed$9(self) : fail$9(orFailWith(self))));
const filterOrFail$1 = /* @__PURE__ */ dual$1((args$2) => isEffect$1(args$2[0]), (self, predicate, orFailWith) => filterOrElse$1(self, predicate, (a$1) => orFailWith === void 0 ? fail$9(new NoSuchElementException$1()) : failSync$2(() => orFailWith(a$1))));
const findFirst$3 = /* @__PURE__ */ dual$1(2, (elements, predicate) => suspend$3(() => {
	const iterator = elements[Symbol.iterator]();
	const next = iterator.next();
	if (!next.done) return findLoop(iterator, 0, predicate, next.value);
	return succeed$9(none$7());
}));
const findLoop = (iterator, index, f$1, value) => flatMap$5(f$1(value, index), (result) => {
	if (result) return succeed$9(some$4(value));
	const next = iterator.next();
	if (!next.done) return findLoop(iterator, index + 1, f$1, next.value);
	return succeed$9(none$7());
});
const firstSuccessOf$1 = (effects) => suspend$3(() => {
	const list = fromIterable$9(effects);
	if (!isNonEmpty$4(list)) return dieSync$2(() => new IllegalArgumentException$1(`Received an empty collection of effects`));
	return pipe$3(tailNonEmpty(list), reduce$12(headNonEmpty(list), (left$2, right$2) => orElse$4(left$2, () => right$2)));
});
const flipWith$1 = /* @__PURE__ */ dual$1(2, (self, f$1) => flip$1(f$1(flip$1(self))));
const match$7 = /* @__PURE__ */ dual$1(2, (self, options) => matchEffect$2(self, {
	onFailure: (e) => succeed$9(options.onFailure(e)),
	onSuccess: (a$1) => succeed$9(options.onSuccess(a$1))
}));
const every$1 = /* @__PURE__ */ dual$1(2, (elements, predicate) => suspend$3(() => forAllLoop(elements[Symbol.iterator](), 0, predicate)));
const forAllLoop = (iterator, index, f$1) => {
	const next = iterator.next();
	return next.done ? succeed$9(true) : flatMap$5(f$1(next.value, index), (b$1) => b$1 ? forAllLoop(iterator, index + 1, f$1) : succeed$9(b$1));
};
const forever$2 = (self) => {
	const loop$2 = flatMap$5(flatMap$5(self, () => yieldNow$3()), () => loop$2);
	return loop$2;
};
const fiberRefs = /* @__PURE__ */ withFiberRuntime$1((state) => succeed$9(state.getFiberRefs()));
const head$1 = (self) => flatMap$5(self, (as$6) => {
	const next = as$6[Symbol.iterator]().next();
	if (next.done) return fail$9(new NoSuchElementException$1());
	return succeed$9(next.value);
});
const ignore$1 = (self) => match$7(self, {
	onFailure: constVoid$1,
	onSuccess: constVoid$1
});
const ignoreLogged$1 = (self) => matchCauseEffect$2(self, {
	onFailure: (cause$2) => logDebug$1(cause$2, "An error was silently ignored because it is not anticipated to be useful"),
	onSuccess: () => void_$4
});
const inheritFiberRefs$1 = (childFiberRefs) => updateFiberRefs$1((parentFiberId, parentFiberRefs) => joinAs(parentFiberRefs, parentFiberId, childFiberRefs));
const isFailure$2 = (self) => match$7(self, {
	onFailure: constTrue,
	onSuccess: constFalse
});
const isSuccess$1 = (self) => match$7(self, {
	onFailure: constFalse,
	onSuccess: constTrue
});
const iterate$1 = (initial, options) => suspend$3(() => {
	if (options.while(initial)) return flatMap$5(options.body(initial), (z2) => iterate$1(z2, options));
	return succeed$9(initial);
});
/** @internal */
const logWithLevel = (level) => (...message) => {
	const levelOption = fromNullable$2(level);
	let cause$2 = void 0;
	for (let i$1 = 0, len = message.length; i$1 < len; i$1++) {
		const msg = message[i$1];
		if (isCause$1(msg)) {
			if (cause$2 !== void 0) cause$2 = sequential$3(cause$2, msg);
			else cause$2 = msg;
			message = [...message.slice(0, i$1), ...message.slice(i$1 + 1)];
			i$1--;
		}
	}
	if (cause$2 === void 0) cause$2 = empty$15;
	return withFiberRuntime$1((fiberState) => {
		fiberState.log(message, cause$2, levelOption);
		return void_$4;
	});
};
/** @internal */
const log$1 = /* @__PURE__ */ logWithLevel();
/** @internal */
const logTrace$1 = /* @__PURE__ */ logWithLevel(Trace);
/** @internal */
const logDebug$1 = /* @__PURE__ */ logWithLevel(Debug);
/** @internal */
const logInfo$1 = /* @__PURE__ */ logWithLevel(Info);
/** @internal */
const logWarning$1 = /* @__PURE__ */ logWithLevel(Warning);
/** @internal */
const logError$1 = /* @__PURE__ */ logWithLevel(Error$2);
/** @internal */
const logFatal$1 = /* @__PURE__ */ logWithLevel(Fatal);
const withLogSpan$1 = /* @__PURE__ */ dual$1(2, (effect, label) => flatMap$5(currentTimeMillis, (now) => fiberRefLocallyWith(effect, currentLogSpan, prepend(make$21(label, now)))));
const logAnnotations$1 = /* @__PURE__ */ fiberRefGet(currentLogAnnotations);
const loop$1 = (initial, options) => options.discard ? loopDiscard(initial, options.while, options.step, options.body) : map$9(loopInternal(initial, options.while, options.step, options.body), fromIterable$10);
const loopInternal = (initial, cont, inc, body) => suspend$3(() => cont(initial) ? flatMap$5(body(initial), (a$1) => map$9(loopInternal(inc(initial), cont, inc, body), prepend(a$1))) : sync$3(() => empty$25()));
const loopDiscard = (initial, cont, inc, body) => suspend$3(() => cont(initial) ? flatMap$5(body(initial), () => loopDiscard(inc(initial), cont, inc, body)) : void_$4);
const mapAccum$1 = /* @__PURE__ */ dual$1(3, (elements, initial, f$1) => suspend$3(() => {
	const iterator = elements[Symbol.iterator]();
	const builder = [];
	let result = succeed$9(initial);
	let next;
	let i$1 = 0;
	while (!(next = iterator.next()).done) {
		const index = i$1++;
		const value = next.value;
		result = flatMap$5(result, (state) => map$9(f$1(state, value, index), ([z, b$1]) => {
			builder.push(b$1);
			return z;
		}));
	}
	return map$9(result, (z) => [z, builder]);
}));
const mapErrorCause$1 = /* @__PURE__ */ dual$1(2, (self, f$1) => matchCauseEffect$2(self, {
	onFailure: (c$1) => failCauseSync$2(() => f$1(c$1)),
	onSuccess: succeed$9
}));
const memoize = (self) => pipe$3(deferredMake(), flatMap$5((deferred) => pipe$3(diffFiberRefsAndRuntimeFlags(self), intoDeferred$1(deferred), once$2, map$9((complete$4) => zipRight$3(complete$4, pipe$3(deferredAwait(deferred), flatMap$5(([patch$11, a$1]) => as$4(zip$4(patchFiberRefs$1(patch$11[0]), updateRuntimeFlags(patch$11[1])), a$1))))))));
const merge$2 = (self) => matchEffect$2(self, {
	onFailure: (e) => succeed$9(e),
	onSuccess: succeed$9
});
const negate$1 = (self) => map$9(self, (b$1) => !b$1);
const none$4 = (self) => flatMap$5(self, (option$2) => {
	switch (option$2._tag) {
		case "None": return void_$4;
		case "Some": return fail$9(new NoSuchElementException$1());
	}
});
const once$2 = (self) => map$9(make$19(true), (ref) => asVoid$3(whenEffect$1(self, getAndSet(ref, false))));
const option$1 = (self) => matchEffect$2(self, {
	onFailure: () => succeed$9(none$7()),
	onSuccess: (a$1) => succeed$9(some$4(a$1))
});
const orElseFail$1 = /* @__PURE__ */ dual$1(2, (self, evaluate$1) => orElse$4(self, () => failSync$2(evaluate$1)));
const orElseSucceed$1 = /* @__PURE__ */ dual$1(2, (self, evaluate$1) => orElse$4(self, () => sync$3(evaluate$1)));
const parallelErrors$1 = (self) => matchCauseEffect$2(self, {
	onFailure: (cause$2) => {
		const errors = fromIterable$10(failures$1(cause$2));
		return errors.length === 0 ? failCause$8(cause$2) : fail$9(errors);
	},
	onSuccess: succeed$9
});
const patchFiberRefs$1 = (patch$11) => updateFiberRefs$1((fiberId$2, fiberRefs$3) => pipe$3(patch$11, patch$2(fiberId$2, fiberRefs$3)));
const promise$1 = (evaluate$1) => evaluate$1.length >= 1 ? async_((resolve, signal) => {
	try {
		evaluate$1(signal).then((a$1) => resolve(succeed$9(a$1)), (e) => resolve(die$4(e)));
	} catch (e) {
		resolve(die$4(e));
	}
}) : async_((resolve) => {
	try {
		evaluate$1().then((a$1) => resolve(succeed$9(a$1)), (e) => resolve(die$4(e)));
	} catch (e) {
		resolve(die$4(e));
	}
});
const provideService$1 = /* @__PURE__ */ dual$1(3, (self, tag$1, service) => contextWithEffect$1((env$2) => provideContext$1(self, add$3(env$2, tag$1, service))));
const provideServiceEffect$1 = /* @__PURE__ */ dual$1(3, (self, tag$1, effect) => contextWithEffect$1((env$2) => flatMap$5(effect, (service) => provideContext$1(self, pipe$3(env$2, add$3(tag$1, service))))));
const random$1 = /* @__PURE__ */ randomWith$1(succeed$9);
const reduce$4 = /* @__PURE__ */ dual$1(3, (elements, zero$1, f$1) => fromIterable$10(elements).reduce((acc, el, i$1) => flatMap$5(acc, (a$1) => f$1(a$1, el, i$1)), succeed$9(zero$1)));
const reduceRight$1 = /* @__PURE__ */ dual$1(3, (elements, zero$1, f$1) => fromIterable$10(elements).reduceRight((acc, el, i$1) => flatMap$5(acc, (a$1) => f$1(el, a$1, i$1)), succeed$9(zero$1)));
const reduceWhile$1 = /* @__PURE__ */ dual$1(3, (elements, zero$1, options) => flatMap$5(sync$3(() => elements[Symbol.iterator]()), (iterator) => reduceWhileLoop(iterator, 0, zero$1, options.while, options.body)));
const reduceWhileLoop = (iterator, index, state, predicate, f$1) => {
	const next = iterator.next();
	if (!next.done && predicate(state)) return flatMap$5(f$1(state, next.value, index), (nextState) => reduceWhileLoop(iterator, index + 1, nextState, predicate, f$1));
	return succeed$9(state);
};
const repeatN$1 = /* @__PURE__ */ dual$1(2, (self, n$1) => suspend$3(() => repeatNLoop(self, n$1)));
const repeatNLoop = (self, n$1) => flatMap$5(self, (a$1) => n$1 <= 0 ? succeed$9(a$1) : zipRight$3(yieldNow$3(), repeatNLoop(self, n$1 - 1)));
const sandbox$1 = (self) => matchCauseEffect$2(self, {
	onFailure: fail$9,
	onSuccess: succeed$9
});
const setFiberRefs$1 = (fiberRefs$3) => suspend$3(() => setAll(fiberRefs$3));
const sleep$1 = sleep$2;
const succeedNone$1 = /* @__PURE__ */ succeed$9(/* @__PURE__ */ none$7());
const succeedSome$1 = (value) => succeed$9(some$4(value));
const summarized$1 = /* @__PURE__ */ dual$1(3, (self, summary$2, f$1) => flatMap$5(summary$2, (start$2) => flatMap$5(self, (value) => map$9(summary$2, (end$2) => [f$1(start$2, end$2), value]))));
const tagMetrics$1 = /* @__PURE__ */ dual$1((args$2) => isEffect$1(args$2[0]), function() {
	return labelMetrics$1(arguments[0], typeof arguments[1] === "string" ? [make$17(arguments[1], arguments[2])] : Object.entries(arguments[1]).map(([k, v]) => make$17(k, v)));
});
const labelMetrics$1 = /* @__PURE__ */ dual$1(2, (self, labels) => fiberRefLocallyWith(self, currentMetricLabels, (old) => union$8(old, labels)));
const takeUntil$1 = /* @__PURE__ */ dual$1(2, (elements, predicate) => suspend$3(() => {
	const iterator = elements[Symbol.iterator]();
	const builder = [];
	let next;
	let effect = succeed$9(false);
	let i$1 = 0;
	while ((next = iterator.next()) && !next.done) {
		const a$1 = next.value;
		const index = i$1++;
		effect = flatMap$5(effect, (bool) => {
			if (bool) return succeed$9(true);
			builder.push(a$1);
			return predicate(a$1, index);
		});
	}
	return map$9(effect, () => builder);
}));
const takeWhile$1 = /* @__PURE__ */ dual$1(2, (elements, predicate) => suspend$3(() => {
	const iterator = elements[Symbol.iterator]();
	const builder = [];
	let next;
	let taking = succeed$9(true);
	let i$1 = 0;
	while ((next = iterator.next()) && !next.done) {
		const a$1 = next.value;
		const index = i$1++;
		taking = flatMap$5(taking, (taking$1) => pipe$3(taking$1 ? predicate(a$1, index) : succeed$9(false), map$9((bool) => {
			if (bool) builder.push(a$1);
			return bool;
		})));
	}
	return map$9(taking, () => builder);
}));
const tapBoth$1 = /* @__PURE__ */ dual$1(2, (self, { onFailure, onSuccess }) => matchCauseEffect$2(self, {
	onFailure: (cause$2) => {
		const either$4 = failureOrCause$1(cause$2);
		switch (either$4._tag) {
			case "Left": return zipRight$3(onFailure(either$4.left), failCause$8(cause$2));
			case "Right": return failCause$8(cause$2);
		}
	},
	onSuccess: (a$1) => as$4(onSuccess(a$1), a$1)
}));
const tapDefect$1 = /* @__PURE__ */ dual$1(2, (self, f$1) => catchAllCause$1(self, (cause$2) => match$11(keepDefects$1(cause$2), {
	onNone: () => failCause$8(cause$2),
	onSome: (a$1) => zipRight$3(f$1(a$1), failCause$8(cause$2))
})));
const tapError$1 = /* @__PURE__ */ dual$1(2, (self, f$1) => matchCauseEffect$2(self, {
	onFailure: (cause$2) => {
		const either$4 = failureOrCause$1(cause$2);
		switch (either$4._tag) {
			case "Left": return zipRight$3(f$1(either$4.left), failCause$8(cause$2));
			case "Right": return failCause$8(cause$2);
		}
	},
	onSuccess: succeed$9
}));
const tapErrorTag$1 = /* @__PURE__ */ dual$1(3, (self, k, f$1) => tapError$1(self, (e) => {
	if (isTagged(e, k)) return f$1(e);
	return void_$4;
}));
const tapErrorCause$1 = /* @__PURE__ */ dual$1(2, (self, f$1) => matchCauseEffect$2(self, {
	onFailure: (cause$2) => zipRight$3(f$1(cause$2), failCause$8(cause$2)),
	onSuccess: succeed$9
}));
const timed$1 = (self) => timedWith$1(self, currentTimeNanos);
const timedWith$1 = /* @__PURE__ */ dual$1(2, (self, nanos$1) => summarized$1(self, nanos$1, (start$2, end$2) => nanos(end$2 - start$2)));
const tracerWith$1 = tracerWith$2;
/** @internal */
const tracer$1 = /* @__PURE__ */ tracerWith$1(succeed$9);
const tryPromise$1 = (arg) => {
	let evaluate$1;
	let catcher = void 0;
	if (typeof arg === "function") evaluate$1 = arg;
	else {
		evaluate$1 = arg.try;
		catcher = arg.catch;
	}
	const fail$11 = (e) => catcher ? failSync$2(() => catcher(e)) : fail$9(new UnknownException$1(e, "An unknown error occurred in Effect.tryPromise"));
	if (evaluate$1.length >= 1) return async_((resolve, signal) => {
		try {
			evaluate$1(signal).then((a$1) => resolve(succeed$9(a$1)), (e) => resolve(fail$11(e)));
		} catch (e) {
			resolve(fail$11(e));
		}
	});
	return async_((resolve) => {
		try {
			evaluate$1().then((a$1) => resolve(succeed$9(a$1)), (e) => resolve(fail$11(e)));
		} catch (e) {
			resolve(fail$11(e));
		}
	});
};
const tryMap$1 = /* @__PURE__ */ dual$1(2, (self, options) => flatMap$5(self, (a$1) => try_$1({
	try: () => options.try(a$1),
	catch: options.catch
})));
const tryMapPromise$1 = /* @__PURE__ */ dual$1(2, (self, options) => flatMap$5(self, (a$1) => tryPromise$1({
	try: options.try.length >= 1 ? (signal) => options.try(a$1, signal) : () => options.try(a$1),
	catch: options.catch
})));
const unless$1 = /* @__PURE__ */ dual$1(2, (self, condition) => suspend$3(() => condition() ? succeedNone$1 : asSome$1(self)));
const unlessEffect$1 = /* @__PURE__ */ dual$1(2, (self, condition) => flatMap$5(condition, (b$1) => b$1 ? succeedNone$1 : asSome$1(self)));
const unsandbox$1 = (self) => mapErrorCause$1(self, flatten$4);
const updateFiberRefs$1 = (f$1) => withFiberRuntime$1((state) => {
	state.setFiberRefs(f$1(state.id(), state.getFiberRefs()));
	return void_$4;
});
const updateService$1 = /* @__PURE__ */ dual$1(3, (self, tag$1, f$1) => mapInputContext$1(self, (context$2) => add$3(context$2, tag$1, f$1(unsafeGet$3(context$2, tag$1)))));
const when$1 = /* @__PURE__ */ dual$1(2, (self, condition) => suspend$3(() => condition() ? map$9(self, some$4) : succeed$9(none$7())));
const whenFiberRef$1 = /* @__PURE__ */ dual$1(3, (self, fiberRef, predicate) => flatMap$5(fiberRefGet(fiberRef), (s$1) => predicate(s$1) ? map$9(self, (a$1) => [s$1, some$4(a$1)]) : succeed$9([s$1, none$7()])));
const whenRef$1 = /* @__PURE__ */ dual$1(3, (self, ref, predicate) => flatMap$5(get(ref), (s$1) => predicate(s$1) ? map$9(self, (a$1) => [s$1, some$4(a$1)]) : succeed$9([s$1, none$7()])));
const withMetric$1 = /* @__PURE__ */ dual$1(2, (self, metric) => metric(self));
/** @internal */
const serviceFunctionEffect$1 = (getService, f$1) => (...args$2) => flatMap$5(getService, (a$1) => f$1(a$1)(...args$2));
/** @internal */
const serviceFunction$1 = (getService, f$1) => (...args$2) => map$9(getService, (a$1) => f$1(a$1)(...args$2));
/** @internal */
const serviceFunctions$1 = (getService) => new Proxy({}, { get(_target, prop, _receiver) {
	return (...args$2) => flatMap$5(getService, (s$1) => s$1[prop](...args$2));
} });
/** @internal */
const serviceConstants$1 = (getService) => new Proxy({}, { get(_target, prop, _receiver) {
	return flatMap$5(getService, (s$1) => isEffect$1(s$1[prop]) ? s$1[prop] : succeed$9(s$1[prop]));
} });
/** @internal */
const serviceMembers$1 = (getService) => ({
	functions: serviceFunctions$1(getService),
	constants: serviceConstants$1(getService)
});
/** @internal */
const serviceOption$1 = (tag$1) => map$9(context$1(), getOption(tag$1));
/** @internal */
const serviceOptional$1 = (tag$1) => flatMap$5(context$1(), getOption(tag$1));
const annotateCurrentSpan$1 = function() {
	const args$2 = arguments;
	return ignore$1(flatMap$5(currentSpan$1, (span$1) => sync$3(() => {
		if (typeof args$2[0] === "string") span$1.attribute(args$2[0], args$2[1]);
		else for (const key in args$2[0]) span$1.attribute(key, args$2[0][key]);
	})));
};
const linkSpanCurrent$1 = function() {
	const args$2 = arguments;
	const links = Array.isArray(args$2[0]) ? args$2[0] : [{
		_tag: "SpanLink",
		span: args$2[0],
		attributes: args$2[1] ?? {}
	}];
	return ignore$1(flatMap$5(currentSpan$1, (span$1) => sync$3(() => span$1.addLinks(links))));
};
const annotateSpans$1 = /* @__PURE__ */ dual$1((args$2) => isEffect$1(args$2[0]), function() {
	const args$2 = arguments;
	return fiberRefLocallyWith(args$2[0], currentTracerSpanAnnotations, typeof args$2[1] === "string" ? set$3(args$2[1], args$2[2]) : (annotations$1) => Object.entries(args$2[1]).reduce((acc, [key, value]) => set$3(acc, key, value), annotations$1));
});
/** @internal */
const currentParentSpan$1 = /* @__PURE__ */ serviceOptional$1(spanTag);
/** @internal */
const currentSpan$1 = /* @__PURE__ */ flatMap$5(/* @__PURE__ */ context$1(), (context$2) => {
	const span$1 = context$2.unsafeMap.get(spanTag.key);
	return span$1 !== void 0 && span$1._tag === "Span" ? succeed$9(span$1) : fail$9(new NoSuchElementException$1());
});
const linkSpans$1 = /* @__PURE__ */ dual$1((args$2) => isEffect$1(args$2[0]), (self, span$1, attributes) => fiberRefLocallyWith(self, currentTracerSpanLinks, append$1({
	_tag: "SpanLink",
	span: span$1,
	attributes: attributes ?? {}
})));
const bigint0$1 = /* @__PURE__ */ BigInt(0);
const filterDisablePropagation = /* @__PURE__ */ flatMap$12((span$1) => get$9(span$1.context, DisablePropagation$1) ? span$1._tag === "Span" ? filterDisablePropagation(span$1.parent) : none$7() : some$4(span$1));
/** @internal */
const unsafeMakeSpan = (fiber, name, options) => {
	const disablePropagation = !fiber.getFiberRef(currentTracerEnabled) || options.context && get$9(options.context, DisablePropagation$1);
	const context$2 = fiber.getFiberRef(currentContext);
	const parent = options.parent ? some$4(options.parent) : options.root ? none$7() : filterDisablePropagation(getOption(context$2, spanTag));
	let span$1;
	if (disablePropagation) span$1 = noopSpan({
		name,
		parent,
		context: add$3(options.context ?? empty$31(), DisablePropagation$1, true)
	});
	else {
		const services = fiber.getFiberRef(currentServices);
		const tracer$2 = get$9(services, tracerTag);
		const clock$2 = get$9(services, Clock);
		const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
		const fiberRefs$3 = fiber.getFiberRefs();
		const annotationsFromEnv = get$2(fiberRefs$3, currentTracerSpanAnnotations);
		const linksFromEnv = get$2(fiberRefs$3, currentTracerSpanLinks);
		const links = linksFromEnv._tag === "Some" ? options.links !== void 0 ? [...toReadonlyArray(linksFromEnv.value), ...options.links ?? []] : toReadonlyArray(linksFromEnv.value) : options.links ?? empty$33();
		span$1 = tracer$2.span(name, parent, options.context ?? empty$31(), links, timingEnabled ? clock$2.unsafeCurrentTimeNanos() : bigint0$1, options.kind ?? "internal", options);
		if (annotationsFromEnv._tag === "Some") forEach$5(annotationsFromEnv.value, (value, key) => span$1.attribute(key, value));
		if (options.attributes !== void 0) Object.entries(options.attributes).forEach(([k, v]) => span$1.attribute(k, v));
	}
	if (typeof options.captureStackTrace === "function") spanToTrace.set(span$1, options.captureStackTrace);
	return span$1;
};
/** @internal */
const makeSpan$1 = (name, options) => {
	options = addSpanStackTrace(options);
	return withFiberRuntime$1((fiber) => succeed$9(unsafeMakeSpan(fiber, name, options)));
};
const spanAnnotations$1 = /* @__PURE__ */ fiberRefGet(currentTracerSpanAnnotations);
const spanLinks$1 = /* @__PURE__ */ fiberRefGet(currentTracerSpanLinks);
/** @internal */
const endSpan = (span$1, exit$3, clock$2, timingEnabled) => sync$3(() => {
	if (span$1.status._tag === "Ended") return;
	if (exitIsFailure(exit$3) && spanToTrace.has(span$1)) span$1.attribute("code.stacktrace", spanToTrace.get(span$1)());
	span$1.end(timingEnabled ? clock$2.unsafeCurrentTimeNanos() : bigint0$1, exit$3);
});
/** @internal */
const useSpan$1 = (name, ...args$2) => {
	const options = addSpanStackTrace(args$2.length === 1 ? void 0 : args$2[0]);
	const evaluate$1 = args$2[args$2.length - 1];
	return withFiberRuntime$1((fiber) => {
		const span$1 = unsafeMakeSpan(fiber, name, options);
		const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
		const clock$2 = get$9(fiber.getFiberRef(currentServices), clockTag);
		return onExit$2(evaluate$1(span$1), (exit$3) => endSpan(span$1, exit$3, clock$2, timingEnabled));
	});
};
/** @internal */
const withParentSpan$1 = /* @__PURE__ */ dual$1(2, (self, span$1) => provideService$1(self, spanTag, span$1));
/** @internal */
const withSpan$1 = function() {
	const dataFirst = typeof arguments[0] !== "string";
	const name = dataFirst ? arguments[1] : arguments[0];
	const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
	if (dataFirst) {
		const self = arguments[0];
		return useSpan$1(name, options, (span$1) => withParentSpan$1(self, span$1));
	}
	return (self) => useSpan$1(name, options, (span$1) => withParentSpan$1(self, span$1));
};
const functionWithSpan$1 = (options) => function() {
	let captureStackTrace = options.captureStackTrace ?? false;
	if (options.captureStackTrace !== false) {
		const limit = Error.stackTraceLimit;
		Error.stackTraceLimit = 2;
		const error = /* @__PURE__ */ new Error();
		Error.stackTraceLimit = limit;
		let cache = false;
		captureStackTrace = () => {
			if (cache !== false) return cache;
			if (error.stack) {
				cache = error.stack.trim().split("\n").slice(2).join("\n").trim();
				return cache;
			}
		};
	}
	return suspend$3(() => {
		const opts = typeof options.options === "function" ? options.options.apply(null, arguments) : options.options;
		return withSpan$1(suspend$3(() => internalCall(() => options.body.apply(this, arguments))), opts.name, {
			...opts,
			captureStackTrace
		});
	});
};
const fromNullable$1 = (value) => value == null ? fail$9(new NoSuchElementException$1()) : succeed$9(value);
const optionFromOptional$1 = (self) => catchAll$1(map$9(self, some$4), (error) => isNoSuchElementException$1(error) ? succeedNone$1 : fail$9(error));

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/executionStrategy.js
/** @internal */
const OP_SEQUENTIAL = "Sequential";
/** @internal */
const OP_PARALLEL = "Parallel";
/** @internal */
const OP_PARALLEL_N = "ParallelN";
/** @internal */
const sequential$2 = { _tag: OP_SEQUENTIAL };
/** @internal */
const parallel$2 = { _tag: OP_PARALLEL };
/** @internal */
const parallelN$1 = (parallelism) => ({
	_tag: OP_PARALLEL_N,
	parallelism
});
/** @internal */
const isSequential$1 = (self) => self._tag === OP_SEQUENTIAL;
/** @internal */
const isParallel$1 = (self) => self._tag === OP_PARALLEL;
/** @internal */
const isParallelN$1 = (self) => self._tag === OP_PARALLEL_N;
/** @internal */
const match$6 = /* @__PURE__ */ dual$1(2, (self, options) => {
	switch (self._tag) {
		case OP_SEQUENTIAL: return options.onSequential();
		case OP_PARALLEL: return options.onParallel();
		case OP_PARALLEL_N: return options.onParallelN(self.parallelism);
	}
});

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/ExecutionStrategy.js
/**
* Execute effects sequentially.
*
* @since 2.0.0
* @category constructors
*/
const sequential$1 = sequential$2;
/**
* Execute effects in parallel.
*
* @since 2.0.0
* @category constructors
*/
const parallel$1 = parallel$2;
/**
* Execute effects in parallel, up to the specified number of concurrent fibers.
*
* @since 2.0.0
* @category constructors
*/
const parallelN = parallelN$1;
/**
* Returns `true` if the specified `ExecutionStrategy` is an instance of
* `Sequential`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isSequential = isSequential$1;
/**
* Returns `true` if the specified `ExecutionStrategy` is an instance of
* `Sequential`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isParallel = isParallel$1;
/**
* Returns `true` if the specified `ExecutionStrategy` is an instance of
* `Sequential`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isParallelN = isParallelN$1;
/**
* Folds over the specified `ExecutionStrategy` using the provided case
* functions.
*
* @since 2.0.0
* @category folding
*/
const match$5 = match$6;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/FiberRefsPatch.js
/**
* @since 2.0.0
* @category constructors
*/
const empty$8 = empty$9;
/**
* Constructs a patch that describes the changes between the specified
* collections of `FiberRef`
*
* @since 2.0.0
* @category constructors
*/
const diff$1 = diff$2;
/**
* Combines this patch and the specified patch to create a new patch that
* describes applying the changes from this patch and the specified patch
* sequentially.
*
* @since 2.0.0
* @category constructors
*/
const combine$1 = combine$2;
/**
* Applies the changes described by this patch to the specified collection
* of `FiberRef` values.
*
* @since 2.0.0
* @category destructors
*/
const patch$1 = patch$2;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/fiberStatus.js
const FiberStatusSymbolKey = "effect/FiberStatus";
/** @internal */
const FiberStatusTypeId$1 = /* @__PURE__ */ Symbol.for(FiberStatusSymbolKey);
/** @internal */
const OP_DONE$1 = "Done";
/** @internal */
const OP_RUNNING = "Running";
/** @internal */
const OP_SUSPENDED = "Suspended";
const DoneHash = /* @__PURE__ */ string(`${FiberStatusSymbolKey}-${OP_DONE$1}`);
/** @internal */
var Done = class {
	[FiberStatusTypeId$1] = FiberStatusTypeId$1;
	_tag = OP_DONE$1;
	[symbol$1]() {
		return DoneHash;
	}
	[symbol](that) {
		return isFiberStatus$1(that) && that._tag === OP_DONE$1;
	}
};
/** @internal */
var Running = class {
	runtimeFlags;
	[FiberStatusTypeId$1] = FiberStatusTypeId$1;
	_tag = OP_RUNNING;
	constructor(runtimeFlags$1) {
		this.runtimeFlags = runtimeFlags$1;
	}
	[symbol$1]() {
		return pipe$3(hash(FiberStatusSymbolKey), combine$11(hash(this._tag)), combine$11(hash(this.runtimeFlags)), cached$2(this));
	}
	[symbol](that) {
		return isFiberStatus$1(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags;
	}
};
/** @internal */
var Suspended = class {
	runtimeFlags;
	blockingOn;
	[FiberStatusTypeId$1] = FiberStatusTypeId$1;
	_tag = OP_SUSPENDED;
	constructor(runtimeFlags$1, blockingOn) {
		this.runtimeFlags = runtimeFlags$1;
		this.blockingOn = blockingOn;
	}
	[symbol$1]() {
		return pipe$3(hash(FiberStatusSymbolKey), combine$11(hash(this._tag)), combine$11(hash(this.runtimeFlags)), combine$11(hash(this.blockingOn)), cached$2(this));
	}
	[symbol](that) {
		return isFiberStatus$1(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && equals(this.blockingOn, that.blockingOn);
	}
};
/** @internal */
const done$5 = /* @__PURE__ */ new Done();
/** @internal */
const running$1 = (runtimeFlags$1) => new Running(runtimeFlags$1);
/** @internal */
const suspended$1 = (runtimeFlags$1, blockingOn) => new Suspended(runtimeFlags$1, blockingOn);
/** @internal */
const isFiberStatus$1 = (u$1) => hasProperty(u$1, FiberStatusTypeId$1);
/** @internal */
const isDone$3 = (self) => self._tag === OP_DONE$1;
/** @internal */
const isRunning$1 = (self) => self._tag === OP_RUNNING;
/** @internal */
const isSuspended$1 = (self) => self._tag === OP_SUSPENDED;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/FiberStatus.js
/**
* @since 2.0.0
* @category symbols
*/
const FiberStatusTypeId = FiberStatusTypeId$1;
/**
* @since 2.0.0
* @category constructors
*/
const done$4 = done$5;
/**
* @since 2.0.0
* @category constructors
*/
const running = running$1;
/**
* @since 2.0.0
* @category constructors
*/
const suspended = suspended$1;
/**
* Returns `true` if the specified value is a `FiberStatus`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isFiberStatus = isFiberStatus$1;
/**
* Returns `true` if the specified `FiberStatus` is `Done`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isDone$2 = isDone$3;
/**
* Returns `true` if the specified `FiberStatus` is `Running`, `false`
* otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isRunning = isRunning$1;
/**
* Returns `true` if the specified `FiberStatus` is `Suspended`, `false`
* otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isSuspended = isSuspended$1;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Micro.js
/**
* @since 3.4.0
* @experimental
* @category type ids
*/
const TypeId$6 = /* @__PURE__ */ Symbol.for("effect/Micro");
/**
* @since 3.4.0
* @experimental
* @category MicroExit
*/
const MicroExitTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroExit");
/**
* @since 3.4.6
* @experimental
* @category MicroCause
*/
const MicroCauseTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroCause");
const microCauseVariance = { _E: identity$2 };
var MicroCauseImpl = class extends globalThis.Error {
	_tag;
	traces;
	[MicroCauseTypeId];
	constructor(_tag, originalError$1, traces) {
		const causeName = `MicroCause.${_tag}`;
		let name;
		let message;
		let stack;
		if (originalError$1 instanceof globalThis.Error) {
			name = `(${causeName}) ${originalError$1.name}`;
			message = originalError$1.message;
			const messageLines = message.split("\n").length;
			stack = originalError$1.stack ? `(${causeName}) ${originalError$1.stack.split("\n").slice(0, messageLines + 3).join("\n")}` : `${name}: ${message}`;
		} else {
			name = causeName;
			message = toStringUnknown(originalError$1, 0);
			stack = `${name}: ${message}`;
		}
		if (traces.length > 0) stack += `\n    ${traces.join("\n    ")}`;
		super(message);
		this._tag = _tag;
		this.traces = traces;
		this[MicroCauseTypeId] = microCauseVariance;
		this.name = name;
		this.stack = stack;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
	toString() {
		return this.stack;
	}
	[NodeInspectSymbol]() {
		return this.stack;
	}
};
var Die = class extends MicroCauseImpl {
	defect;
	constructor(defect, traces = []) {
		super("Die", defect, traces);
		this.defect = defect;
	}
};
/**
* @since 3.4.6
* @experimental
* @category MicroCause
*/
const causeDie = (defect, traces = []) => new Die(defect, traces);
var Interrupt = class extends MicroCauseImpl {
	constructor(traces = []) {
		super("Interrupt", "interrupted", traces);
	}
};
/**
* @since 3.4.6
* @experimental
* @category MicroCause
*/
const causeInterrupt = (traces = []) => new Interrupt(traces);
/**
* @since 3.4.6
* @experimental
* @category MicroCause
*/
const causeIsInterrupt = (self) => self._tag === "Interrupt";
/**
* @since 3.11.0
* @experimental
* @category MicroFiber
*/
const MicroFiberTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroFiber");
const fiberVariance$1 = {
	_A: identity$2,
	_E: identity$2
};
var MicroFiberImpl = class {
	context;
	interruptible;
	[MicroFiberTypeId];
	_stack = [];
	_observers = [];
	_exit;
	_children;
	currentOpCount = 0;
	constructor(context$2, interruptible$4 = true) {
		this.context = context$2;
		this.interruptible = interruptible$4;
		this[MicroFiberTypeId] = fiberVariance$1;
	}
	getRef(ref) {
		return unsafeGetReference(this.context, ref);
	}
	addObserver(cb) {
		if (this._exit) {
			cb(this._exit);
			return constVoid$1;
		}
		this._observers.push(cb);
		return () => {
			const index = this._observers.indexOf(cb);
			if (index >= 0) this._observers.splice(index, 1);
		};
	}
	_interrupted = false;
	unsafeInterrupt() {
		if (this._exit) return;
		this._interrupted = true;
		if (this.interruptible) this.evaluate(exitInterrupt);
	}
	unsafePoll() {
		return this._exit;
	}
	evaluate(effect) {
		if (this._exit) return;
		else if (this._yielded !== void 0) {
			const yielded = this._yielded;
			this._yielded = void 0;
			yielded();
		}
		const exit$3 = this.runLoop(effect);
		if (exit$3 === Yield) return;
		const interruptChildren = fiberMiddleware.interruptChildren && fiberMiddleware.interruptChildren(this);
		if (interruptChildren !== void 0) return this.evaluate(flatMap$3(interruptChildren, () => exit$3));
		this._exit = exit$3;
		for (let i$1 = 0; i$1 < this._observers.length; i$1++) this._observers[i$1](exit$3);
		this._observers.length = 0;
	}
	runLoop(effect) {
		let yielding = false;
		let current = effect;
		this.currentOpCount = 0;
		try {
			while (true) {
				this.currentOpCount++;
				if (!yielding && this.getRef(CurrentScheduler).shouldYield(this)) {
					yielding = true;
					const prev = current;
					current = flatMap$3(yieldNow$2, () => prev);
				}
				current = current[evaluate](this);
				if (current === Yield) {
					const yielded = this._yielded;
					if (MicroExitTypeId in yielded) {
						this._yielded = void 0;
						return yielded;
					}
					return Yield;
				}
			}
		} catch (error) {
			if (!hasProperty(current, evaluate)) return exitDie(`MicroFiber.runLoop: Not a valid effect: ${String(current)}`);
			return exitDie(error);
		}
	}
	getCont(symbol$2) {
		while (true) {
			const op = this._stack.pop();
			if (!op) return void 0;
			const cont = op[ensureCont] && op[ensureCont](this);
			if (cont) return { [symbol$2]: cont };
			if (op[symbol$2]) return op;
		}
	}
	_yielded = void 0;
	yieldWith(value) {
		this._yielded = value;
		return Yield;
	}
	children() {
		return this._children ??= /* @__PURE__ */ new Set();
	}
};
const fiberMiddleware = /* @__PURE__ */ globalValue("effect/Micro/fiberMiddleware", () => ({ interruptChildren: void 0 }));
/**
* @since 3.11.0
* @experimental
* @category MicroFiber
*/
const fiberInterruptAll = (fibers) => suspend$2(() => {
	for (const fiber of fibers) fiber.unsafeInterrupt();
	const iter = fibers[Symbol.iterator]();
	const wait = suspend$2(() => {
		let result = iter.next();
		while (!result.done) {
			if (result.value.unsafePoll()) {
				result = iter.next();
				continue;
			}
			const fiber = result.value;
			return async$1((resume$1) => {
				fiber.addObserver((_$1) => {
					resume$1(wait);
				});
			});
		}
		return exitVoid;
	});
	return wait;
});
const identifier = /* @__PURE__ */ Symbol.for("effect/Micro/identifier");
const args$1 = /* @__PURE__ */ Symbol.for("effect/Micro/args");
const evaluate = /* @__PURE__ */ Symbol.for("effect/Micro/evaluate");
const successCont = /* @__PURE__ */ Symbol.for("effect/Micro/successCont");
const failureCont = /* @__PURE__ */ Symbol.for("effect/Micro/failureCont");
const ensureCont = /* @__PURE__ */ Symbol.for("effect/Micro/ensureCont");
const Yield = /* @__PURE__ */ Symbol.for("effect/Micro/Yield");
const microVariance = {
	_A: identity$2,
	_E: identity$2,
	_R: identity$2
};
const MicroProto = {
	...EffectPrototype,
	_op: "Micro",
	[TypeId$6]: microVariance,
	pipe() {
		return pipeArguments(this, arguments);
	},
	[Symbol.iterator]() {
		return new SingleShotGen(new YieldWrap(this));
	},
	toJSON() {
		return {
			_id: "Micro",
			op: this[identifier],
			...args$1 in this ? { args: this[args$1] } : void 0
		};
	},
	toString() {
		return format(this);
	},
	[NodeInspectSymbol]() {
		return format(this);
	}
};
function defaultEvaluate(_fiber) {
	return exitDie(`Micro.evaluate: Not implemented`);
}
const makePrimitiveProto = (options) => ({
	...MicroProto,
	[identifier]: options.op,
	[evaluate]: options.eval ?? defaultEvaluate,
	[successCont]: options.contA,
	[failureCont]: options.contE,
	[ensureCont]: options.ensure
});
const makePrimitive = (options) => {
	const Proto$1 = makePrimitiveProto(options);
	return function() {
		const self = Object.create(Proto$1);
		self[args$1] = options.single === false ? arguments : arguments[0];
		return self;
	};
};
const makeExit = (options) => {
	const Proto$1 = {
		...makePrimitiveProto(options),
		[MicroExitTypeId]: MicroExitTypeId,
		_tag: options.op,
		get [options.prop]() {
			return this[args$1];
		},
		toJSON() {
			return {
				_id: "MicroExit",
				_tag: options.op,
				[options.prop]: this[args$1]
			};
		},
		[symbol](that) {
			return isMicroExit(that) && that._tag === options.op && equals(this[args$1], that[args$1]);
		},
		[symbol$1]() {
			return cached$2(this, combine$11(string(options.op))(hash(this[args$1])));
		}
	};
	return function(value) {
		const self = Object.create(Proto$1);
		self[args$1] = value;
		self[successCont] = void 0;
		self[failureCont] = void 0;
		self[ensureCont] = void 0;
		return self;
	};
};
/**
* Creates a `Micro` effect that will succeed with the specified constant value.
*
* @since 3.4.0
* @experimental
* @category constructors
*/
const succeed$6 = /* @__PURE__ */ makeExit({
	op: "Success",
	prop: "value",
	eval(fiber) {
		const cont = fiber.getCont(successCont);
		return cont ? cont[successCont](this[args$1], fiber) : fiber.yieldWith(this);
	}
});
/**
* Creates a `Micro` effect that will fail with the specified `MicroCause`.
*
* @since 3.4.6
* @experimental
* @category constructors
*/
const failCause$5 = /* @__PURE__ */ makeExit({
	op: "Failure",
	prop: "cause",
	eval(fiber) {
		let cont = fiber.getCont(failureCont);
		while (causeIsInterrupt(this[args$1]) && cont && fiber.interruptible) cont = fiber.getCont(failureCont);
		return cont ? cont[failureCont](this[args$1], fiber) : fiber.yieldWith(this);
	}
});
/**
* Creates a `Micro` effect that succeeds with a lazily evaluated value.
*
* If the evaluation of the value throws an error, the effect will fail with a
* `Die` variant of the `MicroCause` type.
*
* @since 3.4.0
* @experimental
* @category constructors
*/
const sync$1 = /* @__PURE__ */ makePrimitive({
	op: "Sync",
	eval(fiber) {
		const value = this[args$1]();
		const cont = fiber.getCont(successCont);
		return cont ? cont[successCont](value, fiber) : fiber.yieldWith(exitSucceed(value));
	}
});
/**
* Lazily creates a `Micro` effect from the given side-effect.
*
* @since 3.4.0
* @experimental
* @category constructors
*/
const suspend$2 = /* @__PURE__ */ makePrimitive({
	op: "Suspend",
	eval(_fiber) {
		return this[args$1]();
	}
});
/**
* Pause the execution of the current `Micro` effect, and resume it on the next
* scheduler tick.
*
* @since 3.4.0
* @experimental
* @category constructors
*/
const yieldNowWith = /* @__PURE__ */ makePrimitive({
	op: "Yield",
	eval(fiber) {
		let resumed = false;
		fiber.getRef(CurrentScheduler).scheduleTask(() => {
			if (resumed) return;
			fiber.evaluate(exitVoid);
		}, this[args$1] ?? 0);
		return fiber.yieldWith(() => {
			resumed = true;
		});
	}
});
/**
* Pause the execution of the current `Micro` effect, and resume it on the next
* scheduler tick.
*
* @since 3.4.0
* @experimental
* @category constructors
*/
const yieldNow$2 = /* @__PURE__ */ yieldNowWith(0);
const void_$2 = /* @__PURE__ */ succeed$6(void 0);
/**
* Create a `Micro` effect using the current `MicroFiber`.
*
* @since 3.4.0
* @experimental
* @category constructors
*/
const withMicroFiber = /* @__PURE__ */ makePrimitive({
	op: "WithMicroFiber",
	eval(fiber) {
		return this[args$1](fiber);
	}
});
const asyncOptions = /* @__PURE__ */ makePrimitive({
	op: "Async",
	single: false,
	eval(fiber) {
		const register = this[args$1][0];
		let resumed = false;
		let yielded = false;
		const controller = this[args$1][1] ? new AbortController() : void 0;
		const onCancel = register((effect) => {
			if (resumed) return;
			resumed = true;
			if (yielded) fiber.evaluate(effect);
			else yielded = effect;
		}, controller?.signal);
		if (yielded !== false) return yielded;
		yielded = true;
		fiber._yielded = () => {
			resumed = true;
		};
		if (controller === void 0 && onCancel === void 0) return Yield;
		fiber._stack.push(asyncFinalizer(() => {
			resumed = true;
			controller?.abort();
			return onCancel ?? exitVoid;
		}));
		return Yield;
	}
});
const asyncFinalizer = /* @__PURE__ */ makePrimitive({
	op: "AsyncFinalizer",
	ensure(fiber) {
		if (fiber.interruptible) {
			fiber.interruptible = false;
			fiber._stack.push(setInterruptible(true));
		}
	},
	contE(cause$2, _fiber) {
		return causeIsInterrupt(cause$2) ? flatMap$3(this[args$1](), () => failCause$5(cause$2)) : failCause$5(cause$2);
	}
});
/**
* Create a `Micro` effect from an asynchronous computation.
*
* You can return a cleanup effect that will be run when the effect is aborted.
* It is also passed an `AbortSignal` that is triggered when the effect is
* aborted.
*
* @since 3.4.0
* @experimental
* @category constructors
*/
const async$1 = (register) => asyncOptions(register, register.length >= 2);
/**
* Create a `Micro` effect that will replace the success value of the given
* effect.
*
* @since 3.4.0
* @experimental
* @category mapping & sequencing
*/
const as$2 = /* @__PURE__ */ dual$1(2, (self, value) => map$7(self, (_$1) => value));
/**
* Access the `MicroExit` of the given `Micro` effect.
*
* @since 3.4.6
* @experimental
* @category mapping & sequencing
*/
const exit$1 = (self) => matchCause$1(self, {
	onFailure: exitFailCause,
	onSuccess: exitSucceed
});
/**
* Map the success value of this `Micro` effect to another `Micro` effect, then
* flatten the result.
*
* @since 3.4.0
* @experimental
* @category mapping & sequencing
*/
const flatMap$3 = /* @__PURE__ */ dual$1(2, (self, f$1) => {
	const onSuccess = Object.create(OnSuccessProto);
	onSuccess[args$1] = self;
	onSuccess[successCont] = f$1;
	return onSuccess;
});
const OnSuccessProto = /* @__PURE__ */ makePrimitiveProto({
	op: "OnSuccess",
	eval(fiber) {
		fiber._stack.push(this);
		return this[args$1];
	}
});
/**
* Transforms the success value of the `Micro` effect with the specified
* function.
*
* @since 3.4.0
* @experimental
* @category mapping & sequencing
*/
const map$7 = /* @__PURE__ */ dual$1(2, (self, f$1) => flatMap$3(self, (a$1) => succeed$6(f$1(a$1))));
/**
* @since 3.4.6
* @experimental
* @category MicroExit
*/
const isMicroExit = (u$1) => hasProperty(u$1, MicroExitTypeId);
/**
* @since 3.4.6
* @experimental
* @category MicroExit
*/
const exitSucceed = succeed$6;
/**
* @since 3.4.6
* @experimental
* @category MicroExit
*/
const exitFailCause = failCause$5;
/**
* @since 3.4.6
* @experimental
* @category MicroExit
*/
const exitInterrupt = /* @__PURE__ */ exitFailCause(/* @__PURE__ */ causeInterrupt());
/**
* @since 3.4.6
* @experimental
* @category MicroExit
*/
const exitDie = (defect) => exitFailCause(causeDie(defect));
/**
* @since 3.4.6
* @experimental
* @category MicroExit
*/
const exitVoid = /* @__PURE__ */ exitSucceed(void 0);
/**
* @since 3.11.0
* @experimental
* @category MicroExit
*/
const exitVoidAll = (exits) => {
	for (const exit$3 of exits) if (exit$3._tag === "Failure") return exit$3;
	return exitVoid;
};
const setImmediate = "setImmediate" in globalThis ? globalThis.setImmediate : (f$1) => setTimeout(f$1, 0);
/**
* @since 3.5.9
* @experimental
* @category scheduler
*/
var MicroSchedulerDefault = class {
	tasks = [];
	running = false;
	/**
	* @since 3.5.9
	*/
	scheduleTask(task, _priority) {
		this.tasks.push(task);
		if (!this.running) {
			this.running = true;
			setImmediate(this.afterScheduled);
		}
	}
	/**
	* @since 3.5.9
	*/
	afterScheduled = () => {
		this.running = false;
		this.runTasks();
	};
	/**
	* @since 3.5.9
	*/
	runTasks() {
		const tasks = this.tasks;
		this.tasks = [];
		for (let i$1 = 0, len = tasks.length; i$1 < len; i$1++) tasks[i$1]();
	}
	/**
	* @since 3.5.9
	*/
	shouldYield(fiber) {
		return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield);
	}
	/**
	* @since 3.5.9
	*/
	flush() {
		while (this.tasks.length > 0) this.runTasks();
	}
};
/**
* Update the Context with the given mapping function.
*
* @since 3.11.0
* @experimental
* @category environment
*/
const updateContext = /* @__PURE__ */ dual$1(2, (self, f$1) => withMicroFiber((fiber) => {
	const prev = fiber.context;
	fiber.context = f$1(prev);
	return onExit$1(self, () => {
		fiber.context = prev;
		return void_$2;
	});
}));
/**
* Merge the given `Context` with the current context.
*
* @since 3.4.0
* @experimental
* @category environment
*/
const provideContext = /* @__PURE__ */ dual$1(2, (self, provided) => updateContext(self, merge$4(provided)));
/**
* @since 3.11.0
* @experimental
* @category references
*/
var MaxOpsBeforeYield = class extends Reference()("effect/Micro/currentMaxOpsBeforeYield", { defaultValue: () => 2048 }) {};
/**
* @since 3.11.0
* @experimental
* @category environment refs
*/
var CurrentConcurrency = class extends Reference()("effect/Micro/currentConcurrency", { defaultValue: () => "unbounded" }) {};
/**
* @since 3.11.0
* @experimental
* @category environment refs
*/
var CurrentScheduler = class extends Reference()("effect/Micro/currentScheduler", { defaultValue: () => new MicroSchedulerDefault() }) {};
/**
* @since 3.4.6
* @experimental
* @category pattern matching
*/
const matchCauseEffect$1 = /* @__PURE__ */ dual$1(2, (self, options) => {
	const primitive = Object.create(OnSuccessAndFailureProto);
	primitive[args$1] = self;
	primitive[successCont] = options.onSuccess;
	primitive[failureCont] = options.onFailure;
	return primitive;
});
const OnSuccessAndFailureProto = /* @__PURE__ */ makePrimitiveProto({
	op: "OnSuccessAndFailure",
	eval(fiber) {
		fiber._stack.push(this);
		return this[args$1];
	}
});
/**
* @since 3.4.6
* @experimental
* @category pattern matching
*/
const matchCause$1 = /* @__PURE__ */ dual$1(2, (self, options) => matchCauseEffect$1(self, {
	onFailure: (cause$2) => sync$1(() => options.onFailure(cause$2)),
	onSuccess: (value) => sync$1(() => options.onSuccess(value))
}));
/**
* @since 3.4.0
* @experimental
* @category resources & finalization
*/
const MicroScopeTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroScope");
var MicroScopeImpl = class MicroScopeImpl {
	[MicroScopeTypeId];
	state = {
		_tag: "Open",
		finalizers: /* @__PURE__ */ new Set()
	};
	constructor() {
		this[MicroScopeTypeId] = MicroScopeTypeId;
	}
	unsafeAddFinalizer(finalizer) {
		if (this.state._tag === "Open") this.state.finalizers.add(finalizer);
	}
	addFinalizer(finalizer) {
		return suspend$2(() => {
			if (this.state._tag === "Open") {
				this.state.finalizers.add(finalizer);
				return void_$2;
			}
			return finalizer(this.state.exit);
		});
	}
	unsafeRemoveFinalizer(finalizer) {
		if (this.state._tag === "Open") this.state.finalizers.delete(finalizer);
	}
	close(microExit) {
		return suspend$2(() => {
			if (this.state._tag === "Open") {
				const finalizers = Array.from(this.state.finalizers).reverse();
				this.state = {
					_tag: "Closed",
					exit: microExit
				};
				return flatMap$3(forEach$4(finalizers, (finalizer) => exit$1(finalizer(microExit))), exitVoidAll);
			}
			return void_$2;
		});
	}
	get fork() {
		return sync$1(() => {
			const newScope = new MicroScopeImpl();
			if (this.state._tag === "Closed") {
				newScope.state = this.state;
				return newScope;
			}
			function fin(exit$3) {
				return newScope.close(exit$3);
			}
			this.state.finalizers.add(fin);
			newScope.unsafeAddFinalizer((_$1) => sync$1(() => this.unsafeRemoveFinalizer(fin)));
			return newScope;
		});
	}
};
/**
* When the `Micro` effect is completed, run the given finalizer effect with the
* `MicroExit` of the executed effect.
*
* @since 3.4.6
* @experimental
* @category resources & finalization
*/
const onExit$1 = /* @__PURE__ */ dual$1(2, (self, f$1) => uninterruptibleMask$1((restore) => matchCauseEffect$1(restore(self), {
	onFailure: (cause$2) => flatMap$3(f$1(exitFailCause(cause$2)), () => failCause$5(cause$2)),
	onSuccess: (a$1) => flatMap$3(f$1(exitSucceed(a$1)), () => succeed$6(a$1))
})));
const setInterruptible = /* @__PURE__ */ makePrimitive({
	op: "SetInterruptible",
	ensure(fiber) {
		fiber.interruptible = this[args$1];
		if (fiber._interrupted && fiber.interruptible) return () => exitInterrupt;
	}
});
/**
* Flag the effect as interruptible, which means that when the effect is
* interrupted, it will be interrupted immediately.
*
* @since 3.4.0
* @experimental
* @category flags
*/
const interruptible$1 = (self) => withMicroFiber((fiber) => {
	if (fiber.interruptible) return self;
	fiber.interruptible = true;
	fiber._stack.push(setInterruptible(false));
	if (fiber._interrupted) return exitInterrupt;
	return self;
});
/**
* Wrap the given `Micro` effect in an uninterruptible region, preventing the
* effect from being aborted.
*
* You can use the `restore` function to restore a `Micro` effect to the
* interruptibility state before the `uninterruptibleMask` was applied.
*
* @example
* ```ts
* import * as Micro from "effect/Micro"
*
* Micro.uninterruptibleMask((restore) =>
*   Micro.sleep(1000).pipe( // uninterruptible
*     Micro.andThen(restore(Micro.sleep(1000))) // interruptible
*   )
* )
* ```
*
* @since 3.4.0
* @experimental
* @category interruption
*/
const uninterruptibleMask$1 = (f$1) => withMicroFiber((fiber) => {
	if (!fiber.interruptible) return f$1(identity$2);
	fiber.interruptible = false;
	fiber._stack.push(setInterruptible(true));
	return f$1(interruptible$1);
});
/**
* @since 3.11.0
* @experimental
* @category collecting & elements
*/
const whileLoop$1 = /* @__PURE__ */ makePrimitive({
	op: "While",
	contA(value, fiber) {
		this[args$1].step(value);
		if (this[args$1].while()) {
			fiber._stack.push(this);
			return this[args$1].body();
		}
		return exitVoid;
	},
	eval(fiber) {
		if (this[args$1].while()) {
			fiber._stack.push(this);
			return this[args$1].body();
		}
		return exitVoid;
	}
});
/**
* For each element of the provided iterable, run the effect and collect the
* results.
*
* If the `discard` option is set to `true`, the results will be discarded and
* the effect will return `void`.
*
* The `concurrency` option can be set to control how many effects are run
* concurrently. By default, the effects are run sequentially.
*
* @since 3.4.0
* @experimental
* @category collecting & elements
*/
const forEach$4 = (iterable, f$1, options) => withMicroFiber((parent) => {
	const concurrencyOption = options?.concurrency === "inherit" ? parent.getRef(CurrentConcurrency) : options?.concurrency ?? 1;
	const concurrency = concurrencyOption === "unbounded" ? Number.POSITIVE_INFINITY : Math.max(1, concurrencyOption);
	const items = fromIterable$10(iterable);
	let length$1 = items.length;
	if (length$1 === 0) return options?.discard ? void_$2 : succeed$6([]);
	const out = options?.discard ? void 0 : new Array(length$1);
	let index = 0;
	if (concurrency === 1) return as$2(whileLoop$1({
		while: () => index < items.length,
		body: () => f$1(items[index], index),
		step: out ? (b$1) => out[index++] = b$1 : (_$1) => index++
	}), out);
	return async$1((resume$1) => {
		const fibers = /* @__PURE__ */ new Set();
		let result = void 0;
		let inProgress = 0;
		let doneCount = 0;
		let pumping = false;
		let interrupted$2 = false;
		function pump() {
			pumping = true;
			while (inProgress < concurrency && index < length$1) {
				const currentIndex = index;
				const item = items[currentIndex];
				index++;
				inProgress++;
				try {
					const child = unsafeFork$2(parent, f$1(item, currentIndex), true, true);
					fibers.add(child);
					child.addObserver((exit$3) => {
						fibers.delete(child);
						if (interrupted$2) return;
						else if (exit$3._tag === "Failure") {
							if (result === void 0) {
								result = exit$3;
								length$1 = index;
								fibers.forEach((fiber) => fiber.unsafeInterrupt());
							}
						} else if (out !== void 0) out[currentIndex] = exit$3.value;
						doneCount++;
						inProgress--;
						if (doneCount === length$1) resume$1(result ?? succeed$6(out));
						else if (!pumping && inProgress < concurrency) pump();
					});
				} catch (err) {
					result = exitDie(err);
					length$1 = index;
					fibers.forEach((fiber) => fiber.unsafeInterrupt());
				}
			}
			pumping = false;
		}
		pump();
		return suspend$2(() => {
			interrupted$2 = true;
			index = length$1;
			return fiberInterruptAll(fibers);
		});
	});
});
const unsafeFork$2 = (parent, effect, immediate = false, daemon = false) => {
	const child = new MicroFiberImpl(parent.context, parent.interruptible);
	if (!daemon) {
		parent.children().add(child);
		child.addObserver(() => parent.children().delete(child));
	}
	if (immediate) child.evaluate(effect);
	else parent.getRef(CurrentScheduler).scheduleTask(() => child.evaluate(effect), 0);
	return child;
};
/**
* Execute the `Micro` effect and return a `MicroFiber` that can be awaited, joined,
* or aborted.
*
* You can listen for the result by adding an observer using the handle's
* `addObserver` method.
*
* @example
* ```ts
* import * as Micro from "effect/Micro"
*
* const handle = Micro.succeed(42).pipe(
*   Micro.delay(1000),
*   Micro.runFork
* )
*
* handle.addObserver((exit) => {
*   console.log(exit)
* })
* ```
*
* @since 3.4.0
* @experimental
* @category execution
*/
const runFork$1 = (effect, options) => {
	const fiber = new MicroFiberImpl(CurrentScheduler.context(options?.scheduler ?? new MicroSchedulerDefault()));
	fiber.evaluate(effect);
	if (options?.signal) if (options.signal.aborted) fiber.unsafeInterrupt();
	else {
		const abort = () => fiber.unsafeInterrupt();
		options.signal.addEventListener("abort", abort, { once: true });
		fiber.addObserver(() => options.signal.removeEventListener("abort", abort));
	}
	return fiber;
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Scheduler.js
/**
* @since 2.0.0
* @category utils
*/
var PriorityBuckets = class {
	/**
	* @since 2.0.0
	*/
	buckets = [];
	/**
	* @since 2.0.0
	*/
	scheduleTask(task, priority) {
		const length$1 = this.buckets.length;
		let bucket = void 0;
		let index = 0;
		for (; index < length$1; index++) if (this.buckets[index][0] <= priority) bucket = this.buckets[index];
		else break;
		if (bucket && bucket[0] === priority) bucket[1].push(task);
		else if (index === length$1) this.buckets.push([priority, [task]]);
		else this.buckets.splice(index, 0, [priority, [task]]);
	}
};
/**
* @since 2.0.0
* @category constructors
*/
var MixedScheduler = class {
	maxNextTickBeforeTimer;
	/**
	* @since 2.0.0
	*/
	running = false;
	/**
	* @since 2.0.0
	*/
	tasks = /* @__PURE__ */ new PriorityBuckets();
	constructor(maxNextTickBeforeTimer) {
		this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;
	}
	/**
	* @since 2.0.0
	*/
	starveInternal(depth) {
		const tasks = this.tasks.buckets;
		this.tasks.buckets = [];
		for (const [_$1, toRun] of tasks) for (let i$1 = 0; i$1 < toRun.length; i$1++) toRun[i$1]();
		if (this.tasks.buckets.length === 0) this.running = false;
		else this.starve(depth);
	}
	/**
	* @since 2.0.0
	*/
	starve(depth = 0) {
		if (depth >= this.maxNextTickBeforeTimer) setTimeout(() => this.starveInternal(0), 0);
		else Promise.resolve(void 0).then(() => this.starveInternal(depth + 1));
	}
	/**
	* @since 2.0.0
	*/
	shouldYield(fiber) {
		return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
	}
	/**
	* @since 2.0.0
	*/
	scheduleTask(task, priority) {
		this.tasks.scheduleTask(task, priority);
		if (!this.running) {
			this.running = true;
			this.starve();
		}
	}
};
/**
* @since 2.0.0
* @category schedulers
*/
const defaultScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Scheduler/defaultScheduler"), () => new MixedScheduler(2048));
/**
* @since 2.0.0
* @category constructors
*/
var SyncScheduler = class {
	/**
	* @since 2.0.0
	*/
	tasks = /* @__PURE__ */ new PriorityBuckets();
	/**
	* @since 2.0.0
	*/
	deferred = false;
	/**
	* @since 2.0.0
	*/
	scheduleTask(task, priority) {
		if (this.deferred) defaultScheduler.scheduleTask(task, priority);
		else this.tasks.scheduleTask(task, priority);
	}
	/**
	* @since 2.0.0
	*/
	shouldYield(fiber) {
		return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
	}
	/**
	* @since 2.0.0
	*/
	flush() {
		while (this.tasks.buckets.length > 0) {
			const tasks = this.tasks.buckets;
			this.tasks.buckets = [];
			for (const [_$1, toRun] of tasks) for (let i$1 = 0; i$1 < toRun.length; i$1++) toRun[i$1]();
		}
		this.deferred = true;
	}
};
/** @internal */
const currentScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentScheduler"), () => fiberRefUnsafeMake(defaultScheduler));
/** @internal */
const withScheduler$1 = /* @__PURE__ */ dual$1(2, (self, scheduler) => fiberRefLocally(self, currentScheduler, scheduler));

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/completedRequestMap.js
/** @internal */
const currentRequestMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestMap"), () => fiberRefUnsafeMake(/* @__PURE__ */ new Map()));

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/concurrency.js
/** @internal */
const match$4 = (concurrency, sequential$4, unbounded$1, bounded) => {
	switch (concurrency) {
		case void 0: return sequential$4();
		case "unbounded": return unbounded$1();
		case "inherit": return fiberRefGetWith(currentConcurrency, (concurrency$1) => concurrency$1 === "unbounded" ? unbounded$1() : concurrency$1 > 1 ? bounded(concurrency$1) : sequential$4());
		default: return concurrency > 1 ? bounded(concurrency) : sequential$4();
	}
};
/** @internal */
const matchSimple = (concurrency, sequential$4, concurrent) => {
	switch (concurrency) {
		case void 0: return sequential$4();
		case "unbounded": return concurrent();
		case "inherit": return fiberRefGetWith(currentConcurrency, (concurrency$1) => concurrency$1 === "unbounded" || concurrency$1 > 1 ? concurrent() : sequential$4());
		default: return concurrency > 1 ? concurrent() : sequential$4();
	}
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/fiberMessage.js
/** @internal */
const OP_INTERRUPT_SIGNAL = "InterruptSignal";
/** @internal */
const OP_STATEFUL = "Stateful";
/** @internal */
const OP_RESUME = "Resume";
/** @internal */
const OP_YIELD_NOW = "YieldNow";
/** @internal */
const interruptSignal = (cause$2) => ({
	_tag: OP_INTERRUPT_SIGNAL,
	cause: cause$2
});
/** @internal */
const stateful = (onFiber) => ({
	_tag: OP_STATEFUL,
	onFiber
});
/** @internal */
const resume = (effect) => ({
	_tag: OP_RESUME,
	effect
});
/** @internal */
const yieldNow$1 = () => ({ _tag: OP_YIELD_NOW });

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/fiberScope.js
/** @internal */
const FiberScopeSymbolKey = "effect/FiberScope";
/** @internal */
const FiberScopeTypeId = /* @__PURE__ */ Symbol.for(FiberScopeSymbolKey);
/** @internal */
var Global = class {
	[FiberScopeTypeId] = FiberScopeTypeId;
	fiberId = none$6;
	roots = /* @__PURE__ */ new Set();
	add(_runtimeFlags, child) {
		this.roots.add(child);
		child.addObserver(() => {
			this.roots.delete(child);
		});
	}
};
/** @internal */
var Local = class {
	fiberId;
	parent;
	[FiberScopeTypeId] = FiberScopeTypeId;
	constructor(fiberId$2, parent) {
		this.fiberId = fiberId$2;
		this.parent = parent;
	}
	add(_runtimeFlags, child) {
		this.parent.tell(stateful((parentFiber) => {
			parentFiber.addChild(child);
			child.addObserver(() => {
				parentFiber.removeChild(child);
			});
		}));
	}
};
/** @internal */
const unsafeMake$1 = (fiber) => {
	return new Local(fiber.id(), fiber);
};
/** @internal */
const globalScope = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberScope/Global"), () => new Global());

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/fiber.js
/** @internal */
const FiberSymbolKey = "effect/Fiber";
/** @internal */
const FiberTypeId$1 = /* @__PURE__ */ Symbol.for(FiberSymbolKey);
/** @internal */
const fiberVariance = {
	_E: (_$1) => _$1,
	_A: (_$1) => _$1
};
/** @internal */
const fiberProto = {
	[FiberTypeId$1]: fiberVariance,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const RuntimeFiberSymbolKey = "effect/Fiber";
/** @internal */
const RuntimeFiberTypeId$1 = /* @__PURE__ */ Symbol.for(RuntimeFiberSymbolKey);
/** @internal */
const Order$1 = /* @__PURE__ */ pipe$3(/* @__PURE__ */ tuple(Order$4, Order$4), /* @__PURE__ */ mapInput((fiber) => [fiber.id().startTimeMillis, fiber.id().id]));
/** @internal */
const isFiber$1 = (u$1) => hasProperty(u$1, FiberTypeId$1);
/** @internal */
const isRuntimeFiber$1 = (self) => RuntimeFiberTypeId$1 in self;
/** @internal */
const _await$1 = (self) => self.await;
/** @internal */
const children$1 = (self) => self.children;
/** @internal */
const done$3 = (exit$3) => {
	return {
		...CommitPrototype$1,
		commit() {
			return join$1(this);
		},
		...fiberProto,
		id: () => none$6,
		await: succeed$9(exit$3),
		children: succeed$9([]),
		inheritAll: void_$4,
		poll: succeed$9(some$4(exit$3)),
		interruptAsFork: () => void_$4
	};
};
/** @internal */
const dump$1 = (self) => map$9(self.status, (status$2) => ({
	id: self.id(),
	status: status$2
}));
/** @internal */
const dumpAll$1 = (fibers) => forEachSequential(fibers, dump$1);
/** @internal */
const fail$6 = (error) => done$3(fail$7(error));
/** @internal */
const failCause$4 = (cause$2) => done$3(failCause$6(cause$2));
/** @internal */
const fromEffect$2 = (effect) => map$9(exit$2(effect), done$3);
/** @internal */
const id$1 = (self) => self.id();
/** @internal */
const inheritAll$1 = (self) => self.inheritAll;
/** @internal */
const interrupted$1 = (fiberId$2) => done$3(interrupt$3(fiberId$2));
/** @internal */
const interruptAll$1 = (fibers) => flatMap$5(fiberId$1, (fiberId$2) => pipe$3(fibers, interruptAllAs$1(fiberId$2)));
/** @internal */
const interruptAllAs$1 = /* @__PURE__ */ dual$1(2, /* @__PURE__ */ fnUntraced$1(function* (fibers, fiberId$2) {
	for (const fiber of fibers) {
		if (isRuntimeFiber$1(fiber)) {
			fiber.unsafeInterruptAsFork(fiberId$2);
			continue;
		}
		yield* fiber.interruptAsFork(fiberId$2);
	}
	for (const fiber of fibers) {
		if (isRuntimeFiber$1(fiber) && fiber.unsafePoll()) continue;
		yield* fiber.await;
	}
}));
/** @internal */
const interruptAsFork$1 = /* @__PURE__ */ dual$1(2, (self, fiberId$2) => self.interruptAsFork(fiberId$2));
/** @internal */
const join$1 = (self) => zipLeft$3(flatten$3(self.await), self.inheritAll);
/** @internal */
const map$6 = /* @__PURE__ */ dual$1(2, (self, f$1) => mapEffect$2(self, (a$1) => sync$3(() => f$1(a$1))));
/** @internal */
const mapEffect$2 = /* @__PURE__ */ dual$1(2, (self, f$1) => {
	return {
		...CommitPrototype$1,
		commit() {
			return join$1(this);
		},
		...fiberProto,
		id: () => self.id(),
		await: flatMap$5(self.await, forEachEffect(f$1)),
		children: self.children,
		inheritAll: self.inheritAll,
		poll: flatMap$5(self.poll, (result) => {
			switch (result._tag) {
				case "None": return succeed$9(none$7());
				case "Some": return pipe$3(forEachEffect(result.value, f$1), map$9(some$4));
			}
		}),
		interruptAsFork: (id$2) => self.interruptAsFork(id$2)
	};
});
/** @internal */
const mapFiber$1 = /* @__PURE__ */ dual$1(2, (self, f$1) => map$9(self.await, match$8({
	onFailure: (cause$2) => failCause$4(cause$2),
	onSuccess: (a$1) => f$1(a$1)
})));
/** @internal */
const match$3 = /* @__PURE__ */ dual$1(2, (self, { onFiber, onRuntimeFiber }) => {
	if (isRuntimeFiber$1(self)) return onRuntimeFiber(self);
	return onFiber(self);
});
/** @internal */
const _never = {
	...CommitPrototype$1,
	commit() {
		return join$1(this);
	},
	...fiberProto,
	id: () => none$6,
	await: never$3,
	children: /* @__PURE__ */ succeed$9([]),
	inheritAll: never$3,
	poll: /* @__PURE__ */ succeed$9(/* @__PURE__ */ none$7()),
	interruptAsFork: () => never$3
};
/** @internal */
const never$2 = _never;
/** @internal */
const orElse$3 = /* @__PURE__ */ dual$1(2, (self, that) => ({
	...CommitPrototype$1,
	commit() {
		return join$1(this);
	},
	...fiberProto,
	id: () => getOrElse$1(self.id(), that.id()),
	await: zipWith$4(self.await, that.await, (exit1, exit2) => isSuccess$2(exit1) ? exit1 : exit2),
	children: self.children,
	inheritAll: zipRight$3(that.inheritAll, self.inheritAll),
	poll: zipWith$4(self.poll, that.poll, (option1, option2) => {
		switch (option1._tag) {
			case "None": return none$7();
			case "Some": return isSuccess$2(option1.value) ? option1 : option2;
		}
	}),
	interruptAsFork: (id$2) => pipe$3(interruptAsFiber(self, id$2), zipRight$3(pipe$3(that, interruptAsFiber(id$2))), asVoid$3)
}));
/** @internal */
const orElseEither$2 = /* @__PURE__ */ dual$1(2, (self, that) => orElse$3(map$6(self, left), map$6(that, right)));
/** @internal */
const poll$1 = (self) => self.poll;
/** @internal */
const parseMs = (milliseconds) => {
	const roundTowardsZero = milliseconds > 0 ? Math.floor : Math.ceil;
	return {
		days: roundTowardsZero(milliseconds / 864e5),
		hours: roundTowardsZero(milliseconds / 36e5) % 24,
		minutes: roundTowardsZero(milliseconds / 6e4) % 60,
		seconds: roundTowardsZero(milliseconds / 1e3) % 60,
		milliseconds: roundTowardsZero(milliseconds) % 1e3,
		microseconds: roundTowardsZero(milliseconds * 1e3) % 1e3,
		nanoseconds: roundTowardsZero(milliseconds * 1e6) % 1e3
	};
};
/** @internal */
const renderStatus = (status$2) => {
	if (isDone$2(status$2)) return "Done";
	if (isRunning(status$2)) return "Running";
	return `Suspended(${interruptible$3(status$2.runtimeFlags) ? "interruptible" : "uninterruptible"})`;
};
/** @internal */
const pretty$2 = (self) => flatMap$5(currentTimeMillis, (now) => map$9(dump$1(self), (dump$2) => {
	const { days: days$1, hours: hours$1, milliseconds, minutes: minutes$1, seconds: seconds$1 } = parseMs(now - dump$2.id.startTimeMillis);
	const lifeMsg = (days$1 === 0 ? "" : `${days$1}d`) + (days$1 === 0 && hours$1 === 0 ? "" : `${hours$1}h`) + (days$1 === 0 && hours$1 === 0 && minutes$1 === 0 ? "" : `${minutes$1}m`) + (days$1 === 0 && hours$1 === 0 && minutes$1 === 0 && seconds$1 === 0 ? "" : `${seconds$1}s`) + `${milliseconds}ms`;
	const waitMsg = isSuspended(dump$2.status) ? (() => {
		const ids$2 = ids(dump$2.status.blockingOn);
		return size$8(ids$2) > 0 ? `waiting on ` + Array.from(ids$2).map((id$2) => `${id$2}`).join(", ") : "";
	})() : "";
	const statusMsg = renderStatus(dump$2.status);
	return `[Fiber](#${dump$2.id.id}) (${lifeMsg}) ${waitMsg}\n   Status: ${statusMsg}`;
}));
/** @internal */
const unsafeRoots$1 = () => Array.from(globalScope.roots);
/** @internal */
const roots$1 = /* @__PURE__ */ sync$3(unsafeRoots$1);
/** @internal */
const status$1 = (self) => self.status;
/** @internal */
const succeed$5 = (value) => done$3(succeed$7(value));
const void_$1 = /* @__PURE__ */ succeed$5(void 0);
/** @internal */
const currentFiberURI = "effect/FiberCurrent";
/** @internal */
const getCurrentFiber$1 = () => fromNullable$2(globalThis[currentFiberURI]);

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/logger.js
/** @internal */
const LoggerSymbolKey = "effect/Logger";
/** @internal */
const LoggerTypeId = /* @__PURE__ */ Symbol.for(LoggerSymbolKey);
const loggerVariance = {
	_Message: (_$1) => _$1,
	_Output: (_$1) => _$1
};
/** @internal */
const makeLogger = (log$2) => ({
	[LoggerTypeId]: loggerVariance,
	log: log$2,
	pipe() {
		return pipeArguments(this, arguments);
	}
});
/** @internal */
const map$5 = /* @__PURE__ */ dual$1(2, (self, f$1) => makeLogger((options) => f$1(self.log(options))));
/** @internal */
const none$3 = {
	[LoggerTypeId]: loggerVariance,
	log: constVoid$1,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/**
* Match strings that do not contain any whitespace characters, double quotes,
* or equal signs.
*
* @internal
*/
const textOnly = /^[^\s"=]*$/;
/**
* Used by both {@link stringLogger} and {@link logfmtLogger} to render a log
* message.
*
* @internal
*/
const format$1 = (quoteValue, whitespace) => ({ annotations: annotations$1, cause: cause$2, date, fiberId: fiberId$2, logLevel, message, spans }) => {
	const formatValue = (value) => value.match(textOnly) ? value : quoteValue(value);
	const format$3 = (label, value) => `${formatLabel(label)}=${formatValue(value)}`;
	const append$3 = (label, value) => " " + format$3(label, value);
	let out = format$3("timestamp", date.toISOString());
	out += append$3("level", logLevel.label);
	out += append$3("fiber", threadName$1(fiberId$2));
	const messages = ensure(message);
	for (let i$1 = 0; i$1 < messages.length; i$1++) out += append$3("message", toStringUnknown(messages[i$1], whitespace));
	if (!isEmptyType$1(cause$2)) out += append$3("cause", pretty$3(cause$2, { renderErrorCause: true }));
	for (const span$1 of spans) out += " " + render$1(date.getTime())(span$1);
	for (const [label, value] of annotations$1) out += append$3(label, toStringUnknown(value, whitespace));
	return out;
};
/** @internal */
const escapeDoubleQuotes = (s$1) => `"${s$1.replace(/\\([\s\S])|(")/g, "\\$1$2")}"`;
/** @internal */
const stringLogger = /* @__PURE__ */ makeLogger(/* @__PURE__ */ format$1(escapeDoubleQuotes));
/** @internal */
const structuredLogger = /* @__PURE__ */ makeLogger(({ annotations: annotations$1, cause: cause$2, date, fiberId: fiberId$2, logLevel, message, spans }) => {
	const now = date.getTime();
	const annotationsObj = {};
	const spansObj = {};
	if (size$7(annotations$1) > 0) for (const [k, v] of annotations$1) annotationsObj[k] = structuredMessage(v);
	if (isCons(spans)) for (const span$1 of spans) spansObj[span$1.label] = now - span$1.startTime;
	const messageArr = ensure(message);
	return {
		message: messageArr.length === 1 ? structuredMessage(messageArr[0]) : messageArr.map(structuredMessage),
		logLevel: logLevel.label,
		timestamp: date.toISOString(),
		cause: isEmpty$4(cause$2) ? void 0 : pretty$3(cause$2, { renderErrorCause: true }),
		annotations: annotationsObj,
		spans: spansObj,
		fiberId: threadName$1(fiberId$2)
	};
});
/** @internal */
const structuredMessage = (u$1) => {
	switch (typeof u$1) {
		case "bigint":
		case "function":
		case "symbol": return String(u$1);
		default: return toJSON(u$1);
	}
};
/** @internal */
const jsonLogger = /* @__PURE__ */ map$5(structuredLogger, stringifyCircular);
const colors = {
	bold: "1",
	red: "31",
	green: "32",
	yellow: "33",
	blue: "34",
	cyan: "36",
	white: "37",
	gray: "90",
	black: "30",
	bgBrightRed: "101"
};
const logLevelColors = {
	None: [],
	All: [],
	Trace: [colors.gray],
	Debug: [colors.blue],
	Info: [colors.green],
	Warning: [colors.yellow],
	Error: [colors.red],
	Fatal: [colors.bgBrightRed, colors.black]
};
const hasProcessStdout = typeof process === "object" && process !== null && typeof process.stdout === "object" && process.stdout !== null;
const processStdoutIsTTY = hasProcessStdout && process.stdout.isTTY === true;
const hasProcessStdoutOrDeno = hasProcessStdout || "Deno" in globalThis;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/metric/boundaries.js
/** @internal */
const MetricBoundariesSymbolKey = "effect/MetricBoundaries";
/** @internal */
const MetricBoundariesTypeId = /* @__PURE__ */ Symbol.for(MetricBoundariesSymbolKey);
/** @internal */
var MetricBoundariesImpl = class {
	values;
	[MetricBoundariesTypeId] = MetricBoundariesTypeId;
	constructor(values$6) {
		this.values = values$6;
		this._hash = pipe$3(string(MetricBoundariesSymbolKey), combine$11(array$1(this.values)));
	}
	_hash;
	[symbol$1]() {
		return this._hash;
	}
	[symbol](u$1) {
		return isMetricBoundaries(u$1) && equals(this.values, u$1.values);
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const isMetricBoundaries = (u$1) => hasProperty(u$1, MetricBoundariesTypeId);
/** @internal */
const fromIterable$4 = (iterable) => {
	return new MetricBoundariesImpl(pipe$3(iterable, appendAll$2(of$3(Number.POSITIVE_INFINITY)), dedupe));
};
/** @internal */
const exponential = (options) => pipe$3(makeBy(options.count - 1, (i$1) => options.start * Math.pow(options.factor, i$1)), unsafeFromArray, fromIterable$4);

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/metric/keyType.js
/** @internal */
const MetricKeyTypeSymbolKey = "effect/MetricKeyType";
/** @internal */
const MetricKeyTypeTypeId = /* @__PURE__ */ Symbol.for(MetricKeyTypeSymbolKey);
/** @internal */
const CounterKeyTypeSymbolKey = "effect/MetricKeyType/Counter";
/** @internal */
const CounterKeyTypeTypeId = /* @__PURE__ */ Symbol.for(CounterKeyTypeSymbolKey);
/** @internal */
const FrequencyKeyTypeSymbolKey = "effect/MetricKeyType/Frequency";
/** @internal */
const FrequencyKeyTypeTypeId = /* @__PURE__ */ Symbol.for(FrequencyKeyTypeSymbolKey);
/** @internal */
const GaugeKeyTypeSymbolKey = "effect/MetricKeyType/Gauge";
/** @internal */
const GaugeKeyTypeTypeId = /* @__PURE__ */ Symbol.for(GaugeKeyTypeSymbolKey);
/** @internal */
const HistogramKeyTypeSymbolKey = "effect/MetricKeyType/Histogram";
/** @internal */
const HistogramKeyTypeTypeId = /* @__PURE__ */ Symbol.for(HistogramKeyTypeSymbolKey);
/** @internal */
const SummaryKeyTypeSymbolKey = "effect/MetricKeyType/Summary";
/** @internal */
const SummaryKeyTypeTypeId = /* @__PURE__ */ Symbol.for(SummaryKeyTypeSymbolKey);
const metricKeyTypeVariance = {
	_In: (_$1) => _$1,
	_Out: (_$1) => _$1
};
/** @internal */
var CounterKeyType = class {
	incremental;
	bigint;
	[MetricKeyTypeTypeId] = metricKeyTypeVariance;
	[CounterKeyTypeTypeId] = CounterKeyTypeTypeId;
	constructor(incremental, bigint) {
		this.incremental = incremental;
		this.bigint = bigint;
		this._hash = string(CounterKeyTypeSymbolKey);
	}
	_hash;
	[symbol$1]() {
		return this._hash;
	}
	[symbol](that) {
		return isCounterKey(that);
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const FrequencyKeyTypeHash = /* @__PURE__ */ string(FrequencyKeyTypeSymbolKey);
/** @internal */
var FrequencyKeyType = class {
	preregisteredWords;
	[MetricKeyTypeTypeId] = metricKeyTypeVariance;
	[FrequencyKeyTypeTypeId] = FrequencyKeyTypeTypeId;
	constructor(preregisteredWords) {
		this.preregisteredWords = preregisteredWords;
	}
	[symbol$1]() {
		return FrequencyKeyTypeHash;
	}
	[symbol](that) {
		return isFrequencyKey(that);
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const GaugeKeyTypeHash = /* @__PURE__ */ string(GaugeKeyTypeSymbolKey);
/** @internal */
var GaugeKeyType = class {
	bigint;
	[MetricKeyTypeTypeId] = metricKeyTypeVariance;
	[GaugeKeyTypeTypeId] = GaugeKeyTypeTypeId;
	constructor(bigint) {
		this.bigint = bigint;
	}
	[symbol$1]() {
		return GaugeKeyTypeHash;
	}
	[symbol](that) {
		return isGaugeKey(that);
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
var HistogramKeyType = class {
	boundaries;
	[MetricKeyTypeTypeId] = metricKeyTypeVariance;
	[HistogramKeyTypeTypeId] = HistogramKeyTypeTypeId;
	constructor(boundaries) {
		this.boundaries = boundaries;
		this._hash = pipe$3(string(HistogramKeyTypeSymbolKey), combine$11(hash(this.boundaries)));
	}
	_hash;
	[symbol$1]() {
		return this._hash;
	}
	[symbol](that) {
		return isHistogramKey(that) && equals(this.boundaries, that.boundaries);
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
var SummaryKeyType = class {
	maxAge;
	maxSize;
	error;
	quantiles;
	[MetricKeyTypeTypeId] = metricKeyTypeVariance;
	[SummaryKeyTypeTypeId] = SummaryKeyTypeTypeId;
	constructor(maxAge, maxSize, error, quantiles) {
		this.maxAge = maxAge;
		this.maxSize = maxSize;
		this.error = error;
		this.quantiles = quantiles;
		this._hash = pipe$3(string(SummaryKeyTypeSymbolKey), combine$11(hash(this.maxAge)), combine$11(hash(this.maxSize)), combine$11(hash(this.error)), combine$11(array$1(this.quantiles)));
	}
	_hash;
	[symbol$1]() {
		return this._hash;
	}
	[symbol](that) {
		return isSummaryKey(that) && equals(this.maxAge, that.maxAge) && this.maxSize === that.maxSize && this.error === that.error && equals(this.quantiles, that.quantiles);
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const counter$4 = (options) => new CounterKeyType(options?.incremental ?? false, options?.bigint ?? false);
/** @internal */
const histogram$4 = (boundaries) => {
	return new HistogramKeyType(boundaries);
};
/** @internal */
const isCounterKey = (u$1) => hasProperty(u$1, CounterKeyTypeTypeId);
/** @internal */
const isFrequencyKey = (u$1) => hasProperty(u$1, FrequencyKeyTypeTypeId);
/** @internal */
const isGaugeKey = (u$1) => hasProperty(u$1, GaugeKeyTypeTypeId);
/** @internal */
const isHistogramKey = (u$1) => hasProperty(u$1, HistogramKeyTypeTypeId);
/** @internal */
const isSummaryKey = (u$1) => hasProperty(u$1, SummaryKeyTypeTypeId);

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/metric/key.js
/** @internal */
const MetricKeySymbolKey = "effect/MetricKey";
/** @internal */
const MetricKeyTypeId = /* @__PURE__ */ Symbol.for(MetricKeySymbolKey);
const metricKeyVariance = { _Type: (_$1) => _$1 };
const arrayEquivilence = /* @__PURE__ */ getEquivalence$2(equals);
/** @internal */
var MetricKeyImpl = class {
	name;
	keyType;
	description;
	tags;
	[MetricKeyTypeId] = metricKeyVariance;
	constructor(name, keyType, description, tags = []) {
		this.name = name;
		this.keyType = keyType;
		this.description = description;
		this.tags = tags;
		this._hash = pipe$3(string(this.name + this.description), combine$11(hash(this.keyType)), combine$11(array$1(this.tags)));
	}
	_hash;
	[symbol$1]() {
		return this._hash;
	}
	[symbol](u$1) {
		return isMetricKey(u$1) && this.name === u$1.name && equals(this.keyType, u$1.keyType) && equals(this.description, u$1.description) && arrayEquivilence(this.tags, u$1.tags);
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const isMetricKey = (u$1) => hasProperty(u$1, MetricKeyTypeId);
/** @internal */
const counter$3 = (name, options) => new MetricKeyImpl(name, counter$4(options), fromNullable$2(options?.description));
/** @internal */
const histogram$3 = (name, boundaries, description) => new MetricKeyImpl(name, histogram$4(boundaries), fromNullable$2(description));
/** @internal */
const taggedWithLabels$1 = /* @__PURE__ */ dual$1(2, (self, extraTags) => extraTags.length === 0 ? self : new MetricKeyImpl(self.name, self.keyType, self.description, union$8(self.tags, extraTags)));

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/metric/state.js
/** @internal */
const MetricStateSymbolKey = "effect/MetricState";
/** @internal */
const MetricStateTypeId = /* @__PURE__ */ Symbol.for(MetricStateSymbolKey);
/** @internal */
const CounterStateSymbolKey = "effect/MetricState/Counter";
/** @internal */
const CounterStateTypeId = /* @__PURE__ */ Symbol.for(CounterStateSymbolKey);
/** @internal */
const FrequencyStateSymbolKey = "effect/MetricState/Frequency";
/** @internal */
const FrequencyStateTypeId = /* @__PURE__ */ Symbol.for(FrequencyStateSymbolKey);
/** @internal */
const GaugeStateSymbolKey = "effect/MetricState/Gauge";
/** @internal */
const GaugeStateTypeId = /* @__PURE__ */ Symbol.for(GaugeStateSymbolKey);
/** @internal */
const HistogramStateSymbolKey = "effect/MetricState/Histogram";
/** @internal */
const HistogramStateTypeId = /* @__PURE__ */ Symbol.for(HistogramStateSymbolKey);
/** @internal */
const SummaryStateSymbolKey = "effect/MetricState/Summary";
/** @internal */
const SummaryStateTypeId = /* @__PURE__ */ Symbol.for(SummaryStateSymbolKey);
const metricStateVariance = { _A: (_$1) => _$1 };
/** @internal */
var CounterState = class {
	count;
	[MetricStateTypeId] = metricStateVariance;
	[CounterStateTypeId] = CounterStateTypeId;
	constructor(count) {
		this.count = count;
	}
	[symbol$1]() {
		return pipe$3(hash(CounterStateSymbolKey), combine$11(hash(this.count)), cached$2(this));
	}
	[symbol](that) {
		return isCounterState(that) && this.count === that.count;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const arrayEquals = /* @__PURE__ */ getEquivalence$2(equals);
/** @internal */
var FrequencyState = class {
	occurrences;
	[MetricStateTypeId] = metricStateVariance;
	[FrequencyStateTypeId] = FrequencyStateTypeId;
	constructor(occurrences) {
		this.occurrences = occurrences;
	}
	_hash;
	[symbol$1]() {
		return pipe$3(string(FrequencyStateSymbolKey), combine$11(array$1(fromIterable$10(this.occurrences.entries()))), cached$2(this));
	}
	[symbol](that) {
		return isFrequencyState(that) && arrayEquals(fromIterable$10(this.occurrences.entries()), fromIterable$10(that.occurrences.entries()));
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
var GaugeState = class {
	value;
	[MetricStateTypeId] = metricStateVariance;
	[GaugeStateTypeId] = GaugeStateTypeId;
	constructor(value) {
		this.value = value;
	}
	[symbol$1]() {
		return pipe$3(hash(GaugeStateSymbolKey), combine$11(hash(this.value)), cached$2(this));
	}
	[symbol](u$1) {
		return isGaugeState(u$1) && this.value === u$1.value;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
var HistogramState = class {
	buckets;
	count;
	min;
	max;
	sum;
	[MetricStateTypeId] = metricStateVariance;
	[HistogramStateTypeId] = HistogramStateTypeId;
	constructor(buckets, count, min$2, max$4, sum) {
		this.buckets = buckets;
		this.count = count;
		this.min = min$2;
		this.max = max$4;
		this.sum = sum;
	}
	[symbol$1]() {
		return pipe$3(hash(HistogramStateSymbolKey), combine$11(hash(this.buckets)), combine$11(hash(this.count)), combine$11(hash(this.min)), combine$11(hash(this.max)), combine$11(hash(this.sum)), cached$2(this));
	}
	[symbol](that) {
		return isHistogramState(that) && equals(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
var SummaryState = class {
	error;
	quantiles;
	count;
	min;
	max;
	sum;
	[MetricStateTypeId] = metricStateVariance;
	[SummaryStateTypeId] = SummaryStateTypeId;
	constructor(error, quantiles, count, min$2, max$4, sum) {
		this.error = error;
		this.quantiles = quantiles;
		this.count = count;
		this.min = min$2;
		this.max = max$4;
		this.sum = sum;
	}
	[symbol$1]() {
		return pipe$3(hash(SummaryStateSymbolKey), combine$11(hash(this.error)), combine$11(hash(this.quantiles)), combine$11(hash(this.count)), combine$11(hash(this.min)), combine$11(hash(this.max)), combine$11(hash(this.sum)), cached$2(this));
	}
	[symbol](that) {
		return isSummaryState(that) && this.error === that.error && equals(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const counter$2 = (count) => new CounterState(count);
/** @internal */
const frequency$1 = (occurrences) => {
	return new FrequencyState(occurrences);
};
/** @internal */
const gauge$1 = (count) => new GaugeState(count);
/** @internal */
const histogram$2 = (options) => new HistogramState(options.buckets, options.count, options.min, options.max, options.sum);
/** @internal */
const summary$1 = (options) => new SummaryState(options.error, options.quantiles, options.count, options.min, options.max, options.sum);
/** @internal */
const isCounterState = (u$1) => hasProperty(u$1, CounterStateTypeId);
/**
* @since 2.0.0
* @category refinements
*/
const isFrequencyState = (u$1) => hasProperty(u$1, FrequencyStateTypeId);
/**
* @since 2.0.0
* @category refinements
*/
const isGaugeState = (u$1) => hasProperty(u$1, GaugeStateTypeId);
/**
* @since 2.0.0
* @category refinements
*/
const isHistogramState = (u$1) => hasProperty(u$1, HistogramStateTypeId);
/**
* @since 2.0.0
* @category refinements
*/
const isSummaryState = (u$1) => hasProperty(u$1, SummaryStateTypeId);

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/metric/hook.js
/** @internal */
const MetricHookSymbolKey = "effect/MetricHook";
/** @internal */
const MetricHookTypeId = /* @__PURE__ */ Symbol.for(MetricHookSymbolKey);
const metricHookVariance = {
	_In: (_$1) => _$1,
	_Out: (_$1) => _$1
};
/** @internal */
const make$16 = (options) => ({
	[MetricHookTypeId]: metricHookVariance,
	pipe() {
		return pipeArguments(this, arguments);
	},
	...options
});
const bigint0 = /* @__PURE__ */ BigInt(0);
/** @internal */
const counter$1 = (key) => {
	let sum = key.keyType.bigint ? bigint0 : 0;
	const canUpdate = key.keyType.incremental ? key.keyType.bigint ? (value) => value >= bigint0 : (value) => value >= 0 : (_value) => true;
	const update$5 = (value) => {
		if (canUpdate(value)) sum = sum + value;
	};
	return make$16({
		get: () => counter$2(sum),
		update: update$5,
		modify: update$5
	});
};
/** @internal */
const frequency = (key) => {
	const values$6 = /* @__PURE__ */ new Map();
	for (const word of key.keyType.preregisteredWords) values$6.set(word, 0);
	const update$5 = (word) => {
		const slotCount = values$6.get(word) ?? 0;
		values$6.set(word, slotCount + 1);
	};
	return make$16({
		get: () => frequency$1(values$6),
		update: update$5,
		modify: update$5
	});
};
/** @internal */
const gauge = (_key, startAt) => {
	let value = startAt;
	return make$16({
		get: () => gauge$1(value),
		update: (v) => {
			value = v;
		},
		modify: (v) => {
			value = value + v;
		}
	});
};
/** @internal */
const histogram$1 = (key) => {
	const bounds = key.keyType.boundaries.values;
	const size$11 = bounds.length;
	const values$6 = new Uint32Array(size$11 + 1);
	const boundaries = new Float64Array(size$11);
	let count = 0;
	let sum = 0;
	let min$2 = Number.MAX_VALUE;
	let max$4 = Number.MIN_VALUE;
	pipe$3(bounds, sort(Order$4), map$15((n$1, i$1) => {
		boundaries[i$1] = n$1;
	}));
	const update$5 = (value) => {
		let from = 0;
		let to = size$11;
		while (from !== to) {
			const mid = Math.floor(from + (to - from) / 2);
			if (value <= boundaries[mid]) to = mid;
			else from = mid;
			if (to === from + 1) if (value <= boundaries[from]) to = from;
			else from = to;
		}
		values$6[from] = values$6[from] + 1;
		count = count + 1;
		sum = sum + value;
		if (value < min$2) min$2 = value;
		if (value > max$4) max$4 = value;
	};
	const getBuckets = () => {
		const builder = allocate(size$11);
		let cumulated = 0;
		for (let i$1 = 0; i$1 < size$11; i$1++) {
			const boundary = boundaries[i$1];
			const value = values$6[i$1];
			cumulated = cumulated + value;
			builder[i$1] = [boundary, cumulated];
		}
		return builder;
	};
	return make$16({
		get: () => histogram$2({
			buckets: getBuckets(),
			count,
			min: min$2,
			max: max$4,
			sum
		}),
		update: update$5,
		modify: update$5
	});
};
/** @internal */
const summary = (key) => {
	const { error, maxAge, maxSize, quantiles } = key.keyType;
	const sortedQuantiles = pipe$3(quantiles, sort(Order$4));
	const values$6 = allocate(maxSize);
	let head$4 = 0;
	let count = 0;
	let sum = 0;
	let min$2 = 0;
	let max$4 = 0;
	const snapshot = (now) => {
		const builder = [];
		let i$1 = 0;
		while (i$1 !== maxSize - 1) {
			const item = values$6[i$1];
			if (item != null) {
				const [t$1, v] = item;
				const age = millis(now - t$1);
				if (greaterThanOrEqualTo(age, zero) && lessThanOrEqualTo(age, maxAge)) builder.push(v);
			}
			i$1 = i$1 + 1;
		}
		return calculateQuantiles(error, sortedQuantiles, sort(builder, Order$4));
	};
	const observe = (value, timestamp) => {
		if (maxSize > 0) {
			head$4 = head$4 + 1;
			const target = head$4 % maxSize;
			values$6[target] = [timestamp, value];
		}
		min$2 = count === 0 ? value : Math.min(min$2, value);
		max$4 = count === 0 ? value : Math.max(max$4, value);
		count = count + 1;
		sum = sum + value;
	};
	return make$16({
		get: () => summary$1({
			error,
			quantiles: snapshot(Date.now()),
			count,
			min: min$2,
			max: max$4,
			sum
		}),
		update: ([value, timestamp]) => observe(value, timestamp),
		modify: ([value, timestamp]) => observe(value, timestamp)
	});
};
/** @internal */
const calculateQuantiles = (error, sortedQuantiles, sortedSamples) => {
	const sampleCount = sortedSamples.length;
	if (!isNonEmptyReadonlyArray(sortedQuantiles)) return empty$33();
	const head$4 = sortedQuantiles[0];
	const tail = sortedQuantiles.slice(1);
	const resolvedHead = resolveQuantile(error, sampleCount, none$7(), 0, head$4, sortedSamples);
	const resolved = of$4(resolvedHead);
	tail.forEach((quantile) => {
		resolved.push(resolveQuantile(error, sampleCount, resolvedHead.value, resolvedHead.consumed, quantile, resolvedHead.rest));
	});
	return map$15(resolved, (rq) => [rq.quantile, rq.value]);
};
/** @internal */
const resolveQuantile = (error, sampleCount, current, consumed, quantile, rest) => {
	let error_1 = error;
	let sampleCount_1 = sampleCount;
	let current_1 = current;
	let consumed_1 = consumed;
	let quantile_1 = quantile;
	let rest_1 = rest;
	let error_2 = error;
	let sampleCount_2 = sampleCount;
	let current_2 = current;
	let consumed_2 = consumed;
	let quantile_2 = quantile;
	let rest_2 = rest;
	while (1) {
		if (!isNonEmptyReadonlyArray(rest_1)) return {
			quantile: quantile_1,
			value: none$7(),
			consumed: consumed_1,
			rest: []
		};
		if (quantile_1 === 1) return {
			quantile: quantile_1,
			value: some$4(lastNonEmpty(rest_1)),
			consumed: consumed_1 + rest_1.length,
			rest: []
		};
		const headValue = headNonEmpty$1(rest_1);
		const sameHead = span(rest_1, (n$1) => n$1 === headValue);
		const desired = quantile_1 * sampleCount_1;
		const allowedError = error_1 / 2 * desired;
		const candConsumed = consumed_1 + sameHead[0].length;
		const candError = Math.abs(candConsumed - desired);
		if (candConsumed < desired - allowedError) {
			error_2 = error_1;
			sampleCount_2 = sampleCount_1;
			current_2 = head$3(rest_1);
			consumed_2 = candConsumed;
			quantile_2 = quantile_1;
			rest_2 = sameHead[1];
			error_1 = error_2;
			sampleCount_1 = sampleCount_2;
			current_1 = current_2;
			consumed_1 = consumed_2;
			quantile_1 = quantile_2;
			rest_1 = rest_2;
			continue;
		}
		if (candConsumed > desired + allowedError) {
			const valueToReturn = isNone$2(current_1) ? some$4(headValue) : current_1;
			return {
				quantile: quantile_1,
				value: valueToReturn,
				consumed: consumed_1,
				rest: rest_1
			};
		}
		switch (current_1._tag) {
			case "None":
				error_2 = error_1;
				sampleCount_2 = sampleCount_1;
				current_2 = head$3(rest_1);
				consumed_2 = candConsumed;
				quantile_2 = quantile_1;
				rest_2 = sameHead[1];
				error_1 = error_2;
				sampleCount_1 = sampleCount_2;
				current_1 = current_2;
				consumed_1 = consumed_2;
				quantile_1 = quantile_2;
				rest_1 = rest_2;
				continue;
			case "Some":
				if (candError < Math.abs(desired - current_1.value)) {
					error_2 = error_1;
					sampleCount_2 = sampleCount_1;
					current_2 = head$3(rest_1);
					consumed_2 = candConsumed;
					quantile_2 = quantile_1;
					rest_2 = sameHead[1];
					error_1 = error_2;
					sampleCount_1 = sampleCount_2;
					current_1 = current_2;
					consumed_1 = consumed_2;
					quantile_1 = quantile_2;
					rest_1 = rest_2;
					continue;
				}
				return {
					quantile: quantile_1,
					value: some$4(current_1.value),
					consumed: consumed_1,
					rest: rest_1
				};
		}
	}
	throw new Error("BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues");
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/metric/pair.js
/** @internal */
const MetricPairSymbolKey = "effect/MetricPair";
/** @internal */
const MetricPairTypeId = /* @__PURE__ */ Symbol.for(MetricPairSymbolKey);
const metricPairVariance = { _Type: (_$1) => _$1 };
/** @internal */
const unsafeMake = (metricKey, metricState) => {
	return {
		[MetricPairTypeId]: metricPairVariance,
		metricKey,
		metricState,
		pipe() {
			return pipeArguments(this, arguments);
		}
	};
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/metric/registry.js
/** @internal */
const MetricRegistrySymbolKey = "effect/MetricRegistry";
/** @internal */
const MetricRegistryTypeId = /* @__PURE__ */ Symbol.for(MetricRegistrySymbolKey);
/** @internal */
var MetricRegistryImpl = class {
	[MetricRegistryTypeId] = MetricRegistryTypeId;
	map = /* @__PURE__ */ empty$14();
	snapshot() {
		const result = [];
		for (const [key, hook] of this.map) result.push(unsafeMake(key, hook.get()));
		return result;
	}
	get(key) {
		const hook = pipe$3(this.map, get$4(key), getOrUndefined);
		if (hook == null) {
			if (isCounterKey(key.keyType)) return this.getCounter(key);
			if (isGaugeKey(key.keyType)) return this.getGauge(key);
			if (isFrequencyKey(key.keyType)) return this.getFrequency(key);
			if (isHistogramKey(key.keyType)) return this.getHistogram(key);
			if (isSummaryKey(key.keyType)) return this.getSummary(key);
			throw new Error("BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues");
		} else return hook;
	}
	getCounter(key) {
		let value = pipe$3(this.map, get$4(key), getOrUndefined);
		if (value == null) {
			const counter$5 = counter$1(key);
			if (!pipe$3(this.map, has$2(key))) pipe$3(this.map, set$2(key, counter$5));
			value = counter$5;
		}
		return value;
	}
	getFrequency(key) {
		let value = pipe$3(this.map, get$4(key), getOrUndefined);
		if (value == null) {
			const frequency$2 = frequency(key);
			if (!pipe$3(this.map, has$2(key))) pipe$3(this.map, set$2(key, frequency$2));
			value = frequency$2;
		}
		return value;
	}
	getGauge(key) {
		let value = pipe$3(this.map, get$4(key), getOrUndefined);
		if (value == null) {
			const gauge$2 = gauge(key, key.keyType.bigint ? BigInt(0) : 0);
			if (!pipe$3(this.map, has$2(key))) pipe$3(this.map, set$2(key, gauge$2));
			value = gauge$2;
		}
		return value;
	}
	getHistogram(key) {
		let value = pipe$3(this.map, get$4(key), getOrUndefined);
		if (value == null) {
			const histogram$5 = histogram$1(key);
			if (!pipe$3(this.map, has$2(key))) pipe$3(this.map, set$2(key, histogram$5));
			value = histogram$5;
		}
		return value;
	}
	getSummary(key) {
		let value = pipe$3(this.map, get$4(key), getOrUndefined);
		if (value == null) {
			const summary$2 = summary(key);
			if (!pipe$3(this.map, has$2(key))) pipe$3(this.map, set$2(key, summary$2));
			value = summary$2;
		}
		return value;
	}
};
/** @internal */
const make$15 = () => {
	return new MetricRegistryImpl();
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/metric.js
/** @internal */
const MetricSymbolKey = "effect/Metric";
/** @internal */
const MetricTypeId = /* @__PURE__ */ Symbol.for(MetricSymbolKey);
const metricVariance = {
	_Type: (_$1) => _$1,
	_In: (_$1) => _$1,
	_Out: (_$1) => _$1
};
/** @internal */
const globalMetricRegistry = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Metric/globalMetricRegistry"), () => make$15());
/** @internal */
const make$14 = function(keyType, unsafeUpdate, unsafeValue, unsafeModify) {
	const metric = Object.assign((effect) => tap$1(effect, (a$1) => update$1(metric, a$1)), {
		[MetricTypeId]: metricVariance,
		keyType,
		unsafeUpdate,
		unsafeValue,
		unsafeModify,
		register() {
			this.unsafeValue([]);
			return this;
		},
		pipe() {
			return pipeArguments(this, arguments);
		}
	});
	return metric;
};
/** @internal */
const counter = (name, options) => fromMetricKey(counter$3(name, options));
/** @internal */
const fromMetricKey = (key) => {
	let untaggedHook;
	const hookCache = /* @__PURE__ */ new WeakMap();
	const hook = (extraTags) => {
		if (extraTags.length === 0) {
			if (untaggedHook !== void 0) return untaggedHook;
			untaggedHook = globalMetricRegistry.get(key);
			return untaggedHook;
		}
		let hook$1 = hookCache.get(extraTags);
		if (hook$1 !== void 0) return hook$1;
		hook$1 = globalMetricRegistry.get(taggedWithLabels$1(key, extraTags));
		hookCache.set(extraTags, hook$1);
		return hook$1;
	};
	return make$14(key.keyType, (input, extraTags) => hook(extraTags).update(input), (extraTags) => hook(extraTags).get(), (input, extraTags) => hook(extraTags).modify(input));
};
/** @internal */
const histogram = (name, boundaries, description) => fromMetricKey(histogram$3(name, boundaries, description));
/** @internal */
const tagged$2 = /* @__PURE__ */ dual$1(3, (self, key, value) => taggedWithLabels(self, [make$17(key, value)]));
/** @internal */
const taggedWithLabels = /* @__PURE__ */ dual$1(2, (self, extraTags) => {
	return make$14(self.keyType, (input, extraTags1) => self.unsafeUpdate(input, union$8(extraTags, extraTags1)), (extraTags1) => self.unsafeValue(union$8(extraTags, extraTags1)), (input, extraTags1) => self.unsafeModify(input, union$8(extraTags, extraTags1)));
});
const update$1 = /* @__PURE__ */ dual$1(2, (self, input) => fiberRefGetWith(currentMetricLabels, (tags) => sync$3(() => self.unsafeUpdate(input, tags))));

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/request.js
/** @internal */
const RequestSymbolKey = "effect/Request";
/** @internal */
const RequestTypeId$1 = /* @__PURE__ */ Symbol.for(RequestSymbolKey);
const requestVariance = {
	_E: (_$1) => _$1,
	_A: (_$1) => _$1
};
const RequestPrototype = {
	...StructuralPrototype,
	[RequestTypeId$1]: requestVariance
};
/** @internal */
const isRequest$1 = (u$1) => hasProperty(u$1, RequestTypeId$1);
/** @internal */
const of$1 = () => (args$2) => Object.assign(Object.create(RequestPrototype), args$2);
/** @internal */
const tagged$1 = (tag$1) => (args$2) => {
	const request$1 = Object.assign(Object.create(RequestPrototype), args$2);
	request$1._tag = tag$1;
	return request$1;
};
/** @internal */
const Class$2 = /* @__PURE__ */ function() {
	function Class$5(args$2) {
		if (args$2) Object.assign(this, args$2);
	}
	Class$5.prototype = RequestPrototype;
	return Class$5;
}();
/** @internal */
const TaggedClass$1 = (tag$1) => {
	return class TaggedClass$2 extends Class$2 {
		_tag = tag$1;
	};
};
/** @internal */
const complete$2 = /* @__PURE__ */ dual$1(2, (self, result) => fiberRefGetWith(currentRequestMap, (map$18) => sync$3(() => {
	if (map$18.has(self)) {
		const entry = map$18.get(self);
		if (!entry.state.completed) {
			entry.state.completed = true;
			deferredUnsafeDone(entry.result, result);
		}
	}
})));
/** @internal */
const completeEffect$1 = /* @__PURE__ */ dual$1(2, (self, effect) => matchEffect$2(effect, {
	onFailure: (error) => complete$2(self, exitFail(error)),
	onSuccess: (value) => complete$2(self, exitSucceed$1(value))
}));
/** @internal */
const fail$5 = /* @__PURE__ */ dual$1(2, (self, error) => complete$2(self, exitFail(error)));
/** @internal */
const failCause$3 = /* @__PURE__ */ dual$1(2, (self, cause$2) => complete$2(self, exitFailCause$1(cause$2)));
/** @internal */
const succeed$4 = /* @__PURE__ */ dual$1(2, (self, value) => complete$2(self, exitSucceed$1(value)));
/** @internal */
var Listeners = class {
	count = 0;
	observers = /* @__PURE__ */ new Set();
	interrupted = false;
	addObserver(f$1) {
		this.observers.add(f$1);
	}
	removeObserver(f$1) {
		this.observers.delete(f$1);
	}
	increment() {
		this.count++;
		this.observers.forEach((f$1) => f$1(this.count));
	}
	decrement() {
		this.count--;
		this.observers.forEach((f$1) => f$1(this.count));
	}
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/redBlackTree/iterator.js
/** @internal */
const Direction$1 = {
	Forward: 0,
	Backward: 1
};
/** @internal */
var RedBlackTreeIterator = class RedBlackTreeIterator {
	self;
	stack;
	direction;
	count = 0;
	constructor(self, stack, direction) {
		this.self = self;
		this.stack = stack;
		this.direction = direction;
	}
	/**
	* Clones the iterator
	*/
	clone() {
		return new RedBlackTreeIterator(this.self, this.stack.slice(), this.direction);
	}
	/**
	* Reverse the traversal direction
	*/
	reversed() {
		return new RedBlackTreeIterator(this.self, this.stack.slice(), this.direction === Direction$1.Forward ? Direction$1.Backward : Direction$1.Forward);
	}
	/**
	* Iterator next
	*/
	next() {
		const entry = this.entry;
		this.count++;
		if (this.direction === Direction$1.Forward) this.moveNext();
		else this.movePrev();
		switch (entry._tag) {
			case "None": return {
				done: true,
				value: this.count
			};
			case "Some": return {
				done: false,
				value: entry.value
			};
		}
	}
	/**
	* Returns the key
	*/
	get key() {
		if (this.stack.length > 0) return some$4(this.stack[this.stack.length - 1].key);
		return none$7();
	}
	/**
	* Returns the value
	*/
	get value() {
		if (this.stack.length > 0) return some$4(this.stack[this.stack.length - 1].value);
		return none$7();
	}
	/**
	* Returns the key
	*/
	get entry() {
		return map$16(last$2(this.stack), (node) => [node.key, node.value]);
	}
	/**
	* Returns the position of this iterator in the sorted list
	*/
	get index() {
		let idx = 0;
		const stack = this.stack;
		if (stack.length === 0) {
			const r$1 = this.self._root;
			if (r$1 != null) return r$1.count;
			return 0;
		} else if (stack[stack.length - 1].left != null) idx = stack[stack.length - 1].left.count;
		for (let s$1 = stack.length - 2; s$1 >= 0; --s$1) if (stack[s$1 + 1] === stack[s$1].right) {
			++idx;
			if (stack[s$1].left != null) idx += stack[s$1].left.count;
		}
		return idx;
	}
	/**
	* Advances iterator to next element in list
	*/
	moveNext() {
		const stack = this.stack;
		if (stack.length === 0) return;
		let n$1 = stack[stack.length - 1];
		if (n$1.right != null) {
			n$1 = n$1.right;
			while (n$1 != null) {
				stack.push(n$1);
				n$1 = n$1.left;
			}
		} else {
			stack.pop();
			while (stack.length > 0 && stack[stack.length - 1].right === n$1) {
				n$1 = stack[stack.length - 1];
				stack.pop();
			}
		}
	}
	/**
	* Checks if there is a next element
	*/
	get hasNext() {
		const stack = this.stack;
		if (stack.length === 0) return false;
		if (stack[stack.length - 1].right != null) return true;
		for (let s$1 = stack.length - 1; s$1 > 0; --s$1) if (stack[s$1 - 1].left === stack[s$1]) return true;
		return false;
	}
	/**
	* Advances iterator to previous element in list
	*/
	movePrev() {
		const stack = this.stack;
		if (stack.length === 0) return;
		let n$1 = stack[stack.length - 1];
		if (n$1 != null && n$1.left != null) {
			n$1 = n$1.left;
			while (n$1 != null) {
				stack.push(n$1);
				n$1 = n$1.right;
			}
		} else {
			stack.pop();
			while (stack.length > 0 && stack[stack.length - 1].left === n$1) {
				n$1 = stack[stack.length - 1];
				stack.pop();
			}
		}
	}
	/**
	* Checks if there is a previous element
	*/
	get hasPrev() {
		const stack = this.stack;
		if (stack.length === 0) return false;
		if (stack[stack.length - 1].left != null) return true;
		for (let s$1 = stack.length - 1; s$1 > 0; --s$1) if (stack[s$1 - 1].right === stack[s$1]) return true;
		return false;
	}
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/redBlackTree/node.js
/** @internal */
const Color = {
	Red: 0,
	Black: 1
};
/** @internal */
const clone = ({ color, count, key, left: left$2, right: right$2, value }) => ({
	color,
	key,
	value,
	left: left$2,
	right: right$2,
	count
});
/** @internal */
function swap(n$1, v) {
	n$1.key = v.key;
	n$1.value = v.value;
	n$1.left = v.left;
	n$1.right = v.right;
	n$1.color = v.color;
	n$1.count = v.count;
}
/** @internal */
const repaint = ({ count, key, left: left$2, right: right$2, value }, color) => ({
	color,
	key,
	value,
	left: left$2,
	right: right$2,
	count
});
/** @internal */
const recount = (node) => {
	node.count = 1 + (node.left?.count ?? 0) + (node.right?.count ?? 0);
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/redBlackTree.js
const RedBlackTreeSymbolKey = "effect/RedBlackTree";
/** @internal */
const RedBlackTreeTypeId = /* @__PURE__ */ Symbol.for(RedBlackTreeSymbolKey);
const redBlackTreeVariance = {
	_Key: (_$1) => _$1,
	_Value: (_$1) => _$1
};
const RedBlackTreeProto = {
	[RedBlackTreeTypeId]: redBlackTreeVariance,
	[symbol$1]() {
		let hash$1 = hash(RedBlackTreeSymbolKey);
		for (const item of this) hash$1 ^= pipe$3(hash(item[0]), combine$11(hash(item[1])));
		return cached$2(this, hash$1);
	},
	[symbol](that) {
		if (isRedBlackTree$1(that)) {
			if ((this._root?.count ?? 0) !== (that._root?.count ?? 0)) return false;
			const entries$2 = Array.from(that);
			return Array.from(this).every((itemSelf, i$1) => {
				const itemThat = entries$2[i$1];
				return equals(itemSelf[0], itemThat[0]) && equals(itemSelf[1], itemThat[1]);
			});
		}
		return false;
	},
	[Symbol.iterator]() {
		const stack = [];
		let n$1 = this._root;
		while (n$1 != null) {
			stack.push(n$1);
			n$1 = n$1.left;
		}
		return new RedBlackTreeIterator(this, stack, Direction$1.Forward);
	},
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "RedBlackTree",
			values: Array.from(this).map(toJSON)
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const makeImpl = (ord, root) => {
	const tree = Object.create(RedBlackTreeProto);
	tree._ord = ord;
	tree._root = root;
	return tree;
};
/** @internal */
const isRedBlackTree$1 = (u$1) => hasProperty(u$1, RedBlackTreeTypeId);
/** @internal */
const empty$7 = (ord) => makeImpl(ord, void 0);
/** @internal */
const fromIterable$3 = /* @__PURE__ */ dual$1(2, (entries$2, ord) => {
	let tree = empty$7(ord);
	for (const [key, value] of entries$2) tree = insert$1(tree, key, value);
	return tree;
});
/** @internal */
const make$13 = (ord) => (...entries$2) => {
	return fromIterable$3(entries$2, ord);
};
/** @internal */
const atBackwards = /* @__PURE__ */ dual$1(2, (self, index) => at$1(self, index, Direction$1.Backward));
/** @internal */
const atForwards = /* @__PURE__ */ dual$1(2, (self, index) => at$1(self, index, Direction$1.Forward));
const at$1 = (self, index, direction) => {
	return { [Symbol.iterator]: () => {
		if (index < 0) return new RedBlackTreeIterator(self, [], direction);
		let node = self._root;
		const stack = [];
		while (node !== void 0) {
			stack.push(node);
			if (node.left !== void 0) {
				if (index < node.left.count) {
					node = node.left;
					continue;
				}
				index -= node.left.count;
			}
			if (!index) return new RedBlackTreeIterator(self, stack, direction);
			index -= 1;
			if (node.right !== void 0) {
				if (index >= node.right.count) break;
				node = node.right;
			} else break;
		}
		return new RedBlackTreeIterator(self, [], direction);
	} };
};
/** @internal */
const findAll$1 = /* @__PURE__ */ dual$1(2, (self, key) => {
	const stack = [];
	let node = self._root;
	let result = empty$30();
	while (node !== void 0 || stack.length > 0) if (node) {
		stack.push(node);
		node = node.left;
	} else {
		const current = stack.pop();
		if (equals(key, current.key)) result = prepend$1(current.value)(result);
		node = current.right;
	}
	return result;
});
/** @internal */
const findFirst$2 = /* @__PURE__ */ dual$1(2, (self, key) => {
	const cmp = self._ord;
	let node = self._root;
	while (node !== void 0) {
		const d = cmp(key, node.key);
		if (equals(key, node.key)) return some$4(node.value);
		if (d <= 0) node = node.left;
		else node = node.right;
	}
	return none$7();
});
/** @internal */
const first$1 = (self) => {
	let node = self._root;
	let current = self._root;
	while (node !== void 0) {
		current = node;
		node = node.left;
	}
	return current ? some$4([current.key, current.value]) : none$7();
};
/** @internal */
const getAt$1 = /* @__PURE__ */ dual$1(2, (self, index) => {
	if (index < 0) return none$7();
	let root = self._root;
	let node = void 0;
	while (root !== void 0) {
		node = root;
		if (root.left) {
			if (index < root.left.count) {
				root = root.left;
				continue;
			}
			index -= root.left.count;
		}
		if (!index) return some$4([node.key, node.value]);
		index -= 1;
		if (root.right) {
			if (index >= root.right.count) break;
			root = root.right;
		} else break;
	}
	return none$7();
});
/** @internal */
const getOrder$1 = (tree) => tree._ord;
/** @internal */
const has$1 = /* @__PURE__ */ dual$1(2, (self, key) => isSome(findFirst$2(self, key)));
/** @internal */
const insert$1 = /* @__PURE__ */ dual$1(3, (self, key, value) => {
	const cmp = self._ord;
	let n$1 = self._root;
	const n_stack = [];
	const d_stack = [];
	while (n$1 != null) {
		const d = cmp(key, n$1.key);
		n_stack.push(n$1);
		d_stack.push(d);
		if (d <= 0) n$1 = n$1.left;
		else n$1 = n$1.right;
	}
	n_stack.push({
		color: Color.Red,
		key,
		value,
		left: void 0,
		right: void 0,
		count: 1
	});
	for (let s$1 = n_stack.length - 2; s$1 >= 0; --s$1) {
		const n2 = n_stack[s$1];
		if (d_stack[s$1] <= 0) n_stack[s$1] = {
			color: n2.color,
			key: n2.key,
			value: n2.value,
			left: n_stack[s$1 + 1],
			right: n2.right,
			count: n2.count + 1
		};
		else n_stack[s$1] = {
			color: n2.color,
			key: n2.key,
			value: n2.value,
			left: n2.left,
			right: n_stack[s$1 + 1],
			count: n2.count + 1
		};
	}
	for (let s$1 = n_stack.length - 1; s$1 > 1; --s$1) {
		const p = n_stack[s$1 - 1];
		const n3 = n_stack[s$1];
		if (p.color === Color.Black || n3.color === Color.Black) break;
		const pp = n_stack[s$1 - 2];
		if (pp.left === p) if (p.left === n3) {
			const y$1 = pp.right;
			if (y$1 && y$1.color === Color.Red) {
				p.color = Color.Black;
				pp.right = repaint(y$1, Color.Black);
				pp.color = Color.Red;
				s$1 -= 1;
			} else {
				pp.color = Color.Red;
				pp.left = p.right;
				p.color = Color.Black;
				p.right = pp;
				n_stack[s$1 - 2] = p;
				n_stack[s$1 - 1] = n3;
				recount(pp);
				recount(p);
				if (s$1 >= 3) {
					const ppp = n_stack[s$1 - 3];
					if (ppp.left === pp) ppp.left = p;
					else ppp.right = p;
				}
				break;
			}
		} else {
			const y$1 = pp.right;
			if (y$1 && y$1.color === Color.Red) {
				p.color = Color.Black;
				pp.right = repaint(y$1, Color.Black);
				pp.color = Color.Red;
				s$1 -= 1;
			} else {
				p.right = n3.left;
				pp.color = Color.Red;
				pp.left = n3.right;
				n3.color = Color.Black;
				n3.left = p;
				n3.right = pp;
				n_stack[s$1 - 2] = n3;
				n_stack[s$1 - 1] = p;
				recount(pp);
				recount(p);
				recount(n3);
				if (s$1 >= 3) {
					const ppp = n_stack[s$1 - 3];
					if (ppp.left === pp) ppp.left = n3;
					else ppp.right = n3;
				}
				break;
			}
		}
		else if (p.right === n3) {
			const y$1 = pp.left;
			if (y$1 && y$1.color === Color.Red) {
				p.color = Color.Black;
				pp.left = repaint(y$1, Color.Black);
				pp.color = Color.Red;
				s$1 -= 1;
			} else {
				pp.color = Color.Red;
				pp.right = p.left;
				p.color = Color.Black;
				p.left = pp;
				n_stack[s$1 - 2] = p;
				n_stack[s$1 - 1] = n3;
				recount(pp);
				recount(p);
				if (s$1 >= 3) {
					const ppp = n_stack[s$1 - 3];
					if (ppp.right === pp) ppp.right = p;
					else ppp.left = p;
				}
				break;
			}
		} else {
			const y$1 = pp.left;
			if (y$1 && y$1.color === Color.Red) {
				p.color = Color.Black;
				pp.left = repaint(y$1, Color.Black);
				pp.color = Color.Red;
				s$1 -= 1;
			} else {
				p.left = n3.right;
				pp.color = Color.Red;
				pp.right = n3.left;
				n3.color = Color.Black;
				n3.right = p;
				n3.left = pp;
				n_stack[s$1 - 2] = n3;
				n_stack[s$1 - 1] = p;
				recount(pp);
				recount(p);
				recount(n3);
				if (s$1 >= 3) {
					const ppp = n_stack[s$1 - 3];
					if (ppp.right === pp) ppp.right = n3;
					else ppp.left = n3;
				}
				break;
			}
		}
	}
	n_stack[0].color = Color.Black;
	return makeImpl(self._ord, n_stack[0]);
});
/** @internal */
const keysForward = (self) => keys$1(self, Direction$1.Forward);
/** @internal */
const keysBackward = (self) => keys$1(self, Direction$1.Backward);
const keys$1 = (self, direction) => {
	const begin = self[Symbol.iterator]();
	let count = 0;
	return {
		[Symbol.iterator]: () => keys$1(self, direction),
		next: () => {
			count++;
			const entry = begin.key;
			if (direction === Direction$1.Forward) begin.moveNext();
			else begin.movePrev();
			switch (entry._tag) {
				case "None": return {
					done: true,
					value: count
				};
				case "Some": return {
					done: false,
					value: entry.value
				};
			}
		}
	};
};
/** @internal */
const last$1 = (self) => {
	let node = self._root;
	let current = self._root;
	while (node !== void 0) {
		current = node;
		node = node.right;
	}
	return current ? some$4([current.key, current.value]) : none$7();
};
/** @internal */
const reversed$1 = (self) => {
	return { [Symbol.iterator]: () => {
		const stack = [];
		let node = self._root;
		while (node !== void 0) {
			stack.push(node);
			node = node.right;
		}
		return new RedBlackTreeIterator(self, stack, Direction$1.Backward);
	} };
};
/** @internal */
const greaterThanBackwards = /* @__PURE__ */ dual$1(2, (self, key) => greaterThan$1(self, key, Direction$1.Backward));
/** @internal */
const greaterThanForwards = /* @__PURE__ */ dual$1(2, (self, key) => greaterThan$1(self, key, Direction$1.Forward));
const greaterThan$1 = (self, key, direction) => {
	return { [Symbol.iterator]: () => {
		const cmp = self._ord;
		let node = self._root;
		const stack = [];
		let last_ptr = 0;
		while (node !== void 0) {
			const d = cmp(key, node.key);
			stack.push(node);
			if (d < 0) last_ptr = stack.length;
			if (d < 0) node = node.left;
			else node = node.right;
		}
		stack.length = last_ptr;
		return new RedBlackTreeIterator(self, stack, direction);
	} };
};
/** @internal */
const greaterThanEqualBackwards = /* @__PURE__ */ dual$1(2, (self, key) => greaterThanEqual$1(self, key, Direction$1.Backward));
/** @internal */
const greaterThanEqualForwards = /* @__PURE__ */ dual$1(2, (self, key) => greaterThanEqual$1(self, key, Direction$1.Forward));
const greaterThanEqual$1 = (self, key, direction = Direction$1.Forward) => {
	return { [Symbol.iterator]: () => {
		const cmp = self._ord;
		let node = self._root;
		const stack = [];
		let last_ptr = 0;
		while (node !== void 0) {
			const d = cmp(key, node.key);
			stack.push(node);
			if (d <= 0) last_ptr = stack.length;
			if (d <= 0) node = node.left;
			else node = node.right;
		}
		stack.length = last_ptr;
		return new RedBlackTreeIterator(self, stack, direction);
	} };
};
/** @internal */
const lessThanBackwards = /* @__PURE__ */ dual$1(2, (self, key) => lessThan$5(self, key, Direction$1.Backward));
/** @internal */
const lessThanForwards = /* @__PURE__ */ dual$1(2, (self, key) => lessThan$5(self, key, Direction$1.Forward));
const lessThan$5 = (self, key, direction) => {
	return { [Symbol.iterator]: () => {
		const cmp = self._ord;
		let node = self._root;
		const stack = [];
		let last_ptr = 0;
		while (node !== void 0) {
			const d = cmp(key, node.key);
			stack.push(node);
			if (d > 0) last_ptr = stack.length;
			if (d <= 0) node = node.left;
			else node = node.right;
		}
		stack.length = last_ptr;
		return new RedBlackTreeIterator(self, stack, direction);
	} };
};
/** @internal */
const lessThanEqualBackwards = /* @__PURE__ */ dual$1(2, (self, key) => lessThanEqual$1(self, key, Direction$1.Backward));
/** @internal */
const lessThanEqualForwards = /* @__PURE__ */ dual$1(2, (self, key) => lessThanEqual$1(self, key, Direction$1.Forward));
const lessThanEqual$1 = (self, key, direction) => {
	return { [Symbol.iterator]: () => {
		const cmp = self._ord;
		let node = self._root;
		const stack = [];
		let last_ptr = 0;
		while (node !== void 0) {
			const d = cmp(key, node.key);
			stack.push(node);
			if (d >= 0) last_ptr = stack.length;
			if (d < 0) node = node.left;
			else node = node.right;
		}
		stack.length = last_ptr;
		return new RedBlackTreeIterator(self, stack, direction);
	} };
};
/** @internal */
const forEach$3 = /* @__PURE__ */ dual$1(2, (self, f$1) => {
	const root = self._root;
	if (root !== void 0) visitFull(root, (key, value) => {
		f$1(key, value);
		return none$7();
	});
});
/** @internal */
const forEachGreaterThanEqual$1 = /* @__PURE__ */ dual$1(3, (self, min$2, f$1) => {
	const root = self._root;
	const ord = self._ord;
	if (root !== void 0) visitGreaterThanEqual(root, min$2, ord, (key, value) => {
		f$1(key, value);
		return none$7();
	});
});
/** @internal */
const forEachLessThan$1 = /* @__PURE__ */ dual$1(3, (self, max$4, f$1) => {
	const root = self._root;
	const ord = self._ord;
	if (root !== void 0) visitLessThan(root, max$4, ord, (key, value) => {
		f$1(key, value);
		return none$7();
	});
});
/** @internal */
const forEachBetween$1 = /* @__PURE__ */ dual$1(2, (self, { body, max: max$4, min: min$2 }) => {
	const root = self._root;
	const ord = self._ord;
	if (root) visitBetween(root, min$2, max$4, ord, (key, value) => {
		body(key, value);
		return none$7();
	});
});
/** @internal */
const reduce$3 = /* @__PURE__ */ dual$1(3, (self, zero$1, f$1) => {
	let accumulator = zero$1;
	for (const entry of self) accumulator = f$1(accumulator, entry[1], entry[0]);
	return accumulator;
});
/** @internal */
const removeFirst$1 = /* @__PURE__ */ dual$1(2, (self, key) => {
	if (!has$1(self, key)) return self;
	const ord = self._ord;
	const cmp = ord;
	let node = self._root;
	const stack = [];
	while (node !== void 0) {
		const d = cmp(key, node.key);
		stack.push(node);
		if (equals(key, node.key)) node = void 0;
		else if (d <= 0) node = node.left;
		else node = node.right;
	}
	if (stack.length === 0) return self;
	const cstack = new Array(stack.length);
	let n$1 = stack[stack.length - 1];
	cstack[cstack.length - 1] = {
		color: n$1.color,
		key: n$1.key,
		value: n$1.value,
		left: n$1.left,
		right: n$1.right,
		count: n$1.count
	};
	for (let i$1 = stack.length - 2; i$1 >= 0; --i$1) {
		n$1 = stack[i$1];
		if (n$1.left === stack[i$1 + 1]) cstack[i$1] = {
			color: n$1.color,
			key: n$1.key,
			value: n$1.value,
			left: cstack[i$1 + 1],
			right: n$1.right,
			count: n$1.count
		};
		else cstack[i$1] = {
			color: n$1.color,
			key: n$1.key,
			value: n$1.value,
			left: n$1.left,
			right: cstack[i$1 + 1],
			count: n$1.count
		};
	}
	n$1 = cstack[cstack.length - 1];
	if (n$1.left !== void 0 && n$1.right !== void 0) {
		const split = cstack.length;
		n$1 = n$1.left;
		while (n$1.right != null) {
			cstack.push(n$1);
			n$1 = n$1.right;
		}
		const v = cstack[split - 1];
		cstack.push({
			color: n$1.color,
			key: v.key,
			value: v.value,
			left: n$1.left,
			right: n$1.right,
			count: n$1.count
		});
		cstack[split - 1].key = n$1.key;
		cstack[split - 1].value = n$1.value;
		for (let i$1 = cstack.length - 2; i$1 >= split; --i$1) {
			n$1 = cstack[i$1];
			cstack[i$1] = {
				color: n$1.color,
				key: n$1.key,
				value: n$1.value,
				left: n$1.left,
				right: cstack[i$1 + 1],
				count: n$1.count
			};
		}
		cstack[split - 1].left = cstack[split];
	}
	n$1 = cstack[cstack.length - 1];
	if (n$1.color === Color.Red) {
		const p = cstack[cstack.length - 2];
		if (p.left === n$1) p.left = void 0;
		else if (p.right === n$1) p.right = void 0;
		cstack.pop();
		for (let i$1 = 0; i$1 < cstack.length; ++i$1) cstack[i$1].count--;
		return makeImpl(ord, cstack[0]);
	} else if (n$1.left !== void 0 || n$1.right !== void 0) {
		if (n$1.left !== void 0) swap(n$1, n$1.left);
		else if (n$1.right !== void 0) swap(n$1, n$1.right);
		n$1.color = Color.Black;
		for (let i$1 = 0; i$1 < cstack.length - 1; ++i$1) cstack[i$1].count--;
		return makeImpl(ord, cstack[0]);
	} else if (cstack.length === 1) return makeImpl(ord, void 0);
	else {
		for (let i$1 = 0; i$1 < cstack.length; ++i$1) cstack[i$1].count--;
		const parent = cstack[cstack.length - 2];
		fixDoubleBlack(cstack);
		if (parent.left === n$1) parent.left = void 0;
		else parent.right = void 0;
	}
	return makeImpl(ord, cstack[0]);
});
/** @internal */
const size$4 = (self) => self._root?.count ?? 0;
/** @internal */
const valuesForward = (self) => values$1(self, Direction$1.Forward);
/** @internal */
const valuesBackward = (self) => values$1(self, Direction$1.Backward);
/** @internal */
const values$1 = (self, direction) => {
	const begin = self[Symbol.iterator]();
	let count = 0;
	return {
		[Symbol.iterator]: () => values$1(self, direction),
		next: () => {
			count++;
			const entry = begin.value;
			if (direction === Direction$1.Forward) begin.moveNext();
			else begin.movePrev();
			switch (entry._tag) {
				case "None": return {
					done: true,
					value: count
				};
				case "Some": return {
					done: false,
					value: entry.value
				};
			}
		}
	};
};
const visitFull = (node, visit) => {
	let current = node;
	let stack = void 0;
	let done$8 = false;
	while (!done$8) if (current != null) {
		stack = make$41(current, stack);
		current = current.left;
	} else if (stack != null) {
		const value = visit(stack.value.key, stack.value.value);
		if (isSome(value)) return value;
		current = stack.value.right;
		stack = stack.previous;
	} else done$8 = true;
	return none$7();
};
const visitGreaterThanEqual = (node, min$2, ord, visit) => {
	let current = node;
	let stack = void 0;
	let done$8 = false;
	while (!done$8) if (current !== void 0) {
		stack = make$41(current, stack);
		if (ord(min$2, current.key) <= 0) current = current.left;
		else current = void 0;
	} else if (stack !== void 0) {
		if (ord(min$2, stack.value.key) <= 0) {
			const value = visit(stack.value.key, stack.value.value);
			if (isSome(value)) return value;
		}
		current = stack.value.right;
		stack = stack.previous;
	} else done$8 = true;
	return none$7();
};
const visitLessThan = (node, max$4, ord, visit) => {
	let current = node;
	let stack = void 0;
	let done$8 = false;
	while (!done$8) if (current !== void 0) {
		stack = make$41(current, stack);
		current = current.left;
	} else if (stack !== void 0 && ord(max$4, stack.value.key) > 0) {
		const value = visit(stack.value.key, stack.value.value);
		if (isSome(value)) return value;
		current = stack.value.right;
		stack = stack.previous;
	} else done$8 = true;
	return none$7();
};
const visitBetween = (node, min$2, max$4, ord, visit) => {
	let current = node;
	let stack = void 0;
	let done$8 = false;
	while (!done$8) if (current !== void 0) {
		stack = make$41(current, stack);
		if (ord(min$2, current.key) <= 0) current = current.left;
		else current = void 0;
	} else if (stack !== void 0 && ord(max$4, stack.value.key) > 0) {
		if (ord(min$2, stack.value.key) <= 0) {
			const value = visit(stack.value.key, stack.value.value);
			if (isSome(value)) return value;
		}
		current = stack.value.right;
		stack = stack.previous;
	} else done$8 = true;
	return none$7();
};
/**
* Fix up a double black node in a Red-Black Tree.
*/
const fixDoubleBlack = (stack) => {
	let n$1, p, s$1, z;
	for (let i$1 = stack.length - 1; i$1 >= 0; --i$1) {
		n$1 = stack[i$1];
		if (i$1 === 0) {
			n$1.color = Color.Black;
			return;
		}
		p = stack[i$1 - 1];
		if (p.left === n$1) {
			s$1 = p.right;
			if (s$1 !== void 0 && s$1.right !== void 0 && s$1.right.color === Color.Red) {
				s$1 = p.right = clone(s$1);
				z = s$1.right = clone(s$1.right);
				p.right = s$1.left;
				s$1.left = p;
				s$1.right = z;
				s$1.color = p.color;
				n$1.color = Color.Black;
				p.color = Color.Black;
				z.color = Color.Black;
				recount(p);
				recount(s$1);
				if (i$1 > 1) {
					const pp = stack[i$1 - 2];
					if (pp.left === p) pp.left = s$1;
					else pp.right = s$1;
				}
				stack[i$1 - 1] = s$1;
				return;
			} else if (s$1 !== void 0 && s$1.left !== void 0 && s$1.left.color === Color.Red) {
				s$1 = p.right = clone(s$1);
				z = s$1.left = clone(s$1.left);
				p.right = z.left;
				s$1.left = z.right;
				z.left = p;
				z.right = s$1;
				z.color = p.color;
				p.color = Color.Black;
				s$1.color = Color.Black;
				n$1.color = Color.Black;
				recount(p);
				recount(s$1);
				recount(z);
				if (i$1 > 1) {
					const pp = stack[i$1 - 2];
					if (pp.left === p) pp.left = z;
					else pp.right = z;
				}
				stack[i$1 - 1] = z;
				return;
			}
			if (s$1 !== void 0 && s$1.color === Color.Black) if (p.color === Color.Red) {
				p.color = Color.Black;
				p.right = repaint(s$1, Color.Red);
				return;
			} else {
				p.right = repaint(s$1, Color.Red);
				continue;
			}
			else if (s$1 !== void 0) {
				s$1 = clone(s$1);
				p.right = s$1.left;
				s$1.left = p;
				s$1.color = p.color;
				p.color = Color.Red;
				recount(p);
				recount(s$1);
				if (i$1 > 1) {
					const pp = stack[i$1 - 2];
					if (pp.left === p) pp.left = s$1;
					else pp.right = s$1;
				}
				stack[i$1 - 1] = s$1;
				stack[i$1] = p;
				if (i$1 + 1 < stack.length) stack[i$1 + 1] = n$1;
				else stack.push(n$1);
				i$1 = i$1 + 2;
			}
		} else {
			s$1 = p.left;
			if (s$1 !== void 0 && s$1.left !== void 0 && s$1.left.color === Color.Red) {
				s$1 = p.left = clone(s$1);
				z = s$1.left = clone(s$1.left);
				p.left = s$1.right;
				s$1.right = p;
				s$1.left = z;
				s$1.color = p.color;
				n$1.color = Color.Black;
				p.color = Color.Black;
				z.color = Color.Black;
				recount(p);
				recount(s$1);
				if (i$1 > 1) {
					const pp = stack[i$1 - 2];
					if (pp.right === p) pp.right = s$1;
					else pp.left = s$1;
				}
				stack[i$1 - 1] = s$1;
				return;
			} else if (s$1 !== void 0 && s$1.right !== void 0 && s$1.right.color === Color.Red) {
				s$1 = p.left = clone(s$1);
				z = s$1.right = clone(s$1.right);
				p.left = z.right;
				s$1.right = z.left;
				z.right = p;
				z.left = s$1;
				z.color = p.color;
				p.color = Color.Black;
				s$1.color = Color.Black;
				n$1.color = Color.Black;
				recount(p);
				recount(s$1);
				recount(z);
				if (i$1 > 1) {
					const pp = stack[i$1 - 2];
					if (pp.right === p) pp.right = z;
					else pp.left = z;
				}
				stack[i$1 - 1] = z;
				return;
			}
			if (s$1 !== void 0 && s$1.color === Color.Black) if (p.color === Color.Red) {
				p.color = Color.Black;
				p.left = repaint(s$1, Color.Red);
				return;
			} else {
				p.left = repaint(s$1, Color.Red);
				continue;
			}
			else if (s$1 !== void 0) {
				s$1 = clone(s$1);
				p.left = s$1.right;
				s$1.right = p;
				s$1.color = p.color;
				p.color = Color.Red;
				recount(p);
				recount(s$1);
				if (i$1 > 1) {
					const pp = stack[i$1 - 2];
					if (pp.right === p) pp.right = s$1;
					else pp.left = s$1;
				}
				stack[i$1 - 1] = s$1;
				stack[i$1] = p;
				if (i$1 + 1 < stack.length) stack[i$1 + 1] = n$1;
				else stack.push(n$1);
				i$1 = i$1 + 2;
			}
		}
	}
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/RedBlackTree.js
RedBlackTreeTypeId;
/**
* @since 2.0.0
* @category constants
*/
const Direction = Direction$1;
/**
* @since 2.0.0
* @category refinements
*/
const isRedBlackTree = isRedBlackTree$1;
/**
* Creates an empty `RedBlackTree`.
*
* @since 2.0.0
* @category constructors
*/
const empty$6 = empty$7;
/**
* Creates a new `RedBlackTree` from an iterable collection of key/value pairs.
*
* @since 2.0.0
* @category constructors
*/
const fromIterable$2 = fromIterable$3;
/**
* Constructs a new `RedBlackTree` from the specified entries.
*
* @since 2.0.0
* @category constructors
*/
const make$12 = make$13;
/**
* Returns an iterator that points to the element at the specified index of the
* tree.
*
* **Note**: The iterator will run through elements in order.
*
* @since 2.0.0
* @category traversing
*/
const at = atForwards;
/**
* Returns an iterator that points to the element at the specified index of the
* tree.
*
* **Note**: The iterator will run through elements in reverse order.
*
* @since 2.0.0
* @category traversing
*/
const atReversed = atBackwards;
/**
* Finds all values in the tree associated with the specified key.
*
* @since 2.0.0
* @category elements
*/
const findAll = findAll$1;
/**
* Finds the first value in the tree associated with the specified key, if it exists.
*
* @category elements
* @since 2.0.0
*/
const findFirst$1 = findFirst$2;
/**
* Returns the first entry in the tree, if it exists.
*
* @since 2.0.0
* @category getters
*/
const first = first$1;
/**
* Returns the element at the specified index within the tree or `None` if the
* specified index does not exist.
*
* @since 2.0.0
* @category elements
*/
const getAt = getAt$1;
/**
* Gets the `Order<K>` that the `RedBlackTree<K, V>` is using.
*
* @since 2.0.0
* @category getters
*/
const getOrder = getOrder$1;
/**
* Returns an iterator that traverse entries in order with keys greater than the
* specified key.
*
* @since 2.0.0
* @category traversing
*/
const greaterThan = greaterThanForwards;
/**
* Returns an iterator that traverse entries in reverse order with keys greater
* than the specified key.
*
* @since 2.0.0
* @category traversing
*/
const greaterThanReversed = greaterThanBackwards;
/**
* Returns an iterator that traverse entries in order with keys greater than or
* equal to the specified key.
*
* @since 2.0.0
* @category traversing
*/
const greaterThanEqual = greaterThanEqualForwards;
/**
* Returns an iterator that traverse entries in reverse order with keys greater
* than or equal to the specified key.
*
* @since 2.0.0
* @category traversing
*/
const greaterThanEqualReversed = greaterThanEqualBackwards;
/**
* Finds the item with key, if it exists.
*
* @since 2.0.0
* @category elements
*/
const has = has$1;
/**
* Insert a new item into the tree.
*
* @since 2.0.0
*/
const insert = insert$1;
/**
* Get all the keys present in the tree in order.
*
* @since 2.0.0
* @category getters
*/
const keys = keysForward;
/**
* Get all the keys present in the tree in reverse order.
*
* @since 2.0.0
* @category getters
*/
const keysReversed = keysBackward;
/**
* Returns the last entry in the tree, if it exists.
*
* @since 2.0.0
* @category getters
*/
const last = last$1;
/**
* Returns an iterator that traverse entries in order with keys less than the
* specified key.
*
* @since 2.0.0
* @category traversing
*/
const lessThan$4 = lessThanForwards;
/**
* Returns an iterator that traverse entries in reverse order with keys less
* than the specified key.
*
* @since 2.0.0
* @category traversing
*/
const lessThanReversed = lessThanBackwards;
/**
* Returns an iterator that traverse entries in order with keys less than or
* equal to the specified key.
*
* @since 2.0.0
* @category traversing
*/
const lessThanEqual = lessThanEqualForwards;
/**
* Returns an iterator that traverse entries in reverse order with keys less
* than or equal to the specified key.
*
* @since 2.0.0
* @category traversing
*/
const lessThanEqualReversed = lessThanEqualBackwards;
/**
* Execute the specified function for each node of the tree, in order.
*
* @since 2.0.0
* @category traversing
*/
const forEach$2 = forEach$3;
/**
* Visit each node of the tree in order with key greater then or equal to max.
*
* @since 2.0.0
* @category traversing
*/
const forEachGreaterThanEqual = forEachGreaterThanEqual$1;
/**
* Visit each node of the tree in order with key lower then max.
*
* @since 2.0.0
* @category traversing
*/
const forEachLessThan = forEachLessThan$1;
/**
* Visit each node of the tree in order with key lower than max and greater
* than or equal to min.
*
* @since 2.0.0
* @category traversing
*/
const forEachBetween = forEachBetween$1;
/**
* Reduce a state over the entries of the tree.
*
* @since 2.0.0
* @category folding
*/
const reduce$2 = reduce$3;
/**
* Removes the entry with the specified key, if it exists.
*
* @since 2.0.0
*/
const removeFirst = removeFirst$1;
/**
* Traverse the tree in reverse order.
*
* @since 2.0.0
* @category traversing
*/
const reversed = reversed$1;
/**
* Returns the size of the tree.
*
* @since 2.0.0
* @category getters
*/
const size$3 = size$4;
/**
* Get all values present in the tree in order.
*
* @since 2.0.0
* @category getters
*/
const values = valuesForward;
/**
* Get all values present in the tree in reverse order.
*
* @since 2.0.0
* @category getters
*/
const valuesReversed = valuesBackward;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/SortedSet.js
const TypeId$5 = /* @__PURE__ */ Symbol.for("effect/SortedSet");
const SortedSetProto = {
	[TypeId$5]: { _A: (_$1) => _$1 },
	[symbol$1]() {
		return pipe$3(hash(this.keyTree), combine$11(hash(TypeId$5)), cached$2(this));
	},
	[symbol](that) {
		return isSortedSet(that) && equals(this.keyTree, that.keyTree);
	},
	[Symbol.iterator]() {
		return keys(this.keyTree);
	},
	toString() {
		return format(this.toJSON());
	},
	toJSON() {
		return {
			_id: "SortedSet",
			values: Array.from(this).map(toJSON)
		};
	},
	[NodeInspectSymbol]() {
		return this.toJSON();
	},
	pipe() {
		return pipeArguments(this, arguments);
	}
};
const fromTree = (keyTree) => {
	const a$1 = Object.create(SortedSetProto);
	a$1.keyTree = keyTree;
	return a$1;
};
/**
* @since 2.0.0
* @category refinements
*/
const isSortedSet = (u$1) => hasProperty(u$1, TypeId$5);
/**
* @since 2.0.0
* @category elements
*/
const add = /* @__PURE__ */ dual$1(2, (self, value) => has(self.keyTree, value) ? self : fromTree(insert(self.keyTree, value, true)));
/**
* @since 2.0.0
* @category elements
*/
const remove$1 = /* @__PURE__ */ dual$1(2, (self, value) => fromTree(removeFirst(self.keyTree, value)));

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/supervisor.js
/** @internal */
const SupervisorSymbolKey = "effect/Supervisor";
/** @internal */
const SupervisorTypeId = /* @__PURE__ */ Symbol.for(SupervisorSymbolKey);
/** @internal */
const supervisorVariance = { _T: (_$1) => _$1 };
/** @internal */
var ProxySupervisor = class ProxySupervisor {
	underlying;
	value0;
	[SupervisorTypeId] = supervisorVariance;
	constructor(underlying, value0) {
		this.underlying = underlying;
		this.value0 = value0;
	}
	get value() {
		return this.value0;
	}
	onStart(context$2, effect, parent, fiber) {
		this.underlying.onStart(context$2, effect, parent, fiber);
	}
	onEnd(value, fiber) {
		this.underlying.onEnd(value, fiber);
	}
	onEffect(fiber, effect) {
		this.underlying.onEffect(fiber, effect);
	}
	onSuspend(fiber) {
		this.underlying.onSuspend(fiber);
	}
	onResume(fiber) {
		this.underlying.onResume(fiber);
	}
	map(f$1) {
		return new ProxySupervisor(this, pipe$3(this.value, map$9(f$1)));
	}
	zip(right$2) {
		return new Zip(this, right$2);
	}
};
/** @internal */
var Zip = class Zip {
	left;
	right;
	_tag = "Zip";
	[SupervisorTypeId] = supervisorVariance;
	constructor(left$2, right$2) {
		this.left = left$2;
		this.right = right$2;
	}
	get value() {
		return zip$4(this.left.value, this.right.value);
	}
	onStart(context$2, effect, parent, fiber) {
		this.left.onStart(context$2, effect, parent, fiber);
		this.right.onStart(context$2, effect, parent, fiber);
	}
	onEnd(value, fiber) {
		this.left.onEnd(value, fiber);
		this.right.onEnd(value, fiber);
	}
	onEffect(fiber, effect) {
		this.left.onEffect(fiber, effect);
		this.right.onEffect(fiber, effect);
	}
	onSuspend(fiber) {
		this.left.onSuspend(fiber);
		this.right.onSuspend(fiber);
	}
	onResume(fiber) {
		this.left.onResume(fiber);
		this.right.onResume(fiber);
	}
	map(f$1) {
		return new ProxySupervisor(this, pipe$3(this.value, map$9(f$1)));
	}
	zip(right$2) {
		return new Zip(this, right$2);
	}
};
/** @internal */
const isZip = (self) => hasProperty(self, SupervisorTypeId) && isTagged(self, "Zip");
/** @internal */
var Track = class {
	[SupervisorTypeId] = supervisorVariance;
	fibers = /* @__PURE__ */ new Set();
	get value() {
		return sync$3(() => Array.from(this.fibers));
	}
	onStart(_context, _effect, _parent, fiber) {
		this.fibers.add(fiber);
	}
	onEnd(_value, fiber) {
		this.fibers.delete(fiber);
	}
	onEffect(_fiber, _effect) {}
	onSuspend(_fiber) {}
	onResume(_fiber) {}
	map(f$1) {
		return new ProxySupervisor(this, pipe$3(this.value, map$9(f$1)));
	}
	zip(right$2) {
		return new Zip(this, right$2);
	}
	onRun(execution, _fiber) {
		return execution();
	}
};
/** @internal */
var Const = class {
	effect;
	[SupervisorTypeId] = supervisorVariance;
	constructor(effect) {
		this.effect = effect;
	}
	get value() {
		return this.effect;
	}
	onStart(_context, _effect, _parent, _fiber) {}
	onEnd(_value, _fiber) {}
	onEffect(_fiber, _effect) {}
	onSuspend(_fiber) {}
	onResume(_fiber) {}
	map(f$1) {
		return new ProxySupervisor(this, pipe$3(this.value, map$9(f$1)));
	}
	zip(right$2) {
		return new Zip(this, right$2);
	}
	onRun(execution, _fiber) {
		return execution();
	}
};
var FibersIn = class {
	ref;
	[SupervisorTypeId] = supervisorVariance;
	constructor(ref) {
		this.ref = ref;
	}
	get value() {
		return sync$3(() => get$6(this.ref));
	}
	onStart(_context, _effect, _parent, fiber) {
		pipe$3(this.ref, set$4(pipe$3(get$6(this.ref), add(fiber))));
	}
	onEnd(_value, fiber) {
		pipe$3(this.ref, set$4(pipe$3(get$6(this.ref), remove$1(fiber))));
	}
	onEffect(_fiber, _effect) {}
	onSuspend(_fiber) {}
	onResume(_fiber) {}
	map(f$1) {
		return new ProxySupervisor(this, pipe$3(this.value, map$9(f$1)));
	}
	zip(right$2) {
		return new Zip(this, right$2);
	}
	onRun(execution, _fiber) {
		return execution();
	}
};
/** @internal */
const unsafeTrack = () => {
	return new Track();
};
/** @internal */
const track = /* @__PURE__ */ sync$3(unsafeTrack);
/** @internal */
const fromEffect$1 = (effect) => {
	return new Const(effect);
};
/** @internal */
const none$2 = /* @__PURE__ */ globalValue("effect/Supervisor/none", () => fromEffect$1(void_$4));

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Differ.js
/**
* @since 2.0.0
* @category symbol
*/
const TypeId$4 = DifferTypeId;
ChunkPatchTypeId;
ContextPatchTypeId;
HashMapPatchTypeId;
HashSetPatchTypeId;
OrPatchTypeId;
ReadonlyArrayPatchTypeId;
/**
* Constructs a new `Differ`.
*
* @since 2.0.0
* @category constructors
*/
const make$11 = make$33;
/**
* Constructs a differ that knows how to diff `Env` values.
*
* @since 2.0.0
* @category constructors
*/
const environment = environment$1;
/**
* Constructs a differ that knows how to diff a `Chunk` of values given a
* differ that knows how to diff the values.
*
* @since 2.0.0
* @category constructors
*/
const chunk = chunk$1;
/**
* Constructs a differ that knows how to diff a `HashMap` of keys and values given
* a differ that knows how to diff the values.
*
* @since 2.0.0
* @category constructors
*/
const hashMap = hashMap$1;
/**
* Constructs a differ that knows how to diff a `HashSet` of values.
*
* @since 2.0.0
* @category constructors
*/
const hashSet = hashSet$1;
/**
* Combines this differ and the specified differ to produce a differ that
* knows how to diff the sum of their values.
*
* @since 2.0.0
*/
const orElseEither$1 = orElseEither$3;
/**
* Constructs a differ that knows how to diff a `ReadonlyArray` of values.
*
* @since 2.0.0
* @category constructors
*/
const readonlyArray = readonlyArray$1;
/**
* Transforms the type of values that this differ knows how to differ using
* the specified functions that map the new and old value types to each other.
*
* @since 2.0.0
*/
const transform = transform$1;
/**
* Constructs a differ that just diffs two values by returning a function that
* sets the value to the new value. This differ does not support combining
* multiple updates to the value compositionally and should only be used when
* there is no compositional way to update them.
*
* @since 2.0.0
*/
const update = update$4;
/**
* A variant of `update` that allows specifying the function that will be used
* to combine old values with new values.
*
* @since 2.0.0
*/
const updateWith = updateWith$1;
/**
* Combines this differ and the specified differ to produce a new differ that
* knows how to diff the product of their values.
*
* @since 2.0.0
*/
const zip$2 = zip$5;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/supervisor/patch.js
/** @internal */
const OP_EMPTY = "Empty";
/** @internal */
const OP_ADD_SUPERVISOR = "AddSupervisor";
/** @internal */
const OP_REMOVE_SUPERVISOR = "RemoveSupervisor";
/** @internal */
const OP_AND_THEN = "AndThen";
/**
* The empty `SupervisorPatch`.
*
* @internal
*/
const empty$5 = { _tag: OP_EMPTY };
/**
* Combines two patches to produce a new patch that describes applying the
* updates from this patch and then the updates from the specified patch.
*
* @internal
*/
const combine = (self, that) => {
	return {
		_tag: OP_AND_THEN,
		first: self,
		second: that
	};
};
/**
* Applies a `SupervisorPatch` to a `Supervisor` to produce a new `Supervisor`.
*
* @internal
*/
const patch = (self, supervisor) => {
	return patchLoop(supervisor, of$3(self));
};
/** @internal */
const patchLoop = (_supervisor, _patches) => {
	let supervisor = _supervisor;
	let patches = _patches;
	while (isNonEmpty$4(patches)) {
		const head$4 = headNonEmpty(patches);
		switch (head$4._tag) {
			case OP_EMPTY:
				patches = tailNonEmpty(patches);
				break;
			case OP_ADD_SUPERVISOR:
				supervisor = supervisor.zip(head$4.supervisor);
				patches = tailNonEmpty(patches);
				break;
			case OP_REMOVE_SUPERVISOR:
				supervisor = removeSupervisor(supervisor, head$4.supervisor);
				patches = tailNonEmpty(patches);
				break;
			case OP_AND_THEN:
				patches = prepend$1(head$4.first)(prepend$1(head$4.second)(tailNonEmpty(patches)));
				break;
		}
	}
	return supervisor;
};
/** @internal */
const removeSupervisor = (self, that) => {
	if (equals(self, that)) return none$2;
	else if (isZip(self)) return removeSupervisor(self.left, that).zip(removeSupervisor(self.right, that));
	else return self;
};
/** @internal */
const toSet = (self) => {
	if (equals(self, none$2)) return empty$27();
	else if (isZip(self)) return pipe$3(toSet(self.left), union$5(toSet(self.right)));
	else return make$38(self);
};
/** @internal */
const diff = (oldValue, newValue) => {
	if (equals(oldValue, newValue)) return empty$5;
	const oldSupervisors = toSet(oldValue);
	const newSupervisors = toSet(newValue);
	return combine(pipe$3(newSupervisors, difference(oldSupervisors), reduce$8(empty$5, (patch$11, supervisor) => combine(patch$11, {
		_tag: OP_ADD_SUPERVISOR,
		supervisor
	}))), pipe$3(oldSupervisors, difference(newSupervisors), reduce$8(empty$5, (patch$11, supervisor) => combine(patch$11, {
		_tag: OP_REMOVE_SUPERVISOR,
		supervisor
	}))));
};
/** @internal */
const differ = /* @__PURE__ */ make$11({
	empty: empty$5,
	patch,
	combine,
	diff
});

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/fiberRuntime.js
/** @internal */
const fiberStarted = /* @__PURE__ */ counter("effect_fiber_started", { incremental: true });
/** @internal */
const fiberActive = /* @__PURE__ */ counter("effect_fiber_active");
/** @internal */
const fiberSuccesses = /* @__PURE__ */ counter("effect_fiber_successes", { incremental: true });
/** @internal */
const fiberFailures = /* @__PURE__ */ counter("effect_fiber_failures", { incremental: true });
/** @internal */
const fiberLifetimes = /* @__PURE__ */ tagged$2(/* @__PURE__ */ histogram("effect_fiber_lifetimes", /* @__PURE__ */ exponential({
	start: .5,
	factor: 2,
	count: 35
})), "time_unit", "milliseconds");
/** @internal */
const EvaluationSignalContinue = "Continue";
/** @internal */
const EvaluationSignalDone = "Done";
/** @internal */
const EvaluationSignalYieldNow = "Yield";
const runtimeFiberVariance = {
	_E: (_$1) => _$1,
	_A: (_$1) => _$1
};
const absurd = (_$1) => {
	throw new Error(`BUG: FiberRuntime - ${toStringUnknown(_$1)} - please report an issue at https://github.com/Effect-TS/effect/issues`);
};
const YieldedOp = /* @__PURE__ */ Symbol.for("effect/internal/fiberRuntime/YieldedOp");
const yieldedOpChannel = /* @__PURE__ */ globalValue("effect/internal/fiberRuntime/yieldedOpChannel", () => ({ currentOp: null }));
const contOpSuccess = {
	[OP_ON_SUCCESS]: (_$1, cont, value) => {
		return internalCall(() => cont.effect_instruction_i1(value));
	},
	["OnStep"]: (_$1, _cont, value) => {
		return exitSucceed$1(exitSucceed$1(value));
	},
	[OP_ON_SUCCESS_AND_FAILURE]: (_$1, cont, value) => {
		return internalCall(() => cont.effect_instruction_i2(value));
	},
	[OP_REVERT_FLAGS]: (self, cont, value) => {
		self.patchRuntimeFlags(self.currentRuntimeFlags, cont.patch);
		if (interruptible$3(self.currentRuntimeFlags) && self.isInterrupted()) return exitFailCause$1(self.getInterruptedCause());
		else return exitSucceed$1(value);
	},
	[OP_WHILE]: (self, cont, value) => {
		internalCall(() => cont.effect_instruction_i2(value));
		if (internalCall(() => cont.effect_instruction_i0())) {
			self.pushStack(cont);
			return internalCall(() => cont.effect_instruction_i1());
		} else return void_$4;
	},
	[OP_ITERATOR]: (self, cont, value) => {
		const state = internalCall(() => cont.effect_instruction_i0.next(value));
		if (state.done) return exitSucceed$1(state.value);
		self.pushStack(cont);
		return yieldWrapGet(state.value);
	}
};
const drainQueueWhileRunningTable = {
	[OP_INTERRUPT_SIGNAL]: (self, runtimeFlags$1, cur, message) => {
		self.processNewInterruptSignal(message.cause);
		return interruptible$3(runtimeFlags$1) ? exitFailCause$1(message.cause) : cur;
	},
	[OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {
		throw new Error("It is illegal to have multiple concurrent run loops in a single fiber");
	},
	[OP_STATEFUL]: (self, runtimeFlags$1, cur, message) => {
		message.onFiber(self, running(runtimeFlags$1));
		return cur;
	},
	[OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {
		return flatMap$5(yieldNow$3(), () => cur);
	}
};
/**
* Executes all requests, submitting requests to each data source in parallel.
*/
const runBlockedRequests = (self) => forEachSequentialDiscard(flatten$5(self), (requestsByRequestResolver) => forEachConcurrentDiscard(sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential$4]) => {
	const map$18 = /* @__PURE__ */ new Map();
	const arr = [];
	for (const block of sequential$4) {
		arr.push(toReadonlyArray(block));
		for (const entry of block) map$18.set(entry.request, entry);
	}
	const flat = arr.flat();
	return fiberRefLocally(invokeWithInterrupt(dataSource.runAll(arr), flat, () => flat.forEach((entry) => {
		entry.listeners.interrupted = true;
	})), currentRequestMap, map$18);
}, false, false));
const _version = /* @__PURE__ */ getCurrentVersion();
/** @internal */
var FiberRuntime = class extends Class$3 {
	[FiberTypeId$1] = fiberVariance;
	[RuntimeFiberTypeId$1] = runtimeFiberVariance;
	_fiberRefs;
	_fiberId;
	_queue = /* @__PURE__ */ new Array();
	_children = null;
	_observers = /* @__PURE__ */ new Array();
	_running = false;
	_stack = [];
	_asyncInterruptor = null;
	_asyncBlockingOn = null;
	_exitValue = null;
	_steps = [];
	_isYielding = false;
	currentRuntimeFlags;
	currentOpCount = 0;
	currentSupervisor;
	currentScheduler;
	currentTracer;
	currentSpan;
	currentContext;
	currentDefaultServices;
	constructor(fiberId$2, fiberRefs0, runtimeFlags0) {
		super();
		this.currentRuntimeFlags = runtimeFlags0;
		this._fiberId = fiberId$2;
		this._fiberRefs = fiberRefs0;
		if (runtimeMetrics(runtimeFlags0)) {
			const tags = this.getFiberRef(currentMetricLabels);
			fiberStarted.unsafeUpdate(1, tags);
			fiberActive.unsafeUpdate(1, tags);
		}
		this.refreshRefCache();
	}
	commit() {
		return join$1(this);
	}
	/**
	* The identity of the fiber.
	*/
	id() {
		return this._fiberId;
	}
	/**
	* Begins execution of the effect associated with this fiber on in the
	* background. This can be called to "kick off" execution of a fiber after
	* it has been created.
	*/
	resume(effect) {
		this.tell(resume(effect));
	}
	/**
	* The status of the fiber.
	*/
	get status() {
		return this.ask((_$1, status$2) => status$2);
	}
	/**
	* Gets the fiber runtime flags.
	*/
	get runtimeFlags() {
		return this.ask((state, status$2) => {
			if (isDone$2(status$2)) return state.currentRuntimeFlags;
			return status$2.runtimeFlags;
		});
	}
	/**
	* Returns the current `FiberScope` for the fiber.
	*/
	scope() {
		return unsafeMake$1(this);
	}
	/**
	* Retrieves the immediate children of the fiber.
	*/
	get children() {
		return this.ask((fiber) => Array.from(fiber.getChildren()));
	}
	/**
	* Gets the fiber's set of children.
	*/
	getChildren() {
		if (this._children === null) this._children = /* @__PURE__ */ new Set();
		return this._children;
	}
	/**
	* Retrieves the interrupted cause of the fiber, which will be `Cause.empty`
	* if the fiber has not been interrupted.
	*
	* **NOTE**: This method is safe to invoke on any fiber, but if not invoked
	* on this fiber, then values derived from the fiber's state (including the
	* log annotations and log level) may not be up-to-date.
	*/
	getInterruptedCause() {
		return this.getFiberRef(currentInterruptedCause);
	}
	/**
	* Retrieves the whole set of fiber refs.
	*/
	fiberRefs() {
		return this.ask((fiber) => fiber.getFiberRefs());
	}
	/**
	* Returns an effect that will contain information computed from the fiber
	* state and status while running on the fiber.
	*
	* This allows the outside world to interact safely with mutable fiber state
	* without locks or immutable data.
	*/
	ask(f$1) {
		return suspend$3(() => {
			const deferred = deferredUnsafeMake(this._fiberId);
			this.tell(stateful((fiber, status$2) => {
				deferredUnsafeDone(deferred, sync$3(() => f$1(fiber, status$2)));
			}));
			return deferredAwait(deferred);
		});
	}
	/**
	* Adds a message to be processed by the fiber on the fiber.
	*/
	tell(message) {
		this._queue.push(message);
		if (!this._running) {
			this._running = true;
			this.drainQueueLaterOnExecutor();
		}
	}
	get await() {
		return async_((resume$1) => {
			const cb = (exit$3) => resume$1(succeed$9(exit$3));
			this.tell(stateful((fiber, _$1) => {
				if (fiber._exitValue !== null) cb(this._exitValue);
				else fiber.addObserver(cb);
			}));
			return sync$3(() => this.tell(stateful((fiber, _$1) => {
				fiber.removeObserver(cb);
			})));
		}, this.id());
	}
	get inheritAll() {
		return withFiberRuntime$1((parentFiber, parentStatus) => {
			const parentFiberId = parentFiber.id();
			const parentFiberRefs = parentFiber.getFiberRefs();
			const parentRuntimeFlags = parentStatus.runtimeFlags;
			const childFiberRefs = this.getFiberRefs();
			const updatedFiberRefs = joinAs$1(parentFiberRefs, parentFiberId, childFiberRefs);
			parentFiber.setFiberRefs(updatedFiberRefs);
			const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);
			const patch$11 = pipe$3(diff$3(parentRuntimeFlags, updatedRuntimeFlags), exclude(Interruption), exclude(WindDown));
			return updateRuntimeFlags(patch$11);
		});
	}
	/**
	* Tentatively observes the fiber, but returns immediately if it is not
	* already done.
	*/
	get poll() {
		return sync$3(() => fromNullable$2(this._exitValue));
	}
	/**
	* Unsafely observes the fiber, but returns immediately if it is not
	* already done.
	*/
	unsafePoll() {
		return this._exitValue;
	}
	/**
	* In the background, interrupts the fiber as if interrupted from the specified fiber.
	*/
	interruptAsFork(fiberId$2) {
		return sync$3(() => this.tell(interruptSignal(interrupt$6(fiberId$2))));
	}
	/**
	* In the background, interrupts the fiber as if interrupted from the specified fiber.
	*/
	unsafeInterruptAsFork(fiberId$2) {
		this.tell(interruptSignal(interrupt$6(fiberId$2)));
	}
	/**
	* Adds an observer to the list of observers.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	addObserver(observer) {
		if (this._exitValue !== null) observer(this._exitValue);
		else this._observers.push(observer);
	}
	/**
	* Removes the specified observer from the list of observers that will be
	* notified when the fiber exits.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	removeObserver(observer) {
		this._observers = this._observers.filter((o$1) => o$1 !== observer);
	}
	/**
	* Retrieves all fiber refs of the fiber.
	*
	* **NOTE**: This method is safe to invoke on any fiber, but if not invoked
	* on this fiber, then values derived from the fiber's state (including the
	* log annotations and log level) may not be up-to-date.
	*/
	getFiberRefs() {
		this.setFiberRef(currentRuntimeFlags, this.currentRuntimeFlags);
		return this._fiberRefs;
	}
	/**
	* Deletes the specified fiber ref.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	unsafeDeleteFiberRef(fiberRef) {
		this._fiberRefs = delete_$1(this._fiberRefs, fiberRef);
	}
	/**
	* Retrieves the state of the fiber ref, or else its initial value.
	*
	* **NOTE**: This method is safe to invoke on any fiber, but if not invoked
	* on this fiber, then values derived from the fiber's state (including the
	* log annotations and log level) may not be up-to-date.
	*/
	getFiberRef(fiberRef) {
		if (this._fiberRefs.locals.has(fiberRef)) return this._fiberRefs.locals.get(fiberRef)[0][1];
		return fiberRef.initial;
	}
	/**
	* Sets the fiber ref to the specified value.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	setFiberRef(fiberRef, value) {
		this._fiberRefs = updateAs$1(this._fiberRefs, {
			fiberId: this._fiberId,
			fiberRef,
			value
		});
		this.refreshRefCache();
	}
	refreshRefCache() {
		this.currentDefaultServices = this.getFiberRef(currentServices);
		this.currentTracer = this.currentDefaultServices.unsafeMap.get(tracerTag.key);
		this.currentSupervisor = this.getFiberRef(currentSupervisor);
		this.currentScheduler = this.getFiberRef(currentScheduler);
		this.currentContext = this.getFiberRef(currentContext);
		this.currentSpan = this.currentContext.unsafeMap.get(spanTag.key);
	}
	/**
	* Wholesale replaces all fiber refs of this fiber.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	setFiberRefs(fiberRefs$3) {
		this._fiberRefs = fiberRefs$3;
		this.refreshRefCache();
	}
	/**
	* Adds a reference to the specified fiber inside the children set.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	addChild(child) {
		this.getChildren().add(child);
	}
	/**
	* Removes a reference to the specified fiber inside the children set.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	removeChild(child) {
		this.getChildren().delete(child);
	}
	/**
	* Transfers all children of this fiber that are currently running to the
	* specified fiber scope.
	*
	* **NOTE**: This method must be invoked by the fiber itself after it has
	* evaluated the effects but prior to exiting.
	*/
	transferChildren(scope$2) {
		const children$2 = this._children;
		this._children = null;
		if (children$2 !== null && children$2.size > 0) {
			for (const child of children$2) if (child._exitValue === null) scope$2.add(this.currentRuntimeFlags, child);
		}
	}
	/**
	* On the current thread, executes all messages in the fiber's inbox. This
	* method may return before all work is done, in the event the fiber executes
	* an asynchronous operation.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	drainQueueOnCurrentThread() {
		let recurse = true;
		while (recurse) {
			let evaluationSignal = EvaluationSignalContinue;
			const prev = globalThis[currentFiberURI];
			globalThis[currentFiberURI] = this;
			try {
				while (evaluationSignal === EvaluationSignalContinue) evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);
			} finally {
				this._running = false;
				globalThis[currentFiberURI] = prev;
			}
			if (this._queue.length > 0 && !this._running) {
				this._running = true;
				if (evaluationSignal === EvaluationSignalYieldNow) {
					this.drainQueueLaterOnExecutor();
					recurse = false;
				} else recurse = true;
			} else recurse = false;
		}
	}
	/**
	* Schedules the execution of all messages in the fiber's inbox.
	*
	* This method will return immediately after the scheduling
	* operation is completed, but potentially before such messages have been
	* executed.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	drainQueueLaterOnExecutor() {
		this.currentScheduler.scheduleTask(this.run, this.getFiberRef(currentSchedulingPriority));
	}
	/**
	* Drains the fiber's message queue while the fiber is actively running,
	* returning the next effect to execute, which may be the input effect if no
	* additional effect needs to be executed.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	drainQueueWhileRunning(runtimeFlags$1, cur0) {
		let cur = cur0;
		while (this._queue.length > 0) {
			const message = this._queue.splice(0, 1)[0];
			cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags$1, cur, message);
		}
		return cur;
	}
	/**
	* Determines if the fiber is interrupted.
	*
	* **NOTE**: This method is safe to invoke on any fiber, but if not invoked
	* on this fiber, then values derived from the fiber's state (including the
	* log annotations and log level) may not be up-to-date.
	*/
	isInterrupted() {
		return !isEmpty$4(this.getFiberRef(currentInterruptedCause));
	}
	/**
	* Adds an interruptor to the set of interruptors that are interrupting this
	* fiber.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	addInterruptedCause(cause$2) {
		const oldSC = this.getFiberRef(currentInterruptedCause);
		this.setFiberRef(currentInterruptedCause, sequential$3(oldSC, cause$2));
	}
	/**
	* Processes a new incoming interrupt signal.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	processNewInterruptSignal(cause$2) {
		this.addInterruptedCause(cause$2);
		this.sendInterruptSignalToAllChildren();
	}
	/**
	* Interrupts all children of the current fiber, returning an effect that will
	* await the exit of the children. This method will return null if the fiber
	* has no children.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	sendInterruptSignalToAllChildren() {
		if (this._children === null || this._children.size === 0) return false;
		let told = false;
		for (const child of this._children) {
			child.tell(interruptSignal(interrupt$6(this.id())));
			told = true;
		}
		return told;
	}
	/**
	* Interrupts all children of the current fiber, returning an effect that will
	* await the exit of the children. This method will return null if the fiber
	* has no children.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	interruptAllChildren() {
		if (this.sendInterruptSignalToAllChildren()) {
			const it = this._children.values();
			this._children = null;
			let isDone$5 = false;
			const body = () => {
				const next = it.next();
				if (!next.done) return asVoid$3(next.value.await);
				else return sync$3(() => {
					isDone$5 = true;
				});
			};
			return whileLoop$2({
				while: () => !isDone$5,
				body,
				step: () => {}
			});
		}
		return null;
	}
	reportExitValue(exit$3) {
		if (runtimeMetrics(this.currentRuntimeFlags)) {
			const tags = this.getFiberRef(currentMetricLabels);
			const startTimeMillis = this.id().startTimeMillis;
			const endTimeMillis = Date.now();
			fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags);
			fiberActive.unsafeUpdate(-1, tags);
			switch (exit$3._tag) {
				case OP_SUCCESS:
					fiberSuccesses.unsafeUpdate(1, tags);
					break;
				case OP_FAILURE:
					fiberFailures.unsafeUpdate(1, tags);
					break;
			}
		}
		if (exit$3._tag === "Failure") {
			const level = this.getFiberRef(currentUnhandledErrorLogLevel);
			if (!isInterruptedOnly$1(exit$3.cause) && level._tag === "Some") this.log("Fiber terminated with an unhandled error", exit$3.cause, level);
		}
	}
	setExitValue(exit$3) {
		this._exitValue = exit$3;
		this.reportExitValue(exit$3);
		for (let i$1 = this._observers.length - 1; i$1 >= 0; i$1--) this._observers[i$1](exit$3);
		this._observers = [];
	}
	getLoggers() {
		return this.getFiberRef(currentLoggers);
	}
	log(message, cause$2, overrideLogLevel) {
		const logLevel = isSome(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(currentLogLevel);
		const minimumLogLevel = this.getFiberRef(currentMinimumLogLevel);
		if (greaterThan$2(minimumLogLevel, logLevel)) return;
		const spans = this.getFiberRef(currentLogSpan);
		const annotations$1 = this.getFiberRef(currentLogAnnotations);
		const loggers = this.getLoggers();
		const contextMap = this.getFiberRefs();
		if (size$8(loggers) > 0) {
			const clockService = get$9(this.getFiberRef(currentServices), clockTag);
			const date = new Date(clockService.unsafeCurrentTimeMillis());
			withRedactableContext(contextMap, () => {
				for (const logger of loggers) logger.log({
					fiberId: this.id(),
					logLevel,
					message,
					cause: cause$2,
					context: contextMap,
					spans,
					annotations: annotations$1,
					date
				});
			});
		}
	}
	/**
	* Evaluates a single message on the current thread, while the fiber is
	* suspended. This method should only be called while evaluation of the
	* fiber's effect is suspended due to an asynchronous operation.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	evaluateMessageWhileSuspended(message) {
		switch (message._tag) {
			case OP_YIELD_NOW: return EvaluationSignalYieldNow;
			case OP_INTERRUPT_SIGNAL:
				this.processNewInterruptSignal(message.cause);
				if (this._asyncInterruptor !== null) {
					this._asyncInterruptor(exitFailCause$1(message.cause));
					this._asyncInterruptor = null;
				}
				return EvaluationSignalContinue;
			case OP_RESUME:
				this._asyncInterruptor = null;
				this._asyncBlockingOn = null;
				this.evaluateEffect(message.effect);
				return EvaluationSignalContinue;
			case OP_STATEFUL:
				message.onFiber(this, this._exitValue !== null ? done$4 : suspended(this.currentRuntimeFlags, this._asyncBlockingOn));
				return EvaluationSignalContinue;
			default: return absurd(message);
		}
	}
	/**
	* Evaluates an effect until completion, potentially asynchronously.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	evaluateEffect(effect0) {
		this.currentSupervisor.onResume(this);
		try {
			let effect = interruptible$3(this.currentRuntimeFlags) && this.isInterrupted() ? exitFailCause$1(this.getInterruptedCause()) : effect0;
			while (effect !== null) {
				const eff = effect;
				const exit$3 = this.runLoop(eff);
				if (exit$3 === YieldedOp) {
					const op = yieldedOpChannel.currentOp;
					yieldedOpChannel.currentOp = null;
					if (op._op === OP_YIELD) if (cooperativeYielding(this.currentRuntimeFlags)) {
						this.tell(yieldNow$1());
						this.tell(resume(exitVoid$1));
						effect = null;
					} else effect = exitVoid$1;
					else if (op._op === OP_ASYNC) effect = null;
				} else {
					this.currentRuntimeFlags = pipe$3(this.currentRuntimeFlags, enable$1(WindDown));
					const interruption$1 = this.interruptAllChildren();
					if (interruption$1 !== null) effect = flatMap$5(interruption$1, () => exit$3);
					else {
						if (this._queue.length === 0) this.setExitValue(exit$3);
						else this.tell(resume(exit$3));
						effect = null;
					}
				}
			}
		} finally {
			this.currentSupervisor.onSuspend(this);
		}
	}
	/**
	* Begins execution of the effect associated with this fiber on the current
	* thread. This can be called to "kick off" execution of a fiber after it has
	* been created, in hopes that the effect can be executed synchronously.
	*
	* This is not the normal way of starting a fiber, but it is useful when the
	* express goal of executing the fiber is to synchronously produce its exit.
	*/
	start(effect) {
		if (!this._running) {
			this._running = true;
			const prev = globalThis[currentFiberURI];
			globalThis[currentFiberURI] = this;
			try {
				this.evaluateEffect(effect);
			} finally {
				this._running = false;
				globalThis[currentFiberURI] = prev;
				if (this._queue.length > 0) this.drainQueueLaterOnExecutor();
			}
		} else this.tell(resume(effect));
	}
	/**
	* Begins execution of the effect associated with this fiber on in the
	* background, and on the correct thread pool. This can be called to "kick
	* off" execution of a fiber after it has been created, in hopes that the
	* effect can be executed synchronously.
	*/
	startFork(effect) {
		this.tell(resume(effect));
	}
	/**
	* Takes the current runtime flags, patches them to return the new runtime
	* flags, and then makes any changes necessary to fiber state based on the
	* specified patch.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	patchRuntimeFlags(oldRuntimeFlags, patch$11) {
		const newRuntimeFlags = patch$4(oldRuntimeFlags, patch$11);
		globalThis[currentFiberURI] = this;
		this.currentRuntimeFlags = newRuntimeFlags;
		return newRuntimeFlags;
	}
	/**
	* Initiates an asynchronous operation, by building a callback that will
	* resume execution, and then feeding that callback to the registration
	* function, handling error cases and repeated resumptions appropriately.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	initiateAsync(runtimeFlags$1, asyncRegister) {
		let alreadyCalled = false;
		const callback = (effect) => {
			if (!alreadyCalled) {
				alreadyCalled = true;
				this.tell(resume(effect));
			}
		};
		if (interruptible$3(runtimeFlags$1)) this._asyncInterruptor = callback;
		try {
			asyncRegister(callback);
		} catch (e) {
			callback(failCause$8(die$5(e)));
		}
	}
	pushStack(cont) {
		this._stack.push(cont);
		if (cont._op === "OnStep") this._steps.push({
			refs: this.getFiberRefs(),
			flags: this.currentRuntimeFlags
		});
	}
	popStack() {
		const item = this._stack.pop();
		if (item) {
			if (item._op === "OnStep") this._steps.pop();
			return item;
		}
	}
	getNextSuccessCont() {
		let frame = this.popStack();
		while (frame) {
			if (frame._op !== OP_ON_FAILURE) return frame;
			frame = this.popStack();
		}
	}
	getNextFailCont() {
		let frame = this.popStack();
		while (frame) {
			if (frame._op !== OP_ON_SUCCESS && frame._op !== OP_WHILE && frame._op !== OP_ITERATOR) return frame;
			frame = this.popStack();
		}
	}
	[OP_TAG](op) {
		return sync$3(() => unsafeGet$3(this.currentContext, op));
	}
	["Left"](op) {
		return fail$9(op.left);
	}
	["None"](_$1) {
		return fail$9(new NoSuchElementException$1());
	}
	["Right"](op) {
		return exitSucceed$1(op.right);
	}
	["Some"](op) {
		return exitSucceed$1(op.value);
	}
	["Micro"](op) {
		return unsafeAsync((microResume) => {
			let resume$1 = microResume;
			const fiber = runFork$1(provideContext(op, this.currentContext));
			fiber.addObserver((exit$3) => {
				if (exit$3._tag === "Success") return resume$1(exitSucceed$1(exit$3.value));
				switch (exit$3.cause._tag) {
					case "Interrupt": return resume$1(exitFailCause$1(interrupt$6(none$6)));
					case "Fail": return resume$1(fail$9(exit$3.cause.error));
					case "Die": return resume$1(die$4(exit$3.cause.defect));
				}
			});
			return unsafeAsync((abortResume) => {
				resume$1 = (_$1) => {
					abortResume(void_$4);
				};
				fiber.unsafeInterrupt();
			});
		});
	}
	[OP_SYNC](op) {
		const value = internalCall(() => op.effect_instruction_i0());
		const cont = this.getNextSuccessCont();
		if (cont !== void 0) {
			if (!(cont._op in contOpSuccess)) absurd(cont);
			return contOpSuccess[cont._op](this, cont, value);
		} else {
			yieldedOpChannel.currentOp = exitSucceed$1(value);
			return YieldedOp;
		}
	}
	[OP_SUCCESS](op) {
		const oldCur = op;
		const cont = this.getNextSuccessCont();
		if (cont !== void 0) {
			if (!(cont._op in contOpSuccess)) absurd(cont);
			return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0);
		} else {
			yieldedOpChannel.currentOp = oldCur;
			return YieldedOp;
		}
	}
	[OP_FAILURE](op) {
		const cause$2 = op.effect_instruction_i0;
		const cont = this.getNextFailCont();
		if (cont !== void 0) switch (cont._op) {
			case OP_ON_FAILURE:
			case OP_ON_SUCCESS_AND_FAILURE: if (!(interruptible$3(this.currentRuntimeFlags) && this.isInterrupted())) return internalCall(() => cont.effect_instruction_i1(cause$2));
			else return exitFailCause$1(stripFailures$1(cause$2));
			case "OnStep": if (!(interruptible$3(this.currentRuntimeFlags) && this.isInterrupted())) return exitSucceed$1(exitFailCause$1(cause$2));
			else return exitFailCause$1(stripFailures$1(cause$2));
			case OP_REVERT_FLAGS:
				this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch);
				if (interruptible$3(this.currentRuntimeFlags) && this.isInterrupted()) return exitFailCause$1(sequential$3(cause$2, this.getInterruptedCause()));
				else return exitFailCause$1(cause$2);
			default: absurd(cont);
		}
		else {
			yieldedOpChannel.currentOp = exitFailCause$1(cause$2);
			return YieldedOp;
		}
	}
	[OP_WITH_RUNTIME](op) {
		return internalCall(() => op.effect_instruction_i0(this, running(this.currentRuntimeFlags)));
	}
	["Blocked"](op) {
		const refs = this.getFiberRefs();
		const flags = this.currentRuntimeFlags;
		if (this._steps.length > 0) {
			const frames = [];
			const snap = this._steps[this._steps.length - 1];
			let frame = this.popStack();
			while (frame && frame._op !== "OnStep") {
				frames.push(frame);
				frame = this.popStack();
			}
			this.setFiberRefs(snap.refs);
			this.currentRuntimeFlags = snap.flags;
			const patchRefs = diff$1(snap.refs, refs);
			const patchFlags = diff$3(snap.flags, flags);
			return exitSucceed$1(blocked$1(op.effect_instruction_i0, withFiberRuntime$1((newFiber) => {
				while (frames.length > 0) newFiber.pushStack(frames.pop());
				newFiber.setFiberRefs(patch$1(newFiber.id(), newFiber.getFiberRefs())(patchRefs));
				newFiber.currentRuntimeFlags = patch$4(patchFlags)(newFiber.currentRuntimeFlags);
				return op.effect_instruction_i1;
			})));
		}
		return uninterruptibleMask$2((restore) => flatMap$5(forkDaemon$1(runRequestBlock$1(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1)));
	}
	["RunBlocked"](op) {
		return runBlockedRequests(op.effect_instruction_i0);
	}
	[OP_UPDATE_RUNTIME_FLAGS](op) {
		const updateFlags = op.effect_instruction_i0;
		const oldRuntimeFlags = this.currentRuntimeFlags;
		const newRuntimeFlags = patch$4(oldRuntimeFlags, updateFlags);
		if (interruptible$3(newRuntimeFlags) && this.isInterrupted()) return exitFailCause$1(this.getInterruptedCause());
		else {
			this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags);
			if (op.effect_instruction_i1) {
				const revertFlags = diff$3(newRuntimeFlags, oldRuntimeFlags);
				this.pushStack(new RevertFlags(revertFlags, op));
				return internalCall(() => op.effect_instruction_i1(oldRuntimeFlags));
			} else return exitVoid$1;
		}
	}
	[OP_ON_SUCCESS](op) {
		this.pushStack(op);
		return op.effect_instruction_i0;
	}
	["OnStep"](op) {
		this.pushStack(op);
		return op.effect_instruction_i0;
	}
	[OP_ON_FAILURE](op) {
		this.pushStack(op);
		return op.effect_instruction_i0;
	}
	[OP_ON_SUCCESS_AND_FAILURE](op) {
		this.pushStack(op);
		return op.effect_instruction_i0;
	}
	[OP_ASYNC](op) {
		this._asyncBlockingOn = op.effect_instruction_i1;
		this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0);
		yieldedOpChannel.currentOp = op;
		return YieldedOp;
	}
	[OP_YIELD](op) {
		this._isYielding = false;
		yieldedOpChannel.currentOp = op;
		return YieldedOp;
	}
	[OP_WHILE](op) {
		const check$1 = op.effect_instruction_i0;
		const body = op.effect_instruction_i1;
		if (check$1()) {
			this.pushStack(op);
			return body();
		} else return exitVoid$1;
	}
	[OP_ITERATOR](op) {
		return contOpSuccess[OP_ITERATOR](this, op, void 0);
	}
	[OP_COMMIT](op) {
		return internalCall(() => op.commit());
	}
	/**
	* The main run-loop for evaluating effects.
	*
	* **NOTE**: This method must be invoked by the fiber itself.
	*/
	runLoop(effect0) {
		let cur = effect0;
		this.currentOpCount = 0;
		while (true) {
			if ((this.currentRuntimeFlags & OpSupervision) !== 0) this.currentSupervisor.onEffect(this, cur);
			if (this._queue.length > 0) cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur);
			if (!this._isYielding) {
				this.currentOpCount += 1;
				const shouldYield = this.currentScheduler.shouldYield(this);
				if (shouldYield !== false) {
					this._isYielding = true;
					this.currentOpCount = 0;
					const oldCur = cur;
					cur = flatMap$5(yieldNow$3({ priority: shouldYield }), () => oldCur);
				}
			}
			try {
				cur = this.currentTracer.context(() => {
					if (_version !== cur[EffectTypeId$2]._V) {
						const level = this.getFiberRef(currentVersionMismatchErrorLogLevel);
						if (level._tag === "Some") {
							const effectVersion = cur[EffectTypeId$2]._V;
							this.log(`Executing an Effect versioned ${effectVersion} with a Runtime of version ${getCurrentVersion()}, you may want to dedupe the effect dependencies, you can use the language service plugin to detect this at compile time: https://github.com/Effect-TS/language-service`, empty$15, level);
						}
					}
					return this[cur._op](cur);
				}, this);
				if (cur === YieldedOp) {
					const op = yieldedOpChannel.currentOp;
					if (op._op === OP_YIELD || op._op === OP_ASYNC) return YieldedOp;
					yieldedOpChannel.currentOp = null;
					return op._op === OP_SUCCESS || op._op === OP_FAILURE ? op : exitFailCause$1(die$5(op));
				}
			} catch (e) {
				if (cur !== YieldedOp && !hasProperty(cur, "_op") || !(cur._op in this)) cur = dieMessage$1(`Not a valid effect: ${toStringUnknown(cur)}`);
				else if (isInterruptedException$1(e)) cur = exitFailCause$1(sequential$3(die$5(e), interrupt$6(none$6)));
				else cur = die$4(e);
			}
		}
	}
	run = () => {
		this.drainQueueOnCurrentThread();
	};
};
/** @internal */
const currentMinimumLogLevel = /* @__PURE__ */ globalValue("effect/FiberRef/currentMinimumLogLevel", () => fiberRefUnsafeMake(fromLiteral("Info")));
/** @internal */
const loggerWithConsoleLog = (self) => makeLogger((opts) => {
	const services = getOrDefault(opts.context, currentServices);
	get$9(services, consoleTag).unsafe.log(self.log(opts));
});
/** @internal */
const defaultLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/defaultLogger"), () => loggerWithConsoleLog(stringLogger));
/** @internal */
const tracerLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/tracerLogger"), () => makeLogger(({ annotations: annotations$1, cause: cause$2, context: context$2, fiberId: fiberId$2, logLevel, message }) => {
	const span$1 = getOption(getOrDefault$1(context$2, currentContext), spanTag);
	if (span$1._tag === "None" || span$1.value._tag === "ExternalSpan") return;
	const clockService = unsafeGet$3(getOrDefault$1(context$2, currentServices), clockTag);
	const attributes = {};
	for (const [key, value] of annotations$1) attributes[key] = value;
	attributes["effect.fiberId"] = threadName(fiberId$2);
	attributes["effect.logLevel"] = logLevel.label;
	if (cause$2 !== null && cause$2._tag !== "Empty") attributes["effect.cause"] = pretty$3(cause$2, { renderErrorCause: true });
	span$1.value.event(toStringUnknown(Array.isArray(message) && message.length === 1 ? message[0] : message), clockService.unsafeCurrentTimeNanos(), attributes);
}));
/** @internal */
const currentLoggers = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLoggers"), () => fiberRefUnsafeMakeHashSet(make$38(defaultLogger, tracerLogger)));
const annotateLogsScoped$1 = function() {
	if (typeof arguments[0] === "string") return fiberRefLocallyScopedWith(currentLogAnnotations, set$3(arguments[0], arguments[1]));
	const entries$2 = Object.entries(arguments[0]);
	return fiberRefLocallyScopedWith(currentLogAnnotations, mutate((annotations$1) => {
		for (let i$1 = 0; i$1 < entries$2.length; i$1++) {
			const [key, value] = entries$2[i$1];
			set$3(annotations$1, key, value);
		}
		return annotations$1;
	}));
};
/** @internal */
const whenLogLevel$1 = /* @__PURE__ */ dual$1(2, (effect, level) => {
	const requiredLogLevel = typeof level === "string" ? fromLiteral(level) : level;
	return withFiberRuntime$1((fiberState) => {
		const minimumLogLevel = fiberState.getFiberRef(currentMinimumLogLevel);
		if (greaterThan$2(minimumLogLevel, requiredLogLevel)) return succeed$9(none$7());
		return map$9(effect, some$4);
	});
});
const acquireRelease$1 = /* @__PURE__ */ dual$1((args$2) => isEffect$1(args$2[0]), (acquire, release) => uninterruptible$1(tap$1(acquire, (a$1) => addFinalizer$2((exit$3) => release(a$1, exit$3)))));
const acquireReleaseInterruptible$1 = /* @__PURE__ */ dual$1((args$2) => isEffect$1(args$2[0]), (acquire, release) => ensuring$1(acquire, addFinalizer$2((exit$3) => release(exit$3))));
const addFinalizer$2 = (finalizer) => withFiberRuntime$1((runtime$4) => {
	const acquireRefs = runtime$4.getFiberRefs();
	const acquireFlags = disable$1(runtime$4.currentRuntimeFlags, Interruption);
	return flatMap$5(scope$1, (scope$2) => scopeAddFinalizerExit(scope$2, (exit$3) => withFiberRuntime$1((runtimeFinalizer) => {
		const preRefs = runtimeFinalizer.getFiberRefs();
		const preFlags = runtimeFinalizer.currentRuntimeFlags;
		const patchRefs = diff$1(preRefs, acquireRefs);
		const patchFlags = diff$3(preFlags, acquireFlags);
		const inverseRefs = diff$1(acquireRefs, preRefs);
		runtimeFinalizer.setFiberRefs(patch$1(patchRefs, runtimeFinalizer.id(), acquireRefs));
		return ensuring$1(withRuntimeFlags(finalizer(exit$3), patchFlags), sync$3(() => {
			runtimeFinalizer.setFiberRefs(patch$1(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()));
		}));
	})));
});
const daemonChildren$1 = (self) => {
	return fiberRefLocally(currentForkScopeOverride, some$4(globalScope))(self);
};
/** @internal */
const _existsParFound = /* @__PURE__ */ Symbol.for("effect/Effect/existsPar/found");
const exists$1 = /* @__PURE__ */ dual$1((args$2) => isIterable(args$2[0]) && !isEffect$1(args$2[0]), (elements, predicate, options) => matchSimple(options?.concurrency, () => suspend$3(() => existsLoop(elements[Symbol.iterator](), 0, predicate)), () => matchEffect$2(forEach$1(elements, (a$1, i$1) => if_$1(predicate(a$1, i$1), {
	onTrue: () => fail$9(_existsParFound),
	onFalse: () => void_$4
}), options), {
	onFailure: (e) => e === _existsParFound ? succeed$9(true) : fail$9(e),
	onSuccess: () => succeed$9(false)
})));
const existsLoop = (iterator, index, f$1) => {
	const next = iterator.next();
	if (next.done) return succeed$9(false);
	return flatMap$5(f$1(next.value, index), (b$1) => b$1 ? succeed$9(b$1) : existsLoop(iterator, index + 1, f$1));
};
const filter$2 = /* @__PURE__ */ dual$1((args$2) => isIterable(args$2[0]) && !isEffect$1(args$2[0]), (elements, predicate, options) => {
	const predicate_ = options?.negate ? (a$1, i$1) => map$9(predicate(a$1, i$1), not) : predicate;
	return matchSimple(options?.concurrency, () => suspend$3(() => fromIterable$10(elements).reduceRight((effect, a$1, i$1) => zipWith$4(effect, suspend$3(() => predicate_(a$1, i$1)), (list, b$1) => b$1 ? [a$1, ...list] : list), sync$3(() => new Array()))), () => map$9(forEach$1(elements, (a$1, i$1) => map$9(predicate_(a$1, i$1), (b$1) => b$1 ? some$4(a$1) : none$7()), options), getSomes));
});
const allResolveInput = (input) => {
	if (Array.isArray(input) || isIterable(input)) return [input, none$7()];
	const keys$5 = Object.keys(input);
	const size$11 = keys$5.length;
	return [keys$5.map((k) => input[k]), some$4((values$6) => {
		const res = {};
		for (let i$1 = 0; i$1 < size$11; i$1++) res[keys$5[i$1]] = values$6[i$1];
		return res;
	})];
};
const allValidate = (effects, reconcile, options) => {
	const eitherEffects = [];
	for (const effect of effects) eitherEffects.push(either$1(effect));
	return flatMap$5(forEach$1(eitherEffects, identity$2, {
		concurrency: options?.concurrency,
		batching: options?.batching,
		concurrentFinalizers: options?.concurrentFinalizers
	}), (eithers) => {
		const none$9 = none$7();
		const size$11 = eithers.length;
		const errors = new Array(size$11);
		const successes = new Array(size$11);
		let errored = false;
		for (let i$1 = 0; i$1 < size$11; i$1++) {
			const either$4 = eithers[i$1];
			if (either$4._tag === "Left") {
				errors[i$1] = some$4(either$4.left);
				errored = true;
			} else {
				successes[i$1] = either$4.right;
				errors[i$1] = none$9;
			}
		}
		if (errored) return reconcile._tag === "Some" ? fail$9(reconcile.value(errors)) : fail$9(errors);
		else if (options?.discard) return void_$4;
		return reconcile._tag === "Some" ? succeed$9(reconcile.value(successes)) : succeed$9(successes);
	});
};
const allEither = (effects, reconcile, options) => {
	const eitherEffects = [];
	for (const effect of effects) eitherEffects.push(either$1(effect));
	if (options?.discard) return forEach$1(eitherEffects, identity$2, {
		concurrency: options?.concurrency,
		batching: options?.batching,
		discard: true,
		concurrentFinalizers: options?.concurrentFinalizers
	});
	return map$9(forEach$1(eitherEffects, identity$2, {
		concurrency: options?.concurrency,
		batching: options?.batching,
		concurrentFinalizers: options?.concurrentFinalizers
	}), (eithers) => reconcile._tag === "Some" ? reconcile.value(eithers) : eithers);
};
const all$2 = (arg, options) => {
	const [effects, reconcile] = allResolveInput(arg);
	if (options?.mode === "validate") return allValidate(effects, reconcile, options);
	else if (options?.mode === "either") return allEither(effects, reconcile, options);
	return options?.discard !== true && reconcile._tag === "Some" ? map$9(forEach$1(effects, identity$2, options), reconcile.value) : forEach$1(effects, identity$2, options);
};
const allWith$1 = (options) => (arg) => all$2(arg, options);
const allSuccesses$1 = (elements, options) => map$9(all$2(fromIterable$10(elements).map(exit$2), options), filterMap$4((exit$3) => exitIsSuccess(exit$3) ? some$4(exit$3.effect_instruction_i0) : none$7()));
const replicate$1 = /* @__PURE__ */ dual$1(2, (self, n$1) => Array.from({ length: n$1 }, () => self));
const replicateEffect$1 = /* @__PURE__ */ dual$1((args$2) => isEffect$1(args$2[0]), (self, n$1, options) => all$2(replicate$1(self, n$1), options));
const forEach$1 = /* @__PURE__ */ dual$1((args$2) => isIterable(args$2[0]), (self, f$1, options) => withFiberRuntime$1((r$1) => {
	const isRequestBatchingEnabled = options?.batching === true || options?.batching === "inherit" && r$1.getFiberRef(currentRequestBatching);
	if (options?.discard) return match$4(options.concurrency, () => finalizersMaskInternal(sequential$1, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachConcurrentDiscard(self, (a$1, i$1) => restore(f$1(a$1, i$1)), true, false, 1) : forEachSequentialDiscard(self, (a$1, i$1) => restore(f$1(a$1, i$1)))), () => finalizersMaskInternal(parallel$1, options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self, (a$1, i$1) => restore(f$1(a$1, i$1)), isRequestBatchingEnabled, false)), (n$1) => finalizersMaskInternal(parallelN(n$1), options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self, (a$1, i$1) => restore(f$1(a$1, i$1)), isRequestBatchingEnabled, false, n$1)));
	return match$4(options?.concurrency, () => finalizersMaskInternal(sequential$1, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachParN(self, 1, (a$1, i$1) => restore(f$1(a$1, i$1)), true) : forEachSequential(self, (a$1, i$1) => restore(f$1(a$1, i$1)))), () => finalizersMaskInternal(parallel$1, options?.concurrentFinalizers)((restore) => forEachParUnbounded(self, (a$1, i$1) => restore(f$1(a$1, i$1)), isRequestBatchingEnabled)), (n$1) => finalizersMaskInternal(parallelN(n$1), options?.concurrentFinalizers)((restore) => forEachParN(self, n$1, (a$1, i$1) => restore(f$1(a$1, i$1)), isRequestBatchingEnabled)));
}));
const forEachParUnbounded = (self, f$1, batching) => suspend$3(() => {
	const as$6 = fromIterable$10(self);
	const array$3 = new Array(as$6.length);
	const fn = (a$1, i$1) => flatMap$5(f$1(a$1, i$1), (b$1) => sync$3(() => array$3[i$1] = b$1));
	return zipRight$3(forEachConcurrentDiscard(as$6, fn, batching, false), succeed$9(array$3));
});
/** @internal */
const forEachConcurrentDiscard = (self, f$1, batching, processAll, n$1) => uninterruptibleMask$2((restore) => transplant$1((graft) => withFiberRuntime$1((parent) => {
	let todos = Array.from(self).reverse();
	let target = todos.length;
	if (target === 0) return void_$4;
	let counter$5 = 0;
	let interrupted$2 = false;
	const fibersCount = n$1 ? Math.min(todos.length, n$1) : todos.length;
	const fibers = /* @__PURE__ */ new Set();
	const results = new Array();
	const interruptAll$2 = () => fibers.forEach((fiber) => {
		fiber.currentScheduler.scheduleTask(() => {
			fiber.unsafeInterruptAsFork(parent.id());
		}, 0);
	});
	const startOrder = new Array();
	const joinOrder = new Array();
	const residual = new Array();
	const collectExits = () => {
		const exits = results.filter(({ exit: exit$3 }) => exit$3._tag === "Failure").sort((a$1, b$1) => a$1.index < b$1.index ? -1 : a$1.index === b$1.index ? 0 : 1).map(({ exit: exit$3 }) => exit$3);
		if (exits.length === 0) exits.push(exitVoid$1);
		return exits;
	};
	const runFiber = (eff, interruptImmediately = false) => {
		const runnable = uninterruptible$1(graft(eff));
		const fiber = unsafeForkUnstarted(runnable, parent, parent.currentRuntimeFlags, globalScope);
		parent.currentScheduler.scheduleTask(() => {
			if (interruptImmediately) fiber.unsafeInterruptAsFork(parent.id());
			fiber.resume(runnable);
		}, 0);
		return fiber;
	};
	const onInterruptSignal = () => {
		if (!processAll) {
			target -= todos.length;
			todos = [];
		}
		interrupted$2 = true;
		interruptAll$2();
	};
	const stepOrExit = batching ? step$1 : exit$2;
	const processingFiber = runFiber(async_((resume$1) => {
		const pushResult = (res, index) => {
			if (res._op === "Blocked") residual.push(res);
			else {
				results.push({
					index,
					exit: res
				});
				if (res._op === "Failure" && !interrupted$2) onInterruptSignal();
			}
		};
		const next = () => {
			if (todos.length > 0) {
				const a$1 = todos.pop();
				let index = counter$5++;
				const returnNextElement = () => {
					const a$2 = todos.pop();
					index = counter$5++;
					return flatMap$5(yieldNow$3(), () => flatMap$5(stepOrExit(restore(f$1(a$2, index))), onRes));
				};
				const onRes = (res) => {
					if (todos.length > 0) {
						pushResult(res, index);
						if (todos.length > 0) return returnNextElement();
					}
					return succeed$9(res);
				};
				const fiber = runFiber(flatMap$5(stepOrExit(restore(f$1(a$1, index))), onRes));
				startOrder.push(fiber);
				fibers.add(fiber);
				if (interrupted$2) fiber.currentScheduler.scheduleTask(() => {
					fiber.unsafeInterruptAsFork(parent.id());
				}, 0);
				fiber.addObserver((wrapped) => {
					let exit$3;
					if (wrapped._op === "Failure") exit$3 = wrapped;
					else exit$3 = wrapped.effect_instruction_i0;
					joinOrder.push(fiber);
					fibers.delete(fiber);
					pushResult(exit$3, index);
					if (results.length === target) resume$1(succeed$9(getOrElse$5(exitCollectAll(collectExits(), { parallel: true }), () => exitVoid$1)));
					else if (residual.length + results.length === target) {
						const exits = collectExits();
						const requests = residual.map((blocked$2) => blocked$2.effect_instruction_i0).reduce(par);
						resume$1(succeed$9(blocked$1(requests, forEachConcurrentDiscard([getOrElse$5(exitCollectAll(exits, { parallel: true }), () => exitVoid$1), ...residual.map((blocked$2) => blocked$2.effect_instruction_i1)], (i$1) => i$1, batching, true, n$1))));
					} else next();
				});
			}
		};
		for (let i$1 = 0; i$1 < fibersCount; i$1++) next();
	}));
	return asVoid$3(onExit$2(flatten$3(restore(join$1(processingFiber))), exitMatch({
		onFailure: (cause$2) => {
			onInterruptSignal();
			const target$1 = residual.length + 1;
			const concurrency = Math.min(typeof n$1 === "number" ? n$1 : residual.length, residual.length);
			const toPop = Array.from(residual);
			return async_((cb) => {
				const exits = [];
				let count = 0;
				let index = 0;
				const check$1 = (index$1, hitNext) => (exit$3) => {
					exits[index$1] = exit$3;
					count++;
					if (count === target$1) cb(exitSucceed$1(exitFailCause$1(cause$2)));
					if (toPop.length > 0 && hitNext) next();
				};
				const next = () => {
					runFiber(toPop.pop(), true).addObserver(check$1(index, true));
					index++;
				};
				processingFiber.addObserver(check$1(index, false));
				index++;
				for (let i$1 = 0; i$1 < concurrency; i$1++) next();
			});
		},
		onSuccess: () => forEachSequential(joinOrder, (f$2) => f$2.inheritAll)
	})));
})));
const forEachParN = (self, n$1, f$1, batching) => suspend$3(() => {
	const as$6 = fromIterable$10(self);
	const array$3 = new Array(as$6.length);
	const fn = (a$1, i$1) => map$9(f$1(a$1, i$1), (b$1) => array$3[i$1] = b$1);
	return zipRight$3(forEachConcurrentDiscard(as$6, fn, batching, false, n$1), succeed$9(array$3));
});
const fork$2 = (self) => withFiberRuntime$1((state, status$2) => succeed$9(unsafeFork$1(self, state, status$2.runtimeFlags)));
const forkDaemon$1 = (self) => forkWithScopeOverride(self, globalScope);
const forkWithErrorHandler$1 = /* @__PURE__ */ dual$1(2, (self, handler) => fork$2(onError$1(self, (cause$2) => {
	const either$4 = failureOrCause$1(cause$2);
	switch (either$4._tag) {
		case "Left": return handler(either$4.left);
		case "Right": return failCause$8(either$4.right);
	}
})));
/** @internal */
const unsafeFork$1 = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
	const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
	childFiber.resume(effect);
	return childFiber;
};
/** @internal */
const unsafeForkUnstarted = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
	return unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
};
/** @internal */
const unsafeMakeChildFiber = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
	const childId = unsafeMake$7();
	const parentFiberRefs = parentFiber.getFiberRefs();
	const childFiberRefs = forkAs$1(parentFiberRefs, childId);
	const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);
	const childContext = getOrDefault$1(childFiberRefs, currentContext);
	const supervisor = childFiber.currentSupervisor;
	supervisor.onStart(childContext, effect, some$4(parentFiber), childFiber);
	childFiber.addObserver((exit$3) => supervisor.onEnd(exit$3, childFiber));
	(overrideScope !== null ? overrideScope : pipe$3(parentFiber.getFiberRef(currentForkScopeOverride), getOrElse$5(() => parentFiber.scope()))).add(parentRuntimeFlags, childFiber);
	return childFiber;
};
const forkWithScopeOverride = (self, scopeOverride) => withFiberRuntime$1((parentFiber, parentStatus) => succeed$9(unsafeFork$1(self, parentFiber, parentStatus.runtimeFlags, scopeOverride)));
const mergeAll$2 = /* @__PURE__ */ dual$1((args$2) => isFunction(args$2[2]), (elements, zero$1, f$1, options) => matchSimple(options?.concurrency, () => fromIterable$10(elements).reduce((acc, a$1, i$1) => zipWith$4(acc, a$1, (acc$1, a$2) => f$1(acc$1, a$2, i$1)), succeed$9(zero$1)), () => flatMap$5(make$19(zero$1), (acc) => flatMap$5(forEach$1(elements, (effect, i$1) => flatMap$5(effect, (a$1) => update$2(acc, (b$1) => f$1(b$1, a$1, i$1))), options), () => get(acc)))));
const partition$1 = /* @__PURE__ */ dual$1((args$2) => isIterable(args$2[0]), (elements, f$1, options) => pipe$3(forEach$1(elements, (a$1, i$1) => either$1(f$1(a$1, i$1)), options), map$9((chunk$2) => partitionMap(chunk$2, identity$2))));
const validateAll$1 = /* @__PURE__ */ dual$1((args$2) => isIterable(args$2[0]), (elements, f$1, options) => flatMap$5(partition$1(elements, f$1, {
	concurrency: options?.concurrency,
	batching: options?.batching,
	concurrentFinalizers: options?.concurrentFinalizers
}), ([es, bs]) => isNonEmptyArray(es) ? fail$9(es) : options?.discard ? void_$4 : succeed$9(bs)));
const raceAll$1 = (all$6) => withFiberRuntime$1((state, status$2) => async_((resume$1) => {
	const fibers = /* @__PURE__ */ new Set();
	let winner;
	let failures$2 = empty$15;
	const interruptAll$2 = () => {
		for (const fiber of fibers) fiber.unsafeInterruptAsFork(state.id());
	};
	let latch = false;
	let empty$34 = true;
	for (const self of all$6) {
		empty$34 = false;
		const fiber = unsafeFork$1(interruptible$2(self), state, status$2.runtimeFlags);
		fibers.add(fiber);
		fiber.addObserver((exit$3) => {
			fibers.delete(fiber);
			if (!winner) if (exit$3._tag === "Success") {
				latch = true;
				winner = fiber;
				failures$2 = empty$15;
				interruptAll$2();
			} else failures$2 = parallel$3(exit$3.cause, failures$2);
			if (latch && fibers.size === 0) resume$1(winner ? zipRight$3(inheritAll$1(winner), winner.unsafePoll()) : failCause$8(failures$2));
		});
		if (winner) break;
	}
	if (empty$34) return resume$1(dieSync$2(() => new IllegalArgumentException$1(`Received an empty collection of effects`)));
	latch = true;
	return interruptAllAs$1(fibers, state.id());
}));
const reduceEffect$1 = /* @__PURE__ */ dual$1((args$2) => isIterable(args$2[0]) && !isEffect$1(args$2[0]), (elements, zero$1, f$1, options) => matchSimple(options?.concurrency, () => fromIterable$10(elements).reduce((acc, a$1, i$1) => zipWith$4(acc, a$1, (acc$1, a$2) => f$1(acc$1, a$2, i$1)), zero$1), () => suspend$3(() => pipe$3(mergeAll$2([zero$1, ...elements], none$7(), (acc, elem, i$1) => {
	switch (acc._tag) {
		case "None": return some$4(elem);
		case "Some": return some$4(f$1(acc.value, elem, i$1));
	}
}, options), map$9((option$2) => {
	switch (option$2._tag) {
		case "None": throw new Error("BUG: Effect.reduceEffect - please report an issue at https://github.com/Effect-TS/effect/issues");
		case "Some": return option$2.value;
	}
})))));
const parallelFinalizers$1 = (self) => contextWithEffect$1((context$2) => match$11(getOption(context$2, scopeTag), {
	onNone: () => self,
	onSome: (scope$2) => {
		switch (scope$2.strategy._tag) {
			case "Parallel": return self;
			case "Sequential":
			case "ParallelN": return flatMap$5(scopeFork(scope$2, parallel$1), (inner) => scopeExtend(self, inner));
		}
	}
}));
const parallelNFinalizers = (parallelism) => (self) => contextWithEffect$1((context$2) => match$11(getOption(context$2, scopeTag), {
	onNone: () => self,
	onSome: (scope$2) => {
		if (scope$2.strategy._tag === "ParallelN" && scope$2.strategy.parallelism === parallelism) return self;
		return flatMap$5(scopeFork(scope$2, parallelN(parallelism)), (inner) => scopeExtend(self, inner));
	}
}));
const finalizersMask$1 = (strategy) => (self) => finalizersMaskInternal(strategy, true)(self);
const finalizersMaskInternal = (strategy, concurrentFinalizers) => (self) => contextWithEffect$1((context$2) => match$11(getOption(context$2, scopeTag), {
	onNone: () => self(identity$2),
	onSome: (scope$2) => {
		if (concurrentFinalizers === true) {
			const patch$11 = strategy._tag === "Parallel" ? parallelFinalizers$1 : strategy._tag === "Sequential" ? sequentialFinalizers$1 : parallelNFinalizers(strategy.parallelism);
			switch (scope$2.strategy._tag) {
				case "Parallel": return patch$11(self(parallelFinalizers$1));
				case "Sequential": return patch$11(self(sequentialFinalizers$1));
				case "ParallelN": return patch$11(self(parallelNFinalizers(scope$2.strategy.parallelism)));
			}
		} else return self(identity$2);
	}
}));
const scopeWith$1 = (f$1) => flatMap$5(scopeTag, f$1);
/** @internal */
const scopedWith$1 = (f$1) => flatMap$5(scopeMake(), (scope$2) => onExit$2(f$1(scope$2), (exit$3) => scope$2.close(exit$3)));
const scopedEffect = (effect) => flatMap$5(scopeMake(), (scope$2) => scopeUse(effect, scope$2));
const sequentialFinalizers$1 = (self) => contextWithEffect$1((context$2) => match$11(getOption(context$2, scopeTag), {
	onNone: () => self,
	onSome: (scope$2) => {
		switch (scope$2.strategy._tag) {
			case "Sequential": return self;
			case "Parallel":
			case "ParallelN": return flatMap$5(scopeFork(scope$2, sequential$1), (inner) => scopeExtend(self, inner));
		}
	}
}));
const tagMetricsScoped$1 = (key, value) => labelMetricsScoped$1([make$17(key, value)]);
const labelMetricsScoped$1 = (labels) => fiberRefLocallyScopedWith(currentMetricLabels, (old) => union$8(old, labels));
const using$1 = /* @__PURE__ */ dual$1(2, (self, use$1) => scopedWith$1((scope$2) => flatMap$5(scopeExtend(self, scope$2), use$1)));
/** @internal */
const validate$1 = /* @__PURE__ */ dual$1((args$2) => isEffect$1(args$2[1]), (self, that, options) => validateWith$1(self, that, (a$1, b$1) => [a$1, b$1], options));
/** @internal */
const validateWith$1 = /* @__PURE__ */ dual$1((args$2) => isEffect$1(args$2[1]), (self, that, f$1, options) => flatten$3(zipWithOptions(exit$2(self), exit$2(that), (ea, eb) => exitZipWith(ea, eb, {
	onSuccess: f$1,
	onFailure: (ca, cb) => options?.concurrent ? parallel$3(ca, cb) : sequential$3(ca, cb)
}), options)));
const validateFirst$1 = /* @__PURE__ */ dual$1((args$2) => isIterable(args$2[0]), (elements, f$1, options) => flip$1(forEach$1(elements, (a$1, i$1) => flip$1(f$1(a$1, i$1)), options)));
const withClockScoped$1 = (c$1) => fiberRefLocallyScopedWith(currentServices, add$3(clockTag, c$1));
const withRandomScoped$1 = (value) => fiberRefLocallyScopedWith(currentServices, add$3(randomTag, value));
const withConfigProviderScoped$1 = (provider) => fiberRefLocallyScopedWith(currentServices, add$3(configProviderTag, provider));
const withEarlyRelease$1 = (self) => scopeWith$1((parent) => flatMap$5(scopeFork(parent, sequential$2), (child) => pipe$3(self, scopeExtend(child), map$9((value) => [fiberIdWith$1((fiberId$2) => scopeClose(child, exitInterrupt$1(fiberId$2))), value]))));
/** @internal */
const zipOptions = /* @__PURE__ */ dual$1((args$2) => isEffect$1(args$2[1]), (self, that, options) => zipWithOptions(self, that, (a$1, b$1) => [a$1, b$1], options));
/** @internal */
const zipLeftOptions = /* @__PURE__ */ dual$1((args$2) => isEffect$1(args$2[1]), (self, that, options) => {
	if (options?.concurrent !== true && (options?.batching === void 0 || options.batching === false)) return zipLeft$3(self, that);
	return zipWithOptions(self, that, (a$1, _$1) => a$1, options);
});
/** @internal */
const zipRightOptions = /* @__PURE__ */ dual$1((args$2) => isEffect$1(args$2[1]), (self, that, options) => {
	if (options?.concurrent !== true && (options?.batching === void 0 || options.batching === false)) return zipRight$3(self, that);
	return zipWithOptions(self, that, (_$1, b$1) => b$1, options);
});
/** @internal */
const zipWithOptions = /* @__PURE__ */ dual$1((args$2) => isEffect$1(args$2[1]), (self, that, f$1, options) => map$9(all$2([self, that], {
	concurrency: options?.concurrent ? 2 : 1,
	batching: options?.batching,
	concurrentFinalizers: options?.concurrentFinalizers
}), ([a$1, a2]) => f$1(a$1, a2)));
const withRuntimeFlagsScoped = (update$5) => {
	if (update$5 === empty$17) return void_$4;
	return pipe$3(runtimeFlags, flatMap$5((runtimeFlags$1) => {
		const updatedRuntimeFlags = patch$4(runtimeFlags$1, update$5);
		const revertRuntimeFlags = diff$3(updatedRuntimeFlags, runtimeFlags$1);
		return pipe$3(updateRuntimeFlags(update$5), zipRight$3(addFinalizer$2(() => updateRuntimeFlags(revertRuntimeFlags))), asVoid$3);
	}), uninterruptible$1);
};
/** @internal */
const scopeTag = /* @__PURE__ */ GenericTag$1("effect/Scope");
const scope$1 = scopeTag;
const scopeUnsafeAddFinalizer = (scope$2, fin) => {
	if (scope$2.state._tag === "Open") scope$2.state.finalizers.set({}, fin);
};
const ScopeImplProto = {
	[ScopeTypeId$1]: ScopeTypeId$1,
	[CloseableScopeTypeId$1]: CloseableScopeTypeId$1,
	pipe() {
		return pipeArguments(this, arguments);
	},
	fork(strategy) {
		return sync$3(() => {
			const newScope = scopeUnsafeMake(strategy);
			if (this.state._tag === "Closed") {
				newScope.state = this.state;
				return newScope;
			}
			const key = {};
			const fin = (exit$3) => newScope.close(exit$3);
			this.state.finalizers.set(key, fin);
			scopeUnsafeAddFinalizer(newScope, (_$1) => sync$3(() => {
				if (this.state._tag === "Open") this.state.finalizers.delete(key);
			}));
			return newScope;
		});
	},
	close(exit$3) {
		return suspend$3(() => {
			if (this.state._tag === "Closed") return void_$4;
			const finalizers = Array.from(this.state.finalizers.values()).reverse();
			this.state = {
				_tag: "Closed",
				exit: exit$3
			};
			if (finalizers.length === 0) return void_$4;
			return isSequential$1(this.strategy) ? pipe$3(forEachSequential(finalizers, (fin) => exit$2(fin(exit$3))), flatMap$5((results) => pipe$3(exitCollectAll(results), map$16(exitAsVoid), getOrElse$5(() => exitVoid$1)))) : isParallel$1(this.strategy) ? pipe$3(forEachParUnbounded(finalizers, (fin) => exit$2(fin(exit$3)), false), flatMap$5((results) => pipe$3(exitCollectAll(results, { parallel: true }), map$16(exitAsVoid), getOrElse$5(() => exitVoid$1)))) : pipe$3(forEachParN(finalizers, this.strategy.parallelism, (fin) => exit$2(fin(exit$3)), false), flatMap$5((results) => pipe$3(exitCollectAll(results, { parallel: true }), map$16(exitAsVoid), getOrElse$5(() => exitVoid$1))));
		});
	},
	addFinalizer(fin) {
		return suspend$3(() => {
			if (this.state._tag === "Closed") return fin(this.state.exit);
			this.state.finalizers.set({}, fin);
			return void_$4;
		});
	}
};
const scopeUnsafeMake = (strategy = sequential$2) => {
	const scope$2 = Object.create(ScopeImplProto);
	scope$2.strategy = strategy;
	scope$2.state = {
		_tag: "Open",
		finalizers: /* @__PURE__ */ new Map()
	};
	return scope$2;
};
const scopeMake = (strategy = sequential$2) => sync$3(() => scopeUnsafeMake(strategy));
const scopeExtend = /* @__PURE__ */ dual$1(2, (effect, scope$2) => mapInputContext$1(effect, merge$4(make$44(scopeTag, scope$2))));
const scopeUse = /* @__PURE__ */ dual$1(2, (effect, scope$2) => pipe$3(effect, scopeExtend(scope$2), onExit$2((exit$3) => scope$2.close(exit$3))));
/** @internal */
const fiberRefUnsafeMakeSupervisor = (initial) => fiberRefUnsafeMakePatch(initial, {
	differ,
	fork: empty$5
});
const fiberRefLocallyScoped = /* @__PURE__ */ dual$1(2, (self, value) => asVoid$3(acquireRelease$1(flatMap$5(fiberRefGet(self), (oldValue) => as$4(fiberRefSet(self, value), oldValue)), (oldValue) => fiberRefSet(self, oldValue))));
const fiberRefLocallyScopedWith = /* @__PURE__ */ dual$1(2, (self, f$1) => fiberRefGetWith(self, (a$1) => fiberRefLocallyScoped(self, f$1(a$1))));
/** @internal */
const currentRuntimeFlags = /* @__PURE__ */ fiberRefUnsafeMakeRuntimeFlags(none$5);
/** @internal */
const currentSupervisor = /* @__PURE__ */ fiberRefUnsafeMakeSupervisor(none$2);
const fiberAwaitAll = (fibers) => forEach$1(fibers, _await$1);
/** @internal */
const fiberAll = (fibers) => {
	return {
		...CommitPrototype,
		commit() {
			return join$1(this);
		},
		[FiberTypeId$1]: fiberVariance,
		id: () => fromIterable$10(fibers).reduce((id$2, fiber) => combine$9(id$2, fiber.id()), none$6),
		await: exit$2(forEachParUnbounded(fibers, (fiber) => flatten$3(fiber.await), false)),
		children: map$9(forEachParUnbounded(fibers, (fiber) => fiber.children, false), flatten$7),
		inheritAll: forEachSequentialDiscard(fibers, (fiber) => fiber.inheritAll),
		poll: map$9(forEachSequential(fibers, (fiber) => fiber.poll), reduceRight$3(some$4(exitSucceed$1(new Array())), (optionB, optionA) => {
			switch (optionA._tag) {
				case "None": return none$7();
				case "Some": switch (optionB._tag) {
					case "None": return none$7();
					case "Some": return some$4(exitZipWith(optionA.value, optionB.value, {
						onSuccess: (a$1, chunk$2) => [a$1, ...chunk$2],
						onFailure: parallel$3
					}));
				}
			}
		})),
		interruptAsFork: (fiberId$2) => forEachSequentialDiscard(fibers, (fiber) => fiber.interruptAsFork(fiberId$2))
	};
};
const fiberInterruptFork = (self) => asVoid$3(forkDaemon$1(interruptFiber(self)));
const fiberJoinAll = (fibers) => join$1(fiberAll(fibers));
const fiberScoped = (self) => acquireRelease$1(succeed$9(self), interruptFiber);
/** @internal */
const raceWith$1 = /* @__PURE__ */ dual$1(3, (self, other, options) => raceFibersWith(self, other, {
	onSelfWin: (winner, loser) => flatMap$5(winner.await, (exit$3) => {
		switch (exit$3._tag) {
			case OP_SUCCESS: return flatMap$5(winner.inheritAll, () => options.onSelfDone(exit$3, loser));
			case OP_FAILURE: return options.onSelfDone(exit$3, loser);
		}
	}),
	onOtherWin: (winner, loser) => flatMap$5(winner.await, (exit$3) => {
		switch (exit$3._tag) {
			case OP_SUCCESS: return flatMap$5(winner.inheritAll, () => options.onOtherDone(exit$3, loser));
			case OP_FAILURE: return options.onOtherDone(exit$3, loser);
		}
	})
}));
/** @internal */
const disconnect$1 = (self) => uninterruptibleMask$2((restore) => fiberIdWith$1((fiberId$2) => flatMap$5(forkDaemon$1(restore(self)), (fiber) => pipe$3(restore(join$1(fiber)), onInterrupt$1(() => pipe$3(fiber, interruptAsFork$1(fiberId$2)))))));
/** @internal */
const race$1 = /* @__PURE__ */ dual$1(2, (self, that) => fiberIdWith$1((parentFiberId) => raceWith$1(self, that, {
	onSelfDone: (exit$3, right$2) => exitMatchEffect(exit$3, {
		onFailure: (cause$2) => pipe$3(join$1(right$2), mapErrorCause$1((cause2) => parallel$3(cause$2, cause2))),
		onSuccess: (value) => pipe$3(right$2, interruptAsFiber(parentFiberId), as$4(value))
	}),
	onOtherDone: (exit$3, left$2) => exitMatchEffect(exit$3, {
		onFailure: (cause$2) => pipe$3(join$1(left$2), mapErrorCause$1((cause2) => parallel$3(cause2, cause$2))),
		onSuccess: (value) => pipe$3(left$2, interruptAsFiber(parentFiberId), as$4(value))
	})
})));
/** @internal */
const raceFibersWith = /* @__PURE__ */ dual$1(3, (self, other, options) => withFiberRuntime$1((parentFiber, parentStatus) => {
	const parentRuntimeFlags = parentStatus.runtimeFlags;
	const raceIndicator = make$37(true);
	const leftFiber = unsafeMakeChildFiber(self, parentFiber, parentRuntimeFlags, options.selfScope);
	const rightFiber = unsafeMakeChildFiber(other, parentFiber, parentRuntimeFlags, options.otherScope);
	return async_((cb) => {
		leftFiber.addObserver(() => completeRace(leftFiber, rightFiber, options.onSelfWin, raceIndicator, cb));
		rightFiber.addObserver(() => completeRace(rightFiber, leftFiber, options.onOtherWin, raceIndicator, cb));
		leftFiber.startFork(self);
		rightFiber.startFork(other);
	}, combine$9(leftFiber.id(), rightFiber.id()));
}));
const completeRace = (winner, loser, cont, ab, cb) => {
	if (compareAndSet(true, false)(ab)) cb(cont(winner, loser));
};
/** @internal */
const ensuring$1 = /* @__PURE__ */ dual$1(2, (self, finalizer) => uninterruptibleMask$2((restore) => matchCauseEffect$2(restore(self), {
	onFailure: (cause1) => matchCauseEffect$2(finalizer, {
		onFailure: (cause2) => failCause$8(sequential$3(cause1, cause2)),
		onSuccess: () => failCause$8(cause1)
	}),
	onSuccess: (a$1) => as$4(finalizer, a$1)
})));
/** @internal */
const invokeWithInterrupt = (self, entries$2, onInterrupt$2) => fiberIdWith$1((id$2) => flatMap$5(flatMap$5(forkDaemon$1(interruptible$2(self)), (processing) => async_((cb) => {
	const counts = entries$2.map((_$1) => _$1.listeners.count);
	const checkDone = () => {
		if (counts.every((count) => count === 0)) {
			if (entries$2.every((_$1) => {
				if (_$1.result.state.current._tag === "Pending") return true;
				else if (_$1.result.state.current._tag === "Done" && exitIsExit(_$1.result.state.current.effect) && _$1.result.state.current.effect._tag === "Failure" && isInterrupted$2(_$1.result.state.current.effect.cause)) return true;
				else return false;
			})) {
				cleanup.forEach((f$1) => f$1());
				onInterrupt$2?.();
				cb(interruptFiber(processing));
			}
		}
	};
	processing.addObserver((exit$3) => {
		cleanup.forEach((f$1) => f$1());
		cb(exit$3);
	});
	const cleanup = entries$2.map((r$1, i$1) => {
		const observer = (count) => {
			counts[i$1] = count;
			checkDone();
		};
		r$1.listeners.addObserver(observer);
		return () => r$1.listeners.removeObserver(observer);
	});
	checkDone();
	return sync$3(() => {
		cleanup.forEach((f$1) => f$1());
	});
})), () => suspend$3(() => {
	const residual = entries$2.flatMap((entry) => {
		if (!entry.state.completed) return [entry];
		return [];
	});
	return forEachSequentialDiscard(residual, (entry) => complete$2(entry.request, exitInterrupt$1(id$2)));
})));
/** @internal */
const interruptWhenPossible$1 = /* @__PURE__ */ dual$1(2, (self, all$6) => fiberRefGetWith(currentRequestMap, (map$18) => suspend$3(() => {
	return invokeWithInterrupt(self, fromIterable$10(all$6).flatMap((_$1) => map$18.has(_$1) ? [map$18.get(_$1)] : []));
})));
/** @internal */
const makeSpanScoped$1 = (name, options) => {
	options = addSpanStackTrace(options);
	return uninterruptible$1(withFiberRuntime$1((fiber) => {
		const scope$2 = unsafeGet$3(fiber.getFiberRef(currentContext), scopeTag);
		const span$1 = unsafeMakeSpan(fiber, name, options);
		const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
		const clock_ = get$9(fiber.getFiberRef(currentServices), clockTag);
		return as$4(scopeAddFinalizerExit(scope$2, (exit$3) => endSpan(span$1, exit$3, clock_, timingEnabled)), span$1);
	}));
};
const withTracerScoped$1 = (value) => fiberRefLocallyScopedWith(currentServices, add$3(tracerTag, value));
/** @internal */
const withSpanScoped$1 = function() {
	const dataFirst = typeof arguments[0] !== "string";
	const name = dataFirst ? arguments[1] : arguments[0];
	const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
	if (dataFirst) {
		const self = arguments[0];
		return flatMap$5(makeSpanScoped$1(name, addSpanStackTrace(options)), (span$1) => provideService$1(self, spanTag, span$1));
	}
	return (self) => flatMap$5(makeSpanScoped$1(name, addSpanStackTrace(options)), (span$1) => provideService$1(self, spanTag, span$1));
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/cache.js
/** @internal */
const complete$1 = (key, exit$3, entryStats, timeToLiveMillis) => struct$1({
	_tag: "Complete",
	key,
	exit: exit$3,
	entryStats,
	timeToLiveMillis
});
/** @internal */
const pending = (key, deferred) => struct$1({
	_tag: "Pending",
	key,
	deferred
});
/** @internal */
const refreshing = (deferred, complete$4) => struct$1({
	_tag: "Refreshing",
	deferred,
	complete: complete$4
});
/** @internal */
const MapKeyTypeId = /* @__PURE__ */ Symbol.for("effect/Cache/MapKey");
var MapKeyImpl = class {
	current;
	[MapKeyTypeId] = MapKeyTypeId;
	previous = void 0;
	next = void 0;
	constructor(current) {
		this.current = current;
	}
	[symbol$1]() {
		return pipe$3(hash(this.current), combine$11(hash(this.previous)), combine$11(hash(this.next)), cached$2(this));
	}
	[symbol](that) {
		if (this === that) return true;
		return isMapKey(that) && equals(this.current, that.current) && equals(this.previous, that.previous) && equals(this.next, that.next);
	}
};
/** @internal */
const makeMapKey = (current) => new MapKeyImpl(current);
/** @internal */
const isMapKey = (u$1) => hasProperty(u$1, MapKeyTypeId);
var KeySetImpl = class {
	head = void 0;
	tail = void 0;
	add(key) {
		if (key !== this.tail) if (this.tail === void 0) {
			this.head = key;
			this.tail = key;
		} else {
			const previous = key.previous;
			const next = key.next;
			if (next !== void 0) {
				key.next = void 0;
				if (previous !== void 0) {
					previous.next = next;
					next.previous = previous;
				} else {
					this.head = next;
					this.head.previous = void 0;
				}
			}
			this.tail.next = key;
			key.previous = this.tail;
			this.tail = key;
		}
	}
	remove() {
		const key = this.head;
		if (key !== void 0) {
			const next = key.next;
			if (next !== void 0) {
				key.next = void 0;
				this.head = next;
				this.head.previous = void 0;
			} else {
				this.head = void 0;
				this.tail = void 0;
			}
		}
		return key;
	}
};
/** @internal */
const makeKeySet = () => new KeySetImpl();
/**
* Constructs a new `CacheState` from the specified values.
*
* @internal
*/
const makeCacheState = (map$18, keys$5, accesses, updating, hits, misses) => ({
	map: map$18,
	keys: keys$5,
	accesses,
	updating,
	hits,
	misses
});
/**
* Constructs an initial cache state.
*
* @internal
*/
const initialCacheState = () => makeCacheState(empty$14(), makeKeySet(), unbounded(), make$37(false), 0, 0);
/** @internal */
const CacheSymbolKey = "effect/Cache";
/** @internal */
const CacheTypeId = /* @__PURE__ */ Symbol.for(CacheSymbolKey);
const cacheVariance = {
	_Key: (_$1) => _$1,
	_Error: (_$1) => _$1,
	_Value: (_$1) => _$1
};
/** @internal */
const ConsumerCacheSymbolKey = "effect/ConsumerCache";
/** @internal */
const ConsumerCacheTypeId = /* @__PURE__ */ Symbol.for(ConsumerCacheSymbolKey);
const consumerCacheVariance = {
	_Key: (_$1) => _$1,
	_Error: (_$1) => _$1,
	_Value: (_$1) => _$1
};
/** @internal */
const makeCacheStats = (options) => options;
/** @internal */
const makeEntryStats = (loadedMillis) => ({ loadedMillis });
var CacheImpl = class {
	capacity;
	context;
	fiberId;
	lookup;
	timeToLive;
	[CacheTypeId] = cacheVariance;
	[ConsumerCacheTypeId] = consumerCacheVariance;
	cacheState;
	constructor(capacity, context$2, fiberId$2, lookup, timeToLive) {
		this.capacity = capacity;
		this.context = context$2;
		this.fiberId = fiberId$2;
		this.lookup = lookup;
		this.timeToLive = timeToLive;
		this.cacheState = initialCacheState();
	}
	get(key) {
		return map$9(this.getEither(key), merge$6);
	}
	get cacheStats() {
		return sync$3(() => makeCacheStats({
			hits: this.cacheState.hits,
			misses: this.cacheState.misses,
			size: size$5(this.cacheState.map)
		}));
	}
	getOption(key) {
		return suspend$3(() => match$11(get$4(this.cacheState.map, key), {
			onNone: () => {
				const mapKey = makeMapKey(key);
				this.trackAccess(mapKey);
				this.trackMiss();
				return succeed$9(none$7());
			},
			onSome: (value) => this.resolveMapValue(value)
		}));
	}
	getOptionComplete(key) {
		return suspend$3(() => match$11(get$4(this.cacheState.map, key), {
			onNone: () => {
				const mapKey = makeMapKey(key);
				this.trackAccess(mapKey);
				this.trackMiss();
				return succeed$9(none$7());
			},
			onSome: (value) => this.resolveMapValue(value, true)
		}));
	}
	contains(key) {
		return sync$3(() => has$2(this.cacheState.map, key));
	}
	entryStats(key) {
		return sync$3(() => {
			const option$2 = get$4(this.cacheState.map, key);
			if (isSome(option$2)) switch (option$2.value._tag) {
				case "Complete": {
					const loaded = option$2.value.entryStats.loadedMillis;
					return some$4(makeEntryStats(loaded));
				}
				case "Pending": return none$7();
				case "Refreshing": {
					const loaded = option$2.value.complete.entryStats.loadedMillis;
					return some$4(makeEntryStats(loaded));
				}
			}
			return none$7();
		});
	}
	getEither(key) {
		return suspend$3(() => {
			const k = key;
			let mapKey = void 0;
			let deferred = void 0;
			let value = getOrUndefined(get$4(this.cacheState.map, k));
			if (value === void 0) {
				deferred = unsafeMake$6(this.fiberId);
				mapKey = makeMapKey(k);
				if (has$2(this.cacheState.map, k)) value = getOrUndefined(get$4(this.cacheState.map, k));
				else set$2(this.cacheState.map, k, pending(mapKey, deferred));
			}
			if (value === void 0) {
				this.trackAccess(mapKey);
				this.trackMiss();
				return map$9(this.lookupValueOf(key, deferred), right);
			} else return flatMap$5(this.resolveMapValue(value), match$11({
				onNone: () => this.getEither(key),
				onSome: (value$1) => succeed$9(left(value$1))
			}));
		});
	}
	invalidate(key) {
		return sync$3(() => {
			remove$3(this.cacheState.map, key);
		});
	}
	invalidateWhen(key, when$2) {
		return sync$3(() => {
			const value = get$4(this.cacheState.map, key);
			if (isSome(value) && value.value._tag === "Complete") {
				if (value.value.exit._tag === "Success") {
					if (when$2(value.value.exit.value)) remove$3(this.cacheState.map, key);
				}
			}
		});
	}
	get invalidateAll() {
		return sync$3(() => {
			this.cacheState.map = empty$14();
		});
	}
	refresh(key) {
		return clockWith$1((clock$2) => suspend$3(() => {
			const k = key;
			const deferred = unsafeMake$6(this.fiberId);
			let value = getOrUndefined(get$4(this.cacheState.map, k));
			if (value === void 0) if (has$2(this.cacheState.map, k)) value = getOrUndefined(get$4(this.cacheState.map, k));
			else set$2(this.cacheState.map, k, pending(makeMapKey(k), deferred));
			if (value === void 0) return asVoid$3(this.lookupValueOf(key, deferred));
			else switch (value._tag) {
				case "Complete":
					if (this.hasExpired(clock$2, value.timeToLiveMillis)) {
						const found = getOrUndefined(get$4(this.cacheState.map, k));
						if (equals(found, value)) remove$3(this.cacheState.map, k);
						return asVoid$3(this.get(key));
					}
					return pipe$3(this.lookupValueOf(key, deferred), when$1(() => {
						const current = getOrUndefined(get$4(this.cacheState.map, k));
						if (equals(current, value)) {
							const mapValue = refreshing(deferred, value);
							set$2(this.cacheState.map, k, mapValue);
							return true;
						}
						return false;
					}), asVoid$3);
				case "Pending": return _await$2(value.deferred);
				case "Refreshing": return _await$2(value.deferred);
			}
		}));
	}
	set(key, value) {
		return clockWith$1((clock$2) => sync$3(() => {
			const now = clock$2.unsafeCurrentTimeMillis();
			const k = key;
			const lookupResult = succeed$7(value);
			const mapValue = complete$1(makeMapKey(k), lookupResult, makeEntryStats(now), now + toMillis(decode$3(this.timeToLive(lookupResult))));
			set$2(this.cacheState.map, k, mapValue);
		}));
	}
	get size() {
		return sync$3(() => {
			return size$5(this.cacheState.map);
		});
	}
	get values() {
		return sync$3(() => {
			const values$6 = [];
			for (const entry of this.cacheState.map) if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") values$6.push(entry[1].exit.value);
			return values$6;
		});
	}
	get entries() {
		return sync$3(() => {
			const values$6 = [];
			for (const entry of this.cacheState.map) if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") values$6.push([entry[0], entry[1].exit.value]);
			return values$6;
		});
	}
	get keys() {
		return sync$3(() => {
			const keys$5 = [];
			for (const entry of this.cacheState.map) if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") keys$5.push(entry[0]);
			return keys$5;
		});
	}
	resolveMapValue(value, ignorePending = false) {
		return clockWith$1((clock$2) => {
			switch (value._tag) {
				case "Complete":
					this.trackAccess(value.key);
					if (this.hasExpired(clock$2, value.timeToLiveMillis)) {
						remove$3(this.cacheState.map, value.key.current);
						return succeed$9(none$7());
					}
					this.trackHit();
					return map$9(value.exit, some$4);
				case "Pending":
					this.trackAccess(value.key);
					this.trackHit();
					if (ignorePending) return succeed$9(none$7());
					return map$9(_await$2(value.deferred), some$4);
				case "Refreshing":
					this.trackAccess(value.complete.key);
					this.trackHit();
					if (this.hasExpired(clock$2, value.complete.timeToLiveMillis)) {
						if (ignorePending) return succeed$9(none$7());
						return map$9(_await$2(value.deferred), some$4);
					}
					return map$9(value.complete.exit, some$4);
			}
		});
	}
	trackHit() {
		this.cacheState.hits = this.cacheState.hits + 1;
	}
	trackMiss() {
		this.cacheState.misses = this.cacheState.misses + 1;
	}
	trackAccess(key) {
		offer(this.cacheState.accesses, key);
		if (compareAndSet(this.cacheState.updating, false, true)) {
			let loop$2 = true;
			while (loop$2) {
				const key$1 = poll$2(this.cacheState.accesses, EmptyMutableQueue);
				if (key$1 === EmptyMutableQueue) loop$2 = false;
				else this.cacheState.keys.add(key$1);
			}
			let size$11 = size$5(this.cacheState.map);
			loop$2 = size$11 > this.capacity;
			while (loop$2) {
				const key$1 = this.cacheState.keys.remove();
				if (key$1 !== void 0) {
					if (has$2(this.cacheState.map, key$1.current)) {
						remove$3(this.cacheState.map, key$1.current);
						size$11 = size$11 - 1;
						loop$2 = size$11 > this.capacity;
					}
				} else loop$2 = false;
			}
			set$4(this.cacheState.updating, false);
		}
	}
	hasExpired(clock$2, timeToLiveMillis) {
		return clock$2.unsafeCurrentTimeMillis() > timeToLiveMillis;
	}
	lookupValueOf(input, deferred) {
		return clockWith$1((clock$2) => suspend$3(() => {
			const key = input;
			return pipe$3(this.lookup(input), provideContext$1(this.context), exit$2, flatMap$5((exit$3) => {
				const now = clock$2.unsafeCurrentTimeMillis();
				const stats = makeEntryStats(now);
				const value = complete$1(makeMapKey(key), exit$3, stats, now + toMillis(decode$3(this.timeToLive(exit$3))));
				set$2(this.cacheState.map, key, value);
				return zipRight$3(done$6(deferred, exit$3), exit$3);
			}), onInterrupt$1(() => zipRight$3(interrupt$4(deferred), sync$3(() => {
				remove$3(this.cacheState.map, key);
			}))));
		}));
	}
};
/** @internal */
const unsafeMakeWith = (capacity, lookup, timeToLive) => new CacheImpl(capacity, empty$31(), none$1, lookup, (exit$3) => decode$3(timeToLive(exit$3)));

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Cause.js
/**
* A unique symbol identifying the `Cause` type.
*
* **Details**
*
* This provides a symbol that helps identify instances of the `Cause` data
* type. This can be used for advanced operations such as refining types or
* building internal utilities that check whether an unknown value is a `Cause`.
*
* @see {@link isCause} Check if a value is a `Cause`
*
* @since 2.0.0
* @category Symbols
*/
const CauseTypeId = CauseTypeId$1;
/**
* A unique symbol identifying the `RuntimeException` type.
*
* **Details**
*
* This provides a symbol that identifies a `RuntimeException`. This is
* typically used internally by the library to recognize checked exceptions that
* occur during runtime.
*
* @see {@link RuntimeException} Create or work with a `RuntimeException`
*
* @since 2.0.0
* @category Symbols
*/
const RuntimeExceptionTypeId = RuntimeExceptionTypeId$1;
/**
* A unique symbol identifying the `InterruptedException` type.
*
* **Details**
*
* This provides a symbol that identifies an `InterruptedException`. This is
* typically used internally to recognize when a fiber has been interrupted,
* helping the framework handle interruption logic correctly.
*
* @see {@link InterruptedException} Create or work with an `InterruptedException`
*
* @since 2.0.0
* @category Symbols
*/
const InterruptedExceptionTypeId = InterruptedExceptionTypeId$1;
/**
* A unique symbol identifying the `IllegalArgumentException` type.
*
* **Details**
*
* This provides a symbol that identifies an `IllegalArgumentException`. This is
* often used in scenarios where invalid arguments are supplied to methods that
* expect specific input.
*
* @see {@link IllegalArgumentException} Create or work with an `IllegalArgumentException`
*
* @since 2.0.0
* @category Symbols
*/
const IllegalArgumentExceptionTypeId = IllegalArgumentExceptionTypeId$1;
/**
* A unique symbol identifying the `NoSuchElementException` type.
*
* **Details**
*
* This provides a symbol that identifies a `NoSuchElementException`. It helps
* differentiate cases where a required element is missing within a data
* structure.
*
* @see {@link NoSuchElementException} Create or work with a `NoSuchElementException`
*
* @since 2.0.0
* @category Symbols
*/
const NoSuchElementExceptionTypeId = NoSuchElementExceptionTypeId$1;
/**
* A unique symbol identifying the `InvalidPubSubCapacityException` type.
*
* **Details**
*
* This provides a symbol that identifies an `InvalidPubSubCapacityException`.
* It indicates an error related to an invalid capacity passed to a `PubSub`
* structure.
*
* @see {@link InvalidPubSubCapacityException} Create or work with an `InvalidPubSubCapacityException`
*
* @since 2.0.0
* @category Symbols
*/
const InvalidPubSubCapacityExceptionTypeId = InvalidPubSubCapacityExceptionTypeId$1;
/**
* A unique symbol identifying the `ExceededCapacityException` type.
*
* **Details**
*
* This provides a symbol that identifies an `ExceededCapacityException`. It
* denotes situations where a resource has exceeded its configured capacity
* limit.
*
* @see {@link ExceededCapacityException} Create or work with an `ExceededCapacityException`
*
* @since 3.5.0
* @category Symbols
*/
const ExceededCapacityExceptionTypeId = ExceededCapacityExceptionTypeId$1;
/**
* A unique symbol identifying the `TimeoutException` type.
*
* **Details**
*
* This provides a symbol that identifies a `TimeoutException`. It helps the
* framework recognize errors related to operations that fail to complete within
* a given timeframe.
*
* @see {@link TimeoutException} Create or work with a `TimeoutException`
*
* @since 2.0.0
* @category Symbols
*/
const TimeoutExceptionTypeId = TimeoutExceptionTypeId$1;
/**
* A unique symbol identifying the `UnknownException` type.
*
* **Details**
*
* This provides a symbol that identifies an `UnknownException`. It is typically
* used for generic or unexpected errors that do not fit other specific
* exception categories.
*
* @see {@link UnknownException} Create or work with an `UnknownException`
*
* @since 2.0.0
* @category Symbols
*/
const UnknownExceptionTypeId = UnknownExceptionTypeId$1;
/**
* Creates an error that occurs at runtime, extendable for other exception
* types.
*
* @since 2.0.0
* @category Errors
*/
const YieldableError = YieldableError$1;
/**
* Creates an `Empty` cause.
*
* **Details**
*
* This function returns a cause that signifies "no error." It's commonly used
* to represent an absence of failure conditions.
*
* @see {@link isEmpty} Check if a `Cause` is empty
*
* @since 2.0.0
* @category Constructors
*/
const empty$4 = empty$15;
/**
* Creates a `Fail` cause from an expected error.
*
* **Details**
*
* This function constructs a `Cause` carrying an error of type `E`. It's used
* when you want to represent a known or anticipated failure in your effectful
* computations.
*
* @see {@link isFailure} Check if a `Cause` contains a failure
*
* @since 2.0.0
* @category Constructors
*/
const fail$4 = fail$10;
/**
* Creates a `Die` cause from an unexpected error.
*
* **Details**
*
* This function wraps an unhandled or unknown defect (like a runtime crash)
* into a `Cause`. It's useful for capturing unforeseen issues in a structured
* way.
*
* @see {@link isDie} Check if a `Cause` contains a defect
*
* @since 2.0.0
* @category Constructors
*/
const die$1 = die$5;
/**
* Creates an `Interrupt` cause from a `FiberId`.
*
* **Details**
*
* This function represents a fiber that has been interrupted. It stores the
* identifier of the interrupted fiber, enabling precise tracking of concurrent
* cancellations.
*
* @see {@link isInterrupted} Check if a `Cause` contains an interruption
*
* @since 2.0.0
* @category Constructors
*/
const interrupt$2 = interrupt$6;
/**
* Combines two `Cause`s in parallel.
*
* **Details**
*
* This function merges two errors that occurred simultaneously. Instead of
* discarding one error, both are retained, allowing for richer error reporting
* and debugging.
*
* @see {@link isParallelType} Check if a `Cause` is a `Parallel`
*
* @since 2.0.0
* @category Constructors
*/
const parallel = parallel$3;
/**
* Combines two `Cause`s sequentially.
*
* **Details**
*
* This function merges two errors that occurred in sequence, such as a main
* error followed by a finalization error. It preserves both errors for complete
* failure information.
*
* @see {@link isSequentialType} Check if a `Cause` is a `Sequential`
*
* @since 2.0.0
* @category Constructors
*/
const sequential = sequential$3;
/**
* Checks if a value is a `Cause`.
*
* @since 2.0.0
* @category Guards
*/
const isCause = isCause$1;
/**
* Checks if a `Cause` is an `Empty` type.
*
* @see {@link empty} Create a new `Empty` cause
*
* @since 2.0.0
* @category Guards
*/
const isEmptyType = isEmptyType$1;
/**
* Checks if a `Cause` is a `Fail` type.
*
* @see {@link fail} Create a new `Fail` cause
*
* @since 2.0.0
* @category Guards
*/
const isFailType = isFailType$1;
/**
* Checks if a `Cause` is a `Die` type.
*
* @see {@link die} Create a new `Die` cause
*
* @since 2.0.0
* @category Guards
*/
const isDieType = isDieType$1;
/**
* Checks if a `Cause` is an `Interrupt` type.
*
* @see {@link interrupt} Create an `Interrupt` cause
*
* @since 2.0.0
* @category Guards
*/
const isInterruptType = isInterruptType$1;
/**
* Checks if a `Cause` is a `Sequential` type.
*
* @see {@link sequential} Combine two `Cause`s sequentially
*
* @since 2.0.0
* @category Guards
*/
const isSequentialType = isSequentialType$1;
/**
* Checks if a `Cause` is a `Parallel` type.
*
* @see {@link parallel} Combine two `Cause`s in parallel
*
* @since 2.0.0
* @category Guards
*/
const isParallelType = isParallelType$1;
/**
* Calculates the size of a `Cause`.
*
* **Details**
*
* This function returns the total number of `Cause` nodes in the semiring
* structure, reflecting how many individual error elements are recorded.
*
* @since 2.0.0
* @category Getters
*/
const size$2 = size$6;
/**
* Checks if a `Cause` is entirely empty.
*
* **Details**
*
* This function returns `true` if the `Cause` contains no errors, defects, or
* interruptions. It's helpful for verifying if a computation truly had no
* failures.
*
* @since 2.0.0
* @category Getters
*/
const isEmpty$2 = isEmpty$4;
/**
* Checks if a `Cause` contains a failure.
*
* **Details**
*
* This function returns `true` if the `Cause` includes any `Fail` error. It's
* commonly used to confirm whether a workflow encountered an anticipated error
* versus just defects or interruptions.
*
* @since 2.0.0
* @category Getters
*/
const isFailure$1 = isFailure$4;
/**
* Checks if a `Cause` contains a defect.
*
* **Details**
*
* This function returns `true` if the `Cause` includes any unexpected or
* unhandled errors (`Die`). It's useful for differentiating known failures from
* unexpected ones.
*
* @since 2.0.0
* @category Getters
*/
const isDie = isDie$1;
/**
* Checks if a `Cause` contains an interruption.
*
* **Details**
*
* This function returns `true` if the `Cause` includes any fiber interruptions.
*
* @since 2.0.0
* @category Getters
*/
const isInterrupted = isInterrupted$2;
/**
* Checks if a `Cause` contains only interruptions.
*
* **Details**
*
* This function returns `true` if the `Cause` has been interrupted but does not
* contain any other failures, such as `Fail` or `Die`. It's helpful for
* verifying purely "cancellation" scenarios.
*
* @since 2.0.0
* @category Getters
*/
const isInterruptedOnly = isInterruptedOnly$1;
/**
* Extracts all recoverable errors of type `E` from a `Cause`.
*
* **Details**
*
* This function returns a chunk of errors, providing a list of all `Fail`
* values found in the cause. It's useful for collecting all known failures for
* logging or combined error handling.
*
* @since 2.0.0
* @category Getters
*/
const failures = failures$1;
/**
* Extracts all unrecoverable defects from a `Cause`.
*
* **Details**
*
* This function returns a chunk of values representing unexpected errors
* (`Die`). It's handy for capturing or logging unanticipated failures that
* might need special handling, such as bug reports.
*
* @since 2.0.0
* @category Getters
*/
const defects = defects$1;
/**
* Collects all `FiberId`s responsible for interrupting a fiber.
*
* **Details**
*
* This function returns a set of IDs indicating which fibers caused
* interruptions within this `Cause`. It's useful for debugging concurrency
* issues or tracing cancellations.
*
* @since 2.0.0
* @category Getters
*/
const interruptors = interruptors$1;
/**
* Retrieves the first `Fail` error in a `Cause`, if present.
*
* **Details**
*
* This function returns an `Option` containing the first recoverable error
* (`E`) from the cause. It's often used to quickly check if there's a primary
* error to handle or display.
*
* @since 2.0.0
* @category Getters
*/
const failureOption = failureOption$1;
/**
* Splits a `Cause` into either its first `Fail` error or the rest of the cause
* (which might only contain `Die` or `Interrupt`).
*
* **Details**
*
* This function either returns the checked error (`E`) or the remaining
* `Cause<never>` with defects/interruptions. It helps you decide if there's a
* recoverable path or if only unhandled issues remain.
*
* @since 2.0.0
* @category Getters
*/
const failureOrCause = failureOrCause$1;
/**
* Strips out failures with an error of `None` from a `Cause<Option<E>>`.
*
* **Details**
*
* This function turns a `Cause<Option<E>>` into an `Option<Cause<E>>`. If the
* cause only contains failures of `None`, it becomes `None`; otherwise, it
* returns a `Cause` of the remaining errors. It's helpful when working with
* optional errors and filtering out certain error paths.
*
* @since 2.0.0
* @category Getters
*/
const flipCauseOption = flipCauseOption$1;
/**
* Retrieves the first `Die` defect in a `Cause`, if present.
*
* **Details**
*
* This function returns an `Option` containing the first unexpected failure
* (`Die`) discovered. It's helpful for diagnosing the primary defect in a chain
* of errors.
*
* @since 2.0.0
* @category Getters
*/
const dieOption = dieOption$1;
/**
* Retrieves the first `Interrupt` in a `Cause`, if present.
*
* **Details**
*
* This function returns an `Option` with the first fiber interruption
* discovered. This is particularly useful for concurrency analysis or debugging
* cancellations.
*
* @since 2.0.0
* @category Getters
*/
const interruptOption = interruptOption$1;
/**
* Removes all `Fail` and `Interrupt` nodes, keeping only defects (`Die`) in a
* `Cause`.
*
* **Details**
*
* This function strips a cause of recoverable errors and interruptions, leaving
* only unexpected failures. If no defects remain, it returns `None`. It's
* valuable for focusing only on unanticipated problems when both known errors
* and defects could occur.
*
* @since 2.0.0
* @category Getters
*/
const keepDefects = keepDefects$1;
/**
* Linearizes a `Cause` into a set of parallel causes, each containing a
* sequential chain of failures.
*
* **Details**
*
* This function reorganizes the cause structure so that you can analyze each
* parallel branch separately, even if they have multiple sequential errors.
*
* @since 2.0.0
* @category Getters
*/
const linearize = linearize$1;
/**
* Removes `Fail` and `Interrupt` nodes from a `Cause`, keeping only defects
* (`Die`).
*
* **Details**
*
* This function is similar to `keepDefects` but returns a `Cause<never>`
* directly, which can still store `Die` or finalizer-related defects. It's
* helpful for analyzing only the irrecoverable portion of the error.
*
* @since 2.0.0
* @category Getters
*/
const stripFailures = stripFailures$1;
/**
* Removes matching defects from a `Cause` using a partial function, returning
* the remainder.
*
* **Details**
*
* This function applies a user-defined extraction function to each defect
* (`Die`). If the function matches the defect, that defect is removed. If all
* defects match, the result is `None`. Otherwise, you get a `Cause` with the
* unmatched defects.
*
* @since 2.0.0
* @category Getters
*/
const stripSomeDefects = stripSomeDefects$1;
/**
* Replaces any errors in a `Cause` with a provided constant error.
*
* **Details**
*
* This function transforms all `Fail` errors into the specified error value,
* preserving the structure of the `Cause`. It's useful when you no longer need
* the original error details but still want to keep the cause shape.
*
* @see {@link map} Apply a custom transformation to `Fail` errors
*
* @since 2.0.0
* @category Mapping
*/
const as$1 = as$5;
/**
* Transforms the errors in a `Cause` using a user-provided function.
*
* **Details**
*
* This function applies `f` to each `Fail` error while leaving defects (`Die`)
* and interruptions untouched. It's useful for changing or simplifying error
* types in your effectful workflows.
*
* @see {@link as} Replace errors with a single constant
*
* @since 2.0.0
* @category Mapping
*/
const map$4 = map$10;
/**
* Transforms errors in a `Cause` into new causes.
*
* **Details**
*
* This function applies a function `f` to each `Fail` error, converting it into
* a new `Cause`. This is especially powerful for merging or restructuring error
* types while preserving or combining cause information.
*
* @see {@link map} Apply a simpler transformation to errors
*
* @since 2.0.0
* @category Sequencing
*/
const flatMap$2 = flatMap$6;
/**
* Sequences two `Cause`s. The second `Cause` can be dependent on the result of
* the first `Cause`.
*
* @since 2.0.0
* @category Sequencing
*/
const andThen$1 = andThen$3;
/**
* Flattens a nested `Cause` structure.
*
* **Details**
*
* This function takes a `Cause<Cause<E>>` and merges the layers into a single
* `Cause<E>`. It's useful for eliminating additional nesting created by
* repeated transformations or compositions.
*
* @see {@link flatMap} Compose nested causes
*
* @since 2.0.0
* @category Sequencing
*/
const flatten$1 = flatten$4;
/**
* Checks if the current `Cause` contains or is equal to another `Cause`.
*
* **Details**
*
* This function returns `true` if `that` cause is part of or the same as
* the current `Cause`. It's useful when you need to check for specific
* error patterns or deduplicate repeated failures.
*
* @since 2.0.0
* @category Elements
*/
const contains = contains$1;
/**
* Extracts the most "important" defect from a `Cause`.
*
* **Details**
*
* This function reduces a `Cause` to a single, prioritized defect. It evaluates
* the `Cause` in the following order of priority:
*
* 1. If the `Cause` contains a failure (e.g., from `Effect.fail`), it returns
*    the raw error value.
* 2. If there is no failure, it looks for the first defect (e.g., from
*    `Effect.die`).
* 3. If neither of the above is present, and the `Cause` stems from an
*    interruption, it creates and returns an `InterruptedException`.
*
* This function ensures you can always extract a meaningful representation of
* the primary issue from a potentially complex `Cause` structure.
*
* **When to Use**
*
* Use this function when you need to extract the most relevant error or defect
* from a `Cause`, especially in scenarios where multiple errors or defects may
* be present. It's particularly useful for simplifying error reporting or
* logging.
*
* @see {@link squashWith} Allows transforming failures into defects when squashing.
*
* @since 2.0.0
* @category Destructors
*/
const squash = causeSquash;
/**
* Extracts the most "important" defect from a `Cause`, transforming failures
* into defects using a provided function.
*
* **Details**
*
* This function reduces a `Cause` to a single, prioritized defect, while
* allowing you to transform recoverable failures into defects through a custom
* function. It processes the `Cause` in the following order:
*
* 1. If the `Cause` contains a failure (e.g., from `Effect.fail`), it applies
*    the provided function `f` to the error to transform it into a defect.
* 2. If there is no failure, it looks for the first defect (e.g., from
*    `Effect.die`) and returns it.
* 3. If neither is present and the `Cause` stems from an interruption, it
*    returns an `InterruptedException`.
*
* This function is particularly useful when you need custom handling or
* transformation of errors while processing a `Cause`.
*
* @see {@link squash} Extracts the most "important" defect without transforming failures.
*
* @since 2.0.0
* @category Destructors
*/
const squashWith = causeSquashWith;
/**
* Searches a `Cause` using a partial function to extract information.
*
* **Details**
*
* This function allows you to search through a `Cause` using a custom partial
* function. The partial function is applied to the `Cause`, and if it matches,
* the result is returned wrapped in a `Some`. If no match is found, the result
* is `None`.
*
* This is particularly useful when you are only interested in specific types of
* errors, defects, or interruption causes within a potentially complex `Cause`
* structure. By leveraging a partial function, you can focus on extracting only
* the relevant information you care about.
*
* The partial function should return an `Option` indicating whether it matched
* and the value it extracted.
*
* @since 2.0.0
* @category Elements
*/
const find = find$1;
/**
* Preserves parts of a `Cause` that match a given predicate.
*
* **Details**
*
* This function allows you to retain only the parts of a `Cause` structure that
* match a specified predicate or refinement. Any parts of the `Cause` that do
* not match the provided condition are excluded from the result.
*
* You can use this function in two ways:
* - With a `Predicate`: A function that evaluates whether a `Cause` should be
*   retained based on its value.
* - With a `Refinement`: A more specific predicate that can refine the type of
*   the `Cause`.
*
* This is useful when you need to extract specific types of errors, defects, or
* interruptions from a `Cause` while discarding unrelated parts.
*
* @since 2.0.0
* @category Filtering
*/
const filter$1 = filter$3;
/**
* Transforms a `Cause` into a single value using custom handlers for each
* possible case.
*
* **Details**
*
* This function processes a `Cause` by applying a set of custom handlers to
* each possible type of cause: `Empty`, `Fail`, `Die`, `Interrupt`,
* `Sequential`, and `Parallel`. The result of this function is a single value
* of type `Z`. This function allows you to define exactly how to handle each
* part of a `Cause`, whether it's a failure, defect, interruption, or a
* combination of these.
*
* The options parameter provides handlers for:
* - `onEmpty`: Handles the case where the cause is `Empty`, meaning no errors
*   occurred.
* - `onFail`: Processes a failure with an error of type `E`.
* - `onDie`: Processes a defect (unexpected error).
* - `onInterrupt`: Handles a fiber interruption, providing the `FiberId` of the
*   interruption.
* - `onSequential`: Combines two sequential causes into a single value of type
*   `Z`.
* - `onParallel`: Combines two parallel causes into a single value of type `Z`.
*
* @since 2.0.0
* @category Matching
*/
const match$2 = match$9;
/**
* Combines all parts of a `Cause` into a single value by starting with an
* initial value.
*
* **Details**
*
* This function processes a `Cause` by starting with an initial value (`zero`)
* and applying a custom function (`pf`) to combine all elements of the `Cause`
* into a single result of type `Z`. The custom function determines how each
* part of the `Cause` contributes to the final result. The function can return
* an `Option` to either continue combining values or skip specific parts of the
* `Cause`.
*
* This function is useful for tasks such as:
* - Aggregating error messages from a `Cause` into a single string.
* - Summarizing the structure of a `Cause` into a simplified result.
* - Filtering or processing only specific parts of a `Cause`.
*
* The reduction proceeds in a top-down manner, visiting all nodes in the
* `Cause` structure. This gives you complete control over how each part of the
* `Cause` contributes to the final result.
*
* @since 2.0.0
* @category Reducing
*/
const reduce$1 = reduce$5;
/**
* Combines all parts of a `Cause` into a single value using a custom reducer
* and a context.
*
* **Details**
*
* This function allows you to reduce a `Cause` into a single value of type `Z`
* using a custom `CauseReducer`. A `CauseReducer` provides methods to handle
* specific parts of the `Cause`, such as failures, defects, or interruptions.
* Additionally, this function provides access to a `context` value, which can
* be used to carry information or maintain state during the reduction process.
*
* This is particularly useful when the reduction process needs additional
* context or configuration, such as:
* - Aggregating error details with dynamic formatting.
* - Collecting logs or statistics about the `Cause`.
* - Performing stateful transformations based on the `context`.
*
* @see {@link reduce} To reduce a `Cause` without additional context.
*
* @since 2.0.0
* @category Reducing
*/
const reduceWithContext = reduceWithContext$1;
/**
* Creates an error that indicates a `Fiber` was interrupted.
*
* **Details**
*
* This function constructs an `InterruptedException` recognized by the Effect
* runtime. It is usually thrown or returned when a fiber's execution is
* interrupted by external events or by another fiber. This is particularly
* helpful in concurrent programs where fibers may halt each other before
* completion.
*
* @since 2.0.0
* @category Errors
*/
const InterruptedException = InterruptedException$1;
/**
* Checks if a given unknown value is an `InterruptedException`.
*
* @since 2.0.0
* @category Guards
*/
const isInterruptedException = isInterruptedException$1;
/**
* Creates an error indicating an invalid method argument.
*
* **Details**
*
* This function constructs an `IllegalArgumentException`. It is typically
* thrown or returned when an operation receives improper inputs, such as
* out-of-range values or invalid object states.
*
* @since 2.0.0
* @category Errors
*/
const IllegalArgumentException = IllegalArgumentException$1;
/**
* Checks if a given unknown value is an `IllegalArgumentException`.
*
* @since 2.0.0
* @category Guards
*/
const isIllegalArgumentException = isIllegalArgumentException$1;
/**
* Creates an error indicating a missing element.
*
* **Details**
*
* This function constructs a `NoSuchElementException`. It helps you clearly
* communicate that a required element is unavailable.
*
* @since 2.0.0
* @category Errors
*/
const NoSuchElementException = NoSuchElementException$1;
/**
* Checks if a given unknown value is a `NoSuchElementException`.
*
* @since 2.0.0
* @category Guards
*/
const isNoSuchElementException = isNoSuchElementException$1;
/**
* Creates an error for general runtime errors.
*
* **Details**
*
* This function constructs a `RuntimeException`, for errors that occur at
* runtime but are not specifically typed or categorized as interruptions,
* missing elements, or invalid arguments. It helps unify a wide range of
* unexpected conditions under a single, recognizable error type.
*
* @since 2.0.0
* @category Errors
*/
const RuntimeException = RuntimeException$1;
/**
* Checks if a given unknown value is a `RuntimeException`.
*
* @since 2.0.0
* @category Guards
*/
const isRuntimeException = isRuntimeException$1;
/**
* Creates an error for operations that exceed their expected time.
*
* **Details**
*
* This function constructs a `TimeoutException`. It is typically used to signal
* that an operation or fiber did not complete within a designated time limit,
* allowing you to handle slow or hanging processes.
*
* @since 2.0.0
* @category Errors
*/
const TimeoutException = TimeoutException$1;
/**
* Checks if a given unknown value is a `TimeoutException`.
*
* @since 3.15.0
* @category Guards
*/
const isTimeoutException = isTimeoutException$1;
/**
* Creates an instance of `UnknownException`, an error object used to handle
* unknown errors such as those from rejected promises.
*
* **Details**
*
* This function constructs an `UnknownException` with flexible behavior for
* managing the error message and cause.
*
* The required `error` argument is passed as the `cause` to the global `Error`
* constructor, ensuring that the original cause is preserved in the error chain
* for debugging purposes. This ensures that the origin stack trace is
* preserved.
*
* The `error` argument is always stored in the `error` property of the
* `UnknownException` instance for reference, regardless of its type.
*
* Additionally, if you provide a `message` argument, it is used as the error
* message. If no `message` is provided, the error message defaults to `"An
* unknown error occurred"`.
*
* **When to Use**
*
* Use this function when you need to handle unexpected or unknown errors in
* your application, particularly when the source of the error might not provide
* a clear message. This is useful for wrapping generic errors thrown from
* promises or external APIs.
*
* @since 2.0.0
* @category Errors
*/
const UnknownException = UnknownException$1;
/**
* Checks if a given unknown value is an `UnknownException`.
*
* @since 2.0.0
* @category Guards
*/
const isUnknownException = isUnknownException$1;
/**
* Creates an error indicating resource capacity has been exceeded.
*
* **Details**
*
* This function constructs an `ExceededCapacityException`, signifying that an
* operation or resource usage surpassed established limits. This can be
* essential for concurrency or resource management situations, ensuring your
* application doesn't go beyond acceptable thresholds.
*
* @since 3.5.0
* @category Errors
*/
const ExceededCapacityException = ExceededCapacityException$1;
/**
* Checks if a given unknown value is an `ExceededCapacityException`.
*
* @since 3.5.0
* @category Guards
*/
const isExceededCapacityException = isExceededCapacityException$1;
/**
* Converts a `Cause` into a human-readable string.
*
* **Details**
*
* This function pretty-prints the entire `Cause`, including any failures,
* defects, and interruptions. It can be especially helpful for logging,
* debugging, or displaying structured errors to users.
*
* You can optionally pass `options` to configure how the error cause is
* rendered. By default, it includes essential details of all errors in the
* `Cause`.
*
* @see {@link prettyErrors} Get a list of `PrettyError` objects instead of a single string.
*
* @since 2.0.0
* @category Formatting
*/
const pretty$1 = pretty$3;
/**
* Returns a list of prettified errors (`PrettyError`) from a `Cause`.
*
* **Details**
*
* This function inspects the entire `Cause` and produces an array of
* `PrettyError` objects. Each object may include additional metadata, such as a
* `Span`, to provide deeper insights into where and how the error occurred.
*
* @since 3.2.0
* @category Formatting
*/
const prettyErrors = prettyErrors$1;
/**
* Retrieves the original, unproxied error instance from an error object.
*
* **Details**
*
* This function returns the underlying error object without any
* library-specific wrapping or proxying that might occur during error handling.
* This can be essential if you need direct access to the error's native
* properties, such as stack traces or custom data fields, for detailed
* debugging or integration with external systems.
*
* @since 2.0.0
* @category Errors
*/
const originalError = originalInstance;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/schedule/interval.js
/** @internal */
const IntervalSymbolKey = "effect/ScheduleInterval";
/** @internal */
const IntervalTypeId$1 = /* @__PURE__ */ Symbol.for(IntervalSymbolKey);
/** @internal */
const empty$3 = {
	[IntervalTypeId$1]: IntervalTypeId$1,
	startMillis: 0,
	endMillis: 0
};
/** @internal */
const make$10 = (startMillis, endMillis) => {
	if (startMillis > endMillis) return empty$3;
	return {
		[IntervalTypeId$1]: IntervalTypeId$1,
		startMillis,
		endMillis
	};
};
/** @internal */
const lessThan$3 = /* @__PURE__ */ dual$1(2, (self, that) => min$1(self, that) === self);
/** @internal */
const min$1 = /* @__PURE__ */ dual$1(2, (self, that) => {
	if (self.endMillis <= that.startMillis) return self;
	if (that.endMillis <= self.startMillis) return that;
	if (self.startMillis < that.startMillis) return self;
	if (that.startMillis < self.startMillis) return that;
	if (self.endMillis <= that.endMillis) return self;
	return that;
});
/** @internal */
const max$3 = /* @__PURE__ */ dual$1(2, (self, that) => min$1(self, that) === self ? that : self);
/** @internal */
const isEmpty$1 = (self) => {
	return self.startMillis >= self.endMillis;
};
/** @internal */
const isNonEmpty$3 = (self) => {
	return !isEmpty$1(self);
};
/** @internal */
const intersect$4 = /* @__PURE__ */ dual$1(2, (self, that) => {
	return make$10(Math.max(self.startMillis, that.startMillis), Math.min(self.endMillis, that.endMillis));
});
/** @internal */
const size$1 = (self) => {
	return millis(self.endMillis - self.startMillis);
};
/** @internal */
const union$3 = /* @__PURE__ */ dual$1(2, (self, that) => {
	const start$2 = Math.max(self.startMillis, that.startMillis);
	const end$2 = Math.min(self.endMillis, that.endMillis);
	return start$2 < end$2 ? none$7() : some$4(make$10(start$2, end$2));
});
/** @internal */
const after$1 = (startMilliseconds) => {
	return make$10(startMilliseconds, Number.POSITIVE_INFINITY);
};
/** @internal */
const before$1 = (endMilliseconds) => {
	return make$10(Number.NEGATIVE_INFINITY, endMilliseconds);
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/ScheduleInterval.js
/**
* @since 2.0.0
* @category symbols
*/
const IntervalTypeId = IntervalTypeId$1;
/**
* Constructs a new interval from the two specified endpoints. If the start
* endpoint greater than the end endpoint, then a zero size interval will be
* returned.
*
* @since 2.0.0
* @category constructors
*/
const make$9 = make$10;
/**
* An `Interval` of zero-width.
*
* @since 2.0.0
* @category constructors
*/
const empty$2 = empty$3;
/**
* Returns `true` if this `Interval` is less than `that` interval, `false`
* otherwise.
*
* @since 2.0.0
* @category ordering
*/
const lessThan$2 = lessThan$3;
/**
* Returns the minimum of two `Interval`s.
*
* @since 2.0.0
* @category ordering
*/
const min = min$1;
/**
* Returns the maximum of two `Interval`s.
*
* @since 2.0.0
* @category ordering
*/
const max$2 = max$3;
/**
* Returns `true` if the specified `Interval` is empty, `false` otherwise.
*
* @since 2.0.0
* @category ordering
*/
const isEmpty = isEmpty$1;
/**
* Returns `true` if the specified `Interval` is non-empty, `false` otherwise.
*
* @since 2.0.0
* @category ordering
*/
const isNonEmpty$2 = isNonEmpty$3;
/**
* Computes a new `Interval` which is the intersection of this `Interval` and
* that `Interval`.
*
* @since 2.0.0
* @category ordering
*/
const intersect$3 = intersect$4;
/**
* Calculates the size of the `Interval` as the `Duration` from the start of the
* interval to the end of the interval.
*
* @since 2.0.0
* @category getters
*/
const size = size$1;
/**
* Computes a new `Interval` which is the union of this `Interval` and that
* `Interval` as a `Some`, otherwise returns `None` if the two intervals cannot
* form a union.
*
* @since 2.0.0
* @category utils
*/
const union$2 = union$3;
/**
* Construct an `Interval` that includes all time equal to and after the
* specified start time.
*
* @since 2.0.0
* @category constructors
*/
const after = after$1;
/**
* Construct an `Interval` that includes all time equal to and before the
* specified end time.
*
* @category constructors
* @since 2.0.0
*/
const before = before$1;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/schedule/intervals.js
/** @internal */
const IntervalsSymbolKey = "effect/ScheduleIntervals";
/** @internal */
const IntervalsTypeId$1 = /* @__PURE__ */ Symbol.for(IntervalsSymbolKey);
/** @internal */
const make$8 = (intervals) => {
	return {
		[IntervalsTypeId$1]: IntervalsTypeId$1,
		intervals
	};
};
/** @internal */
const empty$1 = /* @__PURE__ */ make$8(/* @__PURE__ */ empty$30());
/** @internal */
const fromIterable$1 = (intervals) => Array.from(intervals).reduce((intervals$1, interval) => pipe$3(intervals$1, union$1(make$8(of$3(interval)))), empty$1);
/** @internal */
const union$1 = /* @__PURE__ */ dual$1(2, (self, that) => {
	if (!isNonEmpty$4(that.intervals)) return self;
	if (!isNonEmpty$4(self.intervals)) return that;
	if (headNonEmpty(self.intervals).startMillis < headNonEmpty(that.intervals).startMillis) return unionLoop(tailNonEmpty(self.intervals), that.intervals, headNonEmpty(self.intervals), empty$30());
	return unionLoop(self.intervals, tailNonEmpty(that.intervals), headNonEmpty(that.intervals), empty$30());
});
/** @internal */
const unionLoop = (_self, _that, _interval, _acc) => {
	let self = _self;
	let that = _that;
	let interval = _interval;
	let acc = _acc;
	while (isNonEmpty$4(self) || isNonEmpty$4(that)) if (!isNonEmpty$4(self) && isNonEmpty$4(that)) if (interval.endMillis < headNonEmpty(that).startMillis) {
		acc = pipe$3(acc, prepend$1(interval));
		interval = headNonEmpty(that);
		that = tailNonEmpty(that);
		self = empty$30();
	} else {
		interval = make$9(interval.startMillis, headNonEmpty(that).endMillis);
		that = tailNonEmpty(that);
		self = empty$30();
	}
	else if (isNonEmpty$4(self) && isEmpty$9(that)) if (interval.endMillis < headNonEmpty(self).startMillis) {
		acc = pipe$3(acc, prepend$1(interval));
		interval = headNonEmpty(self);
		that = empty$30();
		self = tailNonEmpty(self);
	} else {
		interval = make$9(interval.startMillis, headNonEmpty(self).endMillis);
		that = empty$30();
		self = tailNonEmpty(self);
	}
	else if (isNonEmpty$4(self) && isNonEmpty$4(that)) if (headNonEmpty(self).startMillis < headNonEmpty(that).startMillis) if (interval.endMillis < headNonEmpty(self).startMillis) {
		acc = pipe$3(acc, prepend$1(interval));
		interval = headNonEmpty(self);
		self = tailNonEmpty(self);
	} else {
		interval = make$9(interval.startMillis, headNonEmpty(self).endMillis);
		self = tailNonEmpty(self);
	}
	else if (interval.endMillis < headNonEmpty(that).startMillis) {
		acc = pipe$3(acc, prepend$1(interval));
		interval = headNonEmpty(that);
		that = tailNonEmpty(that);
	} else {
		interval = make$9(interval.startMillis, headNonEmpty(that).endMillis);
		that = tailNonEmpty(that);
	}
	else throw new Error(getBugErrorMessage("Intervals.unionLoop"));
	return make$8(pipe$3(acc, prepend$1(interval), reverse$1));
};
/** @internal */
const intersect$2 = /* @__PURE__ */ dual$1(2, (self, that) => intersectLoop(self.intervals, that.intervals, empty$30()));
/** @internal */
const intersectLoop = (_left, _right, _acc) => {
	let left$2 = _left;
	let right$2 = _right;
	let acc = _acc;
	while (isNonEmpty$4(left$2) && isNonEmpty$4(right$2)) {
		const interval = pipe$3(headNonEmpty(left$2), intersect$3(headNonEmpty(right$2)));
		const intervals = isEmpty(interval) ? acc : pipe$3(acc, prepend$1(interval));
		if (pipe$3(headNonEmpty(left$2), lessThan$2(headNonEmpty(right$2)))) left$2 = tailNonEmpty(left$2);
		else right$2 = tailNonEmpty(right$2);
		acc = intervals;
	}
	return make$8(reverse$1(acc));
};
/** @internal */
const start$1 = (self) => {
	return pipe$3(self.intervals, head$2, getOrElse$5(() => empty$2)).startMillis;
};
/** @internal */
const end$1 = (self) => {
	return pipe$3(self.intervals, head$2, getOrElse$5(() => empty$2)).endMillis;
};
/** @internal */
const lessThan$1 = /* @__PURE__ */ dual$1(2, (self, that) => start$1(self) < start$1(that));
/** @internal */
const isNonEmpty$1 = (self) => {
	return isNonEmpty$4(self.intervals);
};
/** @internal */
const max$1 = /* @__PURE__ */ dual$1(2, (self, that) => lessThan$1(self, that) ? that : self);

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/ScheduleIntervals.js
/**
* @since 2.0.0
* @category symbols
*/
const IntervalsTypeId = IntervalsTypeId$1;
/**
* Creates a new `Intervals` from a `List` of `Interval`s.
*
* @since 2.0.0
* @category constructors
*/
const make$7 = make$8;
/**
* Constructs an empty list of `Interval`s.
*
* @since 2.0.0
* @category constructors
*/
const empty = empty$1;
/**
* Creates `Intervals` from the specified `Iterable<Interval>`.
*
* @since 2.0.0
* @category constructors
*/
const fromIterable = fromIterable$1;
/**
* Computes the union of this `Intervals` and  that `Intervals`
*
* @since 2.0.0
* @category utils
*/
const union = union$1;
/**
* Produces the intersection of this `Intervals` and that `Intervals`.
*
* @since 2.0.0
* @category utils
*/
const intersect$1 = intersect$2;
/**
* The start of the earliest interval in the specified `Intervals`.
*
* @since 2.0.0
* @category getters
*/
const start = start$1;
/**
* The end of the latest interval in the specified `Intervals`.
*
* @since 2.0.0
* @category getters
*/
const end = end$1;
/**
* Returns `true` if the start of this `Intervals` is before the start of that
* `Intervals`, `false` otherwise.
*
* @since 2.0.0
* @category ordering
*/
const lessThan = lessThan$1;
/**
* Returns `true` if this `Intervals` is non-empty, `false` otherwise.
*
* @since 2.0.0
* @category getters
*/
const isNonEmpty = isNonEmpty$1;
/**
* Returns the maximum of the two `Intervals` (i.e. which has the latest start).
*
* @since 2.0.0
* @category ordering
*/
const max = max$1;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/schedule/decision.js
/** @internal */
const OP_CONTINUE = "Continue";
/** @internal */
const OP_DONE = "Done";
/** @internal */
const _continue$1 = (intervals) => {
	return {
		_tag: OP_CONTINUE,
		intervals
	};
};
/** @internal */
const continueWith$1 = (interval) => {
	return {
		_tag: OP_CONTINUE,
		intervals: make$7(of$3(interval))
	};
};
/** @internal */
const done$2 = { _tag: OP_DONE };
/** @internal */
const isContinue$1 = (self) => {
	return self._tag === OP_CONTINUE;
};
/** @internal */
const isDone$1 = (self) => {
	return self._tag === OP_DONE;
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/ScheduleDecision.js
const _continue = _continue$1;
/**
* @since 2.0.0
* @category constructors
*/
const continueWith = continueWith$1;
/**
* @since 2.0.0
* @category constructors
*/
const done$1 = done$2;
/**
* @since 2.0.0
* @category refinements
*/
const isContinue = isContinue$1;
/**
* @since 2.0.0
* @category refinements
*/
const isDone = isDone$1;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Scope.js
/**
* A unique identifier for the `Scope` type.
*
* @since 2.0.0
* @category symbols
*/
const ScopeTypeId = ScopeTypeId$1;
/**
* A unique identifier for the `CloseableScope` type.
*
* @since 2.0.0
* @category symbols
*/
const CloseableScopeTypeId = CloseableScopeTypeId$1;
/**
* A tag representing the current `Scope` in the environment.
*
* @since 2.0.0
* @category context
*/
const Scope = scopeTag;
/**
* Adds a finalizer to this scope. The finalizer is guaranteed to be run when
* the scope is closed. Use this when the finalizer does not need to know the
* `Exit` value that the scope is closed with.
*
* @see {@link addFinalizerExit}
*
* @since 2.0.0
* @category utils
*/
const addFinalizer$1 = scopeAddFinalizer;
/**
* Adds a finalizer to this scope. The finalizer receives the `Exit` value
* when the scope is closed, allowing it to perform different actions based
* on the exit status.
*
* @see {@link addFinalizer}
*
* @since 2.0.0
* @category utils
*/
const addFinalizerExit = scopeAddFinalizerExit;
/**
* Closes this scope with the specified exit value, running all finalizers that
* have been added to the scope.
*
* @since 2.0.0
* @category destructors
*/
const close = scopeClose;
/**
* Extends the scope of an `Effect` that requires a scope into this scope.
* It provides this scope to the effect but does not close the scope when the
* effect completes execution. This allows extending a scoped value into a
* larger scope.
*
* @since 2.0.0
* @category utils
*/
const extend = scopeExtend;
/**
* Forks a new child scope with the specified execution strategy. The child scope
* will automatically be closed when this scope is closed.
*
* @since 2.0.0
* @category utils
*/
const fork$1 = scopeFork;
/**
* Provides this closeable scope to an `Effect` that requires a scope,
* guaranteeing that the scope is closed with the result of that effect as
* soon as the effect completes execution, whether by success, failure, or
* interruption.
*
* @since 2.0.0
* @category destructors
*/
const use = scopeUse;
/**
* Creates a new closeable scope where finalizers will run according to the
* specified `ExecutionStrategy`. If no execution strategy is provided, `sequential`
* will be used by default.
*
* @since 2.0.0
* @category constructors
*/
const make$6 = scopeMake;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/effect/circular.js
/** @internal */
var Semaphore = class {
	permits;
	waiters = /* @__PURE__ */ new Set();
	taken = 0;
	constructor(permits) {
		this.permits = permits;
	}
	get free() {
		return this.permits - this.taken;
	}
	take = (n$1) => asyncInterrupt((resume$1) => {
		if (this.free < n$1) {
			const observer = () => {
				if (this.free < n$1) return;
				this.waiters.delete(observer);
				this.taken += n$1;
				resume$1(succeed$9(n$1));
			};
			this.waiters.add(observer);
			return sync$3(() => {
				this.waiters.delete(observer);
			});
		}
		this.taken += n$1;
		return resume$1(succeed$9(n$1));
	});
	updateTakenUnsafe(fiber, f$1) {
		this.taken = f$1(this.taken);
		if (this.waiters.size > 0) fiber.getFiberRef(currentScheduler).scheduleTask(() => {
			const iter = this.waiters.values();
			let item = iter.next();
			while (item.done === false && this.free > 0) {
				item.value();
				item = iter.next();
			}
		}, fiber.getFiberRef(currentSchedulingPriority));
		return succeed$9(this.free);
	}
	updateTaken(f$1) {
		return withFiberRuntime$1((fiber) => this.updateTakenUnsafe(fiber, f$1));
	}
	resize = (permits) => asVoid$3(withFiberRuntime$1((fiber) => {
		this.permits = permits;
		if (this.free < 0) return void_$4;
		return this.updateTakenUnsafe(fiber, (taken) => taken);
	}));
	release = (n$1) => this.updateTaken((taken) => taken - n$1);
	releaseAll = /* @__PURE__ */ this.updateTaken((_$1) => 0);
	withPermits = (n$1) => (self) => uninterruptibleMask$2((restore) => flatMap$5(restore(this.take(n$1)), (permits) => ensuring$1(restore(self), this.release(permits))));
	withPermitsIfAvailable = (n$1) => (self) => uninterruptibleMask$2((restore) => suspend$3(() => {
		if (this.free < n$1) return succeedNone$1;
		this.taken += n$1;
		return ensuring$1(restore(asSome$1(self)), this.release(n$1));
	}));
};
/** @internal */
const unsafeMakeSemaphore$1 = (permits) => new Semaphore(permits);
/** @internal */
const makeSemaphore$1 = (permits) => sync$3(() => unsafeMakeSemaphore$1(permits));
var Latch = class extends Class$3 {
	isOpen;
	waiters = [];
	scheduled = false;
	constructor(isOpen) {
		super();
		this.isOpen = isOpen;
	}
	commit() {
		return this.await;
	}
	unsafeSchedule(fiber) {
		if (this.scheduled || this.waiters.length === 0) return void_$4;
		this.scheduled = true;
		fiber.currentScheduler.scheduleTask(this.flushWaiters, fiber.getFiberRef(currentSchedulingPriority));
		return void_$4;
	}
	flushWaiters = () => {
		this.scheduled = false;
		const waiters = this.waiters;
		this.waiters = [];
		for (let i$1 = 0; i$1 < waiters.length; i$1++) waiters[i$1](exitVoid$1);
	};
	open = /* @__PURE__ */ withFiberRuntime$1((fiber) => {
		if (this.isOpen) return void_$4;
		this.isOpen = true;
		return this.unsafeSchedule(fiber);
	});
	unsafeOpen() {
		if (this.isOpen) return;
		this.isOpen = true;
		this.flushWaiters();
	}
	release = /* @__PURE__ */ withFiberRuntime$1((fiber) => {
		if (this.isOpen) return void_$4;
		return this.unsafeSchedule(fiber);
	});
	await = /* @__PURE__ */ asyncInterrupt((resume$1) => {
		if (this.isOpen) return resume$1(void_$4);
		this.waiters.push(resume$1);
		return sync$3(() => {
			const index = this.waiters.indexOf(resume$1);
			if (index !== -1) this.waiters.splice(index, 1);
		});
	});
	unsafeClose() {
		this.isOpen = false;
	}
	close = /* @__PURE__ */ sync$3(() => {
		this.isOpen = false;
	});
	whenOpen = (self) => {
		return zipRight$3(this.await, self);
	};
};
/** @internal */
const unsafeMakeLatch$1 = (open$1) => new Latch(open$1 ?? false);
/** @internal */
const makeLatch$1 = (open$1) => sync$3(() => unsafeMakeLatch$1(open$1));
/** @internal */
const awaitAllChildren$1 = (self) => ensuringChildren$1(self, fiberAwaitAll);
/** @internal */
const cached$1 = /* @__PURE__ */ dual$1(2, (self, timeToLive) => map$9(cachedInvalidateWithTTL$1(self, timeToLive), (tuple$2) => tuple$2[0]));
/** @internal */
const cachedInvalidateWithTTL$1 = /* @__PURE__ */ dual$1(2, (self, timeToLive) => {
	const duration = decode$3(timeToLive);
	return flatMap$5(context$1(), (env$2) => map$9(makeSynchronized(none$7()), (cache) => [provideContext$1(getCachedValue(self, duration, cache), env$2), invalidateCache(cache)]));
});
/** @internal */
const computeCachedValue = (self, timeToLive, start$2) => {
	const timeToLiveMillis = toMillis(decode$3(timeToLive));
	return pipe$3(deferredMake(), tap$1((deferred) => intoDeferred$1(self, deferred)), map$9((deferred) => some$4([start$2 + timeToLiveMillis, deferred])));
};
/** @internal */
const getCachedValue = (self, timeToLive, cache) => uninterruptibleMask$2((restore) => pipe$3(clockWith$1((clock$2) => clock$2.currentTimeMillis), flatMap$5((time) => updateSomeAndGetEffectSynchronized(cache, (option$2) => {
	switch (option$2._tag) {
		case "None": return some$4(computeCachedValue(self, timeToLive, time));
		case "Some": {
			const [end$2] = option$2.value;
			return end$2 - time <= 0 ? some$4(computeCachedValue(self, timeToLive, time)) : none$7();
		}
	}
})), flatMap$5((option$2) => isNone$2(option$2) ? dieMessage$1("BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/effect/issues") : restore(deferredAwait(option$2.value[1])))));
/** @internal */
const invalidateCache = (cache) => set$1(cache, none$7());
/** @internal */
const ensuringChild$1 = /* @__PURE__ */ dual$1(2, (self, f$1) => ensuringChildren$1(self, (children$2) => f$1(fiberAll(children$2))));
/** @internal */
const ensuringChildren$1 = /* @__PURE__ */ dual$1(2, (self, children$2) => flatMap$5(track, (supervisor) => pipe$3(supervised$1(self, supervisor), ensuring$1(flatMap$5(supervisor.value, children$2)))));
/** @internal */
const forkAll$1 = /* @__PURE__ */ dual$1((args$2) => isIterable(args$2[0]), (effects, options) => options?.discard ? forEachSequentialDiscard(effects, fork$2) : map$9(forEachSequential(effects, fork$2), fiberAll));
/** @internal */
const forkIn$1 = /* @__PURE__ */ dual$1(2, (self, scope$2) => withFiberRuntime$1((parent, parentStatus) => {
	const scopeImpl = scope$2;
	const fiber = unsafeFork$1(self, parent, parentStatus.runtimeFlags, globalScope);
	if (scopeImpl.state._tag === "Open") {
		const finalizer = () => fiberIdWith$1((fiberId$2) => equals(fiberId$2, fiber.id()) ? void_$4 : asVoid$3(interruptFiber(fiber)));
		const key = {};
		scopeImpl.state.finalizers.set(key, finalizer);
		fiber.addObserver(() => {
			if (scopeImpl.state._tag === "Closed") return;
			scopeImpl.state.finalizers.delete(key);
		});
	} else fiber.unsafeInterruptAsFork(parent.id());
	return succeed$9(fiber);
}));
/** @internal */
const forkScoped$1 = (self) => scopeWith$1((scope$2) => forkIn$1(self, scope$2));
/** @internal */
const fromFiber$1 = (fiber) => join$1(fiber);
/** @internal */
const fromFiberEffect$1 = (fiber) => suspend$3(() => flatMap$5(fiber, join$1));
const memoKeySymbol = /* @__PURE__ */ Symbol.for("effect/Effect/memoizeFunction.key");
var Key = class {
	a;
	eq;
	[memoKeySymbol] = memoKeySymbol;
	constructor(a$1, eq) {
		this.a = a$1;
		this.eq = eq;
	}
	[symbol](that) {
		if (hasProperty(that, memoKeySymbol)) if (this.eq) return this.eq(this.a, that.a);
		else return equals(this.a, that.a);
		return false;
	}
	[symbol$1]() {
		return this.eq ? 0 : cached$2(this, hash(this.a));
	}
};
/** @internal */
const cachedFunction$1 = (f$1, eq) => {
	return pipe$3(sync$3(() => empty$14()), flatMap$5(makeSynchronized), map$9((ref) => (a$1) => pipe$3(ref.modifyEffect((map$18) => {
		const result = pipe$3(map$18, get$4(new Key(a$1, eq)));
		if (isNone$2(result)) return pipe$3(deferredMake(), tap$1((deferred) => pipe$3(diffFiberRefs$1(f$1(a$1)), intoDeferred$1(deferred), fork$2)), map$9((deferred) => [deferred, pipe$3(map$18, set$2(new Key(a$1, eq), deferred))]));
		return succeed$9([result.value, map$18]);
	}), flatMap$5(deferredAwait), flatMap$5(([patch$11, b$1]) => pipe$3(patchFiberRefs$1(patch$11), as$4(b$1))))));
};
/** @internal */
const raceFirst$1 = /* @__PURE__ */ dual$1(2, (self, that) => pipe$3(exit$2(self), race$1(exit$2(that)), (effect) => flatten$3(effect)));
/** @internal */
const supervised$1 = /* @__PURE__ */ dual$1(2, (self, supervisor) => {
	return fiberRefLocallyWith(currentSupervisor, (s$1) => s$1.zip(supervisor))(self);
});
/** @internal */
const timeout$1 = /* @__PURE__ */ dual$1(2, (self, duration) => timeoutFail$1(self, {
	onTimeout: () => timeoutExceptionFromDuration(duration),
	duration
}));
/** @internal */
const timeoutFail$1 = /* @__PURE__ */ dual$1(2, (self, { duration, onTimeout }) => flatten$3(timeoutTo$1(self, {
	onTimeout: () => failSync$2(onTimeout),
	onSuccess: succeed$9,
	duration
})));
/** @internal */
const timeoutFailCause$1 = /* @__PURE__ */ dual$1(2, (self, { duration, onTimeout }) => flatten$3(timeoutTo$1(self, {
	onTimeout: () => failCauseSync$2(onTimeout),
	onSuccess: succeed$9,
	duration
})));
/** @internal */
const timeoutOption$1 = /* @__PURE__ */ dual$1(2, (self, duration) => timeoutTo$1(self, {
	duration,
	onSuccess: some$4,
	onTimeout: none$7
}));
/** @internal */
const timeoutTo$1 = /* @__PURE__ */ dual$1(2, (self, { duration, onSuccess, onTimeout }) => fiberIdWith$1((parentFiberId) => uninterruptibleMask$2((restore) => raceFibersWith(restore(self), interruptible$2(sleep$1(duration)), {
	onSelfWin: (winner, loser) => flatMap$5(winner.await, (exit$3) => {
		if (exit$3._tag === "Success") return flatMap$5(winner.inheritAll, () => as$4(interruptAsFiber(loser, parentFiberId), onSuccess(exit$3.value)));
		else return flatMap$5(interruptAsFiber(loser, parentFiberId), () => exitFailCause$1(exit$3.cause));
	}),
	onOtherWin: (winner, loser) => flatMap$5(winner.await, (exit$3) => {
		if (exit$3._tag === "Success") return flatMap$5(winner.inheritAll, () => as$4(interruptAsFiber(loser, parentFiberId), onTimeout()));
		else return flatMap$5(interruptAsFiber(loser, parentFiberId), () => exitFailCause$1(exit$3.cause));
	}),
	otherScope: globalScope
}))));
/** @internal */
const SynchronizedSymbolKey = "effect/Ref/SynchronizedRef";
/** @internal */
const SynchronizedTypeId = /* @__PURE__ */ Symbol.for(SynchronizedSymbolKey);
/** @internal */
const synchronizedVariance = { _A: (_$1) => _$1 };
/** @internal */
var SynchronizedImpl = class extends Class$3 {
	ref;
	withLock;
	[SynchronizedTypeId] = synchronizedVariance;
	[RefTypeId$1] = refVariance;
	[TypeId$7] = TypeId$7;
	constructor(ref, withLock) {
		super();
		this.ref = ref;
		this.withLock = withLock;
		this.get = get$1(this.ref);
	}
	get;
	commit() {
		return this.get;
	}
	modify(f$1) {
		return this.modifyEffect((a$1) => succeed$9(f$1(a$1)));
	}
	modifyEffect(f$1) {
		return this.withLock(pipe$3(flatMap$5(get$1(this.ref), f$1), flatMap$5(([b$1, a$1]) => as$4(set$1(this.ref, a$1), b$1))));
	}
};
/** @internal */
const makeSynchronized = (value) => sync$3(() => unsafeMakeSynchronized(value));
/** @internal */
const unsafeMakeSynchronized = (value) => {
	return new SynchronizedImpl(unsafeMake$3(value), unsafeMakeSemaphore$1(1).withPermits(1));
};
/** @internal */
const updateSomeAndGetEffectSynchronized = /* @__PURE__ */ dual$1(2, (self, pf) => self.modifyEffect((value) => {
	const result = pf(value);
	switch (result._tag) {
		case "None": return succeed$9([value, value]);
		case "Some": return map$9(result.value, (a$1) => [a$1, a$1]);
	}
}));
/** @internal */
const zipFiber = /* @__PURE__ */ dual$1(2, (self, that) => zipWithFiber(self, that, (a$1, b$1) => [a$1, b$1]));
/** @internal */
const zipLeftFiber = /* @__PURE__ */ dual$1(2, (self, that) => zipWithFiber(self, that, (a$1, _$1) => a$1));
/** @internal */
const zipRightFiber = /* @__PURE__ */ dual$1(2, (self, that) => zipWithFiber(self, that, (_$1, b$1) => b$1));
/** @internal */
const zipWithFiber = /* @__PURE__ */ dual$1(3, (self, that, f$1) => ({
	...CommitPrototype,
	commit() {
		return join$1(this);
	},
	[FiberTypeId$1]: fiberVariance,
	id: () => pipe$3(self.id(), getOrElse$1(that.id())),
	await: pipe$3(self.await, flatten$3, zipWithOptions(flatten$3(that.await), f$1, { concurrent: true }), exit$2),
	children: self.children,
	inheritAll: zipRight$3(that.inheritAll, self.inheritAll),
	poll: zipWith$4(self.poll, that.poll, (optionA, optionB) => pipe$3(optionA, flatMap$12((exitA) => pipe$3(optionB, map$16((exitB) => zipWith$3(exitA, exitB, {
		onSuccess: f$1,
		onFailure: parallel$3
	})))))),
	interruptAsFork: (id$2) => zipRight$3(self.interruptAsFork(id$2), that.interruptAsFork(id$2)),
	pipe() {
		return pipeArguments(this, arguments);
	}
}));
const bindAll$1 = /* @__PURE__ */ dual$1((args$2) => isEffect$1(args$2[0]), (self, f$1, options) => flatMap$5(self, (a$1) => all$2(f$1(a$1), options).pipe(map$9((record) => Object.assign({}, a$1, record)))));

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/managedRuntime/circular.js
/** @internal */
const TypeId$3 = /* @__PURE__ */ Symbol.for("effect/ManagedRuntime");

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/opCodes/layer.js
/** @internal */
const OP_FRESH = "Fresh";
/** @internal */
const OP_SUSPEND = "Suspend";
/** @internal */
const OP_ZIP_WITH = "ZipWith";

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Fiber.js
/**
* @since 2.0.0
* @category symbols
*/
const FiberTypeId = FiberTypeId$1;
/**
* @since 2.0.0
* @category symbols
*/
const RuntimeFiberTypeId = RuntimeFiberTypeId$1;
/**
* @since 2.0.0
* @category instances
*/
const Order = Order$1;
/**
* Returns `true` if the specified value is a `Fiber`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isFiber = isFiber$1;
/**
* Returns `true` if the specified `Fiber` is a `RuntimeFiber`, `false`
* otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isRuntimeFiber = isRuntimeFiber$1;
/**
* The identity of the fiber.
*
* @since 2.0.0
* @category getters
*/
const id = id$1;
const _await = _await$1;
/**
* Awaits on all fibers to be completed, successfully or not.
*
* @since 2.0.0
* @category destructors
*/
const awaitAll = fiberAwaitAll;
/**
* Retrieves the immediate children of the fiber.
*
* @since 2.0.0
* @category getters
*/
const children = children$1;
/**
* Collects all fibers into a single fiber producing an in-order list of the
* results.
*
* @since 2.0.0
* @category constructors
*/
const all$1 = fiberAll;
/**
* A fiber that is done with the specified `Exit` value.
*
* @since 2.0.0
* @category constructors
*/
const done = done$3;
/**
* @since 2.0.0
* @category destructors
*/
const dump = dump$1;
/**
* @since 2.0.0
* @category destructors
*/
const dumpAll = dumpAll$1;
/**
* A fiber that has already failed with the specified value.
*
* @since 2.0.0
* @category constructors
*/
const fail$3 = fail$6;
/**
* Creates a `Fiber` that has already failed with the specified cause.
*
* @since 2.0.0
* @category constructors
*/
const failCause$2 = failCause$4;
/**
* Lifts an `Effect` into a `Fiber`.
*
* @since 2.0.0
* @category conversions
*/
const fromEffect = fromEffect$2;
/**
* Gets the current fiber if one is running.
*
* @since 2.0.0
* @category utilities
*/
const getCurrentFiber = getCurrentFiber$1;
/**
* Inherits values from all `FiberRef` instances into current fiber. This
* will resume immediately.
*
* @since 2.0.0
* @category destructors
*/
const inheritAll = inheritAll$1;
/**
* Interrupts the fiber from whichever fiber is calling this method. If the
* fiber has already exited, the returned effect will resume immediately.
* Otherwise, the effect will resume when the fiber exits.
*
* @since 2.0.0
* @category interruption
*/
const interrupt$1 = interruptFiber;
/**
* Constructrs a `Fiber` that is already interrupted.
*
* @since 2.0.0
* @category constructors
*/
const interrupted = interrupted$1;
/**
* Interrupts the fiber as if interrupted from the specified fiber. If the
* fiber has already exited, the returned effect will resume immediately.
* Otherwise, the effect will resume when the fiber exits.
*
* @since 2.0.0
* @category interruption
*/
const interruptAs = interruptAsFiber;
/**
* Interrupts the fiber as if interrupted from the specified fiber. If the
* fiber has already exited, the returned effect will resume immediately.
* Otherwise, the effect will resume when the fiber exits.
*
* @since 2.0.0
* @category interruption
*/
const interruptAsFork = interruptAsFork$1;
/**
* Interrupts all fibers, awaiting their interruption.
*
* @since 2.0.0
* @category interruption
*/
const interruptAll = interruptAll$1;
/**
* Interrupts all fibers as by the specified fiber, awaiting their
* interruption.
*
* @since 2.0.0
* @category interruption
*/
const interruptAllAs = interruptAllAs$1;
/**
* Interrupts the fiber from whichever fiber is calling this method. The
* interruption will happen in a separate daemon fiber, and the returned
* effect will always resume immediately without waiting.
*
* @since 2.0.0
* @category interruption
*/
const interruptFork = fiberInterruptFork;
/**
* Joins the fiber, which suspends the joining fiber until the result of the
* fiber has been determined. Attempting to join a fiber that has erred will
* result in a catchable error. Joining an interrupted fiber will result in an
* "inner interruption" of this fiber, unlike interruption triggered by
* another fiber, "inner interruption" can be caught and recovered.
*
* @since 2.0.0
* @category destructors
*/
const join = join$1;
/**
* Joins all fibers, awaiting their _successful_ completion. Attempting to
* join a fiber that has erred will result in a catchable error, _if_ that
* error does not result from interruption.
*
* @since 2.0.0
* @category destructors
*/
const joinAll = fiberJoinAll;
/**
* Maps over the value the Fiber computes.
*
* @since 2.0.0
* @category mapping
*/
const map$3 = map$6;
/**
* Effectually maps over the value the fiber computes.
*
* @since 2.0.0
* @category mapping
*/
const mapEffect$1 = mapEffect$2;
/**
* Passes the success of this fiber to the specified callback, and continues
* with the fiber that it returns.
*
* @since 2.0.0
* @category mapping
*/
const mapFiber = mapFiber$1;
/**
* Folds over the `Fiber` or `RuntimeFiber`.
*
* @since 2.0.0
* @category folding
*/
const match$1 = match$3;
/**
* A fiber that never fails or succeeds.
*
* @since 2.0.0
* @category constructors
*/
const never$1 = never$2;
/**
* Returns a fiber that prefers `this` fiber, but falls back to the `that` one
* when `this` one fails. Interrupting the returned fiber will interrupt both
* fibers, sequentially, from left to right.
*
* @since 2.0.0
* @category alternatives
*/
const orElse$2 = orElse$3;
/**
* Returns a fiber that prefers `this` fiber, but falls back to the `that` one
* when `this` one fails. Interrupting the returned fiber will interrupt both
* fibers, sequentially, from left to right.
*
* @since 2.0.0
* @category alternatives
*/
const orElseEither = orElseEither$2;
/**
* Tentatively observes the fiber, but returns immediately if it is not
* already done.
*
* @since 2.0.0
* @category getters
*/
const poll = poll$1;
/**
* Pretty-prints a `RuntimeFiber`.
*
* @since 2.0.0
* @category destructors
*/
const pretty = pretty$2;
/**
* Returns a chunk containing all root fibers.
*
* @since 2.0.0
* @category constructors
*/
const roots = roots$1;
/**
* Returns a chunk containing all root fibers.
*
* @since 2.0.0
* @category constructors
*/
const unsafeRoots = unsafeRoots$1;
/**
* Converts this fiber into a scoped effect. The fiber is interrupted when the
* scope is closed.
*
* @since 2.0.0
* @category destructors
*/
const scoped$1 = fiberScoped;
/**
* Returns the `FiberStatus` of a `RuntimeFiber`.
*
* @since 2.0.0
* @category getters
*/
const status = status$1;
/**
* Returns a fiber that has already succeeded with the specified value.
*
* @since 2.0.0
* @category constructors
*/
const succeed$3 = succeed$5;
const void_ = void_$1;
/**
* Zips this fiber and the specified fiber together, producing a tuple of
* their output.
*
* @since 2.0.0
* @category zipping
*/
const zip$1 = zipFiber;
/**
* Same as `zip` but discards the output of that `Fiber`.
*
* @since 2.0.0
* @category zipping
*/
const zipLeft$1 = zipLeftFiber;
/**
* Same as `zip` but discards the output of this `Fiber`.
*
* @since 2.0.0
* @category zipping
*/
const zipRight$1 = zipRightFiber;
/**
* Zips this fiber with the specified fiber, combining their results using the
* specified combiner function. Both joins and interruptions are performed in
* sequential order from left to right.
*
* @since 2.0.0
* @category zipping
*/
const zipWith$2 = zipWithFiber;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/runtime.js
const makeDual = (f$1) => function() {
	if (arguments.length === 1) {
		const runtime$4 = arguments[0];
		return (effect, ...args$2) => f$1(runtime$4, effect, ...args$2);
	}
	return f$1.apply(this, arguments);
};
/** @internal */
const unsafeFork = /* @__PURE__ */ makeDual((runtime$4, self, options) => {
	const fiberId$2 = unsafeMake$7();
	const fiberRefUpdates = [[currentContext, [[fiberId$2, runtime$4.context]]]];
	if (options?.scheduler) fiberRefUpdates.push([currentScheduler, [[fiberId$2, options.scheduler]]]);
	let fiberRefs$3 = updateManyAs(runtime$4.fiberRefs, {
		entries: fiberRefUpdates,
		forkAs: fiberId$2
	});
	if (options?.updateRefs) fiberRefs$3 = options.updateRefs(fiberRefs$3, fiberId$2);
	const fiberRuntime = new FiberRuntime(fiberId$2, fiberRefs$3, runtime$4.runtimeFlags);
	let effect = self;
	if (options?.scope) effect = flatMap$5(fork$1(options.scope, sequential$2), (closeableScope) => zipRight$3(scopeAddFinalizer(closeableScope, fiberIdWith$1((id$2) => equals(id$2, fiberRuntime.id()) ? void_$4 : interruptAsFiber(fiberRuntime, id$2))), onExit$2(self, (exit$3) => close(closeableScope, exit$3))));
	const supervisor = fiberRuntime.currentSupervisor;
	if (supervisor !== none$2) {
		supervisor.onStart(runtime$4.context, effect, none$7(), fiberRuntime);
		fiberRuntime.addObserver((exit$3) => supervisor.onEnd(exit$3, fiberRuntime));
	}
	globalScope.add(runtime$4.runtimeFlags, fiberRuntime);
	if (options?.immediate === false) fiberRuntime.resume(effect);
	else fiberRuntime.start(effect);
	return fiberRuntime;
});
/** @internal */
const unsafeRunCallback = /* @__PURE__ */ makeDual((runtime$4, effect, options = {}) => {
	const fiberRuntime = unsafeFork(runtime$4, effect, options);
	if (options.onExit) fiberRuntime.addObserver((exit$3) => {
		options.onExit(exit$3);
	});
	return (id$2, cancelOptions) => unsafeRunCallback(runtime$4)(pipe$3(fiberRuntime, interruptAs(id$2 ?? none$6)), {
		...cancelOptions,
		onExit: cancelOptions?.onExit ? (exit$3) => cancelOptions.onExit(flatten$2(exit$3)) : void 0
	});
});
/** @internal */
const unsafeRunSync = /* @__PURE__ */ makeDual((runtime$4, effect) => {
	const result = unsafeRunSyncExit(runtime$4)(effect);
	if (result._tag === "Failure") throw fiberFailure(result.effect_instruction_i0);
	return result.effect_instruction_i0;
});
var AsyncFiberExceptionImpl = class extends Error {
	fiber;
	_tag = "AsyncFiberException";
	constructor(fiber) {
		super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);
		this.fiber = fiber;
		this.name = this._tag;
		this.stack = this.message;
	}
};
const asyncFiberException = (fiber) => {
	const limit = Error.stackTraceLimit;
	Error.stackTraceLimit = 0;
	const error = new AsyncFiberExceptionImpl(fiber);
	Error.stackTraceLimit = limit;
	return error;
};
/** @internal */
const FiberFailureId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure");
/** @internal */
const FiberFailureCauseId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure/Cause");
var FiberFailureImpl = class extends Error {
	[FiberFailureId];
	[FiberFailureCauseId];
	constructor(cause$2) {
		const head$4 = prettyErrors$1(cause$2)[0];
		super(head$4?.message || "An error has occurred");
		this[FiberFailureId] = FiberFailureId;
		this[FiberFailureCauseId] = cause$2;
		this.name = head$4 ? `(FiberFailure) ${head$4.name}` : "FiberFailure";
		if (head$4?.stack) this.stack = head$4.stack;
	}
	toJSON() {
		return {
			_id: "FiberFailure",
			cause: this[FiberFailureCauseId].toJSON()
		};
	}
	toString() {
		return "(FiberFailure) " + pretty$3(this[FiberFailureCauseId], { renderErrorCause: true });
	}
	[NodeInspectSymbol]() {
		return this.toString();
	}
};
/** @internal */
const fiberFailure = (cause$2) => {
	const limit = Error.stackTraceLimit;
	Error.stackTraceLimit = 0;
	const error = new FiberFailureImpl(cause$2);
	Error.stackTraceLimit = limit;
	return error;
};
const fastPath = (effect) => {
	const op = effect;
	switch (op._op) {
		case "Failure":
		case "Success": return op;
		case "Left": return exitFail(op.left);
		case "Right": return exitSucceed$1(op.right);
		case "Some": return exitSucceed$1(op.value);
		case "None": return exitFail(NoSuchElementException$1());
	}
};
/** @internal */
const unsafeRunSyncExit = /* @__PURE__ */ makeDual((runtime$4, effect) => {
	const op = fastPath(effect);
	if (op) return op;
	const scheduler = new SyncScheduler();
	const fiberRuntime = unsafeFork(runtime$4)(effect, { scheduler });
	scheduler.flush();
	const result = fiberRuntime.unsafePoll();
	if (result) return result;
	return exitDie$1(capture(asyncFiberException(fiberRuntime), currentSpanFromFiber(fiberRuntime)));
});
/** @internal */
const unsafeRunPromise = /* @__PURE__ */ makeDual((runtime$4, effect, options) => unsafeRunPromiseExit(runtime$4, effect, options).then((result) => {
	switch (result._tag) {
		case OP_SUCCESS: return result.effect_instruction_i0;
		case OP_FAILURE: throw fiberFailure(result.effect_instruction_i0);
	}
}));
/** @internal */
const unsafeRunPromiseExit = /* @__PURE__ */ makeDual((runtime$4, effect, options) => new Promise((resolve) => {
	const op = fastPath(effect);
	if (op) resolve(op);
	const fiber = unsafeFork(runtime$4)(effect);
	fiber.addObserver((exit$3) => {
		resolve(exit$3);
	});
	if (options?.signal !== void 0) if (options.signal.aborted) fiber.unsafeInterruptAsFork(fiber.id());
	else options.signal.addEventListener("abort", () => {
		fiber.unsafeInterruptAsFork(fiber.id());
	}, { once: true });
}));
/** @internal */
var RuntimeImpl = class {
	context;
	runtimeFlags;
	fiberRefs;
	constructor(context$2, runtimeFlags$1, fiberRefs$3) {
		this.context = context$2;
		this.runtimeFlags = runtimeFlags$1;
		this.fiberRefs = fiberRefs$3;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const make$5 = (options) => new RuntimeImpl(options.context, options.runtimeFlags, options.fiberRefs);
/** @internal */
const runtime$1 = () => withFiberRuntime$1((state, status$2) => succeed$9(new RuntimeImpl(state.getFiberRef(currentContext), status$2.runtimeFlags, state.getFiberRefs())));
/** @internal */
const defaultRuntimeFlags = /* @__PURE__ */ make$31(Interruption, CooperativeYielding, RuntimeMetrics);
/** @internal */
const defaultRuntime = /* @__PURE__ */ make$5({
	context: /* @__PURE__ */ empty$31(),
	runtimeFlags: defaultRuntimeFlags,
	fiberRefs: /* @__PURE__ */ empty$10()
});
/** @internal */
const unsafeRunEffect = /* @__PURE__ */ unsafeRunCallback(defaultRuntime);
/** @internal */
const unsafeForkEffect = /* @__PURE__ */ unsafeFork(defaultRuntime);
/** @internal */
const unsafeRunPromiseEffect = /* @__PURE__ */ unsafeRunPromise(defaultRuntime);
/** @internal */
const unsafeRunPromiseExitEffect = /* @__PURE__ */ unsafeRunPromiseExit(defaultRuntime);
/** @internal */
const unsafeRunSyncEffect = /* @__PURE__ */ unsafeRunSync(defaultRuntime);
/** @internal */
const unsafeRunSyncExitEffect = /* @__PURE__ */ unsafeRunSyncExit(defaultRuntime);
/** @internal */
const asyncEffect$1 = (register) => suspend$3(() => {
	let cleanup = void 0;
	return flatMap$5(deferredMake(), (deferred) => flatMap$5(runtime$1(), (runtime$4) => uninterruptibleMask$2((restore) => zipRight$3(fork$2(restore(matchCauseEffect$2(register((cb) => unsafeRunCallback(runtime$4)(intoDeferred$1(cb, deferred))), {
		onFailure: (cause$2) => deferredFailCause(deferred, cause$2),
		onSuccess: (cleanup_) => {
			cleanup = cleanup_;
			return void_$4;
		}
	}))), restore(onInterrupt$1(deferredAwait(deferred), () => cleanup ?? void_$4))))));
});

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/synchronizedRef.js
/** @internal */
const modifyEffect = /* @__PURE__ */ dual$1(2, (self, f$1) => self.modifyEffect(f$1));

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/layer.js
/** @internal */
const LayerSymbolKey = "effect/Layer";
/** @internal */
const LayerTypeId = /* @__PURE__ */ Symbol.for(LayerSymbolKey);
const layerVariance = {
	_RIn: (_$1) => _$1,
	_E: (_$1) => _$1,
	_ROut: (_$1) => _$1
};
/** @internal */
const proto$1 = {
	[LayerTypeId]: layerVariance,
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const MemoMapTypeIdKey = "effect/Layer/MemoMap";
/** @internal */
const MemoMapTypeId = /* @__PURE__ */ Symbol.for(MemoMapTypeIdKey);
/** @internal */
const CurrentMemoMap = /* @__PURE__ */ Reference()("effect/Layer/CurrentMemoMap", { defaultValue: () => unsafeMakeMemoMap() });
/** @internal */
const isLayer = (u$1) => hasProperty(u$1, LayerTypeId);
/** @internal */
const isFresh = (self) => {
	return self._op_layer === OP_FRESH;
};
/** @internal */
var MemoMapImpl = class {
	ref;
	[MemoMapTypeId];
	constructor(ref) {
		this.ref = ref;
		this[MemoMapTypeId] = MemoMapTypeId;
	}
	/**
	* Checks the memo map to see if a layer exists. If it is, immediately
	* returns it. Otherwise, obtains the layer, stores it in the memo map,
	* and adds a finalizer to the `Scope`.
	*/
	getOrElseMemoize(layer$11, scope$2) {
		return pipe$3(modifyEffect(this.ref, (map$18) => {
			const inMap = map$18.get(layer$11);
			if (inMap !== void 0) {
				const [acquire, release] = inMap;
				const cached$3 = pipe$3(acquire, flatMap$5(([patch$11, b$1]) => pipe$3(patchFiberRefs$1(patch$11), as$4(b$1))), onExit$2(exitMatch({
					onFailure: () => void_$4,
					onSuccess: () => scopeAddFinalizerExit(scope$2, release)
				})));
				return succeed$9([cached$3, map$18]);
			}
			return pipe$3(make$20(0), flatMap$5((observers) => pipe$3(deferredMake(), flatMap$5((deferred) => pipe$3(make$20(() => void_$4), map$9((finalizerRef) => {
				const resource = uninterruptibleMask$2((restore) => pipe$3(scopeMake(), flatMap$5((innerScope) => pipe$3(restore(flatMap$5(makeBuilder(layer$11, innerScope, true), (f$1) => diffFiberRefs$1(f$1(this)))), exit$2, flatMap$5((exit$3) => {
					switch (exit$3._tag) {
						case OP_FAILURE: return pipe$3(deferredFailCause(deferred, exit$3.effect_instruction_i0), zipRight$3(scopeClose(innerScope, exit$3)), zipRight$3(failCause$8(exit$3.effect_instruction_i0)));
						case OP_SUCCESS: return pipe$3(set$1(finalizerRef, (exit$4) => pipe$3(scopeClose(innerScope, exit$4), whenEffect$1(modify$1(observers, (n$1) => [n$1 === 1, n$1 - 1])), asVoid$3)), zipRight$3(update$3(observers, (n$1) => n$1 + 1)), zipRight$3(scopeAddFinalizerExit(scope$2, (exit$4) => pipe$3(sync$3(() => map$18.delete(layer$11)), zipRight$3(get$1(finalizerRef)), flatMap$5((finalizer) => finalizer(exit$4))))), zipRight$3(deferredSucceed(deferred, exit$3.effect_instruction_i0)), as$4(exit$3.effect_instruction_i0[1]));
					}
				})))));
				const memoized = [pipe$3(deferredAwait(deferred), onExit$2(exitMatchEffect({
					onFailure: () => void_$4,
					onSuccess: () => update$3(observers, (n$1) => n$1 + 1)
				}))), (exit$3) => pipe$3(get$1(finalizerRef), flatMap$5((finalizer) => finalizer(exit$3)))];
				return [resource, isFresh(layer$11) ? map$18 : map$18.set(layer$11, memoized)];
			}))))));
		}), flatten$3);
	}
};
/** @internal */
const makeMemoMap = /* @__PURE__ */ suspend$3(() => map$9(makeSynchronized(/* @__PURE__ */ new Map()), (ref) => new MemoMapImpl(ref)));
/** @internal */
const unsafeMakeMemoMap = () => new MemoMapImpl(unsafeMakeSynchronized(/* @__PURE__ */ new Map()));
/** @internal */
const buildWithScope = /* @__PURE__ */ dual$1(2, (self, scope$2) => flatMap$5(makeMemoMap, (memoMap) => buildWithMemoMap(self, memoMap, scope$2)));
/** @internal */
const buildWithMemoMap = /* @__PURE__ */ dual$1(3, (self, memoMap, scope$2) => flatMap$5(makeBuilder(self, scope$2), (run) => provideService$1(run(memoMap), CurrentMemoMap, memoMap)));
const makeBuilder = (self, scope$2, inMemoMap = false) => {
	const op = self;
	switch (op._op_layer) {
		case "Locally": return sync$3(() => (memoMap) => op.f(memoMap.getOrElseMemoize(op.self, scope$2)));
		case "ExtendScope": return sync$3(() => (memoMap) => scopeWith$1((scope$3) => memoMap.getOrElseMemoize(op.layer, scope$3)));
		case "Fold": return sync$3(() => (memoMap) => pipe$3(memoMap.getOrElseMemoize(op.layer, scope$2), matchCauseEffect$2({
			onFailure: (cause$2) => memoMap.getOrElseMemoize(op.failureK(cause$2), scope$2),
			onSuccess: (value) => memoMap.getOrElseMemoize(op.successK(value), scope$2)
		})));
		case "Fresh": return sync$3(() => (_$1) => pipe$3(op.layer, buildWithScope(scope$2)));
		case "FromEffect": return inMemoMap ? sync$3(() => (_$1) => op.effect) : sync$3(() => (memoMap) => memoMap.getOrElseMemoize(self, scope$2));
		case "Provide": return sync$3(() => (memoMap) => pipe$3(memoMap.getOrElseMemoize(op.first, scope$2), flatMap$5((env$2) => pipe$3(memoMap.getOrElseMemoize(op.second, scope$2), provideContext$1(env$2)))));
		case "Scoped": return inMemoMap ? sync$3(() => (_$1) => scopeExtend(op.effect, scope$2)) : sync$3(() => (memoMap) => memoMap.getOrElseMemoize(self, scope$2));
		case "Suspend": return sync$3(() => (memoMap) => memoMap.getOrElseMemoize(op.evaluate(), scope$2));
		case "ProvideMerge": return sync$3(() => (memoMap) => pipe$3(memoMap.getOrElseMemoize(op.first, scope$2), zipWith$4(memoMap.getOrElseMemoize(op.second, scope$2), op.zipK)));
		case "ZipWith": return sync$3(() => (memoMap) => pipe$3(memoMap.getOrElseMemoize(op.first, scope$2), zipWithOptions(memoMap.getOrElseMemoize(op.second, scope$2), op.zipK, { concurrent: true })));
	}
};
/** @internal */
const merge$1 = /* @__PURE__ */ dual$1(2, (self, that) => zipWith$1(self, that, (a$1, b$1) => merge$4(a$1, b$1)));
/** @internal */
const mergeAll$1 = (...layers) => {
	let final = layers[0];
	for (let i$1 = 1; i$1 < layers.length; i$1++) final = merge$1(final, layers[i$1]);
	return final;
};
/** @internal */
const suspend$1 = (evaluate$1) => {
	const suspend$4 = Object.create(proto$1);
	suspend$4._op_layer = OP_SUSPEND;
	suspend$4.evaluate = evaluate$1;
	return suspend$4;
};
/** @internal */
const zipWith$1 = /* @__PURE__ */ dual$1(3, (self, that, f$1) => suspend$1(() => {
	const zipWith$6 = Object.create(proto$1);
	zipWith$6._op_layer = OP_ZIP_WITH;
	zipWith$6.first = self;
	zipWith$6.second = that;
	zipWith$6.zipK = f$1;
	return zipWith$6;
}));
const provideSomeLayer = /* @__PURE__ */ dual$1(2, (self, layer$11) => scopedWith$1((scope$2) => flatMap$5(buildWithScope(layer$11, scope$2), (context$2) => provideSomeContext(self, context$2))));
const provideSomeRuntime = /* @__PURE__ */ dual$1(2, (self, rt) => {
	const patchRefs = diff$1(defaultRuntime.fiberRefs, rt.fiberRefs);
	const patchFlags = diff$3(defaultRuntime.runtimeFlags, rt.runtimeFlags);
	return uninterruptibleMask$2((restore) => withFiberRuntime$1((fiber) => {
		const oldContext = fiber.getFiberRef(currentContext);
		const oldRefs = fiber.getFiberRefs();
		const newRefs = patch$1(fiber.id(), oldRefs)(patchRefs);
		const oldFlags = fiber.currentRuntimeFlags;
		const newFlags = patch$4(patchFlags)(oldFlags);
		const rollbackRefs = diff$1(newRefs, oldRefs);
		const rollbackFlags = diff$3(newFlags, oldFlags);
		fiber.setFiberRefs(newRefs);
		fiber.currentRuntimeFlags = newFlags;
		return ensuring$1(provideSomeContext(restore(self), merge$4(oldContext, rt.context)), withFiberRuntime$1((fiber$1) => {
			fiber$1.setFiberRefs(patch$1(fiber$1.id(), fiber$1.getFiberRefs())(rollbackRefs));
			fiber$1.currentRuntimeFlags = patch$4(rollbackFlags)(fiber$1.currentRuntimeFlags);
			return void_$4;
		}));
	}));
});
/** @internal */
const effect_provide = /* @__PURE__ */ dual$1(2, (self, source) => {
	if (Array.isArray(source)) return provideSomeLayer(self, mergeAll$1(...source));
	else if (isLayer(source)) return provideSomeLayer(self, source);
	else if (isContext(source)) return provideSomeContext(self, source);
	else if (TypeId$3 in source) return flatMap$5(source.runtimeEffect, (rt) => provideSomeRuntime(self, rt));
	else return provideSomeRuntime(self, source);
});

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/console.js
/** @internal */
const console$2 = /* @__PURE__ */ map$9(/* @__PURE__ */ fiberRefGet(currentServices), /* @__PURE__ */ get$9(consoleTag));
/** @internal */
const consoleWith$1 = (f$1) => fiberRefGetWith(currentServices, (services) => f$1(get$9(services, consoleTag)));
/** @internal */
const withConsole$1 = /* @__PURE__ */ dual$1(2, (effect, value) => fiberRefLocallyWith(effect, currentServices, add$3(consoleTag, value)));
/** @internal */
const withConsoleScoped$1 = (console$3) => fiberRefLocallyScopedWith(currentServices, add$3(consoleTag, console$3));

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Data.js
/**
* @example
* ```ts
* import * as assert from "node:assert"
* import { Data, Equal } from "effect"
*
* const alice = Data.struct({ name: "Alice", age: 30 })
*
* const bob = Data.struct({ name: "Bob", age: 40 })
*
* assert.deepStrictEqual(Equal.equals(alice, alice), true)
* assert.deepStrictEqual(Equal.equals(alice, Data.struct({ name: "Alice", age: 30 })), true)
*
* assert.deepStrictEqual(Equal.equals(alice, { name: "Alice", age: 30 }), false)
* assert.deepStrictEqual(Equal.equals(alice, bob), false)
* ```
*
* @category constructors
* @since 2.0.0
*/
const struct = struct$1;
/**
* Provides a constructor for a Case Class.
*
* @example
* ```ts
* import * as assert from "node:assert"
* import { Data, Equal } from "effect"
*
* class Person extends Data.Class<{ readonly name: string }> {}
*
* // Creating instances of Person
* const mike1 = new Person({ name: "Mike" })
* const mike2 = new Person({ name: "Mike" })
* const john = new Person({ name: "John" })
*
* // Checking equality
* assert.deepStrictEqual(Equal.equals(mike1, mike2), true)
* assert.deepStrictEqual(Equal.equals(mike1, john), false)
* ```
*
* @since 2.0.0
* @category constructors
*/
const Class$1 = Structural$1;
/**
* @since 2.0.0
* @category constructors
*/
const Structural = Structural$1;
/**
* Provides a constructor for a Case Class.
*
* @since 2.0.0
* @category constructors
*/
const Error$1 = /* @__PURE__ */ function() {
	const plainArgsSymbol = /* @__PURE__ */ Symbol.for("effect/Data/Error/plainArgs");
	return { BaseEffectError: class extends YieldableError$1 {
		constructor(args$2) {
			super(args$2?.message, args$2?.cause ? { cause: args$2.cause } : void 0);
			if (args$2) {
				Object.assign(this, args$2);
				Object.defineProperty(this, plainArgsSymbol, {
					value: args$2,
					enumerable: false
				});
			}
		}
		toJSON() {
			return {
				...this[plainArgsSymbol],
				...this
			};
		}
	} }.BaseEffectError;
}();
/**
* @since 2.0.0
* @category constructors
*/
const TaggedError = (tag$1) => {
	const O$1 = { BaseEffectError: class extends Error$1 {
		_tag = tag$1;
	} };
	O$1.BaseEffectError.prototype.name = tag$1;
	return O$1.BaseEffectError;
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/schedule.js
/** @internal */
const ScheduleSymbolKey = "effect/Schedule";
/** @internal */
const ScheduleTypeId = /* @__PURE__ */ Symbol.for(ScheduleSymbolKey);
/** @internal */
const isSchedule = (u$1) => hasProperty(u$1, ScheduleTypeId);
/** @internal */
const ScheduleDriverSymbolKey = "effect/ScheduleDriver";
/** @internal */
const ScheduleDriverTypeId = /* @__PURE__ */ Symbol.for(ScheduleDriverSymbolKey);
/** @internal */
const defaultIterationMetadata = {
	start: 0,
	now: 0,
	input: void 0,
	output: void 0,
	elapsed: zero,
	elapsedSincePrevious: zero,
	recurrence: 0
};
/** @internal */
const CurrentIterationMetadata = /* @__PURE__ */ Reference()("effect/Schedule/CurrentIterationMetadata", { defaultValue: () => defaultIterationMetadata });
const scheduleVariance = {
	_Out: (_$1) => _$1,
	_In: (_$1) => _$1,
	_R: (_$1) => _$1
};
const scheduleDriverVariance = {
	_Out: (_$1) => _$1,
	_In: (_$1) => _$1,
	_R: (_$1) => _$1
};
/** @internal */
var ScheduleImpl = class {
	initial;
	step;
	[ScheduleTypeId] = scheduleVariance;
	constructor(initial, step$3) {
		this.initial = initial;
		this.step = step$3;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
};
/** @internal */
const updateInfo = (iterationMetaRef, now, input, output) => update$3(iterationMetaRef, (prev) => prev.recurrence === 0 ? {
	now,
	input,
	output,
	recurrence: prev.recurrence + 1,
	elapsed: zero,
	elapsedSincePrevious: zero,
	start: now
} : {
	now,
	input,
	output,
	recurrence: prev.recurrence + 1,
	elapsed: millis(now - prev.start),
	elapsedSincePrevious: millis(now - prev.now),
	start: prev.start
});
/** @internal */
var ScheduleDriverImpl = class {
	schedule;
	ref;
	[ScheduleDriverTypeId] = scheduleDriverVariance;
	constructor(schedule$1, ref) {
		this.schedule = schedule$1;
		this.ref = ref;
	}
	get state() {
		return map$9(get$1(this.ref), (tuple$2) => tuple$2[1]);
	}
	get last() {
		return flatMap$5(get$1(this.ref), ([element, _$1]) => {
			switch (element._tag) {
				case "None": return failSync$2(() => new NoSuchElementException$1());
				case "Some": return succeed$9(element.value);
			}
		});
	}
	iterationMeta = /* @__PURE__ */ unsafeMake$3(defaultIterationMetadata);
	get reset() {
		return set$1(this.ref, [none$7(), this.schedule.initial]).pipe(zipLeft$3(set$1(this.iterationMeta, defaultIterationMetadata)));
	}
	next(input) {
		return pipe$3(map$9(get$1(this.ref), (tuple$2) => tuple$2[1]), flatMap$5((state) => pipe$3(currentTimeMillis, flatMap$5((now) => pipe$3(suspend$3(() => this.schedule.step(now, input, state)), flatMap$5(([state$1, out, decision]) => {
			const setState = set$1(this.ref, [some$4(out), state$1]);
			if (isDone(decision)) return setState.pipe(zipRight$3(fail$9(none$7())));
			const millis$1 = start(decision.intervals) - now;
			if (millis$1 <= 0) return setState.pipe(zipRight$3(updateInfo(this.iterationMeta, now, input, out)), as$4(out));
			const duration = millis(millis$1);
			return pipe$3(setState, zipRight$3(updateInfo(this.iterationMeta, now, input, out)), zipRight$3(sleep$1(duration)), as$4(out));
		}))))));
	}
};
/** @internal */
const makeWithState = (initial, step$3) => new ScheduleImpl(initial, step$3);
/** @internal */
const asVoid$1 = (self) => map$2(self, constVoid$1);
/** @internal */
const check = /* @__PURE__ */ dual$1(2, (self, test) => checkEffect(self, (input, out) => sync$3(() => test(input, out))));
/** @internal */
const checkEffect = /* @__PURE__ */ dual$1(2, (self, test) => makeWithState(self.initial, (now, input, state) => flatMap$5(self.step(now, input, state), ([state$1, out, decision]) => {
	if (isDone(decision)) return succeed$9([
		state$1,
		out,
		done$1
	]);
	return map$9(test(input, out), (cont) => cont ? [
		state$1,
		out,
		decision
	] : [
		state$1,
		out,
		done$1
	]);
})));
/** @internal */
const driver = (self) => pipe$3(make$20([none$7(), self.initial]), map$9((ref) => new ScheduleDriverImpl(self, ref)));
/** @internal */
const intersect = /* @__PURE__ */ dual$1(2, (self, that) => intersectWith(self, that, intersect$1));
/** @internal */
const intersectWith = /* @__PURE__ */ dual$1(3, (self, that, f$1) => makeWithState([self.initial, that.initial], (now, input, state) => pipe$3(zipWith$4(self.step(now, input, state[0]), that.step(now, input, state[1]), (a$1, b$1) => [a$1, b$1]), flatMap$5(([[lState, out, lDecision], [rState, out2, rDecision]]) => {
	if (isContinue(lDecision) && isContinue(rDecision)) return intersectWithLoop(self, that, input, lState, out, lDecision.intervals, rState, out2, rDecision.intervals, f$1);
	return succeed$9([
		[lState, rState],
		[out, out2],
		done$1
	]);
}))));
/** @internal */
const intersectWithLoop = (self, that, input, lState, out, lInterval, rState, out2, rInterval, f$1) => {
	const combined = f$1(lInterval, rInterval);
	if (isNonEmpty(combined)) return succeed$9([
		[lState, rState],
		[out, out2],
		_continue(combined)
	]);
	if (pipe$3(lInterval, lessThan(rInterval))) return flatMap$5(self.step(end(lInterval), input, lState), ([lState$1, out$1, decision]) => {
		if (isDone(decision)) return succeed$9([
			[lState$1, rState],
			[out$1, out2],
			done$1
		]);
		return intersectWithLoop(self, that, input, lState$1, out$1, decision.intervals, rState, out2, rInterval, f$1);
	});
	return flatMap$5(that.step(end(rInterval), input, rState), ([rState$1, out2$1, decision]) => {
		if (isDone(decision)) return succeed$9([
			[lState, rState$1],
			[out, out2$1],
			done$1
		]);
		return intersectWithLoop(self, that, input, lState, out, lInterval, rState$1, out2$1, decision.intervals, f$1);
	});
};
/** @internal */
const map$2 = /* @__PURE__ */ dual$1(2, (self, f$1) => mapEffect(self, (out) => sync$3(() => f$1(out))));
/** @internal */
const mapEffect = /* @__PURE__ */ dual$1(2, (self, f$1) => makeWithState(self.initial, (now, input, state) => flatMap$5(self.step(now, input, state), ([state$1, out, decision]) => map$9(f$1(out), (out2) => [
	state$1,
	out2,
	decision
]))));
/** @internal */
const passthrough = (self) => makeWithState(self.initial, (now, input, state) => pipe$3(self.step(now, input, state), map$9(([state$1, _$1, decision]) => [
	state$1,
	input,
	decision
])));
/** @internal */
const recurs = (n$1) => whileOutput(forever$1, (out) => out < n$1);
/** @internal */
const unfold = (initial, f$1) => makeWithState(initial, (now, _$1, state) => sync$3(() => [
	f$1(state),
	state,
	continueWith(after(now))
]));
/** @internal */
const untilInputEffect = /* @__PURE__ */ dual$1(2, (self, f$1) => checkEffect(self, (input, _$1) => negate$1(f$1(input))));
/** @internal */
const whileInputEffect = /* @__PURE__ */ dual$1(2, (self, f$1) => checkEffect(self, (input, _$1) => f$1(input)));
/** @internal */
const whileOutput = /* @__PURE__ */ dual$1(2, (self, f$1) => check(self, (_$1, out) => f$1(out)));
const ScheduleDefectTypeId = /* @__PURE__ */ Symbol.for("effect/Schedule/ScheduleDefect");
var ScheduleDefect = class {
	error;
	[ScheduleDefectTypeId];
	constructor(error) {
		this.error = error;
		this[ScheduleDefectTypeId] = ScheduleDefectTypeId;
	}
};
const isScheduleDefect = (u$1) => hasProperty(u$1, ScheduleDefectTypeId);
const scheduleDefectWrap = (self) => catchAll$1(self, (e) => die$4(new ScheduleDefect(e)));
/** @internal */
const scheduleDefectRefailCause = (cause$2) => match$11(find$1(cause$2, (_$1) => isDieType$1(_$1) && isScheduleDefect(_$1.defect) ? some$4(_$1.defect) : none$7()), {
	onNone: () => cause$2,
	onSome: (error) => fail$10(error.error)
});
/** @internal */
const scheduleDefectRefail = (effect) => catchAllCause$1(effect, (cause$2) => failCause$8(scheduleDefectRefailCause(cause$2)));
/** @internal */
const repeat_Effect = /* @__PURE__ */ dual$1(2, (self, schedule$1) => repeatOrElse_Effect(self, schedule$1, (e, _$1) => fail$9(e)));
/** @internal */
const repeat_combined = /* @__PURE__ */ dual$1(2, (self, options) => {
	if (isSchedule(options)) return repeat_Effect(self, options);
	const base = options.schedule ?? passthrough(forever$1);
	const withWhile = options.while ? whileInputEffect(base, (a$1) => {
		const applied = options.while(a$1);
		if (typeof applied === "boolean") return succeed$9(applied);
		return scheduleDefectWrap(applied);
	}) : base;
	const withUntil = options.until ? untilInputEffect(withWhile, (a$1) => {
		const applied = options.until(a$1);
		if (typeof applied === "boolean") return succeed$9(applied);
		return scheduleDefectWrap(applied);
	}) : withWhile;
	return scheduleDefectRefail(repeat_Effect(self, options.times ? intersect(withUntil, recurs(options.times)).pipe(map$2((intersectionPair) => intersectionPair[0])) : withUntil));
});
/** @internal */
const repeatOrElse_Effect = /* @__PURE__ */ dual$1(3, (self, schedule$1, orElse$6) => flatMap$5(driver(schedule$1), (driver$1) => matchEffect$2(self, {
	onFailure: (error) => orElse$6(error, none$7()),
	onSuccess: (value) => repeatOrElseEffectLoop(provideServiceEffect$1(self, CurrentIterationMetadata, get$1(driver$1.iterationMeta)), driver$1, (error, option$2) => provideServiceEffect$1(orElse$6(error, option$2), CurrentIterationMetadata, get$1(driver$1.iterationMeta)), value)
})));
/** @internal */
const repeatOrElseEffectLoop = (self, driver$1, orElse$6, value) => matchEffect$2(driver$1.next(value), {
	onFailure: () => orDie$1(driver$1.last),
	onSuccess: (b$1) => matchEffect$2(self, {
		onFailure: (error) => orElse$6(error, some$4(b$1)),
		onSuccess: (value$1) => repeatOrElseEffectLoop(self, driver$1, orElse$6, value$1)
	})
});
/** @internal */
const retry_Effect = /* @__PURE__ */ dual$1(2, (self, policy) => retryOrElse_Effect(self, policy, (e, _$1) => fail$9(e)));
/** @internal */
const retry_combined = /* @__PURE__ */ dual$1(2, (self, options) => {
	if (isSchedule(options)) return retry_Effect(self, options);
	return scheduleDefectRefail(retry_Effect(self, fromRetryOptions(options)));
});
/** @internal */
const fromRetryOptions = (options) => {
	const base = options.schedule ?? forever$1;
	const withWhile = options.while ? whileInputEffect(base, (e) => {
		const applied = options.while(e);
		if (typeof applied === "boolean") return succeed$9(applied);
		return scheduleDefectWrap(applied);
	}) : base;
	const withUntil = options.until ? untilInputEffect(withWhile, (e) => {
		const applied = options.until(e);
		if (typeof applied === "boolean") return succeed$9(applied);
		return scheduleDefectWrap(applied);
	}) : withWhile;
	return options.times ? intersect(withUntil, recurs(options.times)) : withUntil;
};
/** @internal */
const retryOrElse_Effect = /* @__PURE__ */ dual$1(3, (self, policy, orElse$6) => flatMap$5(driver(policy), (driver$1) => retryOrElse_EffectLoop(provideServiceEffect$1(self, CurrentIterationMetadata, get$1(driver$1.iterationMeta)), driver$1, (e, out) => provideServiceEffect$1(orElse$6(e, out), CurrentIterationMetadata, get$1(driver$1.iterationMeta)))));
/** @internal */
const retryOrElse_EffectLoop = (self, driver$1, orElse$6) => {
	return catchAll$1(self, (e) => matchEffect$2(driver$1.next(e), {
		onFailure: () => pipe$3(driver$1.last, orDie$1, flatMap$5((out) => orElse$6(e, out))),
		onSuccess: () => retryOrElse_EffectLoop(self, driver$1, orElse$6)
	}));
};
/** @internal */
const schedule_Effect = /* @__PURE__ */ dual$1(2, (self, schedule$1) => scheduleFrom_Effect(self, void 0, schedule$1));
/** @internal */
const scheduleFrom_Effect = /* @__PURE__ */ dual$1(3, (self, initial, schedule$1) => flatMap$5(driver(schedule$1), (driver$1) => scheduleFrom_EffectLoop(provideServiceEffect$1(self, CurrentIterationMetadata, get$1(driver$1.iterationMeta)), initial, driver$1)));
/** @internal */
const scheduleFrom_EffectLoop = (self, initial, driver$1) => matchEffect$2(driver$1.next(initial), {
	onFailure: () => orDie$1(driver$1.last),
	onSuccess: () => flatMap$5(self, (a$1) => scheduleFrom_EffectLoop(self, a$1, driver$1))
});
/** @internal */
const forever$1 = /* @__PURE__ */ unfold(0, (n$1) => n$1 + 1);
/** @internal */
const once$1 = /* @__PURE__ */ asVoid$1(/* @__PURE__ */ recurs(1));
/** @internal */
const scheduleForked$1 = /* @__PURE__ */ dual$1(2, (self, schedule$1) => forkScoped$1(schedule_Effect(self, schedule$1)));

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/executionPlan.js
/** @internal */
const withExecutionPlan$1 = /* @__PURE__ */ dual$1(2, (effect, plan) => suspend$3(() => {
	let i$1 = 0;
	let result;
	return flatMap$5(whileLoop$2({
		while: () => i$1 < plan.steps.length && (result === void 0 || isLeft(result)),
		body: () => {
			const step$3 = plan.steps[i$1];
			let nextEffect = effect_provide(effect, step$3.provide);
			if (result) {
				let attempted = false;
				const wrapped = nextEffect;
				nextEffect = suspend$3(() => {
					if (attempted) return wrapped;
					attempted = true;
					return result;
				});
				nextEffect = scheduleDefectRefail(retry_Effect(nextEffect, scheduleFromStep(step$3, false)));
			} else {
				const schedule$1 = scheduleFromStep(step$3, true);
				nextEffect = schedule$1 ? scheduleDefectRefail(retry_Effect(nextEffect, schedule$1)) : nextEffect;
			}
			return either$1(nextEffect);
		},
		step: (either$4) => {
			result = either$4;
			i$1++;
		}
	}), () => result);
}));
/** @internal */
const scheduleFromStep = (step$3, first$2) => {
	if (!first$2) return fromRetryOptions({
		schedule: step$3.schedule ? step$3.schedule : step$3.attempts ? void 0 : once$1,
		times: step$3.attempts,
		while: step$3.while
	});
	else if (step$3.attempts === 1 || !(step$3.schedule || step$3.attempts)) return;
	return fromRetryOptions({
		schedule: step$3.schedule,
		while: step$3.while,
		times: step$3.attempts ? step$3.attempts - 1 : void 0
	});
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/query.js
/** @internal */
const currentCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCache"), () => fiberRefUnsafeMake(unsafeMakeWith(65536, () => map$9(deferredMake(), (handle) => ({
	listeners: new Listeners(),
	handle
})), () => seconds(60))));
/** @internal */
const currentCacheEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCacheEnabled"), () => fiberRefUnsafeMake(false));
/** @internal */
const fromRequest = (request$1, dataSource) => flatMap$5(isEffect$1(dataSource) ? dataSource : succeed$9(dataSource), (ds) => fiberIdWith$1((id$2) => {
	const proxy = new Proxy(request$1, {});
	return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
		if (cacheEnabled) {
			const cached$3 = fiberRefGetWith(currentCache, (cache) => flatMap$5(cache.getEither(proxy), (orNew) => {
				switch (orNew._tag) {
					case "Left":
						if (orNew.left.listeners.interrupted) return flatMap$5(cache.invalidateWhen(proxy, (entry) => entry.handle === orNew.left.handle), () => cached$3);
						orNew.left.listeners.increment();
						return uninterruptibleMask$2((restore) => flatMap$5(exit$2(blocked$1(empty$16, restore(deferredAwait(orNew.left.handle)))), (exit$3) => {
							orNew.left.listeners.decrement();
							return exit$3;
						}));
					case "Right":
						orNew.right.listeners.increment();
						return uninterruptibleMask$2((restore) => flatMap$5(exit$2(blocked$1(single(ds, makeEntry$1({
							request: proxy,
							result: orNew.right.handle,
							listeners: orNew.right.listeners,
							ownerId: id$2,
							state: { completed: false }
						})), restore(deferredAwait(orNew.right.handle)))), () => {
							orNew.right.listeners.decrement();
							return deferredAwait(orNew.right.handle);
						}));
				}
			}));
			return cached$3;
		}
		const listeners = new Listeners();
		listeners.increment();
		return flatMap$5(deferredMake(), (ref) => ensuring$1(blocked$1(single(ds, makeEntry$1({
			request: proxy,
			result: ref,
			listeners,
			ownerId: id$2,
			state: { completed: false }
		})), deferredAwait(ref)), sync$3(() => listeners.decrement())));
	});
}));
/** @internal */
const cacheRequest = (request$1, result) => {
	return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
		if (cacheEnabled) return fiberRefGetWith(currentCache, (cache) => flatMap$5(cache.getEither(request$1), (orNew) => {
			switch (orNew._tag) {
				case "Left": return void_$4;
				case "Right": return deferredComplete(orNew.right.handle, result);
			}
		}));
		return void_$4;
	});
};
/** @internal */
const withRequestCaching$1 = /* @__PURE__ */ dual$1(2, (self, strategy) => fiberRefLocally(self, currentCacheEnabled, strategy));
/** @internal */
const withRequestCache$1 = /* @__PURE__ */ dual$1(2, (self, cache) => fiberRefLocally(self, currentCache, cache));

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Request.js
/**
* @since 2.0.0
* @category symbols
*/
const RequestTypeId = RequestTypeId$1;
/**
* Returns `true` if the specified value is a `Request`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isRequest = isRequest$1;
/**
* Constructs a new `Request`.
*
* @since 2.0.0
* @category constructors
*/
const of = of$1;
/**
* Constructs a new `Request`.
*
* @since 2.0.0
* @category constructors
*/
const tagged = tagged$1;
/**
* Provides a constructor for a Request Class.
*
* @example
* ```ts
* import { Request } from "effect"
*
* type Success = string
* type Error = never
*
* class MyRequest extends Request.Class<Success, Error, {
*   readonly id: string
* }> {}
* ```
*
* @since 2.0.0
* @category constructors
*/
const Class = Class$2;
/**
* Provides a Tagged constructor for a Request Class.
*
* @example
* ```ts
* import { Request } from "effect"
*
* type Success = string
* type Error = never
*
* class MyRequest extends Request.TaggedClass("MyRequest")<Success, Error, {
*   readonly name: string
* }> {}
* ```
*
* @since 2.0.0
* @category constructors
*/
const TaggedClass = TaggedClass$1;
/**
* Complete a `Request` with the specified result.
*
* @since 2.0.0
* @category request completion
*/
const complete = complete$2;
/**
* Interrupts the child effect when requests are no longer needed
*
* @since 2.0.0
* @category request completion
*/
const interruptWhenPossible = interruptWhenPossible$1;
/**
* Complete a `Request` with the specified effectful computation, failing the
* request with the error from the effect workflow if it fails, and completing
* the request with the value of the effect workflow if it succeeds.
*
* @since 2.0.0
* @category request completion
*/
const completeEffect = completeEffect$1;
/**
* Complete a `Request` with the specified error.
*
* @since 2.0.0
* @category request completion
*/
const fail$2 = fail$5;
/**
* Complete a `Request` with the specified cause.
*
* @since 2.0.0
* @category request completion
*/
const failCause$1 = failCause$3;
/**
* Complete a `Request` with the specified value.
*
* @since 2.0.0
* @category request completion
*/
const succeed$2 = succeed$4;
/**
* @since 2.0.0
* @category guards
*/
const isEntry = isEntry$1;
/**
* @since 2.0.0
* @category constructors
*/
const makeEntry = makeEntry$1;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Effect.js
/**
* @since 2.0.0
* @category Symbols
*/
const EffectTypeId = EffectTypeId$2;
/**
* Checks if a given value is an `Effect` value.
*
* **When to Use**
*
* This function can be useful for checking the type of a value before
* attempting to operate on it as an `Effect` value. For example, you could use
* `Effect.isEffect` to check the type of a value before using it as an argument
* to a function that expects an `Effect` value.
*
* @since 2.0.0
* @category Guards
*/
const isEffect = isEffect$1;
/**
* Returns an effect that caches its result for a specified `Duration`,
* known as "timeToLive" (TTL).
*
* **Details**
*
* This function is used to cache the result of an effect for a specified amount
* of time. This means that the first time the effect is evaluated, its result
* is computed and stored.
*
* If the effect is evaluated again within the specified `timeToLive`, the
* cached result will be used, avoiding recomputation.
*
* After the specified duration has passed, the cache expires, and the effect
* will be recomputed upon the next evaluation.
*
* **When to Use**
*
* Use this function when you have an effect that involves costly operations or
* computations, and you want to avoid repeating them within a short time frame.
*
* It's ideal for scenarios where the result of an effect doesn't change
* frequently and can be reused for a specified duration.
*
* By caching the result, you can improve efficiency and reduce unnecessary
* computations, especially in performance-critical applications.
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* let i = 1
* const expensiveTask = Effect.promise<string>(() => {
*   console.log("expensive task...")
*   return new Promise((resolve) => {
*     setTimeout(() => {
*       resolve(`result ${i++}`)
*     }, 100)
*   })
* })
*
* const program = Effect.gen(function* () {
*   const cached = yield* Effect.cachedWithTTL(expensiveTask, "150 millis")
*   yield* cached.pipe(Effect.andThen(Console.log))
*   yield* cached.pipe(Effect.andThen(Console.log))
*   yield* Effect.sleep("100 millis")
*   yield* cached.pipe(Effect.andThen(Console.log))
* })
*
* Effect.runFork(program)
* // Output:
* // expensive task...
* // result 1
* // result 1
* // expensive task...
* // result 2
* ```
*
* @see {@link cached} for a similar function that caches the result
* indefinitely.
* @see {@link cachedInvalidateWithTTL} for a similar function that includes an
* additional effect for manually invalidating the cached value.
*
* @since 2.0.0
* @category Caching
*/
const cachedWithTTL = cached$1;
/**
* Caches an effect's result for a specified duration and allows manual
* invalidation before expiration.
*
* **Details**
*
* This function behaves similarly to {@link cachedWithTTL} by caching the
* result of an effect for a specified period of time. However, it introduces an
* additional feature: it provides an effect that allows you to manually
* invalidate the cached result before it naturally expires.
*
* This gives you more control over the cache, allowing you to refresh the
* result when needed, even if the original cache has not yet expired.
*
* Once the cache is invalidated, the next time the effect is evaluated, the
* result will be recomputed, and the cache will be refreshed.
*
* **When to Use**
*
* Use this function when you have an effect whose result needs to be cached for
* a certain period, but you also want the option to refresh the cache manually
* before the expiration time.
*
* This is useful when you need to ensure that the cached data remains valid for
* a certain period but still want to invalidate it if the underlying data
* changes or if you want to force a recomputation.
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* let i = 1
* const expensiveTask = Effect.promise<string>(() => {
*   console.log("expensive task...")
*   return new Promise((resolve) => {
*     setTimeout(() => {
*       resolve(`result ${i++}`)
*     }, 100)
*   })
* })
*
* const program = Effect.gen(function* () {
*   const [cached, invalidate] = yield* Effect.cachedInvalidateWithTTL(
*     expensiveTask,
*     "1 hour"
*   )
*   yield* cached.pipe(Effect.andThen(Console.log))
*   yield* cached.pipe(Effect.andThen(Console.log))
*   yield* invalidate
*   yield* cached.pipe(Effect.andThen(Console.log))
* })
*
* Effect.runFork(program)
* // Output:
* // expensive task...
* // result 1
* // result 1
* // expensive task...
* // result 2
* ```
*
* @see {@link cached} for a similar function that caches the result
* indefinitely.
* @see {@link cachedWithTTL} for a similar function that caches the result for
* a specified duration but does not include an effect for manual invalidation.
*
* @since 2.0.0
* @category Caching
*/
const cachedInvalidateWithTTL = cachedInvalidateWithTTL$1;
/**
* Returns an effect that lazily computes a result and caches it for subsequent
* evaluations.
*
* **Details**
*
* This function wraps an effect and ensures that its result is computed only
* once. Once the result is computed, it is cached, meaning that subsequent
* evaluations of the same effect will return the cached result without
* re-executing the logic.
*
* **When to Use**
*
* Use this function when you have an expensive or time-consuming operation that
* you want to avoid repeating. The first evaluation will compute the result,
* and all following evaluations will immediately return the cached value,
* improving performance and reducing unnecessary work.
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* let i = 1
* const expensiveTask = Effect.promise<string>(() => {
*   console.log("expensive task...")
*   return new Promise((resolve) => {
*     setTimeout(() => {
*       resolve(`result ${i++}`)
*     }, 100)
*   })
* })
*
* const program = Effect.gen(function* () {
*   console.log("non-cached version:")
*   yield* expensiveTask.pipe(Effect.andThen(Console.log))
*   yield* expensiveTask.pipe(Effect.andThen(Console.log))
*   console.log("cached version:")
*   const cached = yield* Effect.cached(expensiveTask)
*   yield* cached.pipe(Effect.andThen(Console.log))
*   yield* cached.pipe(Effect.andThen(Console.log))
* })
*
* Effect.runFork(program)
* // Output:
* // non-cached version:
* // expensive task...
* // result 1
* // expensive task...
* // result 2
* // cached version:
* // expensive task...
* // result 3
* // result 3
* ```
*
* @see {@link cachedWithTTL} for a similar function that includes a
* time-to-live duration for the cached value.
* @see {@link cachedInvalidateWithTTL} for a similar function that includes an
* additional effect for manually invalidating the cached value.
*
* @since 2.0.0
* @category Caching
*/
const cached = memoize;
/**
* Returns a memoized version of a function with effects, reusing results for
* the same inputs.
*
* **Details**
*
* This function creates a memoized version of a given function that performs an
* effect. Memoization ensures that once a result is computed for a specific
* input, it is stored and reused for subsequent calls with the same input,
* reducing the need to recompute the result.
*
* The function can optionally take an `Equivalence` parameter to
* determine how inputs are compared for caching purposes.
*
* **When to Use**
*
* Use this function when you have a function that performs an effect and you
* want to avoid recomputing the result for the same input multiple times.
*
* It's ideal for functions that produce deterministic results based on their
* inputs, and you want to improve performance by caching the output.
*
* This is particularly useful in scenarios where the function involves
* expensive calculations or operations that should be avoided after the first
* execution with the same parameters.
*
* **Example**
*
* ```ts
* import { Effect, Random } from "effect"
*
* const program = Effect.gen(function* () {
*   const randomNumber = (n: number) => Random.nextIntBetween(1, n)
*   console.log("non-memoized version:")
*   console.log(yield* randomNumber(10))
*   console.log(yield* randomNumber(10))
*
*   console.log("memoized version:")
*   const memoized = yield* Effect.cachedFunction(randomNumber)
*   console.log(yield* memoized(10))
*   console.log(yield* memoized(10))
* })
*
* Effect.runFork(program)
* // Example Output:
* // non-memoized version:
* // 2
* // 8
* // memoized version:
* // 5
* // 5
* ```
*
* @since 2.0.0
* @category Caching
*/
const cachedFunction = cachedFunction$1;
/**
* Returns an effect that executes only once, regardless of how many times it's
* called.
*
* **Details**
*
* This function ensures that a specific effect is executed only a single time,
* no matter how many times it is invoked. The result of the effect will be
* cached, and subsequent calls to the effect will immediately return the cached
* result without re-executing the original logic.
*
* **When to Use**
*
* Use this function when you need to perform a task only once, regardless of
* how many times the effect is triggered. It's particularly useful when you
* have initialization tasks, logging, or other one-time actions that should not
* be repeated. This can help optimize performance and avoid redundant actions.
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* const program = Effect.gen(function* () {
*   const task1 = Console.log("task1")
*   yield* Effect.repeatN(task1, 2)
*   const task2 = yield* Effect.once(Console.log("task2"))
*   yield* Effect.repeatN(task2, 2)
* })
*
* Effect.runFork(program)
* // Output:
* // task1
* // task1
* // task1
* // task2
* ```
*
* @since 2.0.0
* @category Caching
*/
const once = once$2;
/**
* Combines multiple effects into one, returning results based on the input
* structure.
*
* **Details**
*
* Use this function when you need to run multiple effects and combine their
* results into a single output. It supports tuples, iterables, structs, and
* records, making it flexible for different input types.
*
* For instance, if the input is a tuple:
*
* ```ts skip-type-checking
* //         ┌─── a tuple of effects
* //         ▼
* Effect.all([effect1, effect2, ...])
* ```
*
* the effects are executed sequentially, and the result is a new effect
* containing the results as a tuple. The results in the tuple match the order
* of the effects passed to `Effect.all`.
*
* **Concurrency**
*
* You can control the execution order (e.g., sequential vs. concurrent) using
* the `concurrency` option.
*
* **Short-Circuiting Behavior**
*
* This function stops execution on the first error it encounters, this is
* called "short-circuiting". If any effect in the collection fails, the
* remaining effects will not run, and the error will be propagated. To change
* this behavior, you can use the `mode` option, which allows all effects to run
* and collect results as `Either` or `Option`.
*
* **The `mode` option**
*
* The `{ mode: "either" }` option changes the behavior of `Effect.all` to
* ensure all effects run, even if some fail. Instead of stopping on the first
* failure, this mode collects both successes and failures, returning an array
* of `Either` instances where each result is either a `Right` (success) or a
* `Left` (failure).
*
* Similarly, the `{ mode: "validate" }` option uses `Option` to indicate
* success or failure. Each effect returns `None` for success and `Some` with
* the error for failure.
*
* **Example** (Combining Effects in Tuples)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const tupleOfEffects = [
*   Effect.succeed(42).pipe(Effect.tap(Console.log)),
*   Effect.succeed("Hello").pipe(Effect.tap(Console.log))
* ] as const
*
* //      ┌─── Effect<[number, string], never, never>
* //      ▼
* const resultsAsTuple = Effect.all(tupleOfEffects)
*
* Effect.runPromise(resultsAsTuple).then(console.log)
* // Output:
* // 42
* // Hello
* // [ 42, 'Hello' ]
* ```
*
* **Example** (Combining Effects in Iterables)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const iterableOfEffects: Iterable<Effect.Effect<number>> = [1, 2, 3].map(
*   (n) => Effect.succeed(n).pipe(Effect.tap(Console.log))
* )
*
* //      ┌─── Effect<number[], never, never>
* //      ▼
* const resultsAsArray = Effect.all(iterableOfEffects)
*
* Effect.runPromise(resultsAsArray).then(console.log)
* // Output:
* // 1
* // 2
* // 3
* // [ 1, 2, 3 ]
* ```
*
* **Example** (Combining Effects in Structs)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const structOfEffects = {
*   a: Effect.succeed(42).pipe(Effect.tap(Console.log)),
*   b: Effect.succeed("Hello").pipe(Effect.tap(Console.log))
* }
*
* //      ┌─── Effect<{ a: number; b: string; }, never, never>
* //      ▼
* const resultsAsStruct = Effect.all(structOfEffects)
*
* Effect.runPromise(resultsAsStruct).then(console.log)
* // Output:
* // 42
* // Hello
* // { a: 42, b: 'Hello' }
* ```
*
* **Example** (Combining Effects in Records)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const recordOfEffects: Record<string, Effect.Effect<number>> = {
*   key1: Effect.succeed(1).pipe(Effect.tap(Console.log)),
*   key2: Effect.succeed(2).pipe(Effect.tap(Console.log))
* }
*
* //      ┌─── Effect<{ [x: string]: number; }, never, never>
* //      ▼
* const resultsAsRecord = Effect.all(recordOfEffects)
*
* Effect.runPromise(resultsAsRecord).then(console.log)
* // Output:
* // 1
* // 2
* // { key1: 1, key2: 2 }
* ```
*
* **Example** (Short-Circuiting Behavior)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const program = Effect.all([
*   Effect.succeed("Task1").pipe(Effect.tap(Console.log)),
*   Effect.fail("Task2: Oh no!").pipe(Effect.tap(Console.log)),
*   // Won't execute due to earlier failure
*   Effect.succeed("Task3").pipe(Effect.tap(Console.log))
* ])
*
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // Task1
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Task2: Oh no!' }
* // }
* ```
*
* **Example** (Collecting Results with `mode: "either"`)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const effects = [
*   Effect.succeed("Task1").pipe(Effect.tap(Console.log)),
*   Effect.fail("Task2: Oh no!").pipe(Effect.tap(Console.log)),
*   Effect.succeed("Task3").pipe(Effect.tap(Console.log))
* ]
*
* const program = Effect.all(effects, { mode: "either" })
*
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // Task1
* // Task3
* // {
* //   _id: 'Exit',
* //   _tag: 'Success',
* //   value: [
* //     { _id: 'Either', _tag: 'Right', right: 'Task1' },
* //     { _id: 'Either', _tag: 'Left', left: 'Task2: Oh no!' },
* //     { _id: 'Either', _tag: 'Right', right: 'Task3' }
* //   ]
* // }
* ```
*
* **Example** (Collecting Results with `mode: "validate"`)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const effects = [
*   Effect.succeed("Task1").pipe(Effect.tap(Console.log)),
*   Effect.fail("Task2: Oh no!").pipe(Effect.tap(Console.log)),
*   Effect.succeed("Task3").pipe(Effect.tap(Console.log))
* ]
*
* const program = Effect.all(effects, { mode: "validate" })
*
* Effect.runPromiseExit(program).then((result) => console.log("%o", result))
* // Output:
* // Task1
* // Task3
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: {
* //     _id: 'Cause',
* //     _tag: 'Fail',
* //     failure: [
* //       { _id: 'Option', _tag: 'None' },
* //       { _id: 'Option', _tag: 'Some', value: 'Task2: Oh no!' },
* //       { _id: 'Option', _tag: 'None' }
* //     ]
* //   }
* // }
* ```
*
* @see {@link forEach} for iterating over elements and applying an effect.
* @see {@link allWith} for a data-last version of this function.
*
* @since 2.0.0
* @category Collecting
*/
const all = all$2;
/**
* A data-last version of {@link all}, designed for use in pipelines.
*
* **When to Use**
*
* This function enables you to combine multiple effects and customize execution
* options such as concurrency levels. This version is useful in functional
* pipelines where you first define your data and then apply operations to it.
*
* **Example**
*
* ```ts
* import { Effect, pipe } from "effect"
*
* const task1 = Effect.succeed(1).pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Effect.log("task1 done"))
* )
*
* const task2 = Effect.succeed("hello").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Effect.log("task2 done"))
* )
*
* const program = pipe(
*   [task1, task2],
*   // Run both effects concurrently using the concurrent option
*   Effect.allWith({ concurrency: 2 })
* )
*
* Effect.runPromise(program).then(console.log)
* // Output:
* // timestamp=... level=INFO fiber=#3 message="task2 done"
* // timestamp=... level=INFO fiber=#2 message="task1 done"
* // [ 1, 'hello' ]
* ```
*
* @since 2.0.0
* @category Collecting
*/
const allWith = allWith$1;
/**
* Evaluates and runs each effect in the iterable, collecting only the
* successful results while discarding failures.
*
* **Details**
*
* This function function processes an iterable of effects and runs each one. If
* an effect is successful, its result is collected; if it fails, the result is
* discarded. This ensures that only successful outcomes are kept.
*
* **Options**
*
* The function also allows you to customize how the effects are handled by
* specifying options such as concurrency, batching, and how finalizers behave.
* These options provide flexibility in running the effects concurrently or
* adjusting other execution details.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const tasks = [
*   Effect.succeed(1),
*   Effect.fail("Error 1"),
*   Effect.succeed(2),
*   Effect.fail("Error 2")
* ]
*
* const program = Effect.gen(function*() {
*   const successfulResults = yield* Effect.allSuccesses(tasks)
*   console.log(successfulResults)
* })
*
* Effect.runFork(program)
* // Output: [1, 2]
*
* ```
*
* @since 2.0.0
* @category Collecting
*/
const allSuccesses = allSuccesses$1;
/**
* Drops elements until the effectful predicate returns `true`.
*
* **Details**
*
* This function processes a collection of elements and uses an effectful
* predicate to determine when to stop dropping elements. It drops elements from
* the beginning of the collection until the predicate returns `true`.
*
* The predicate is a function that takes an element and its index in the
* collection and returns an effect that evaluates to a boolean.
*
* Once the predicate returns `true`, the remaining elements of the collection
* are returned.
*
* **Note**: The first element for which the predicate returns `true` is also
* dropped.
*
* **When to Use**
*
* This function allows you to conditionally skip over a part of the collection
* based on some criteria defined in the predicate.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const numbers = [1, 2, 3, 4, 5, 6]
* const predicate = (n: number, i: number) => Effect.succeed(n > 3)
*
* const program = Effect.gen(function*() {
*   const result = yield* Effect.dropUntil(numbers, predicate)
*   console.log(result)
* })
*
* Effect.runFork(program)
* // Output: [5, 6]
* ```
*
* @see {@link dropWhile} for a similar function that drops elements while the
* predicate returns `true`.
*
* @since 2.0.0
* @category Collecting
*/
const dropUntil = dropUntil$1;
/**
* Drops elements as long as the predicate returns `true`.
*
* **Details**
*
* This function processes a collection of elements and uses a predicate to
* decide whether to drop an element.
*
* The predicate is a function that takes an element and its index, and it
* returns an effect that evaluates to a boolean.
*
* As long as the predicate returns `true`, elements will continue to be dropped
* from the collection.
*
* Once the predicate returns `false`, the remaining elements are kept.
*
* **When to Use**
*
* This function allows you to discard elements from the start of a collection
* based on a condition, and only keep the rest when the condition no longer
* holds.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const numbers = [1, 2, 3, 4, 5, 6]
* const predicate = (n: number, i: number) => Effect.succeed(n <= 3)
*
* const program = Effect.gen(function*() {
*   const result = yield* Effect.dropWhile(numbers, predicate)
*   console.log(result)
* })
*
* Effect.runFork(program)
* // Output: [4, 5, 6]
* ```
*
* @see {@link dropUntil} for a similar function that drops elements until the
* predicate returns `true`.
*
* @since 2.0.0
* @category Collecting
*/
const dropWhile = dropWhile$1;
/**
* Takes elements from a collection until the effectful predicate returns
* `true`.
*
* **Details**
*
* This function processes a collection of elements and uses an effectful
* predicate to decide when to stop taking elements. The elements are taken from
* the beginning of the collection until the predicate returns `true`.
*
* The predicate is a function that takes an element and its index in the
* collection, and returns an effect that resolves to a boolean.
*
* Once the predicate returns `true`, the remaining elements of the collection
* are discarded, and the function stops taking more elements.
*
* **Note**: The first element for which the predicate returns `true` is also
* included in the result.
*
* **When to Use**
*
* Use this function when you want to conditionally take elements from a
* collection based on a dynamic condition. For example, you may want to collect
* numbers from a list until a certain threshold is reached, or gather items
* until a specific condition is met.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const numbers = [1, 2, 3, 4, 5, 6]
* const predicate = (n: number, i: number) => Effect.succeed(n > 3)
*
* const program = Effect.gen(function*() {
*   const result = yield* Effect.takeUntil(numbers, predicate)
*   console.log(result)
* })
*
* Effect.runFork(program)
* // Output: [ 1, 2, 3, 4 ]
* ```
*
* @see {@link takeWhile} for a similar function that takes elements while the
* predicate returns `true`.
*
* @since 2.0.0
* @category Collecting
*/
const takeUntil = takeUntil$1;
/**
* Takes elements as long as the predicate returns `true`.
*
* **Details**
*
* This function processes a collection of elements and uses a predicate to
* decide whether to take an element.
*
* The predicate is a function that takes an element and its index, and it
* returns an effect that evaluates to a boolean.
*
* As long as the predicate returns `true`, elements will continue to be taken
* from the collection.
*
* Once the predicate returns `false`, the remaining elements are discarded.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const numbers = [1, 2, 3, 4, 5, 6]
* const predicate = (n: number, i: number) => Effect.succeed(n <= 3)
*
* const program = Effect.gen(function*() {
*   const result = yield* Effect.takeWhile(numbers, predicate)
*   console.log(result)
* })
*
* Effect.runFork(program)
* // Output: [1, 2, 3]
* ```
*
* @see {@link takeUntil} for a similar function that takes elements until the predicate returns `true`.
*
* @since 2.0.0
* @category Collecting
*/
const takeWhile = takeWhile$1;
/**
* Determines whether all elements of the iterable satisfy the effectful
* predicate.
*
* **Details**
*
* This function checks whether every element in a given collection (an
* iterable) satisfies a condition defined by an effectful predicate.
*
* The predicate is a function that takes an element and its index, and it
* returns an effect that evaluates to a boolean.
*
* The function will process each element and return `true` if all elements
* satisfy the predicate; otherwise, it returns `false`.
*
* **When to Use**
*
* This function is useful when you need to verify that all items in a
* collection meet certain criteria, even when the evaluation of each item
* involves effects, such as asynchronous checks or complex computations.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const numbers = [2, 4, 6, 8]
* const predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)
*
* const program = Effect.gen(function*() {
*   const allEven = yield* Effect.every(numbers, predicate)
*   console.log(allEven)
* })
*
* Effect.runFork(program)
* // Output: true
* ```
*
* @see {@link exists} for a similar function that returns a boolean indicating
* whether **any** element satisfies the predicate.
*
* @since 2.0.0
* @category Condition Checking
*/
const every = every$1;
/**
* Determines whether any element of the iterable satisfies the effectual
* predicate.
*
* **Details**
*
* This function checks whether any element in a given collection (an iterable)
* satisfies a condition defined by an effectful predicate.
*
* The predicate is a function that takes an element and its index, and it
* returns an effect that evaluates to a boolean.
*
* The function will process each element, and if any element satisfies the
* predicate (returns `true`), the function will immediately return `true`.
*
* If none of the elements satisfy the condition, it will return `false`.
*
* **When to Use**
*
* This function allows you to quickly check for a condition in a collection
* without having to manually iterate over it.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const numbers = [1, 2, 3, 4]
* const predicate = (n: number, i: number) => Effect.succeed(n > 2)
*
* const program = Effect.gen(function*() {
*   const hasLargeNumber = yield* Effect.exists(numbers, predicate)
*   console.log(hasLargeNumber)
* })
*
* Effect.runFork(program)
* // Output: true
* ```
*
* @see {@link every} for a similar function that checks if **all** elements
* satisfy the predicate.
*
* @since 2.0.0
* @category Condition Checking
*/
const exists = exists$1;
/**
* Filters an iterable using the specified effectful predicate.
*
* **Details**
*
* This function filters a collection (an iterable) by applying an effectful
* predicate.
*
* The predicate is a function that takes an element and its index, and it
* returns an effect that evaluates to a boolean.
*
* The function processes each element in the collection and keeps only those
* that satisfy the condition defined by the predicate.
*
* **Options**
*
* You can also adjust the behavior with options such as concurrency, batching,
* or whether to negate the condition.
*
* **When to Use**
*
* This function allows you to selectively keep or remove elements based on a
* condition that may involve asynchronous or side-effect-causing operations.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const numbers = [1, 2, 3, 4, 5]
* const predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)
*
* const program = Effect.gen(function*() {
*   const result = yield* Effect.filter(numbers, predicate)
*   console.log(result)
* })
*
* Effect.runFork(program)
* // Output: [2, 4]
* ```
*
* @since 2.0.0
* @category Filtering
*/
const filter = filter$2;
/**
* Filters and maps elements sequentially in one operation.
*
* This function processes each element one by one. It applies a function that
* returns an `Option` to each element. If the function returns `Some`, the
* element is kept; if it returns `None`, the element is removed. The operation
* is done sequentially for each element.
*
* **Example**
*
* ```ts
* import { Console, Effect, Option } from "effect"
*
* const task = (n: number) =>
*   Effect.succeed(n).pipe(
*     Effect.delay(1000 - (n * 100)),
*     Effect.tap(Console.log(`task${n} done`))
*   )
*
* const program = Effect.filterMap(
*   [task(1), task(2), task(3), task(4)],
*   (n) => n % 2 === 0 ? Option.some(n) : Option.none()
* )
*
* Effect.runPromise(program).then(console.log)
* // Output:
* // task1 done
* // task2 done
* // task3 done
* // task4 done
* // [ 2, 4 ]
* ```
*
* @since 2.0.0
* @category Filtering
*/
const filterMap = filterMap$1;
/**
* Returns the first element that satisfies the effectful predicate.
*
* **Details**
*
* This function processes a collection of elements and applies an effectful
* predicate to each element.
*
* The predicate is a function that takes an element and its index in the
* collection, and it returns an effect that evaluates to a boolean.
*
* The function stops as soon as it finds the first element for which the
* predicate returns `true` and returns that element wrapped in an `Option`.
*
* If no element satisfies the predicate, the result will be `None`.
*
* **When to Use**
*
* This function allows you to efficiently find an element that meets a specific
* condition, even when the evaluation involves effects like asynchronous
* operations or side effects.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const numbers = [1, 2, 3, 4, 5]
* const predicate = (n: number, i: number) => Effect.succeed(n > 3)
*
* const program = Effect.gen(function*() {
*   const result = yield* Effect.findFirst(numbers, predicate)
*   console.log(result)
* })
*
* Effect.runFork(program)
* // Output: { _id: 'Option', _tag: 'Some', value: 4 }
* ```
*
* @since 2.0.0
* @category Collecting
*/
const findFirst = findFirst$3;
/**
* Executes an effectful operation for each element in an `Iterable`.
*
* **Details**
*
* This function applies a provided operation to each element in the iterable,
* producing a new effect that returns an array of results.
*
* If any effect fails, the iteration stops immediately (short-circuiting), and
* the error is propagated.
*
* **Concurrency**
*
* The `concurrency` option controls how many operations are performed
* concurrently. By default, the operations are performed sequentially.
*
* **Discarding Results**
*
* If the `discard` option is set to `true`, the intermediate results are not
* collected, and the final result of the operation is `void`.
*
* **Example** (Applying Effects to Iterable Elements)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const result = Effect.forEach([1, 2, 3, 4, 5], (n, index) =>
*   Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2))
* )
*
* Effect.runPromise(result).then(console.log)
* // Output:
* // Currently at index 0
* // Currently at index 1
* // Currently at index 2
* // Currently at index 3
* // Currently at index 4
* // [ 2, 4, 6, 8, 10 ]
* ```
*
* **Example** (Discarding Results)
*
* ```ts
* import { Effect, Console } from "effect"
*
* // Apply effects but discard the results
* const result = Effect.forEach(
*   [1, 2, 3, 4, 5],
*   (n, index) =>
*     Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2)),
*   { discard: true }
* )
*
* Effect.runPromise(result).then(console.log)
* // Output:
* // Currently at index 0
* // Currently at index 1
* // Currently at index 2
* // Currently at index 3
* // Currently at index 4
* // undefined
* ```
*
* @see {@link all} for combining multiple effects into one.
*
* @since 2.0.0
* @category Looping
*/
const forEach = forEach$1;
/**
* Returns the first element of the iterable if the collection is non-empty, or
* fails with the error `NoSuchElementException` if the collection is empty.
*
* **When to Use**
*
* This function is useful when you need to retrieve the first item from a
* collection and want to handle the case where the collection might be empty
* without causing an unhandled exception.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* // Simulate an async operation
* const fetchNumbers = Effect.succeed([1, 2, 3]).pipe(Effect.delay("100 millis"))
*
* const program = Effect.gen(function*() {
*   const firstElement = yield* Effect.head(fetchNumbers)
*   console.log(firstElement)
* })
*
* Effect.runFork(program)
* // Output: 1
* ```
*
* @since 2.0.0
* @category Collecting
*/
const head = head$1;
/**
* Merges an `Iterable<Effect<A, E, R>>` to a single effect.
*
* **Details**
*
* This function takes an iterable of effects and combines them into a single
* effect. It does this by iterating over each effect in the collection and
* applying a function that accumulates results into a "zero" value, which
* starts with an initial value and is updated with each effect's success.
*
* The provided function `f` is called for each element in the iterable,
* allowing you to specify how to combine the results.
*
* **Options**
*
* The function also allows you to customize how the effects are handled by
* specifying options such as concurrency, batching, and how finalizers behave.
* These options provide flexibility in running the effects concurrently or
* adjusting other execution details.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const numbers = [Effect.succeed(1), Effect.succeed(2), Effect.succeed(3)]
* const add = (sum: number, value: number, i: number) => sum + value
* const zero = 0
*
* const program = Effect.gen(function*() {
*   const total = yield* Effect.mergeAll(numbers, zero, add)
*   console.log(total)
* })
*
* Effect.runFork(program)
* // Output: 6
* ```
*
* @since 2.0.0
* @category Collecting
*/
const mergeAll = mergeAll$2;
/**
* Processes an iterable and applies an effectful function to each element,
* categorizing the results into successes and failures.
*
* **Details**
*
* This function processes each element in the provided iterable by applying an
* effectful function to it. The results are then categorized into two separate
* lists: one for failures and another for successes. This separation allows you
* to handle the two categories differently. Failures are collected in a list
* without interrupting the processing of the remaining elements, so the
* operation continues even if some elements fail. This is particularly useful
* when you need to handle both successful and failed results separately,
* without stopping the entire process on encountering a failure.
*
* **When to Use**
*
* Use this function when you want to process a collection of items and handle
* errors or failures without interrupting the processing of other items. It's
* useful when you need to distinguish between successful and failed results and
* process them separately, for example, when logging errors while continuing to
* work with valid data. The function ensures that failures are captured, while
* successes are processed normally.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* //      ┌─── Effect<[string[], number[]], never, never>
* //      ▼
* const program = Effect.partition([0, 1, 2, 3, 4], (n) => {
*   if (n % 2 === 0) {
*     return Effect.succeed(n)
*   } else {
*     return Effect.fail(`${n} is not even`)
*   }
* })
*
* Effect.runPromise(program).then(console.log, console.error)
* // Output:
* // [ [ '1 is not even', '3 is not even' ], [ 0, 2, 4 ] ]
* ```
*
* @see {@link validateAll} for a function that either collects all failures or all successes.
* @see {@link validateFirst} for a function that stops at the first success.
*
* @since 2.0.0
* @category Error Accumulation
*/
const partition = partition$1;
/**
* Reduces an `Iterable<A>` using an effectual function `f`, working
* sequentially from left to right.
*
* **Details**
*
* This function takes an iterable and applies a function `f` to each element in
* the iterable. The function works sequentially, starting with an initial value
* `zero` and then combining it with each element in the collection. The
* provided function `f` is called for each element in the iterable, allowing
* you to accumulate a result based on the current value and the element being
* processed.
*
* **When to Use**
*
* The function is often used for operations like summing a collection of
* numbers or combining results from multiple tasks. It ensures that operations
* are performed one after the other, maintaining the order of the elements.
*
* **Example**
*
* ```ts
* import { Console, Effect } from "effect"
*
* const processOrder = (id: number) =>
*   Effect.succeed({ id, price: 100 * id })
*     .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))
*
* const program = Effect.reduce(
*   [1, 2, 3, 4],
*   0,
*   (acc, id, i) =>
*     processOrder(id)
*       .pipe(Effect.map((order) => acc + order.price))
* )
*
* Effect.runPromise(program).then(console.log)
* // Output:
* // Order 1 processed
* // Order 2 processed
* // Order 3 processed
* // Order 4 processed
* // 1000
* ```
*
* @see {@link reduceWhile} for a similar function that stops the process based on a predicate.
* @see {@link reduceRight} for a similar function that works from right to left.
*
* @since 2.0.0
* @category Collecting
*/
const reduce = reduce$4;
/**
* Reduces an `Iterable<A>` using an effectual function `body`, working
* sequentially from left to right, stopping the process early when the
* predicate `while` is not satisfied.
*
* **Details**
*
* This function processes a collection of elements, applying a function `body`
* to reduce them to a single value, starting from the first element. It checks
* the value of the accumulator against a predicate (`while`). If at any point
* the predicate returns `false`, the reduction stops, and the accumulated
* result is returned.
*
* **When to Use**
*
* Use this function when you need to reduce a collection of elements, but only
* continue the process as long as a certain condition holds true. For example,
* if you want to sum values in a list but stop as soon as the sum exceeds a
* certain threshold, you can use this function.
*
* **Example**
*
* ```ts
* import { Console, Effect } from "effect"
*
* const processOrder = (id: number) =>
*   Effect.succeed({ id, price: 100 * id })
*     .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))
*
* const program = Effect.reduceWhile(
*   [1, 2, 3, 4],
*   0,
*   {
*     body: (acc, id, i) =>
*       processOrder(id)
*         .pipe(Effect.map((order) => acc + order.price)),
*     while: (acc) => acc < 500
*   }
* )
*
* Effect.runPromise(program).then(console.log)
* // Output:
* // Order 1 processed
* // Order 2 processed
* // Order 3 processed
* // 600
* ```
*
* @since 2.0.0
* @category Collecting
*/
const reduceWhile = reduceWhile$1;
/**
* Reduces an `Iterable<A>` using an effectual function `f`, working
* sequentially from right to left.
*
* **Details**
*
* This function takes an iterable and applies a function `f` to each element in
* the iterable. The function works sequentially, starting with an initial value
* `zero` and then combining it with each element in the collection. The
* provided function `f` is called for each element in the iterable, allowing
* you to accumulate a result based on the current value and the element being
* processed.
*
* **When to Use**
*
* The function is often used for operations like summing a collection of
* numbers or combining results from multiple tasks. It ensures that operations
* are performed one after the other, maintaining the order of the elements.
*
* **Example**
*
* ```ts
* import { Console, Effect } from "effect"
*
* const processOrder = (id: number) =>
*   Effect.succeed({ id, price: 100 * id })
*     .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))
*
* const program = Effect.reduceRight(
*   [1, 2, 3, 4],
*   0,
*   (id, acc, i) =>
*     processOrder(id)
*       .pipe(Effect.map((order) => acc + order.price))
* )
*
* Effect.runPromise(program).then(console.log)
* // Output:
* // Order 4 processed
* // Order 3 processed
* // Order 2 processed
* // Order 1 processed
* // 1000
* ```
*
* @see {@link reduce} for a similar function that works from left to right.
*
* @since 2.0.0
* @category Collecting
*/
const reduceRight = reduceRight$1;
/**
* Reduces an `Iterable<Effect<A, E, R>>` to a single effect.
*
* **Details**
*
* This function processes a collection of effects and combines them into one
* single effect. It starts with an initial effect (`zero`) and applies a
* function `f` to each element in the collection.
*
* **Options**
*
* The function also allows you to customize how the effects are handled by
* specifying options such as concurrency, batching, and how finalizers behave.
* These options provide flexibility in running the effects concurrently or
* adjusting other execution details.
*
* **Example**
*
* ```ts
* import { Console, Effect } from "effect"
*
* const processOrder = (id: number) =>
*   Effect.succeed({ id, price: 100 * id })
*     .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))
*
* const program = Effect.reduceEffect(
*   [processOrder(1), processOrder(2), processOrder(3), processOrder(4)],
*   Effect.succeed(0),
*   (acc, order, i) => acc + order.price
* )
*
* Effect.runPromise(program).then(console.log)
* // Output:
* // Order 1 processed
* // Order 2 processed
* // Order 3 processed
* // Order 4 processed
* // 1000
* ```
*
* @since 2.0.0
* @category Collecting
*/
const reduceEffect = reduceEffect$1;
/**
* Replicates the given effect `n` times.
*
* **Details**
*
* This function takes an effect and replicates it a specified number of times
* (`n`). The result is an array of `n` effects, each of which is identical to
* the original effect.
*
* **Example**
*
* ```ts
* import { Console, Effect } from "effect"
*
* const task = Effect.succeed("Hello, World!").pipe(
*   Effect.tap(Console.log)
* )
*
* const program = Effect.gen(function*() {
*   // Replicate the task 3 times
*   const tasks = Effect.replicate(task, 3)
*   for (const t of tasks) {
*     // Run each task
*     yield* t
*   }
* })
*
* Effect.runFork(program)
* // Output:
* // Hello, World!
* // Hello, World!
* // Hello, World!
* ```
*
* @since 2.0.0
*/
const replicate = replicate$1;
/**
* Performs this effect the specified number of times and collects the results.
*
* **Details**
*
* This function repeats an effect multiple times and collects the results into
* an array. You specify how many times to execute the effect, and it runs that
* many times, either in sequence or concurrently depending on the provided
* options.
*
* **Options**
*
* If the `discard` option is set to `true`, the intermediate results are not
* collected, and the final result of the operation is `void`.
*
* The function also allows you to customize how the effects are handled by
* specifying options such as concurrency, batching, and how finalizers behave.
* These options provide flexibility in running the effects concurrently or
* adjusting other execution details.
*
* **Example**
*
* ```ts
* import { Console, Effect } from "effect"
*
* let counter = 0
*
* const task = Effect.sync(() => ++counter).pipe(
*   Effect.tap(() => Console.log(`Task completed`))
* )
*
* const program = Effect.gen(function*() {
*   // Replicate the task 3 times and collect the results
*   const results = yield* Effect.replicateEffect(task, 3)
*   yield* Console.log(`Results: ${results.join(", ")}`)
* })
*
* Effect.runFork(program)
* // Output:
* // Task completed
* // Task completed
* // Task completed
* // Results: 1, 2, 3
* ```
*
* @since 2.0.0
* @category Collecting
*/
const replicateEffect = replicateEffect$1;
/**
* Applies an effectful operation to each element in a collection while
* collecting both successes and failures.
*
* **Details**
*
* This function allows you to apply an effectful operation to every item in a
* collection.
*
* Unlike {@link forEach}, which would stop at the first error, this function
* continues processing all elements, accumulating both successes and failures.
*
* **When to Use**
*
* Use this function when you want to process every item in a collection, even
* if some items fail. This is particularly useful when you need to perform
* operations on all elements without halting due to an error.
*
* Keep in mind that if there are any failures, **all successes will be lost**,
* so this function is not suitable when you need to keep the successful results
* in case of errors.
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* //      ┌─── Effect<number[], [string, ...string[]], never>
* //      ▼
* const program = Effect.validateAll([1, 2, 3, 4, 5], (n) => {
*   if (n < 4) {
*     return Console.log(`item ${n}`).pipe(Effect.as(n))
*   } else {
*     return Effect.fail(`${n} is not less that 4`)
*   }
* })
*
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // item 1
* // item 2
* // item 3
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: {
* //     _id: 'Cause',
* //     _tag: 'Fail',
* //     failure: [ '4 is not less that 4', '5 is not less that 4' ]
* //   }
* // }
* ```
*
* @see {@link forEach} for a similar function that stops at the first error.
* @see {@link partition} when you need to separate successes and failures
* instead of losing successes with errors.
*
* @since 2.0.0
* @category Error Accumulation
*/
const validateAll = validateAll$1;
/**
* This function is similar to {@link validateAll} but with a key difference: it
* returns the first successful result or all errors if none of the operations
* succeed.
*
* **Details**
*
* This function processes a collection of elements and applies an effectful
* operation to each. Unlike {@link validateAll}, which accumulates both
* successes and failures, `Effect.validateFirst` stops and returns the first
* success it encounters. If no success occurs, it returns all accumulated
* errors. This can be useful when you are interested in the first successful
* result and want to avoid processing further once a valid result is found.
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* //      ┌─── Effect<number, string[], never>
* //      ▼
* const program = Effect.validateFirst([1, 2, 3, 4, 5], (n) => {
*   if (n < 4) {
*     return Effect.fail(`${n} is not less that 4`)
*   } else {
*     return Console.log(`item ${n}`).pipe(Effect.as(n))
*   }
* })
*
* Effect.runPromise(program).then(console.log, console.error)
* // Output:
* // item 4
* // 4
* ```
*
* @see {@link validateAll} for a similar function that accumulates all results.
* @see {@link firstSuccessOf} for a similar function that processes multiple
* effects and returns the first successful one or the last error.
*
* @since 2.0.0
* @category Error Accumulation
*/
const validateFirst = validateFirst$1;
/**
* Creates an `Effect` from a callback-based asynchronous function.
*
* **Details**
*
* The `resume` function:
* - Must be called exactly once. Any additional calls will be ignored.
* - Can return an optional `Effect` that will be run if the `Fiber` executing
*   this `Effect` is interrupted. This can be useful in scenarios where you
*   need to handle resource cleanup if the operation is interrupted.
* - Can receive an `AbortSignal` to handle interruption if needed.
*
* The `FiberId` of the fiber that may complete the async callback may also be
* specified using the `blockingOn` argument. This is called the "blocking
* fiber" because it suspends the fiber executing the `async` effect (i.e.
* semantically blocks the fiber from making progress). Specifying this fiber id
* in cases where it is known will improve diagnostics, but not affect the
* behavior of the returned effect.
*
* **When to Use**
*
* Use `Effect.async` when dealing with APIs that use callback-style instead of
* `async/await` or `Promise`.
*
* **Example** (Wrapping a Callback API)
*
* ```ts
* import { Effect } from "effect"
* import * as NodeFS from "node:fs"
*
* const readFile = (filename: string) =>
*   Effect.async<Buffer, Error>((resume) => {
*     NodeFS.readFile(filename, (error, data) => {
*       if (error) {
*         // Resume with a failed Effect if an error occurs
*         resume(Effect.fail(error))
*       } else {
*         // Resume with a succeeded Effect if successful
*         resume(Effect.succeed(data))
*       }
*     })
*   })
*
* //      ┌─── Effect<Buffer, Error, never>
* //      ▼
* const program = readFile("example.txt")
* ```
*
* **Example** (Handling Interruption with Cleanup)
*
* ```ts
* import { Effect, Fiber } from "effect"
* import * as NodeFS from "node:fs"
*
* // Simulates a long-running operation to write to a file
* const writeFileWithCleanup = (filename: string, data: string) =>
*   Effect.async<void, Error>((resume) => {
*     const writeStream = NodeFS.createWriteStream(filename)
*
*     // Start writing data to the file
*     writeStream.write(data)
*
*     // When the stream is finished, resume with success
*     writeStream.on("finish", () => resume(Effect.void))
*
*     // In case of an error during writing, resume with failure
*     writeStream.on("error", (err) => resume(Effect.fail(err)))
*
*     // Handle interruption by returning a cleanup effect
*     return Effect.sync(() => {
*       console.log(`Cleaning up ${filename}`)
*       NodeFS.unlinkSync(filename)
*     })
*   })
*
* const program = Effect.gen(function* () {
*   const fiber = yield* Effect.fork(
*     writeFileWithCleanup("example.txt", "Some long data...")
*   )
*   // Simulate interrupting the fiber after 1 second
*   yield* Effect.sleep("1 second")
*   yield* Fiber.interrupt(fiber) // This will trigger the cleanup
* })
*
* // Run the program
* Effect.runPromise(program)
* // Output:
* // Cleaning up example.txt
* ```
*
* **Example** (Handling Interruption with AbortSignal)
*
* ```ts
* import { Effect, Fiber } from "effect"
*
* // A task that supports interruption using AbortSignal
* const interruptibleTask = Effect.async<void, Error>((resume, signal) => {
*   // Handle interruption
*   signal.addEventListener("abort", () => {
*     console.log("Abort signal received")
*     clearTimeout(timeoutId)
*   })
*
*   // Simulate a long-running task
*   const timeoutId = setTimeout(() => {
*     console.log("Operation completed")
*     resume(Effect.void)
*   }, 2000)
* })
*
* const program = Effect.gen(function* () {
*   const fiber = yield* Effect.fork(interruptibleTask)
*   // Simulate interrupting the fiber after 1 second
*   yield* Effect.sleep("1 second")
*   yield* Fiber.interrupt(fiber)
* })
*
* // Run the program
* Effect.runPromise(program)
* // Output:
* // Abort signal received
* ```
*
* @since 2.0.0
* @category Creating Effects
*/
const async = async_;
/**
* A variant of {@link async} where the registration function may return an `Effect`.
*
* @since 2.0.0
* @category Creating Effects
*/
const asyncEffect = asyncEffect$1;
/**
* Low level constructor that enables for custom stack tracing cutpoints.
*
* It is meant to be called with a bag of instructions that become available in
* the "this" of the effect.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const throwingFunction = () => { throw new Error() }
* const blowUp = Effect.custom(throwingFunction, function() {
*   return Effect.succeed(this.effect_instruction_i0())
* })
* ```
*
* @since 2.0.0
* @category Creating Effects
*/
const custom = custom$1;
/**
* @since 2.0.0
* @category Creating Effects
*/
const withFiberRuntime = withFiberRuntime$1;
/**
* Creates an `Effect` that represents a recoverable error.
*
* **When to Use**
*
* Use this function to explicitly signal an error in an `Effect`. The error
* will keep propagating unless it is handled. You can handle the error with
* functions like {@link catchAll} or {@link catchTag}.
*
* **Example** (Creating a Failed Effect)
*
* ```ts
* import { Effect } from "effect"
*
* //      ┌─── Effect<never, Error, never>
* //      ▼
* const failure = Effect.fail(
*   new Error("Operation failed due to network error")
* )
* ```
*
* @see {@link succeed} to create an effect that represents a successful value.
*
* @since 2.0.0
* @category Creating Effects
*/
const fail$1 = fail$9;
/**
* Creates an `Effect` that fails with the specified error, evaluated lazily.
*
* @since 2.0.0
* @category Creating Effects
*/
const failSync = failSync$2;
/**
* Creates an `Effect` that fails with the specified `Cause`.
*
* @since 2.0.0
* @category Creating Effects
*/
const failCause = failCause$8;
/**
* Creates an `Effect` that fails with the specified `Cause`, evaluated lazily.
*
* @since 2.0.0
* @category Creating Effects
*/
const failCauseSync = failCauseSync$2;
/**
* Creates an effect that terminates a fiber with a specified error.
*
* **Details**
*
* This function is used to signal a defect, which represents a critical and
* unexpected error in the code. When invoked, it produces an effect that does
* not handle the error and instead terminates the fiber.
*
* The error channel of the resulting effect is of type `never`, indicating that
* it cannot recover from this failure.
*
* **When to Use**
*
* Use this function when encountering unexpected conditions in your code that
* should not be handled as regular errors but instead represent unrecoverable
* defects.
*
* **Example** (Terminating on Division by Zero with a Specified Error)
*
* ```ts
* import { Effect } from "effect"
*
* const divide = (a: number, b: number) =>
*   b === 0
*     ? Effect.die(new Error("Cannot divide by zero"))
*     : Effect.succeed(a / b)
*
* //      ┌─── Effect<number, never, never>
* //      ▼
* const program = divide(1, 0)
*
* Effect.runPromise(program).catch(console.error)
* // Output:
* // (FiberFailure) Error: Cannot divide by zero
* //   ...stack trace...
* ```
*
* @see {@link dieSync} for a variant that throws a specified error, evaluated
* lazily.
* @see {@link dieMessage} for a variant that throws a `RuntimeException` with a
* message.
*
* @since 2.0.0
* @category Creating Effects
*/
const die = die$4;
/**
* Creates an effect that terminates a fiber with a `RuntimeException`
* containing the specified message.
*
* **Details**
*
* This function is used to signal a defect, representing a critical and
* unexpected error in the code. When invoked, it produces an effect that
* terminates the fiber with a `RuntimeException` carrying the given message.
*
* The resulting effect has an error channel of type `never`, indicating it does
* not handle or recover from the error.
*
* **When to Use**
*
* Use this function when you want to terminate a fiber due to an unrecoverable
* defect and include a clear explanation in the message.
*
* **Example** (Terminating on Division by Zero with a Specified Message)
*
* ```ts
* import { Effect } from "effect"
*
* const divide = (a: number, b: number) =>
*   b === 0
*     ? Effect.dieMessage("Cannot divide by zero")
*     : Effect.succeed(a / b)
*
* //      ┌─── Effect<number, never, never>
* //      ▼
* const program = divide(1, 0)
*
* Effect.runPromise(program).catch(console.error)
* // Output:
* // (FiberFailure) RuntimeException: Cannot divide by zero
* //   ...stack trace...
* ```
*
* @see {@link die} for a variant that throws a specified error.
* @see {@link dieSync} for a variant that throws a specified error, evaluated
* lazily.
*
* @since 2.0.0
* @category Creating Effects
*/
const dieMessage = dieMessage$1;
/**
* Creates an effect that dies with the specified error, evaluated lazily.
*
* **Details**
*
* This function allows you to create an effect that will terminate with a fatal error.
* The error is provided as a lazy argument, meaning it will only be evaluated when the effect runs.
*
* @see {@link die} if you don't need to evaluate the error lazily.
*
* @since 2.0.0
* @category Creating Effects
*/
const dieSync = dieSync$2;
/**
* Provides a way to write effectful code using generator functions, simplifying
* control flow and error handling.
*
* **When to Use**
*
* `Effect.gen` allows you to write code that looks and behaves like synchronous
* code, but it can handle asynchronous tasks, errors, and complex control flow
* (like loops and conditions). It helps make asynchronous code more readable
* and easier to manage.
*
* The generator functions work similarly to `async/await` but with more
* explicit control over the execution of effects. You can `yield*` values from
* effects and return the final result at the end.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const addServiceCharge = (amount: number) => amount + 1
*
* const applyDiscount = (
*   total: number,
*   discountRate: number
* ): Effect.Effect<number, Error> =>
*   discountRate === 0
*     ? Effect.fail(new Error("Discount rate cannot be zero"))
*     : Effect.succeed(total - (total * discountRate) / 100)
*
* const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))
*
* const fetchDiscountRate = Effect.promise(() => Promise.resolve(5))
*
* export const program = Effect.gen(function* () {
*   const transactionAmount = yield* fetchTransactionAmount
*   const discountRate = yield* fetchDiscountRate
*   const discountedAmount = yield* applyDiscount(
*     transactionAmount,
*     discountRate
*   )
*   const finalAmount = addServiceCharge(discountedAmount)
*   return `Final amount to charge: ${finalAmount}`
* })
* ```
*
* @since 2.0.0
* @category Creating Effects
*/
const gen = gen$1;
/**
* An effect that that runs indefinitely and never produces any result. The
* moral equivalent of `while(true) {}`, only without the wasted CPU cycles.
*
* **When to Use**
*
* It could be useful for long-running background tasks or to simulate waiting
* behavior without actually consuming resources. This effect is ideal for cases
* where you want to keep the program alive or in a certain state without
* performing any active work.
*
* @since 2.0.0
* @category Creating Effects
*/
const never = never$3;
/**
* Ensures the `Option` is `None`, returning `void`. Otherwise, raises a
* `NoSuchElementException`.
*
* **Details**
*
* This function checks if the provided `Option` is `None`. If it is, it returns
* an effect that produces no result (i.e., `void`). If the `Option` is not
* `None` (i.e., it contains a value), the function will raise a
* `NoSuchElementException` error.
*
* **When to Use**
*
* This is useful when you want to ensure that a certain value is absent (i.e.,
* `None`) before continuing execution, and to handle cases where the value is
* unexpectedly present.
*
* @since 2.0.0
*/
const none = none$4;
/**
* Creates an `Effect` that represents an asynchronous computation guaranteed to
* succeed.
*
* **Details**
*
* The provided function (`thunk`) returns a `Promise` that should never reject; if it does, the error
* will be treated as a "defect".
*
* This defect is not a standard error but indicates a flaw in the logic that
* was expected to be error-free. You can think of it similar to an unexpected
* crash in the program, which can be further managed or logged using tools like
* {@link catchAllDefect}.
*
* **Interruptions**
*
* An optional `AbortSignal` can be provided to allow for interruption of the
* wrapped `Promise` API.
*
* **When to Use**
*
* Use this function when you are sure the operation will not reject.
*
* **Example** (Delayed Message)
*
* ```ts
* import { Effect } from "effect"
*
* const delay = (message: string) =>
*   Effect.promise<string>(
*     () =>
*       new Promise((resolve) => {
*         setTimeout(() => {
*           resolve(message)
*         }, 2000)
*       })
*   )
*
* //      ┌─── Effect<string, never, never>
* //      ▼
* const program = delay("Async operation completed successfully!")
* ```
*
* @see {@link tryPromise} for a version that can handle failures.
*
* @since 2.0.0
* @category Creating Effects
*/
const promise = promise$1;
/**
* Creates an `Effect` that always succeeds with a given value.
*
* **When to Use**
*
* Use this function when you need an effect that completes successfully with a
* specific value without any errors or external dependencies.
*
* **Example** (Creating a Successful Effect)
*
* ```ts
* import { Effect } from "effect"
*
* // Creating an effect that represents a successful scenario
* //
* //      ┌─── Effect<number, never, never>
* //      ▼
* const success = Effect.succeed(42)
* ```
*
* @see {@link fail} to create an effect that represents a failure.
*
* @since 2.0.0
* @category Creating Effects
*/
const succeed$1 = succeed$9;
/**
* Returns an effect which succeeds with `None`.
*
* **When to Use**
*
* Use this function when you need to represent the absence of a value in your
* code, especially when working with optional data. This can be helpful when
* you want to indicate that no result is available without throwing an error or
* performing additional logic.
*
* @see {@link succeedSome} to create an effect that succeeds with a `Some` value.
*
* @since 2.0.0
* @category Creating Effects
*/
const succeedNone = succeedNone$1;
/**
* Returns an effect which succeeds with the value wrapped in a `Some`.
*
* @see {@link succeedNone} for a similar function that returns `None` when the value is absent.
*
* @since 2.0.0
* @category Creating Effects
*/
const succeedSome = succeedSome$1;
/**
* Delays the creation of an `Effect` until it is actually needed.
*
* **Details**
*
* The `Effect.suspend` function takes a thunk that represents the effect and
* wraps it in a suspended effect. This means the effect will not be created
* until it is explicitly needed, which is helpful in various scenarios:
* - **Lazy Evaluation**: Helps optimize performance by deferring computations,
*   especially when the effect might not be needed, or when its computation is
*   expensive. This also ensures that any side effects or scoped captures are
*   re-executed on each invocation.
* - **Handling Circular Dependencies**: Useful in managing circular
*   dependencies, such as recursive functions that need to avoid eager
*   evaluation to prevent stack overflow.
* - **Unifying Return Types**: Can help TypeScript unify return types in
*   situations where multiple branches of logic return different effects,
*   simplifying type inference.
*
* **When to Use**
*
* Use this function when you need to defer the evaluation of an effect until it
* is required. This is particularly useful for optimizing expensive
* computations, managing circular dependencies, or resolving type inference
* issues.
*
* **Example** (Lazy Evaluation with Side Effects)
*
* ```ts
* import { Effect } from "effect"
*
* let i = 0
*
* const bad = Effect.succeed(i++)
*
* const good = Effect.suspend(() => Effect.succeed(i++))
*
* console.log(Effect.runSync(bad)) // Output: 0
* console.log(Effect.runSync(bad)) // Output: 0
*
* console.log(Effect.runSync(good)) // Output: 1
* console.log(Effect.runSync(good)) // Output: 2
* ```
*
* **Example** (Recursive Fibonacci)
*
* ```ts
* import { Effect } from "effect"
*
* const blowsUp = (n: number): Effect.Effect<number> =>
*   n < 2
*     ? Effect.succeed(1)
*     : Effect.zipWith(blowsUp(n - 1), blowsUp(n - 2), (a, b) => a + b)
*
* console.log(Effect.runSync(blowsUp(32)))
* // crash: JavaScript heap out of memory
*
* const allGood = (n: number): Effect.Effect<number> =>
*   n < 2
*     ? Effect.succeed(1)
*     : Effect.zipWith(
*         Effect.suspend(() => allGood(n - 1)),
*         Effect.suspend(() => allGood(n - 2)),
*         (a, b) => a + b
*       )
*
* console.log(Effect.runSync(allGood(32)))
* // Output: 3524578
* ```
*
* **Example** (Using Effect.suspend to Help TypeScript Infer Types)
*
* ```ts
* import { Effect } from "effect"
*
* //   Without suspend, TypeScript may struggle with type inference.
* //   Inferred type:
* //     (a: number, b: number) =>
* //       Effect<never, Error, never> | Effect<number, never, never>
* const withoutSuspend = (a: number, b: number) =>
*   b === 0
*     ? Effect.fail(new Error("Cannot divide by zero"))
*     : Effect.succeed(a / b)
*
* //   Using suspend to unify return types.
* //   Inferred type:
* //     (a: number, b: number) => Effect<number, Error, never>
* const withSuspend = (a: number, b: number) =>
*   Effect.suspend(() =>
*     b === 0
*       ? Effect.fail(new Error("Cannot divide by zero"))
*       : Effect.succeed(a / b)
*   )
* ```
*
* @since 2.0.0
* @category Creating Effects
*/
const suspend = suspend$3;
/**
* Creates an `Effect` that represents a synchronous side-effectful computation.
*
* **Details**
*
* The provided function (`thunk`) must not throw errors; if it does, the error
* will be treated as a "defect".
*
* This defect is not a standard error but indicates a flaw in the logic that
* was expected to be error-free. You can think of it similar to an unexpected
* crash in the program, which can be further managed or logged using tools like
* {@link catchAllDefect}.
*
* **When to Use**
*
* Use this function when you are sure the operation will not fail.
*
* **Example** (Logging a Message)
*
* ```ts
* import { Effect } from "effect"
*
* const log = (message: string) =>
*   Effect.sync(() => {
*     console.log(message) // side effect
*   })
*
* //      ┌─── Effect<void, never, never>
* //      ▼
* const program = log("Hello, World!")
* ```
*
* @see {@link try_ | try} for a version that can handle failures.
*
* @since 2.0.0
* @category Creating Effects
*/
const sync = sync$3;
const _void = void_$4;
/**
* @since 2.0.0
* @category Creating Effects
*/
const yieldNow = yieldNow$3;
const _catch = _catch$1;
/**
* Handles all errors in an effect by providing a fallback effect.
*
* **Details**
*
* This function catches any errors that may occur during the execution of an
* effect and allows you to handle them by specifying a fallback effect. This
* ensures that the program continues without failing by recovering from errors
* using the provided fallback logic.
*
* **Note**: This function only handles recoverable errors. It will not recover
* from unrecoverable defects.
*
* **Example** (Providing Recovery Logic for Recoverable Errors)
*
* ```ts
* import { Effect, Random } from "effect"
*
* class HttpError {
*   readonly _tag = "HttpError"
* }
*
* class ValidationError {
*   readonly _tag = "ValidationError"
* }
*
* //      ┌─── Effect<string, HttpError | ValidationError, never>
* //      ▼
* const program = Effect.gen(function* () {
*   const n1 = yield* Random.next
*   const n2 = yield* Random.next
*   if (n1 < 0.5) {
*     yield* Effect.fail(new HttpError())
*   }
*   if (n2 < 0.5) {
*     yield* Effect.fail(new ValidationError())
*   }
*   return "some result"
* })
*
* //      ┌─── Effect<string, never, never>
* //      ▼
* const recovered = program.pipe(
*   Effect.catchAll((error) =>
*     Effect.succeed(`Recovering from ${error._tag}`)
*   )
* )
* ```
*
* @see {@link catchAllCause} for a version that can recover from both
* recoverable and unrecoverable errors.
*
* @since 2.0.0
* @category Error handling
*/
const catchAll = catchAll$1;
/**
* Handles both recoverable and unrecoverable errors by providing a recovery
* effect.
*
* **When to Use**
*
* The `catchAllCause` function allows you to handle all errors, including
* unrecoverable defects, by providing a recovery effect. The recovery logic is
* based on the `Cause` of the error, which provides detailed information about
* the failure.
*
* **When to Recover from Defects**
*
* Defects are unexpected errors that typically shouldn't be recovered from, as
* they often indicate serious issues. However, in some cases, such as
* dynamically loaded plugins, controlled recovery might be needed.
*
* **Example** (Recovering from All Errors)
*
* ```ts
* import { Cause, Effect } from "effect"
*
* // Define an effect that may fail with a recoverable or unrecoverable error
* const program = Effect.fail("Something went wrong!")
*
* // Recover from all errors by examining the cause
* const recovered = program.pipe(
*   Effect.catchAllCause((cause) =>
*     Cause.isFailure(cause)
*       ? Effect.succeed("Recovered from a regular error")
*       : Effect.succeed("Recovered from a defect")
*   )
* )
*
* Effect.runPromise(recovered).then(console.log)
* // Output: "Recovered from a regular error"
* ```
*
* @since 2.0.0
* @category Error handling
*/
const catchAllCause = catchAllCause$1;
/**
* Recovers from all defects using a provided recovery function.
*
* **When to Use**
*
* There is no sensible way to recover from defects. This method should be used
* only at the boundary between Effect and an external system, to transmit
* information on a defect for diagnostic or explanatory purposes.
*
* **Details**
*
* `catchAllDefect` allows you to handle defects, which are unexpected errors
* that usually cause the program to terminate. This function lets you recover
* from these defects by providing a function that handles the error. However,
* it does not handle expected errors (like those from {@link fail}) or
* execution interruptions (like those from {@link interrupt}).
*
* **When to Recover from Defects**
*
* Defects are unexpected errors that typically shouldn't be recovered from, as
* they often indicate serious issues. However, in some cases, such as
* dynamically loaded plugins, controlled recovery might be needed.
*
* **Example** (Handling All Defects)
*
* ```ts
* import { Effect, Cause, Console } from "effect"
*
* // Simulating a runtime error
* const task = Effect.dieMessage("Boom!")
*
* const program = Effect.catchAllDefect(task, (defect) => {
*   if (Cause.isRuntimeException(defect)) {
*     return Console.log(
*       `RuntimeException defect caught: ${defect.message}`
*     )
*   }
*   return Console.log("Unknown defect caught.")
* })
*
* // We get an Exit.Success because we caught all defects
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // RuntimeException defect caught: Boom!
* // {
* //   _id: "Exit",
* //   _tag: "Success",
* //   value: undefined
* // }
* ```
*
* @since 2.0.0
* @category Error handling
*/
const catchAllDefect = catchAllDefect$1;
/**
* Recovers from specific errors based on a predicate.
*
* **When to Use**
*
* `catchIf` works similarly to {@link catchSome}, but it allows you to
* recover from errors by providing a predicate function. If the predicate
* matches the error, the recovery effect is applied. This function doesn't
* alter the error type, so the resulting effect still carries the original
* error type unless a user-defined type guard is used to narrow the type.
*
* **Example** (Catching Specific Errors with a Predicate)
*
* ```ts
* import { Effect, Random } from "effect"
*
* class HttpError {
*   readonly _tag = "HttpError"
* }
*
* class ValidationError {
*   readonly _tag = "ValidationError"
* }
*
* //      ┌─── Effect<string, HttpError | ValidationError, never>
* //      ▼
* const program = Effect.gen(function* () {
*   const n1 = yield* Random.next
*   const n2 = yield* Random.next
*   if (n1 < 0.5) {
*     yield* Effect.fail(new HttpError())
*   }
*   if (n2 < 0.5) {
*     yield* Effect.fail(new ValidationError())
*   }
*   return "some result"
* })
*
* //      ┌─── Effect<string, ValidationError, never>
* //      ▼
* const recovered = program.pipe(
*   Effect.catchIf(
*     // Only handle HttpError errors
*     (error) => error._tag === "HttpError",
*     () => Effect.succeed("Recovering from HttpError")
*   )
* )
* ```
*
* @since 2.0.0
* @category Error handling
*/
const catchIf = catchIf$1;
/**
* Catches and recovers from specific types of errors, allowing you to attempt
* recovery only for certain errors.
*
* **Details**
*
* `catchSome` lets you selectively catch and handle errors of certain
* types by providing a recovery effect for specific errors. If the error
* matches a condition, recovery is attempted; if not, it doesn't affect the
* program. This function doesn't alter the error type, meaning the error type
* remains the same as in the original effect.
*
* **Example** (Handling Specific Errors with Effect.catchSome)
*
* ```ts
* import { Effect, Random, Option } from "effect"
*
* class HttpError {
*   readonly _tag = "HttpError"
* }
*
* class ValidationError {
*   readonly _tag = "ValidationError"
* }
*
* //      ┌─── Effect<string, HttpError | ValidationError, never>
* //      ▼
* const program = Effect.gen(function* () {
*   const n1 = yield* Random.next
*   const n2 = yield* Random.next
*   if (n1 < 0.5) {
*     yield* Effect.fail(new HttpError())
*   }
*   if (n2 < 0.5) {
*     yield* Effect.fail(new ValidationError())
*   }
*   return "some result"
* })
*
* //      ┌─── Effect<string, HttpError | ValidationError, never>
* //      ▼
* const recovered = program.pipe(
*   Effect.catchSome((error) => {
*     // Only handle HttpError errors
*     if (error._tag === "HttpError") {
*       return Option.some(Effect.succeed("Recovering from HttpError"))
*     } else {
*       return Option.none()
*     }
*   })
* )
* ```
*
* @see {@link catchIf} for a version that allows you to recover from errors based on a predicate.
*
* @since 2.0.0
* @category Error handling
*/
const catchSome = catchSome$1;
/**
* Recovers from specific causes using a provided partial function.
*
* @see {@link catchSome} for a version that allows you to recover from errors.
* @see {@link catchSomeDefect} for a version that allows you to recover from defects.
*
* @since 2.0.0
* @category Error handling
*/
const catchSomeCause = catchSomeCause$1;
/**
* Recovers from specific defects using a provided partial function.
*
* **Details**
*
* `catchSomeDefect` allows you to handle specific defects, which are
* unexpected errors that can cause the program to stop. It uses a partial
* function to catch only certain defects and ignores others. The function does
* not handle expected errors (such as those caused by {@link fail}) or
* interruptions in execution (like those caused by {@link interrupt}).
*
* This function provides a way to handle certain types of defects while
* allowing others to propagate and cause failure in the program.
*
* **Note**: There is no sensible way to recover from defects. This method
* should be used only at the boundary between Effect and an external system, to
* transmit information on a defect for diagnostic or explanatory purposes.
*
* **How the Partial Function Works**
*
* The function provided to `catchSomeDefect` acts as a filter and a handler for defects:
* - It receives the defect as an input.
* - If the defect matches a specific condition (e.g., a certain error type), the function returns
*   an `Option.some` containing the recovery logic.
* - If the defect does not match, the function returns `Option.none`, allowing the defect to propagate.
*
* **Example** (Handling Specific Defects)
*
* ```ts
* import { Effect, Cause, Option, Console } from "effect"
*
* // Simulating a runtime error
* const task = Effect.dieMessage("Boom!")
*
* const program = Effect.catchSomeDefect(task, (defect) => {
*   if (Cause.isIllegalArgumentException(defect)) {
*     return Option.some(
*       Console.log(
*         `Caught an IllegalArgumentException defect: ${defect.message}`
*       )
*     )
*   }
*   return Option.none()
* })
*
* // Since we are only catching IllegalArgumentException
* // we will get an Exit.Failure because we simulated a runtime error.
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: {
* //     _id: 'Cause',
* //     _tag: 'Die',
* //     defect: { _tag: 'RuntimeException' }
* //   }
* // }
* ```
*
* @since 2.0.0
* @category Error handling
*/
const catchSomeDefect = catchSomeDefect$1;
/**
* Catches and handles specific errors by their `_tag` field, which is used as a
* discriminator.
*
* **When to Use**
*
* `catchTag` is useful when your errors are tagged with a readonly `_tag` field
* that identifies the error type. You can use this function to handle specific
* error types by matching the `_tag` value. This allows for precise error
* handling, ensuring that only specific errors are caught and handled.
*
* The error type must have a readonly `_tag` field to use `catchTag`. This
* field is used to identify and match errors.
*
* **Example** (Handling Errors by Tag)
*
* ```ts
* import { Effect, Random } from "effect"
*
* class HttpError {
*   readonly _tag = "HttpError"
* }
*
* class ValidationError {
*   readonly _tag = "ValidationError"
* }
*
* //      ┌─── Effect<string, HttpError | ValidationError, never>
* //      ▼
* const program = Effect.gen(function* () {
*   const n1 = yield* Random.next
*   const n2 = yield* Random.next
*   if (n1 < 0.5) {
*     yield* Effect.fail(new HttpError())
*   }
*   if (n2 < 0.5) {
*     yield* Effect.fail(new ValidationError())
*   }
*   return "some result"
* })
*
* //      ┌─── Effect<string, ValidationError, never>
* //      ▼
* const recovered = program.pipe(
*   // Only handle HttpError errors
*   Effect.catchTag("HttpError", (_HttpError) =>
*     Effect.succeed("Recovering from HttpError")
*   )
* )
* ```
*
* @see {@link catchTags} for a version that allows you to handle multiple error
* types at once.
*
* @since 2.0.0
* @category Error handling
*/
const catchTag = catchTag$1;
/**
* Handles multiple errors in a single block of code using their `_tag` field.
*
* **When to Use**
*
* `catchTags` is a convenient way to handle multiple error types at
* once. Instead of using {@link catchTag} multiple times, you can pass an
* object where each key is an error type's `_tag`, and the value is the handler
* for that specific error. This allows you to catch and recover from multiple
* error types in a single call.
*
* The error type must have a readonly `_tag` field to use `catchTag`. This
* field is used to identify and match errors.
*
* **Example** (Handling Multiple Tagged Error Types at Once)
*
* ```ts
* import { Effect, Random } from "effect"
*
* class HttpError {
*   readonly _tag = "HttpError"
* }
*
* class ValidationError {
*   readonly _tag = "ValidationError"
* }
*
* //      ┌─── Effect<string, HttpError | ValidationError, never>
* //      ▼
* const program = Effect.gen(function* () {
*   const n1 = yield* Random.next
*   const n2 = yield* Random.next
*   if (n1 < 0.5) {
*     yield* Effect.fail(new HttpError())
*   }
*   if (n2 < 0.5) {
*     yield* Effect.fail(new ValidationError())
*   }
*   return "some result"
* })
*
* //      ┌─── Effect<string, never, never>
* //      ▼
* const recovered = program.pipe(
*   Effect.catchTags({
*     HttpError: (_HttpError) =>
*       Effect.succeed(`Recovering from HttpError`),
*     ValidationError: (_ValidationError) =>
*       Effect.succeed(`Recovering from ValidationError`)
*   })
* )
* ```
*
* @since 2.0.0
* @category Error handling
*/
const catchTags = catchTags$1;
/**
* Retrieves the cause of a failure in an effect.
*
* **Details**
*
* This function allows you to expose the detailed cause of an effect, which
* includes a more precise representation of failures, such as error messages
* and defects.
*
* **When to Use**
*
* This function is helpful when you need to inspect the cause of a failure in
* an effect, giving you more information than just the error message. It can be
* used to log, handle, or analyze failures in more detail, including
* distinguishing between different types of defects (e.g., runtime exceptions,
* interruptions, etc.).
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* //      ┌─── Effect<number, string, never>
* //      ▼
* const program = Effect.fail("Oh uh!").pipe(Effect.as(2))
*
* //      ┌─── Effect<void, never, never>
* //      ▼
* const recovered = Effect.gen(function* () {
*   const cause = yield* Effect.cause(program)
*   yield* Console.log(cause)
* })
* ```
*
* @since 2.0.0
* @category Error handling
*/
const cause = cause$1;
/**
* Runs an effect repeatedly until it succeeds, ignoring errors.
*
* **Details**
*
* This function takes an effect and runs it repeatedly until the effect
* successfully completes. If the effect fails, it will ignore the error and
* retry the operation. This is useful when you need to perform a task that may
* fail occasionally, but you want to keep trying until it eventually succeeds.
* It works by repeatedly executing the effect until it no longer throws an
* error.
*
* **When to Use**
*
* Use this function when you want to retry an operation multiple times until it
* succeeds. It is helpful in cases where the operation may fail temporarily
* (e.g., a network request), and you want to keep trying without handling or
* worrying about the errors.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* let counter = 0
*
* const effect = Effect.try(() => {
*   counter++
*   if (counter < 3) {
*     console.log("running effect")
*     throw new Error("error")
*   } else {
*     console.log("effect done")
*     return "some result"
*   }
* })
*
* const program = Effect.eventually(effect)
*
* Effect.runPromise(program).then(console.log)
* // Output:
* // running effect
* // running effect
* // effect done
* // some result
* ```
*
* @since 2.0.0
* @category Error handling
*/
const eventually = eventually$1;
/**
* Discards both the success and failure values of an effect.
*
* **When to Use**
*
* `ignore` allows you to run an effect without caring about its result, whether
* it succeeds or fails. This is useful when you only care about the side
* effects of the effect and do not need to handle or process its outcome.
*
* **Example** (Using Effect.ignore to Discard Values)
*
* ```ts
* import { Effect } from "effect"
*
* //      ┌─── Effect<number, string, never>
* //      ▼
* const task = Effect.fail("Uh oh!").pipe(Effect.as(5))
*
* //      ┌─── Effect<void, never, never>
* //      ▼
* const program = Effect.ignore(task)
* ```
*
* @see {@link ignoreLogged} to log failures while ignoring them.
*
* @since 2.0.0
* @category Error handling
*/
const ignore = ignore$1;
/**
* Ignores the result of an effect but logs any failures.
*
* **Details**
*
* This function takes an effect and returns a new effect that ignores whether
* the original effect succeeds or fails. However, if the effect fails, it will
* log the failure at the Debug level, so you can keep track of any issues that
* arise.
*
* **When to Use**
*
* This is useful in scenarios where you want to continue with your program
* regardless of the result of the effect, but you still want to be aware of
* potential failures that may need attention later.
*
* @since 2.0.0
* @category Error handling
*/
const ignoreLogged = ignoreLogged$1;
/**
* Combines all errors from concurrent operations into a single error.
*
* **Details**
*
* This function is used when you have multiple operations running at the same
* time, and you want to capture all the errors that occur across those
* operations. Instead of handling each error separately, it combines all the
* errors into one unified error.
*
* **When to Use**
*
* When using this function, any errors that occur in the concurrently running
* operations will be grouped together into a single error. This helps simplify
* error handling in cases where you don't need to differentiate between each
* failure, but simply want to know that multiple failures occurred.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const fail1 = Effect.fail("Oh uh!")
* const fail2 = Effect.fail("Oh no!")
* const die = Effect.dieMessage("Boom!")
*
* // Run all effects concurrently and capture all errors
* const program = Effect.all([fail1, fail2, die], {
*   concurrency: "unbounded"
* }).pipe(Effect.asVoid, Effect.parallelErrors)
*
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: { _id: 'Cause', _tag: 'Fail', failure: [ 'Oh uh!', 'Oh no!' ] }
* // }
* ```
*
* @since 2.0.0
* @category Error handling
*/
const parallelErrors = parallelErrors$1;
/**
* Transforms an effect to expose detailed error causes.
*
* **Details**
*
* This function enhances an effect by providing detailed information about any
* error, defect, or interruption that may occur during its execution. It
* modifies the error channel of the effect so that it includes a full cause of
* the failure, wrapped in a `Cause<E>` type.
*
* After applying this function, you can use operators like {@link catchAll} and
* {@link catchTags} to handle specific types of errors.
*
* If you no longer need the detailed cause information, you can revert the
* changes using {@link unsandbox} to return to the original error-handling
* behavior.
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* //      ┌─── Effect<string, Error, never>
* //      ▼
* const task = Effect.fail(new Error("Oh uh!")).pipe(
*   Effect.as("primary result")
* )
*
* //      ┌─── Effect<string, Cause<Error>, never>
* //      ▼
* const sandboxed = Effect.sandbox(task)
*
* const program = Effect.catchTags(sandboxed, {
*   Die: (cause) =>
*     Console.log(`Caught a defect: ${cause.defect}`).pipe(
*       Effect.as("fallback result on defect")
*     ),
*   Interrupt: (cause) =>
*     Console.log(`Caught a defect: ${cause.fiberId}`).pipe(
*       Effect.as("fallback result on fiber interruption")
*     ),
*   Fail: (cause) =>
*     Console.log(`Caught a defect: ${cause.error}`).pipe(
*       Effect.as("fallback result on failure")
*     )
* })
*
* // Restore the original error handling with unsandbox
* const main = Effect.unsandbox(program)
*
* Effect.runPromise(main).then(console.log)
* // Output:
* // Caught a defect: Oh uh!
* // fallback result on failure
* ```
*
* @see {@link unsandbox} to restore the original error handling.
*
* @since 2.0.0
* @category Error handling
*/
const sandbox = sandbox$1;
/**
* Retries a failing effect based on a defined retry policy.
*
* **Details**
*
* The `Effect.retry` function takes an effect and a {@link Schedule} policy,
* and will automatically retry the effect if it fails, following the rules of
* the policy.
*
* If the effect ultimately succeeds, the result will be returned.
*
* If the maximum retries are exhausted and the effect still fails, the failure
* is propagated.
*
* **When to Use**
*
* This can be useful when dealing with intermittent failures, such as network
* issues or temporary resource unavailability. By defining a retry policy, you
* can control the number of retries, the delay between them, and when to stop
* retrying.
*
* **Example** (Retrying with a Fixed Delay)
*
* ```ts
* import { Effect, Schedule } from "effect"
*
* let count = 0
*
* // Simulates an effect with possible failures
* const task = Effect.async<string, Error>((resume) => {
*   if (count <= 2) {
*     count++
*     console.log("failure")
*     resume(Effect.fail(new Error()))
*   } else {
*     console.log("success")
*     resume(Effect.succeed("yay!"))
*   }
* })
*
* // Define a repetition policy using a fixed delay between retries
* const policy = Schedule.fixed("100 millis")
*
* const repeated = Effect.retry(task, policy)
*
* Effect.runPromise(repeated).then(console.log)
* // Output:
* // failure
* // failure
* // failure
* // success
* // yay!
* ```
*
* **Example** (Retrying a Task up to 5 times)
*
* ```ts
* import { Effect } from "effect"
*
* let count = 0
*
* // Simulates an effect with possible failures
* const task = Effect.async<string, Error>((resume) => {
*   if (count <= 2) {
*     count++
*     console.log("failure")
*     resume(Effect.fail(new Error()))
*   } else {
*     console.log("success")
*     resume(Effect.succeed("yay!"))
*   }
* })
*
* // Retry the task up to 5 times
* Effect.runPromise(Effect.retry(task, { times: 5 })).then(console.log)
* // Output:
* // failure
* // failure
* // failure
* // success
* ```
*
* **Example** (Retrying Until a Specific Condition is Met)
*
* ```ts
* import { Effect } from "effect"
*
* let count = 0
*
* // Define an effect that simulates varying error on each invocation
* const action = Effect.failSync(() => {
*   console.log(`Action called ${++count} time(s)`)
*   return `Error ${count}`
* })
*
* // Retry the action until a specific condition is met
* const program = Effect.retry(action, {
*   until: (err) => err === "Error 3"
* })
*
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // Action called 1 time(s)
* // Action called 2 time(s)
* // Action called 3 time(s)
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Error 3' }
* // }
* ```
*
* @see {@link retryOrElse} for a version that allows you to run a fallback.
* @see {@link repeat} if your retry condition is based on successful outcomes rather than errors.
*
* @since 2.0.0
* @category Error handling
*/
const retry = retry_combined;
/**
* Apply an `ExecutionPlan` to the effect, which allows you to fallback to
* different resources in case of failure.
*
* @since 3.16.0
* @category Error handling
* @experimental
*/
const withExecutionPlan = withExecutionPlan$1;
/**
* Retries a failing effect and runs a fallback effect if retries are exhausted.
*
* **Details**
*
* The `Effect.retryOrElse` function attempts to retry a failing effect multiple
* times according to a defined {@link Schedule} policy.
*
* If the retries are exhausted and the effect still fails, it runs a fallback
* effect instead.
*
* **When to Use**
*
* This function is useful when you want to handle failures gracefully by
* specifying an alternative action after repeated failures.
*
* **Example** (Retrying with Fallback)
*
* ```ts
* import { Effect, Schedule, Console } from "effect"
*
* let count = 0
*
* // Simulates an effect with possible failures
* const task = Effect.async<string, Error>((resume) => {
*   if (count <= 2) {
*     count++
*     console.log("failure")
*     resume(Effect.fail(new Error()))
*   } else {
*     console.log("success")
*     resume(Effect.succeed("yay!"))
*   }
* })
*
* // Retry the task with a delay between retries and a maximum of 2 retries
* const policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")
*
* // If all retries fail, run the fallback effect
* const repeated = Effect.retryOrElse(
*   task,
*   policy,
*   // fallback
*   () => Console.log("orElse").pipe(Effect.as("default value"))
* )
*
* Effect.runPromise(repeated).then(console.log)
* // Output:
* // failure
* // failure
* // failure
* // orElse
* // default value
* ```
*
* @see {@link retry} for a version that does not run a fallback effect.
*
* @since 2.0.0
* @category Error handling
*/
const retryOrElse = retryOrElse_Effect;
const try_ = try_$1;
/**
* Returns an effect that maps its success using the specified side-effecting
* `try` function, converting any errors into typed failed effects using the
* `catch` function.
*
* @see {@link tryPromise} for a version that works with asynchronous computations.
*
* @since 2.0.0
* @category Error handling
*/
const tryMap = tryMap$1;
/**
* Returns an effect that maps its success using the specified side-effecting
* `try` function, converting any promise rejections into typed failed effects
* using the `catch` function.
*
* An optional `AbortSignal` can be provided to allow for interruption of the
* wrapped `Promise` API.
*
* @see {@link tryMap} for a version that works with synchronous computations.
*
* @since 2.0.0
* @category Error handling
*/
const tryMapPromise = tryMapPromise$1;
/**
* Creates an `Effect` that represents an asynchronous computation that might
* fail.
*
* **When to Use**
*
* In situations where you need to perform asynchronous operations that might
* fail, such as fetching data from an API, you can use the `tryPromise`
* constructor. This constructor is designed to handle operations that could
* throw exceptions by capturing those exceptions and transforming them into
* manageable errors.
*
* **Error Handling**
*
* There are two ways to handle errors with `tryPromise`:
*
* 1. If you don't provide a `catch` function, the error is caught and the
*    effect fails with an `UnknownException`.
* 2. If you provide a `catch` function, the error is caught and the `catch`
*    function maps it to an error of type `E`.
*
* **Interruptions**
*
* An optional `AbortSignal` can be provided to allow for interruption of the
* wrapped `Promise` API.
*
* **Example** (Fetching a TODO Item)
*
* ```ts
* import { Effect } from "effect"
*
* const getTodo = (id: number) =>
*   // Will catch any errors and propagate them as UnknownException
*   Effect.tryPromise(() =>
*     fetch(`https://jsonplaceholder.typicode.com/todos/${id}`)
*   )
*
* //      ┌─── Effect<Response, UnknownException, never>
* //      ▼
* const program = getTodo(1)
* ```
*
* **Example** (Custom Error Handling)
*
* ```ts
* import { Effect } from "effect"
*
* const getTodo = (id: number) =>
*   Effect.tryPromise({
*     try: () => fetch(`https://jsonplaceholder.typicode.com/todos/${id}`),
*     // remap the error
*     catch: (unknown) => new Error(`something went wrong ${unknown}`)
*   })
*
* //      ┌─── Effect<Response, Error, never>
* //      ▼
* const program = getTodo(1)
* ```
*
* @see {@link promise} if the effectful computation is asynchronous and does not throw errors.
*
* @since 2.0.0
* @category Creating Effects
*/
const tryPromise = tryPromise$1;
/**
* The `unsandbox` function is used to revert an effect that has been
* sandboxed by {@link sandbox}. When you apply `unsandbox`, the
* effect's error channel is restored to its original state, without the
* detailed `Cause<E>` information. This means that any underlying causes of
* errors, defects, or fiber interruptions are no longer exposed in the error
* channel.
*
* This function is useful when you want to remove the detailed error tracking
* provided by `sandbox` and return to the standard error handling for
* your effect. Once unsandboxed, the effect behaves as if `sandbox` was
* never applied.
*
* @see {@link sandbox} to expose the full cause of failures, defects, or interruptions.
*
* @since 2.0.0
* @category Error handling
*/
const unsandbox = unsandbox$1;
/**
* Allows interruption of the current fiber, even in uninterruptible regions.
*
* **Details**
*
* This effect checks whether any other fibers are attempting to interrupt the
* current fiber. If so, it allows the current fiber to perform a
* self-interruption.
*
* **When to Use**
*
* This is useful in situations where you want to allow interruption to happen
* even in regions of the code that are normally uninterruptible.
*
* @since 2.0.0
* @category Interruption
*/
const allowInterrupt = allowInterrupt$1;
/**
* Checks if interruption is allowed and executes a callback accordingly.
*
* **Details**
*
* This function checks the current interrupt status of the running fiber. It
* then calls the provided callback, passing a boolean indicating whether
* interruption is allowed.
*
* **When to Use**
*
* This is useful for handling specific logic based on whether the current
* operation can be interrupted, such as when performing asynchronous operations
* or handling cancellation.
*
* **Example**
*
* ```ts
* import { Console, Effect } from "effect"
*
* const program = Effect.gen(function*() {
*   yield* Effect.checkInterruptible((isInterruptible) => {
*     if (isInterruptible) {
*       return Console.log("You can interrupt this operation.")
*     } else {
*       return Console.log("This operation cannot be interrupted.")
*     }
*   })
* })
*
* Effect.runPromise(program)
* // Output: You can interrupt this operation.
*
* Effect.runPromise(program.pipe(Effect.uninterruptible))
* // Output: This operation cannot be interrupted.
*
* ```
*
*  @since 2.0.0
* @category Interruption
*/
const checkInterruptible = checkInterruptible$1;
/**
* Provides a way to handle timeouts in uninterruptible effects, allowing them
* to continue in the background while the main control flow proceeds with the
* timeout error.
*
* **Details**
*
* The `disconnect` function allows an uninterruptible effect to continue
* running in the background, while enabling the main control flow to
* immediately recognize a timeout condition. This is useful when you want to
* avoid blocking the program due to long-running tasks, especially when those
* tasks do not need to affect the flow of the rest of the program.
*
* Without `disconnect`, an uninterruptible effect will ignore the
* timeout and continue executing until it completes. The timeout error will
* only be assessed after the effect finishes, which can cause delays in
* recognizing a timeout.
*
* With `disconnect`, the uninterruptible effect proceeds in the
* background while the main program flow can immediately handle the timeout
* error or trigger alternative logic. This enables faster timeout handling
* without waiting for the completion of the long-running task.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const longRunningTask = Effect.gen(function* () {
*   console.log("Start heavy processing...")
*   yield* Effect.sleep("5 seconds") // Simulate a long process
*   console.log("Heavy processing done.")
*   return "Data processed"
* })
*
* const timedEffect = longRunningTask.pipe(
*   Effect.uninterruptible,
*   // Allows the task to finish in the background if it times out
*   Effect.disconnect,
*   Effect.timeout("1 second")
* )
*
* Effect.runPromiseExit(timedEffect).then(console.log)
* // Output:
* // Start heavy processing...
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: {
* //     _id: 'Cause',
* //     _tag: 'Fail',
* //     failure: { _tag: 'TimeoutException' }
* //   }
* // }
* // Heavy processing done.
* ```
*
* @see {@link timeout} for a version that interrupts the effect.
* @see {@link uninterruptible} for creating an uninterruptible effect.
*
* @since 2.0.0
* @category Interruption
*/
const disconnect = disconnect$1;
/**
* Represents an effect that interrupts the current fiber.
*
* **Details**
*
* This effect models the explicit interruption of the fiber in which it runs.
* When executed, it causes the fiber to stop its operation immediately,
* capturing the interruption details such as the fiber's ID and its start time.
* The resulting interruption can be observed in the `Exit` type if the effect
* is run with functions like {@link runPromiseExit}.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const program = Effect.gen(function* () {
*   console.log("start")
*   yield* Effect.sleep("2 seconds")
*   yield* Effect.interrupt
*   console.log("done")
*   return "some result"
* })
*
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // start
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: {
* //     _id: 'Cause',
* //     _tag: 'Interrupt',
* //     fiberId: {
* //       _id: 'FiberId',
* //       _tag: 'Runtime',
* //       id: 0,
* //       startTimeMillis: ...
* //     }
* //   }
* // }
* ```
*
* @since 2.0.0
* @category Interruption
*/
const interrupt = interrupt$5;
/**
* @since 2.0.0
* @category Interruption
*/
const interruptWith = interruptWith$2;
/**
* Marks an effect as interruptible.
*
* @since 2.0.0
* @category Interruption
*/
const interruptible = interruptible$2;
/**
* This function behaves like {@link interruptible}, but it also provides a
* `restore` function. This function can be used to restore the interruptibility
* of any specific region of code.
*
* @since 2.0.0
* @category Interruption
*/
const interruptibleMask = interruptibleMask$1;
/**
* Registers a cleanup effect to run when an effect is interrupted.
*
* **Details**
*
* This function allows you to specify an effect to run when the fiber is
* interrupted. This effect will be executed when the fiber is interrupted,
* allowing you to perform cleanup or other actions.
*
* **Example** (Running a Cleanup Action on Interruption)
*
* ```ts
* import { Console, Effect } from "effect"
*
* // This handler is executed when the fiber is interrupted
* const handler = Effect.onInterrupt((_fibers) => Console.log("Cleanup completed"))
*
* const success = Console.log("Task completed").pipe(Effect.as("some result"), handler)
*
* Effect.runFork(success)
* // Output:
* // Task completed
*
* const failure = Console.log("Task failed").pipe(Effect.andThen(Effect.fail("some error")), handler)
*
* Effect.runFork(failure)
* // Output:
* // Task failed
*
* const interruption = Console.log("Task interrupted").pipe(Effect.andThen(Effect.interrupt), handler)
*
* Effect.runFork(interruption)
* // Output:
* // Task interrupted
* // Cleanup completed
* ```
*
* @since 2.0.0
* @category Interruption
*/
const onInterrupt = onInterrupt$1;
/**
* Marks an effect as uninterruptible.
*
* @since 2.0.0
* @category Interruption
*/
const uninterruptible = uninterruptible$1;
/**
* This function behaves like {@link uninterruptible}, but it also provides a
* `restore` function. This function can be used to restore the interruptibility
* of any specific region of code.
*
* @since 2.0.0
* @category Interruption
*/
const uninterruptibleMask = uninterruptibleMask$2;
/**
* Transforms a `Predicate` function into an `Effect` returning the input value if the predicate returns `true`
* or failing with specified error if the predicate fails
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const isPositive = (n: number): boolean => n > 0
*
* // succeeds with `1`
* Effect.liftPredicate(1, isPositive, n => `${n} is not positive`)
*
* // fails with `"0 is not positive"`
* Effect.liftPredicate(0, isPositive, n => `${n} is not positive`)
* ```
*
* @category Condition Checking
* @since 3.4.0
*/
const liftPredicate = liftPredicate$1;
/**
* Replaces the value inside an effect with a constant value.
*
* **Details**
*
* This function allows you to ignore the original value inside an effect and
* replace it with a constant value.
*
* **When to Use**
*
* It is useful when you no longer need the value produced by an effect but want
* to ensure that the effect completes successfully with a specific constant
* result instead. For instance, you can replace the value produced by a
* computation with a predefined value, ignoring what was calculated before.
*
* **Example** (Replacing a Value)
*
* ```ts
* import { pipe, Effect } from "effect"
*
* // Replaces the value 5 with the constant "new value"
* const program = pipe(Effect.succeed(5), Effect.as("new value"))
*
* Effect.runPromise(program).then(console.log)
* // Output: "new value"
* ```
*
* @since 2.0.0
* @category Mapping
*/
const as = as$4;
/**
* This function maps the success value of an `Effect` value to a `Some` value
* in an `Option` value. If the original `Effect` value fails, the returned
* `Effect` value will also fail.
*
* @category Mapping
* @since 2.0.0
*/
const asSome = asSome$1;
/**
* This function maps the error value of an `Effect` value to a `Some` value
* in an `Option` value. If the original `Effect` value succeeds, the returned
* `Effect` value will also succeed.
*
* @category Mapping
* @since 2.0.0
*/
const asSomeError = asSomeError$1;
/**
* This function maps the success value of an `Effect` value to `void`. If the
* original `Effect` value succeeds, the returned `Effect` value will also
* succeed. If the original `Effect` value fails, the returned `Effect` value
* will fail with the same error.
*
* @since 2.0.0
* @category Mapping
*/
const asVoid = asVoid$3;
/**
* Swaps the success and error channels of an effect.
*
* **Details**
*
* This function reverses the flow of an effect by swapping its success and
* error channels. The success value becomes an error, and the error value
* becomes a success.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* //      ┌─── Effect<number, string, never>
* //      ▼
* const program = Effect.fail("Oh uh!").pipe(Effect.as(2))
*
* //      ┌─── Effect<string, number, never>
* //      ▼
* const flipped = Effect.flip(program)
* ```
*
* @since 2.0.0
* @category Mapping
*/
const flip = flip$1;
/**
* Swaps the error/value parameters, applies the function `f` and flips the
* parameters back
*
* @since 2.0.0
* @category Mapping
*/
const flipWith = flipWith$1;
/**
* Transforms the value inside an effect by applying a function to it.
*
* **Syntax**
*
* ```ts skip-type-checking
* const mappedEffect = pipe(myEffect, Effect.map(transformation))
* // or
* const mappedEffect = Effect.map(myEffect, transformation)
* // or
* const mappedEffect = myEffect.pipe(Effect.map(transformation))
* ```
*
* **Details**
*
* `map` takes a function and applies it to the value contained within an
* effect, creating a new effect with the transformed value.
*
* It's important to note that effects are immutable, meaning that the original
* effect is not modified. Instead, a new effect is returned with the updated
* value.
*
* **Example** (Adding a Service Charge)
*
* ```ts
* import { pipe, Effect } from "effect"
*
* const addServiceCharge = (amount: number) => amount + 1
*
* const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))
*
* const finalAmount = pipe(
*   fetchTransactionAmount,
*   Effect.map(addServiceCharge)
* )
*
* Effect.runPromise(finalAmount).then(console.log)
* // Output: 101
* ```
*
* @see {@link mapError} for a version that operates on the error channel.
* @see {@link mapBoth} for a version that operates on both channels.
* @see {@link flatMap} or {@link andThen} for a version that can return a new effect.
*
* @since 2.0.0
* @category Mapping
*/
const map$1 = map$9;
/**
* Applies a stateful transformation to each element of a collection, producing
* new elements along with an updated state.
*
* **When to Use**
*
* Use `mapAccum` when you need to process each element of a collection while
* keeping track of some state across iterations.
*
* **Details**
*
* `mapAccum` takes an initial state (`initial`) and a function (`f`) that is
* applied to each element. This function returns a new state and a transformed
* element. The final effect produces both the accumulated state and the
* transformed collection.
*
* If the input collection is a non-empty array, the return type will match the
* input collection type.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* // Define an initial state and a transformation function
* const initialState = 0
*
* const transformation = (state: number, element: string) =>
*   Effect.succeed<[number, string]>([state + element.length, element.toUpperCase()])
*
* // Apply mapAccum to transform an array of strings
* const program = Effect.mapAccum(["a", "bb", "ccc"], initialState, transformation)
*
* Effect.runPromise(program).then(([finalState, transformedCollection]) => {
*   console.log(finalState)
*   console.log(transformedCollection)
* })
* // Output:
* // 6
* // [ 'A', 'BB', 'CCC' ]
* ```
*
* @since 2.0.0
* @category Mapping
*/
const mapAccum = mapAccum$1;
/**
* Applies transformations to both the success and error channels of an effect.
*
* **Details**
*
* This function takes two map functions as arguments: one for the error channel
* and one for the success channel. You can use it when you want to modify both
* the error and the success values without altering the overall success or
* failure status of the effect.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* //      ┌─── Effect<number, string, never>
* //      ▼
* const simulatedTask = Effect.fail("Oh no!").pipe(Effect.as(1))
*
* //      ┌─── Effect<boolean, Error, never>
* //      ▼
* const modified = Effect.mapBoth(simulatedTask, {
*   onFailure: (message) => new Error(message),
*   onSuccess: (n) => n > 0
* })
* ```
*
* @see {@link map} for a version that operates on the success channel.
* @see {@link mapError} for a version that operates on the error channel.
*
* @since 2.0.0
* @category Mapping
*/
const mapBoth = mapBoth$2;
/**
* Transforms or modifies the error produced by an effect without affecting its
* success value.
*
* **When to Use**
*
* This function is helpful when you want to enhance the error with additional
* information, change the error type, or apply custom error handling while
* keeping the original behavior of the effect's success values intact. It only
* operates on the error channel and leaves the success channel unchanged.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* //      ┌─── Effect<number, string, never>
* //      ▼
* const simulatedTask = Effect.fail("Oh no!").pipe(Effect.as(1))
*
* //      ┌─── Effect<number, Error, never>
* //      ▼
* const mapped = Effect.mapError(
*   simulatedTask,
*   (message) => new Error(message)
* )
* ```
*
* @see {@link map} for a version that operates on the success channel.
* @see {@link mapBoth} for a version that operates on both channels.
* @see {@link orElseFail} if you want to replace the error with a new one.
*
* @since 2.0.0
* @category Mapping
*/
const mapError$1 = mapError$3;
/**
* Maps the cause of failure of an effect using a specified function.
*
* @see {@link sandbox} for a version that exposes the full cause of failures, defects, or interruptions.
* @see {@link catchAllCause} for a version that can recover from all types of defects.
*
* @since 2.0.0
* @category Mapping
*/
const mapErrorCause = mapErrorCause$1;
/**
* Combines both success and error channels of an effect into a single outcome.
*
* **Details**
*
* This function transforms an effect that may fail into one that always returns
* a value, where both success and failure outcomes are handled as values in the
* success channel.
*
* **When to Use**
*
* This can be useful when you want to continue execution regardless of the
* error type and still capture both successful results and errors as part of
* the outcome.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* //      ┌─── Effect<number, string, never>
* //      ▼
* const program = Effect.fail("Oh uh!").pipe(Effect.as(2))
*
* //      ┌─── Effect<number | string, never, never>
* //      ▼
* const recovered = Effect.merge(program)
* ```
*
* @since 2.0.0
* @category Mapping
*/
const merge = merge$2;
/**
* Returns a new effect with the boolean value of this effect negated.
*
* @since 2.0.0
* @category Mapping
*/
const negate = negate$1;
/**
* Creates a scoped resource using an `acquire` and `release` effect.
*
* **Details**
*
* This function helps manage resources by combining two `Effect` values: one
* for acquiring the resource and one for releasing it.
*
* `acquireRelease` does the following:
*
*   1. Ensures that the effect that acquires the resource will not be
*      interrupted. Note that acquisition may still fail due to internal
*      reasons (such as an uncaught exception).
*   2. Ensures that the `release` effect will not be interrupted, and will be
*      executed as long as the acquisition effect successfully acquires the
*      resource.
*
* If the `acquire` function succeeds, the `release` function is added to the
* list of finalizers for the scope. This ensures that the release will happen
* automatically when the scope is closed.
*
* Both `acquire` and `release` run uninterruptibly, meaning they cannot be
* interrupted while they are executing.
*
* Additionally, the `release` function can be influenced by the exit value when
* the scope closes, allowing for custom handling of how the resource is
* released based on the execution outcome.
*
* **When to Use**
*
* This function is used to ensure that an effect that represents the
* acquisition of a resource (for example, opening a file, launching a thread,
* etc.) will not be interrupted, and that the resource will always be released
* when the `Effect` completes execution.
*
* **Example** (Defining a Simple Resource)
*
* ```ts
* import { Effect } from "effect"
*
* // Define an interface for a resource
* interface MyResource {
*   readonly contents: string
*   readonly close: () => Promise<void>
* }
*
* // Simulate resource acquisition
* const getMyResource = (): Promise<MyResource> =>
*   Promise.resolve({
*     contents: "lorem ipsum",
*     close: () =>
*       new Promise((resolve) => {
*         console.log("Resource released")
*         resolve()
*       })
*   })
*
* // Define how the resource is acquired
* const acquire = Effect.tryPromise({
*   try: () =>
*     getMyResource().then((res) => {
*       console.log("Resource acquired")
*       return res
*     }),
*   catch: () => new Error("getMyResourceError")
* })
*
* // Define how the resource is released
* const release = (res: MyResource) => Effect.promise(() => res.close())
*
* // Create the resource management workflow
* //
* //      ┌─── Effect<MyResource, Error, Scope>
* //      ▼
* const resource = Effect.acquireRelease(acquire, release)
* ```
*
* @see {@link acquireUseRelease} for a version that automatically handles the scoping of resources.
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const acquireRelease = acquireRelease$1;
/**
* Creates a scoped resource with an interruptible acquire action.
*
* **Details**
*
* This function is similar to {@link acquireRelease}, but it allows the
* acquisition of the resource to be interrupted. The `acquire` effect, which
* represents the process of obtaining the resource, can be interrupted if
* necessary.
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const acquireReleaseInterruptible = acquireReleaseInterruptible$1;
/**
* Many real-world operations involve working with resources that must be released when no longer needed, such as:
*
* - Database connections
* - File handles
* - Network requests
*
* This function ensures that a resource is:
*
* 1. **Acquired** properly.
* 2. **Used** for its intended purpose.
* 3. **Released** even if an error occurs.
*
* **Example** (Automatically Managing Resource Lifetime)
*
* ```ts
* import { Effect, Console } from "effect"
*
* // Define an interface for a resource
* interface MyResource {
*   readonly contents: string
*   readonly close: () => Promise<void>
* }
*
* // Simulate resource acquisition
* const getMyResource = (): Promise<MyResource> =>
*   Promise.resolve({
*     contents: "lorem ipsum",
*     close: () =>
*       new Promise((resolve) => {
*         console.log("Resource released")
*         resolve()
*       })
*   })
*
* // Define how the resource is acquired
* const acquire = Effect.tryPromise({
*   try: () =>
*     getMyResource().then((res) => {
*       console.log("Resource acquired")
*       return res
*     }),
*   catch: () => new Error("getMyResourceError")
* })
*
* // Define how the resource is released
* const release = (res: MyResource) => Effect.promise(() => res.close())
*
* const use = (res: MyResource) => Console.log(`content is ${res.contents}`)
*
* //      ┌─── Effect<void, Error, never>
* //      ▼
* const program = Effect.acquireUseRelease(acquire, use, release)
*
* Effect.runPromise(program)
* // Output:
* // Resource acquired
* // content is lorem ipsum
* // Resource released
* ```
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const acquireUseRelease = acquireUseRelease$1;
/**
* Ensures a finalizer is added to the scope of the calling effect, guaranteeing
* it runs when the scope is closed.
*
* **Details**
*
* This function adds a finalizer that will execute whenever the scope of the
* effect is closed, regardless of whether the effect succeeds, fails, or is
* interrupted. The finalizer receives the `Exit` value of the effect's scope,
* allowing it to react differently depending on how the effect concludes.
*
* Finalizers are a reliable way to manage resource cleanup, ensuring that
* resources such as file handles, network connections, or database transactions
* are properly closed even in the event of an unexpected interruption or error.
*
* Finalizers operate in conjunction with Effect's scoped resources. If an
* effect with a finalizer is wrapped in a scope, the finalizer will execute
* automatically when the scope ends.
*
* **Example** (Adding a Finalizer on Success)
*
* ```ts
* import { Effect, Console } from "effect"
*
* //      ┌─── Effect<string, never, Scope>
* //      ▼
* const program = Effect.gen(function* () {
*   yield* Effect.addFinalizer((exit) =>
*     Console.log(`Finalizer executed. Exit status: ${exit._tag}`)
*   )
*   return "some result"
* })
*
* // Wrapping the effect in a scope
* //
* //      ┌─── Effect<string, never, never>
* //      ▼
* const runnable = Effect.scoped(program)
*
* Effect.runPromiseExit(runnable).then(console.log)
* // Output:
* // Finalizer executed. Exit status: Success
* // { _id: 'Exit', _tag: 'Success', value: 'some result' }
* ```
*
* **Example** (Adding a Finalizer on Failure)
*
* ```ts
* import { Effect, Console } from "effect"
*
* //      ┌─── Effect<never, string, Scope>
* //      ▼
* const program = Effect.gen(function* () {
*   yield* Effect.addFinalizer((exit) =>
*     Console.log(`Finalizer executed. Exit status: ${exit._tag}`)
*   )
*   return yield* Effect.fail("Uh oh!")
* })
*
* // Wrapping the effect in a scope
* //
* //      ┌─── Effect<never, string, never>
* //      ▼
* const runnable = Effect.scoped(program)
*
* Effect.runPromiseExit(runnable).then(console.log)
* // Output:
* // Finalizer executed. Exit status: Failure
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Uh oh!' }
* // }
* ```
*
* **Example** (Adding a Finalizer on Interruption)
*
* ```ts
* import { Effect, Console } from "effect"
*
* //      ┌─── Effect<never, never, Scope>
* //      ▼
* const program = Effect.gen(function* () {
*   yield* Effect.addFinalizer((exit) =>
*     Console.log(`Finalizer executed. Exit status: ${exit._tag}`)
*   )
*   return yield* Effect.interrupt
* })
*
* // Wrapping the effect in a scope
* //
* //      ┌─── Effect<never, never, never>
* //      ▼
* const runnable = Effect.scoped(program)
*
* Effect.runPromiseExit(runnable).then(console.log)
* // Output:
* // Finalizer executed. Exit status: Failure
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: {
* //     _id: 'Cause',
* //     _tag: 'Interrupt',
* //     fiberId: {
* //       _id: 'FiberId',
* //       _tag: 'Runtime',
* //       id: 0,
* //       startTimeMillis: ...
* //     }
* //   }
* // }
* ```
*
* @see {@link onExit} for attaching a finalizer directly to an effect.
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const addFinalizer = addFinalizer$2;
/**
* Guarantees the execution of a finalizer when an effect starts execution.
*
* **Details**
*
* This function allows you to specify a `finalizer` effect that will always be
* run once the effect starts execution, regardless of whether the effect
* succeeds, fails, or is interrupted.
*
* **When to Use**
*
* This is useful when you need to ensure that certain cleanup or final steps
* are executed in all cases, such as releasing resources or performing
* necessary logging.
*
* While this function provides strong guarantees about executing the finalizer,
* it is considered a low-level tool, which may not be ideal for more complex
* resource management. For higher-level resource management with automatic
* acquisition and release, see the {@link acquireRelease} family of functions.
* For use cases where you need access to the result of an effect, consider
* using {@link onExit}.
*
* **Example** (Running a Finalizer in All Outcomes)
*
* ```ts
* import { Console, Effect } from "effect"
*
* // Define a cleanup effect
* const handler = Effect.ensuring(Console.log("Cleanup completed"))
*
* // Define a successful effect
* const success = Console.log("Task completed").pipe(
*   Effect.as("some result"),
*   handler
* )
*
* Effect.runFork(success)
* // Output:
* // Task completed
* // Cleanup completed
*
* // Define a failing effect
* const failure = Console.log("Task failed").pipe(
*   Effect.andThen(Effect.fail("some error")),
*   handler
* )
*
* Effect.runFork(failure)
* // Output:
* // Task failed
* // Cleanup completed
*
* // Define an interrupted effect
* const interruption = Console.log("Task interrupted").pipe(
*   Effect.andThen(Effect.interrupt),
*   handler
* )
*
* Effect.runFork(interruption)
* // Output:
* // Task interrupted
* // Cleanup completed
* ```
*
* @see {@link onExit} for a version that provides access to the result of an
* effect.
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const ensuring = ensuring$1;
/**
* Ensures a cleanup effect runs whenever the calling effect fails, providing
* the failure cause to the cleanup effect.
*
* **Details**
*
* This function allows you to attach a cleanup effect that runs whenever the
* calling effect fails. The cleanup effect receives the cause of the failure,
* allowing you to perform actions such as logging, releasing resources, or
* executing additional recovery logic based on the error. The cleanup effect
* will execute even if the failure is due to interruption.
*
* Importantly, the cleanup effect itself is uninterruptible, ensuring that it
* completes regardless of external interruptions.
*
* **Example** (Running Cleanup Only on Failure)
*
* ```ts
* import { Console, Effect } from "effect"
*
* // This handler logs the failure cause when the effect fails
* const handler = Effect.onError((cause) =>
*   Console.log(`Cleanup completed: ${cause}`)
* )
*
* // Define a successful effect
* const success = Console.log("Task completed").pipe(
*   Effect.as("some result"),
*   handler
* )
*
* Effect.runFork(success)
* // Output:
* // Task completed
*
* // Define a failing effect
* const failure = Console.log("Task failed").pipe(
*   Effect.andThen(Effect.fail("some error")),
*   handler
* )
*
* Effect.runFork(failure)
* // Output:
* // Task failed
* // Cleanup completed: Error: some error
*
* // Define a failing effect
* const defect = Console.log("Task failed with defect").pipe(
*   Effect.andThen(Effect.die("Boom!")),
*   handler
* )
*
* Effect.runFork(defect)
* // Output:
* // Task failed with defect
* // Cleanup completed: Error: Boom!
*
* // Define an interrupted effect
* const interruption = Console.log("Task interrupted").pipe(
*   Effect.andThen(Effect.interrupt),
*   handler
* )
*
* Effect.runFork(interruption)
* // Output:
* // Task interrupted
* // Cleanup completed: All fibers interrupted without errors.
* ```
*
* @see {@link ensuring} for attaching a cleanup effect that runs on both success and failure.
* @see {@link onExit} for attaching a cleanup effect that runs on all possible exits.
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const onError = onError$1;
/**
* Guarantees that a cleanup function runs regardless of whether the effect
* succeeds, fails, or is interrupted.
*
* **Details**
*
* This function ensures that a provided cleanup function is executed after the
* effect completes, regardless of the outcome. The cleanup function is given
* the `Exit` value of the effect, which provides detailed information about the
* result:
* - If the effect succeeds, the `Exit` contains the success value.
* - If the effect fails, the `Exit` contains the error or failure cause.
* - If the effect is interrupted, the `Exit` reflects the interruption.
*
* The cleanup function is guaranteed to run uninterruptibly, ensuring reliable
* resource management even in complex or high-concurrency scenarios.
*
* **Example** (Running a Cleanup Function with the Effect’s Result)
*
* ```ts
* import { Console, Effect, Exit } from "effect"
*
* // Define a cleanup effect that logs the result
* const handler = Effect.onExit((exit) =>
*   Console.log(`Cleanup completed: ${Exit.getOrElse(exit, String)}`)
* )
*
* // Define a successful effect
* const success = Console.log("Task completed").pipe(
*   Effect.as("some result"),
*   handler
* )
*
* Effect.runFork(success)
* // Output:
* // Task completed
* // Cleanup completed: some result
*
* // Define a failing effect
* const failure = Console.log("Task failed").pipe(
*   Effect.andThen(Effect.fail("some error")),
*   handler
* )
*
* Effect.runFork(failure)
* // Output:
* // Task failed
* // Cleanup completed: Error: some error
*
* // Define an interrupted effect
* const interruption = Console.log("Task interrupted").pipe(
*   Effect.andThen(Effect.interrupt),
*   handler
* )
*
* Effect.runFork(interruption)
* // Output:
* // Task interrupted
* // Cleanup completed: All fibers interrupted without errors.
* ```
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const onExit = onExit$2;
/**
* Ensures that finalizers are run concurrently when the scope of an effect is
* closed.
*
* **Details**
*
* This function modifies the behavior of finalizers within a scoped workflow to
* allow them to run concurrently when the scope is closed.
*
* By default, finalizers are executed sequentially in reverse order of their
* addition, but this function changes that behavior to execute all finalizers
* concurrently.
*
* **When to Use**
*
* Running finalizers concurrently can improve performance when multiple
* independent cleanup tasks need to be performed. However, it requires that
* these tasks do not depend on the order of execution or introduce race
* conditions.
*
* **Example**
*
* ```ts
* import { Console, Effect } from "effect"
*
* // Define a program that adds multiple finalizers
* const program = Effect.gen(function*() {
*   yield* Effect.addFinalizer(() => Console.log("Finalizer 1 executed").pipe(Effect.delay("300 millis")))
*   yield* Effect.addFinalizer(() => Console.log("Finalizer 2 executed").pipe(Effect.delay("100 millis")))
*   yield* Effect.addFinalizer(() => Console.log("Finalizer 3 executed").pipe(Effect.delay("200 millis")))
*   return "some result"
* })
*
* // Modify the program to ensure finalizers run in parallel
* const modified = program.pipe(Effect.parallelFinalizers)
*
* const runnable = Effect.scoped(modified)
*
* Effect.runFork(runnable)
* // Output:
* // Finalizer 2 executed
* // Finalizer 3 executed
* // Finalizer 1 executed
* ```
*
* @see {@link sequentialFinalizers} for a version that ensures finalizers are run sequentially.
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const parallelFinalizers = parallelFinalizers$1;
/**
* Ensures that finalizers are run sequentially in reverse order of their
* addition.
*
* **Details**
*
* This function modifies the behavior of finalizers within a scoped workflow to
* ensure they are run sequentially in reverse order when the scope is closed.
*
* By default, finalizers are executed sequentially, so this only changes the
* behavior if the scope is configured to run finalizers concurrently.
*
* @see {@link parallelFinalizers} for a version that ensures finalizers are run concurrently.
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const sequentialFinalizers = sequentialFinalizers$1;
/**
* Applies a custom execution strategy to finalizers within a scoped workflow.
*
* **Details**
*
* This function allows you to control how finalizers are executed in a scope by
* applying a specified `ExecutionStrategy`. The `strategy` can dictate whether
* finalizers run (e.g., sequentially or in parallel).
*
* Additionally, the function provides a `restore` operation, which ensures that
* the effect passed to it is executed under the default execution strategy.
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const finalizersMask = finalizersMask$1;
/**
* Provides access to the current scope in a scoped workflow.
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const scope = scope$1;
/**
* Accesses the current scope and uses it to perform the specified effect.
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const scopeWith = scopeWith$1;
/**
* Creates a `Scope`, passes it to the specified effectful function, and closes
* the scope when the effect completes (whether through success, failure, or
* interruption).
*
* @since 3.11.0
* @category Scoping, Resources & Finalization
*/
const scopedWith = scopedWith$1;
/**
* Scopes all resources used in an effect to the lifetime of the effect.
*
* **Details**
*
* This function ensures that all resources used within an effect are tied to
* its lifetime. Finalizers for these resources are executed automatically when
* the effect completes, whether through success, failure, or interruption. This
* guarantees proper resource cleanup without requiring explicit management.
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const scoped = scopedEffect;
/**
* Scopes all resources acquired by one effect to the lifetime of another
* effect.
*
* **Details**
*
* This function allows you to scope the resources acquired by one effect
* (`self`) to the lifetime of another effect (`use`). This ensures that the
* resources are cleaned up as soon as the `use` effect completes, regardless of
* how the `use` effect ends (success, failure, or interruption).
*
* **Example**
*
* ```ts
* import { Console, Effect } from "effect"
*
* const acquire = Console.log("Acquiring resource").pipe(
*   Effect.as(1),
*   Effect.tap(Effect.addFinalizer(() => Console.log("Releasing resource")))
* )
* const use = (resource: number) => Console.log(`Using resource: ${resource}`)
*
* const program = acquire.pipe(Effect.using(use))
*
* Effect.runFork(program)
* // Output:
* // Acquiring resource
* // Using resource: 1
* // Releasing resource
* ```
*
* @see {@link scopedWith} Manage scoped operations with a temporary scope.
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const using = using$1;
/**
* Returns the result of the effect and a finalizer to close its scope.
*
* **Details**
*
* This function allows you to retrieve both the result of an effect and a
* finalizer that can be used to manually close its scope. This is useful for
* workflows where you need early access to the result while retaining control
* over the resource cleanup process.
*
* **Example**
*
* ```ts
* import { Console, Effect } from "effect"
*
* const acquire = Console.log("Acquiring resource").pipe(
*   Effect.as(1),
*   Effect.tap(Effect.addFinalizer(() => Console.log("Releasing resource")))
* )
* const program = Effect.gen(function*() {
*   const [finalizer, resource] = yield* Effect.withEarlyRelease(acquire)
*   console.log(`Using resource: ${resource}`)
*   yield* Effect.sleep("1 second")
*   yield* finalizer
* })
*
* Effect.runFork(program.pipe(Effect.scoped))
* // Output:
* // Acquiring resource
* // Using resource: 1
* // Releasing resource
* ```
*
* @since 2.0.0
* @category Scoping, Resources & Finalization
*/
const withEarlyRelease = withEarlyRelease$1;
/**
* Returns a new effect that will not succeed with its value before first
* waiting for the end of all child fibers forked by the effect.
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const awaitAllChildren = awaitAllChildren$1;
/**
* Returns a new workflow that will not supervise any fibers forked by this
* workflow.
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const daemonChildren = daemonChildren$1;
/**
* Constructs an effect with information about the current `Fiber`.
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const descriptor = descriptor$1;
/**
* Constructs an effect based on information about the current `Fiber`.
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const descriptorWith = descriptorWith$1;
/**
* Returns a new workflow that executes this one and captures the changes in
* `FiberRef` values.
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const diffFiberRefs = diffFiberRefs$1;
/**
* Acts on the children of this fiber (collected into a single fiber),
* guaranteeing the specified callback will be invoked, whether or not this
* effect succeeds.
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const ensuringChild = ensuringChild$1;
/**
* Acts on the children of this fiber, guaranteeing the specified callback
* will be invoked, whether or not this effect succeeds.
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const ensuringChildren = ensuringChildren$1;
/**
* @since 2.0.0
* @category Supervision & Fibers
*/
const fiberId = fiberId$1;
/**
* @since 2.0.0
* @category Supervision & Fibers
*/
const fiberIdWith = fiberIdWith$1;
/**
* Creates a new fiber to run an effect concurrently.
*
* **Details**
*
* This function takes an effect and forks it into a separate fiber, allowing it
* to run concurrently without blocking the original effect. The new fiber
* starts execution immediately after being created, and the fiber object is
* returned immediately without waiting for the effect to begin. This is useful
* when you want to run tasks concurrently while continuing other tasks in the
* parent fiber.
*
* The forked fiber is attached to the parent fiber's scope. This means that
* when the parent fiber terminates, the child fiber will also be terminated
* automatically. This feature, known as "auto supervision," ensures that no
* fibers are left running unintentionally. If you prefer not to have this auto
* supervision behavior, you can use {@link forkDaemon} or {@link forkIn}.
*
* **When to Use**
*
* Use this function when you need to run an effect concurrently without
* blocking the current execution flow. For example, you might use it to launch
* background tasks or concurrent computations. However, working with fibers can
* be complex, so before using this function directly, you might want to explore
* higher-level functions like {@link raceWith}, {@link zip}, or others that can
* manage concurrency for you.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const fib = (n: number): Effect.Effect<number> =>
*   n < 2
*     ? Effect.succeed(n)
*     : Effect.zipWith(fib(n - 1), fib(n - 2), (a, b) => a + b)
*
* //      ┌─── Effect<RuntimeFiber<number, never>, never, never>
* //      ▼
* const fib10Fiber = Effect.fork(fib(10))
* ```
*
* @see {@link forkWithErrorHandler} for a version that allows you to handle errors.
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const fork = fork$2;
/**
* Creates a long-running background fiber that is independent of its parent.
*
* **Details**
*
* This function creates a "daemon" fiber that runs in the background and is not
* tied to the lifecycle of its parent fiber. Unlike normal fibers that stop
* when the parent fiber terminates, a daemon fiber will continue running until
* the global scope closes or the fiber completes naturally. This makes it
* useful for tasks that need to run in the background independently, such as
* periodic logging, monitoring, or background data processing.
*
* **Example** (Creating a Daemon Fiber)
*
* ```ts
* import { Effect, Console, Schedule } from "effect"
*
* // Daemon fiber that logs a message repeatedly every second
* const daemon = Effect.repeat(
*   Console.log("daemon: still running!"),
*   Schedule.fixed("1 second")
* )
*
* const parent = Effect.gen(function* () {
*   console.log("parent: started!")
*   // Daemon fiber running independently
*   yield* Effect.forkDaemon(daemon)
*   yield* Effect.sleep("3 seconds")
*   console.log("parent: finished!")
* })
*
* Effect.runFork(parent)
* // Output:
* // parent: started!
* // daemon: still running!
* // daemon: still running!
* // daemon: still running!
* // parent: finished!
* // daemon: still running!
* // daemon: still running!
* // daemon: still running!
* // daemon: still running!
* // daemon: still running!
* // ...etc...
* ```
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const forkDaemon = forkDaemon$1;
/**
* Returns an effect that forks all of the specified values, and returns a
* composite fiber that produces a list of their results, in order.
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const forkAll = forkAll$1;
/**
* Forks an effect in a specific scope, allowing finer control over its
* execution.
*
* **Details**
*
* There are some cases where we need more fine-grained control, so we want to
* fork a fiber in a specific scope. We can use the `Effect.forkIn` operator
* which takes the target scope as an argument.
*
* The fiber will be interrupted when the scope is closed.
*
* **Example** (Forking a Fiber in a Specific Scope)
*
* In this example, the child fiber is forked into the outerScope,
* allowing it to outlive the inner scope but still be terminated
* when the outerScope is closed.
*
* ```ts
* import { Console, Effect, Schedule } from "effect"
*
* // Child fiber that logs a message repeatedly every second
* const child = Effect.repeat(
*   Console.log("child: still running!"),
*   Schedule.fixed("1 second")
* )
*
* const program = Effect.scoped(
*   Effect.gen(function* () {
*     yield* Effect.addFinalizer(() =>
*       Console.log("The outer scope is about to be closed!")
*     )
*
*     // Capture the outer scope
*     const outerScope = yield* Effect.scope
*
*     // Create an inner scope
*     yield* Effect.scoped(
*       Effect.gen(function* () {
*         yield* Effect.addFinalizer(() =>
*           Console.log("The inner scope is about to be closed!")
*         )
*         // Fork the child fiber in the outer scope
*         yield* Effect.forkIn(child, outerScope)
*         yield* Effect.sleep("3 seconds")
*       })
*     )
*
*     yield* Effect.sleep("5 seconds")
*   })
* )
*
* Effect.runFork(program)
* // Output:
* // child: still running!
* // child: still running!
* // child: still running!
* // The inner scope is about to be closed!
* // child: still running!
* // child: still running!
* // child: still running!
* // child: still running!
* // child: still running!
* // child: still running!
* // The outer scope is about to be closed!
* ```
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const forkIn = forkIn$1;
/**
* Forks a fiber in a local scope, ensuring it outlives its parent.
*
* **Details**
*
* This function is used to create fibers that are tied to a local scope,
* meaning they are not dependent on their parent fiber's lifecycle. Instead,
* they will continue running until the scope they were created in is closed.
* This is particularly useful when you need a fiber to run independently of the
* parent fiber, but still want it to be terminated when the scope ends.
*
* Fibers created with this function are isolated from the parent fiber’s
* termination, so they can run for a longer period. This behavior is different
* from fibers created with {@link fork}, which are terminated when the parent fiber
* terminates. With `forkScoped`, the child fiber will keep running until the
* local scope ends, regardless of the state of the parent fiber.
*
* **Example** (Forking a Fiber in a Local Scope)
*
* In this example, the child fiber continues to run beyond the lifetime of the parent fiber.
* The child fiber is tied to the local scope and will be terminated only when the scope ends.
*
* ```ts
* import { Effect, Console, Schedule } from "effect"
*
* // Child fiber that logs a message repeatedly every second
* const child = Effect.repeat(
*   Console.log("child: still running!"),
*   Schedule.fixed("1 second")
* )
*
* //      ┌─── Effect<void, never, Scope>
* //      ▼
* const parent = Effect.gen(function* () {
*   console.log("parent: started!")
*   // Child fiber attached to local scope
*   yield* Effect.forkScoped(child)
*   yield* Effect.sleep("3 seconds")
*   console.log("parent: finished!")
* })
*
* // Program runs within a local scope
* const program = Effect.scoped(
*   Effect.gen(function* () {
*     console.log("Local scope started!")
*     yield* Effect.fork(parent)
*     // Scope lasts for 5 seconds
*     yield* Effect.sleep("5 seconds")
*     console.log("Leaving the local scope!")
*   })
* )
*
* Effect.runFork(program)
* // Output:
* // Local scope started!
* // parent: started!
* // child: still running!
* // child: still running!
* // child: still running!
* // parent: finished!
* // child: still running!
* // child: still running!
* // Leaving the local scope!
* ```
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const forkScoped = forkScoped$1;
/**
* Like {@link fork} but handles an error with the provided handler.
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const forkWithErrorHandler = forkWithErrorHandler$1;
/**
* Creates an `Effect` value that represents the exit value of the specified
* fiber.
*
* @see {@link fromFiberEffect} for creating an effect from a fiber obtained from an effect.
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const fromFiber = fromFiber$1;
/**
* Creates an `Effect` value that represents the exit value of a fiber obtained
* from an effect.
*
* @see {@link fromFiber} for creating an effect from a fiber.
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const fromFiberEffect = fromFiberEffect$1;
/**
* Supervises child fibers by reporting them to a specified supervisor.
*
* **Details**
*
* This function takes a supervisor as an argument and returns an effect where
* all child fibers forked within it are supervised by the provided supervisor.
* This enables you to capture detailed information about these child fibers,
* such as their status, through the supervisor.
*
* **Example** (Monitoring Fiber Count)
*
* ```ts
* import { Effect, Supervisor, Schedule, Fiber, FiberStatus } from "effect"
*
* // Main program that monitors fibers while calculating a Fibonacci number
* const program = Effect.gen(function* () {
*   // Create a supervisor to track child fibers
*   const supervisor = yield* Supervisor.track
*
*   // Start a Fibonacci calculation, supervised by the supervisor
*   const fibFiber = yield* fib(20).pipe(
*     Effect.supervised(supervisor),
*     // Fork the Fibonacci effect into a fiber
*     Effect.fork
*   )
*
*   // Define a schedule to periodically monitor the fiber count every 500ms
*   const policy = Schedule.spaced("500 millis").pipe(
*     Schedule.whileInputEffect((_) =>
*       Fiber.status(fibFiber).pipe(
*         // Continue while the Fibonacci fiber is not done
*         Effect.andThen((status) => status !== FiberStatus.done)
*       )
*     )
*   )
*
*   // Start monitoring the fibers, using the supervisor to track the count
*   const monitorFiber = yield* monitorFibers(supervisor).pipe(
*     // Repeat the monitoring according to the schedule
*     Effect.repeat(policy),
*     // Fork the monitoring into its own fiber
*     Effect.fork
*   )
*
*   // Join the monitor and Fibonacci fibers to ensure they complete
*   yield* Fiber.join(monitorFiber)
*   const result = yield* Fiber.join(fibFiber)
*
*   console.log(`fibonacci result: ${result}`)
* })
*
* // Function to monitor and log the number of active fibers
* const monitorFibers = (
*   supervisor: Supervisor.Supervisor<Array<Fiber.RuntimeFiber<any, any>>>
* ): Effect.Effect<void> =>
*   Effect.gen(function* () {
*     const fibers = yield* supervisor.value // Get the current set of fibers
*     console.log(`number of fibers: ${fibers.length}`)
*   })
*
* // Recursive Fibonacci calculation, spawning fibers for each recursive step
* const fib = (n: number): Effect.Effect<number> =>
*   Effect.gen(function* () {
*     if (n <= 1) {
*       return 1
*     }
*     yield* Effect.sleep("500 millis") // Simulate work by delaying
*
*     // Fork two fibers for the recursive Fibonacci calls
*     const fiber1 = yield* Effect.fork(fib(n - 2))
*     const fiber2 = yield* Effect.fork(fib(n - 1))
*
*     // Join the fibers to retrieve their results
*     const v1 = yield* Fiber.join(fiber1)
*     const v2 = yield* Fiber.join(fiber2)
*
*     return v1 + v2 // Combine the results
*   })
*
* Effect.runPromise(program)
* // Output:
* // number of fibers: 0
* // number of fibers: 2
* // number of fibers: 6
* // number of fibers: 14
* // number of fibers: 30
* // number of fibers: 62
* // number of fibers: 126
* // number of fibers: 254
* // number of fibers: 510
* // number of fibers: 1022
* // number of fibers: 2034
* // number of fibers: 3795
* // number of fibers: 5810
* // number of fibers: 6474
* // number of fibers: 4942
* // number of fibers: 2515
* // number of fibers: 832
* // number of fibers: 170
* // number of fibers: 18
* // number of fibers: 0
* // fibonacci result: 10946
* ```
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const supervised = supervised$1;
/**
* Transplants specified effects so that when those effects fork other
* effects, the forked effects will be governed by the scope of the fiber that
* executes this effect.
*
* This can be used to "graft" deep grandchildren onto a higher-level scope,
* effectively extending their lifespans into the parent scope.
*
* @since 2.0.0
* @category Supervision & Fibers
*/
const transplant = transplant$1;
/**
* @since 2.0.0
* @category Supervision & Fibers
*/
const withConcurrency = withConcurrency$1;
/**
* Sets the provided scheduler for usage in the wrapped effect
*
* @since 2.0.0
* @category Scheduler
*/
const withScheduler = withScheduler$1;
/**
* Sets the scheduling priority used when yielding
*
* @since 2.0.0
* @category Scheduler
*/
const withSchedulingPriority = withSchedulingPriority$1;
/**
* Sets the maximum number of operations before yield by the default schedulers
*
* @since 2.0.0
* @category Scheduler
*/
const withMaxOpsBeforeYield = withMaxOpsBeforeYield$1;
/**
* Retrieves the `Clock` service from the context.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const program = Effect.gen(function*() {
*   const clock = yield* Effect.clock
*   const currentTime = yield* clock.currentTimeMillis
*   console.log(`Current time in milliseconds: ${currentTime}`)
* })
*
* Effect.runFork(program)
* // Example Output:
* // Current time in milliseconds: 1735484796134
* ```
*
* @since 2.0.0
* @category Clock
*/
const clock = clock$1;
/**
* Retrieves the `Clock` service from the context and provides it to the
* specified effectful function.
*
* **Example**
*
* ```ts
* import { Console, Effect } from "effect"
*
* const program = Effect.clockWith((clock) =>
*   clock.currentTimeMillis.pipe(
*     Effect.map((currentTime) => `Current time is: ${currentTime}`),
*     Effect.tap(Console.log)
*   )
* )
*
* Effect.runFork(program)
* // Example Output:
* // Current time is: 1735484929744
* ```
*
* @since 2.0.0
* @category Clock
*/
const clockWith = clockWith$1;
/**
* Sets the implementation of the `Clock` service to the specified value and
* restores it to its original value when the scope is closed.
*
* @since 2.0.0
* @category Clock
*/
const withClockScoped = withClockScoped$1;
/**
* Executes the specified workflow with the specified implementation of the
* `Clock` service.
*
* @since 2.0.0
* @category Clock
*/
const withClock = withClock$1;
/**
* Retreives the `Console` service from the context
*
* @since 2.0.0
* @category Console
*/
const console$1 = console$2;
/**
* Retreives the `Console` service from the context and provides it to the
* specified effectful function.
*
* @since 2.0.0
* @category Console
*/
const consoleWith = consoleWith$1;
/**
* Sets the implementation of the console service to the specified value and
* restores it to its original value when the scope is closed.
*
* @since 2.0.0
* @category Creating Effects
*/
const withConsoleScoped = withConsoleScoped$1;
/**
* Executes the specified workflow with the specified implementation of the
* console service.
*
* @since 2.0.0
* @category Console
*/
const withConsole = withConsole$1;
/**
* Delays the execution of an effect by a specified `Duration`.
*
* **Details
*
* This function postpones the execution of the provided effect by the specified
* duration. The duration can be provided in various formats supported by the
* `Duration` module.
*
* Internally, this function does not block the thread; instead, it uses an
* efficient, non-blocking mechanism to introduce the delay.
*
* **Example**
*
* ```ts
* import { Console, Effect } from "effect"
*
* const task = Console.log("Task executed")
*
* const program = Console.log("start").pipe(
*   Effect.andThen(
*     // Delays the log message by 2 seconds
*     task.pipe(Effect.delay("2 seconds"))
*   )
* )
*
* Effect.runFork(program)
* // Output:
* // start
* // Task executed
* ```
*
* @since 2.0.0
* @category Delays & Timeouts
*/
const delay = delay$1;
/**
* Suspends the execution of an effect for a specified `Duration`.
*
* **Details**
*
* This function pauses the execution of an effect for a given duration. It is
* asynchronous, meaning that it does not block the fiber executing the effect.
* Instead, the fiber is suspended during the delay period and can resume once
* the specified time has passed.
*
* The duration can be specified using various formats supported by the
* `Duration` module, such as a string (`"2 seconds"`) or numeric value
* representing milliseconds.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const program = Effect.gen(function*() {
*   console.log("Starting task...")
*   yield* Effect.sleep("3 seconds") // Waits for 3 seconds
*   console.log("Task completed!")
* })
*
* Effect.runFork(program)
* // Output:
* // Starting task...
* // Task completed!
* ```
*
* @since 2.0.0
* @category Delays & Timeouts
*/
const sleep = sleep$1;
/**
* Executes an effect and measures the time it takes to complete.
*
* **Details**
*
* This function wraps the provided effect and returns a new effect that, when
* executed, performs the original effect and calculates its execution duration.
*
* The result of the new effect includes both the execution time (as a
* `Duration`) and the original effect's result. This is useful for monitoring
* performance or gaining insights into the time taken by specific operations.
*
* The original effect's behavior (success, failure, or interruption) remains
* unchanged, and the timing information is provided alongside the result in a
* tuple.
*
* **Example**
*
* ```ts
* import { Duration, Effect } from "effect"
*
* const task = Effect.gen(function*() {
*   yield* Effect.sleep("2 seconds") // Simulates some work
*   return "some result"
* })
*
* const timedTask = task.pipe(Effect.timed)
*
* const program = Effect.gen(function*() {
*   const [duration, result] = yield* timedTask
*   console.log(`Task completed in ${Duration.toMillis(duration)} ms with result: ${result}`)
* })
*
* Effect.runFork(program)
* // Output: Task completed in 2003.749125 ms with result: some result
* ```
*
* @since 2.0.0
* @category Delays & Timeouts
*/
const timed = timed$1;
/**
* Executes an effect and measures its execution time using a custom clock.
*
* **Details**
*
* This function extends the functionality of {@link timed} by allowing you to
* specify a custom clock for measuring the execution duration. The provided
* effect (`nanoseconds`) represents the clock and should return the current
* time in nanoseconds. The timing information is computed using this custom
* clock instead of the default system clock.
*
* @since 2.0.0
* @category Delays & Timeouts
*/
const timedWith = timedWith$1;
/**
* Adds a time limit to an effect, triggering a timeout if the effect exceeds
* the duration.
*
* **Details**
*
* This function allows you to enforce a time limit on the execution of an
* effect. If the effect does not complete within the given duration, it fails
* with a `TimeoutException`. This is useful for preventing tasks from hanging
* indefinitely, especially in scenarios where responsiveness or resource limits
* are critical.
*
* The returned effect will either:
* - Succeed with the original effect's result if it completes within the
*   specified duration.
* - Fail with a `TimeoutException` if the time limit is exceeded.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const task = Effect.gen(function* () {
*   console.log("Start processing...")
*   yield* Effect.sleep("2 seconds") // Simulates a delay in processing
*   console.log("Processing complete.")
*   return "Result"
* })
*
* // Output will show a TimeoutException as the task takes longer
* // than the specified timeout duration
* const timedEffect = task.pipe(Effect.timeout("1 second"))
*
* Effect.runPromiseExit(timedEffect).then(console.log)
* // Output:
* // Start processing...
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: {
* //     _id: 'Cause',
* //     _tag: 'Fail',
* //     failure: { _tag: 'TimeoutException' }
* //   }
* // }
* ```
*
* @see {@link timeoutFail} for a version that raises a custom error.
* @see {@link timeoutFailCause} for a version that raises a custom defect.
* @see {@link timeoutTo} for a version that allows specifying both success and
* timeout handlers.
*
* @since 2.0.0
* @category Delays & Timeouts
*/
const timeout = timeout$1;
/**
* Gracefully handles timeouts by returning an `Option` that represents either
* the result or a timeout.
*
* **Details**
*
* This function wraps the outcome of an effect in an `Option` type. If the
* effect completes within the specified duration, it returns a `Some`
* containing the result. If the effect times out, it returns a `None`. Unlike
* other timeout methods, this approach does not raise errors or exceptions;
* instead, it allows you to treat timeouts as a regular outcome, simplifying
* the logic for handling delays.
*
* **When to Use**
*
* This is useful when you want to handle timeouts without causing the program
* to fail, making it easier to manage situations where you expect tasks might
* take too long but want to continue executing other tasks.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const task = Effect.gen(function* () {
*   console.log("Start processing...")
*   yield* Effect.sleep("2 seconds") // Simulates a delay in processing
*   console.log("Processing complete.")
*   return "Result"
* })
*
* const timedOutEffect = Effect.all([
*   task.pipe(Effect.timeoutOption("3 seconds")),
*   task.pipe(Effect.timeoutOption("1 second"))
* ])
*
* Effect.runPromise(timedOutEffect).then(console.log)
* // Output:
* // Start processing...
* // Processing complete.
* // Start processing...
* // [
* //   { _id: 'Option', _tag: 'Some', value: 'Result' },
* //   { _id: 'Option', _tag: 'None' }
* // ]
* ```
*
* @see {@link timeout} for a version that raises a `TimeoutException`.
* @see {@link timeoutFail} for a version that raises a custom error.
* @see {@link timeoutFailCause} for a version that raises a custom defect.
* @see {@link timeoutTo} for a version that allows specifying both success and
* timeout handlers.
*
* @since 3.1.0
* @category Delays & Timeouts
*/
const timeoutOption = timeoutOption$1;
/**
* Specifies a custom error to be produced when a timeout occurs.
*
* **Details**
*
* This function allows you to handle timeouts in a customized way by defining a
* specific error to be raised when an effect exceeds the given duration. Unlike
* default timeout behaviors that use generic exceptions, this function gives
* you the flexibility to specify a meaningful error type that aligns with your
* application's needs.
*
* When you apply this function, you provide:
* - A `duration`: The time limit for the effect.
* - An `onTimeout` function: A lazy evaluation function that generates the
*   custom error if the timeout occurs.
*
* If the effect completes within the time limit, its result is returned
* normally. Otherwise, the `onTimeout` function is triggered, and its output is
* used as the error for the effect.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const task = Effect.gen(function* () {
*   console.log("Start processing...")
*   yield* Effect.sleep("2 seconds") // Simulates a delay in processing
*   console.log("Processing complete.")
*   return "Result"
* })
*
* class MyTimeoutError {
*   readonly _tag = "MyTimeoutError"
* }
*
* const program = task.pipe(
*   Effect.timeoutFail({
*     duration: "1 second",
*     onTimeout: () => new MyTimeoutError() // Custom timeout error
*   })
* )
*
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // Start processing...
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: {
* //     _id: 'Cause',
* //     _tag: 'Fail',
* //     failure: MyTimeoutError { _tag: 'MyTimeoutError' }
* //   }
* // }
* ```
*
* @see {@link timeout} for a version that raises a `TimeoutException`.
* @see {@link timeoutFailCause} for a version that raises a custom defect.
* @see {@link timeoutTo} for a version that allows specifying both success and
* timeout handlers.
*
* @since 2.0.0
* @category Delays & Timeouts
*/
const timeoutFail = timeoutFail$1;
/**
* Specifies a custom defect to be thrown when a timeout occurs.
*
* **Details**
*
* This function allows you to handle timeouts as exceptional cases by
* generating a custom defect when an effect exceeds the specified duration. You
* provide:
* - A `duration`: The time limit for the effect.
* - An `onTimeout` function: A lazy evaluation function that generates the
*   custom defect (typically created using `Cause.die`).
*
* If the effect completes within the time limit, its result is returned
* normally. Otherwise, the custom defect is triggered, and the effect fails
* with that defect.
*
* **When to Use**
*
* This is especially useful when you need to treat timeouts as critical
* failures in your application and wish to include meaningful information in
* the defect.
*
* **Example**
*
* ```ts
* import { Effect, Cause } from "effect"
*
* const task = Effect.gen(function* () {
*   console.log("Start processing...")
*   yield* Effect.sleep("2 seconds") // Simulates a delay in processing
*   console.log("Processing complete.")
*   return "Result"
* })
*
* const program = task.pipe(
*   Effect.timeoutFailCause({
*     duration: "1 second",
*     onTimeout: () => Cause.die("Timed out!") // Custom defect for timeout
*   })
* )
*
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // Start processing...
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: { _id: 'Cause', _tag: 'Die', defect: 'Timed out!' }
* // }
* ```
*
* @see {@link timeout} for a version that raises a `TimeoutException`.
* @see {@link timeoutFail} for a version that raises a custom error.
* @see {@link timeoutTo} for a version that allows specifying both success and
* timeout handlers.
*
* @since 2.0.0
* @category Delays & Timeouts
*/
const timeoutFailCause = timeoutFailCause$1;
/**
* Provides custom behavior for successful and timed-out operations.
*
* **Details**
*
* This function allows you to define distinct outcomes for an effect depending
* on whether it completes within a specified time frame or exceeds the timeout
* duration. You can provide:
* - `onSuccess`: A handler for processing the result of the effect if it
*   completes successfully within the time limit.
* - `onTimeout`: A handler for generating a result when the effect times out.
* - `duration`: The maximum allowed time for the effect to complete.
*
* **When to Use**
*
* Unlike {@link timeout}, which raises an exception for timeouts, this function
* gives you full control over the behavior for both success and timeout
* scenarios. It is particularly useful when you want to encapsulate timeouts
* and successes into a specific data structure, like an `Either` type, to
* represent these outcomes in a meaningful way.
*
* **Example**
*
* ```ts
* import { Effect, Either } from "effect"
*
* const task = Effect.gen(function* () {
*   console.log("Start processing...")
*   yield* Effect.sleep("2 seconds") // Simulates a delay in processing
*   console.log("Processing complete.")
*   return "Result"
* })
*
* const program = task.pipe(
*   Effect.timeoutTo({
*     duration: "1 second",
*     onSuccess: (result): Either.Either<string, string> =>
*       Either.right(result),
*     onTimeout: (): Either.Either<string, string> =>
*       Either.left("Timed out!")
*   })
* )
*
* Effect.runPromise(program).then(console.log)
* // Output:
* // Start processing...
* // {
* //   _id: "Either",
* //   _tag: "Left",
* //   left: "Timed out!"
* // }
* ```
*
* @see {@link timeout} for a version that raises a `TimeoutException`.
* @see {@link timeoutFail} for a version that raises a custom error.
* @see {@link timeoutFailCause} for a version that raises a custom defect.
*
* @since 2.0.0
* @category Delays & Timeouts
*/
const timeoutTo = timeoutTo$1;
/**
* Allows working with the default configuration provider.
*
* **Details**
*
* This function retrieves the default configuration provider and passes it to
* the provided function, which can use it to perform computations or retrieve
* configuration values. The function can return an effect that leverages the
* configuration provider for its operations.
*
* @since 2.0.0
* @category Config
*/
const configProviderWith = configProviderWith$1;
/**
* Executes an effect using a specific configuration provider.
*
* **Details**
*
* This function lets you run an effect with a specified configuration provider.
* The custom provider will override the default configuration provider for the
* duration of the effect's execution.
*
* **When to Use**
*
* This is particularly useful when you need to use a different set of
* configuration values or sources for specific parts of your application.
*
* **Example**
*
* ```ts
* import { Config, ConfigProvider, Effect } from "effect"
*
* const customProvider: ConfigProvider.ConfigProvider = ConfigProvider.fromMap(
*   new Map([["custom-key", "custom-value"]])
* )
*
* const program = Effect.withConfigProvider(customProvider)(
*   Effect.gen(function*() {
*     const value = yield* Config.string("custom-key")
*     console.log(`Config value: ${value}`)
*   })
* )
*
* Effect.runPromise(program)
* // Output:
* // Config value: custom-value
* ```
*
* @since 2.0.0
* @category Config
*/
const withConfigProvider = withConfigProvider$1;
/**
* Sets a configuration provider within a scope.
*
* **Details**
*
* This function sets the configuration provider to a specified value and
* ensures that it is restored to its original value when the scope is closed.
*
* @since 2.0.0
* @category Config
*/
const withConfigProviderScoped = withConfigProviderScoped$1;
/**
* Accesses the full context of the effect.
*
* **Details**
*
* This function provides the ability to access the entire context required by
* an effect. The context is a container that holds dependencies or environment
* values needed by an effect to run. By using this function, you can retrieve
* and work with the context directly within an effect.
*
* @since 2.0.0
* @category Context
*/
const context = context$1;
/**
* Accesses the context and applies a transformation function.
*
* **Details**
*
* This function retrieves the context of the effect and applies a pure
* transformation function to it. The result of the transformation is then
* returned within the effect.
*
* @see {@link contextWithEffect} for a version that allows effectful transformations.
*
* @since 2.0.0
* @category Context
*/
const contextWith = contextWith$1;
/**
* Accesses the context and performs an effectful transformation.
*
* **Details**
*
* This function retrieves the context and allows you to transform it
* effectually using another effect. It is useful when the transformation
* involves asynchronous or effectful operations.
*
* @see {@link contextWith} for a version that allows pure transformations.
*
* @since 2.0.0
* @category Context
*/
const contextWithEffect = contextWithEffect$1;
/**
* Provides part of the required context while leaving the rest unchanged.
*
* **Details**
*
* This function allows you to transform the context required by an effect,
* providing part of the context and leaving the rest to be fulfilled later.
*
* **Example**
*
* ```ts
* import { Context, Effect } from "effect"
*
* class Service1 extends Context.Tag("Service1")<Service1, { readonly port: number }>() {}
* class Service2 extends Context.Tag("Service2")<Service2, { readonly connection: string }>() {}
*
* const program = Effect.gen(function*() {
*   const service1 = yield* Service1
*   console.log(service1.port)
*   const service2 = yield* Service2
*   console.log(service2.connection)
*   return "some result"
* })
*
* //      ┌─── Effect<string, never, Service2>
* //      ▼
* const programWithService1 = Effect.mapInputContext(
*   program,
*   (ctx: Context.Context<Service2>) => Context.add(ctx, Service1, { port: 3000 })
* )
*
* const runnable = programWithService1.pipe(
*   Effect.provideService(Service2, { connection: "localhost" }),
*   Effect.provideService(Service1, { port: 3001 })
* )
*
* Effect.runPromise(runnable)
* // Output:
* // 3000
* // localhost
* ```
*
* @since 2.0.0
* @category Context
*/
const mapInputContext = mapInputContext$1;
/**
* Provides necessary dependencies to an effect, removing its environmental
* requirements.
*
* **Details**
*
* This function allows you to supply the required environment for an effect.
* The environment can be provided in the form of one or more `Layer`s, a
* `Context`, a `Runtime`, or a `ManagedRuntime`. Once the environment is
* provided, the effect can run without requiring external dependencies.
*
* You can compose layers to create a modular and reusable way of setting up the
* environment for effects. For example, layers can be used to configure
* databases, logging services, or any other required dependencies.
*
* **Example**
*
* ```ts
* import { Context, Effect, Layer } from "effect"
*
* class Database extends Context.Tag("Database")<
*   Database,
*   { readonly query: (sql: string) => Effect.Effect<Array<unknown>> }
* >() {}
*
* const DatabaseLive = Layer.succeed(
*   Database,
*   {
*     // Simulate a database query
*     query: (sql: string) => Effect.log(`Executing query: ${sql}`).pipe(Effect.as([]))
*   }
* )
*
* //      ┌─── Effect<unknown[], never, Database>
* //      ▼
* const program = Effect.gen(function*() {
*   const database = yield* Database
*   const result = yield* database.query("SELECT * FROM users")
*   return result
* })
*
* //      ┌─── Effect<unknown[], never, never>
* //      ▼
* const runnable = Effect.provide(program, DatabaseLive)
*
* Effect.runPromise(runnable).then(console.log)
* // Output:
* // timestamp=... level=INFO fiber=#0 message="Executing query: SELECT * FROM users"
* // []
* ```
*
* @see {@link provideService} for providing a service to an effect.
*
* @since 2.0.0
* @category Context
*/
const provide = effect_provide;
/**
* Provides an implementation for a service in the context of an effect.
*
* **Details**
*
* This function allows you to supply a specific implementation for a service
* required by an effect. Services are typically defined using `Context.Tag`,
* which acts as a unique identifier for the service. By using this function,
* you link the service to its concrete implementation, enabling the effect to
* execute successfully without additional requirements.
*
* For example, you can use this function to provide a random number generator,
* a logger, or any other service your effect depends on. Once the service is
* provided, all parts of the effect that rely on the service will automatically
* use the implementation you supplied.
*
* **Example**
*
* ```ts
* import { Effect, Context } from "effect"
*
* // Declaring a tag for a service that generates random numbers
* class Random extends Context.Tag("MyRandomService")<
*   Random,
*   { readonly next: Effect.Effect<number> }
* >() {}
*
* // Using the service
* const program = Effect.gen(function* () {
*   const random = yield* Random
*   const randomNumber = yield* random.next
*   console.log(`random number: ${randomNumber}`)
* })
*
* // Providing the implementation
* //
* //      ┌─── Effect<void, never, never>
* //      ▼
* const runnable = Effect.provideService(program, Random, {
*   next: Effect.sync(() => Math.random())
* })
*
* // Run successfully
* Effect.runPromise(runnable)
* // Example Output:
* // random number: 0.8241872233134417
* ```
*
* @see {@link provide} for providing multiple layers to an effect.
*
* @since 2.0.0
* @category Context
*/
const provideService = provideService$1;
/**
* Dynamically provides an implementation for a service using an effect.
*
* **Details**
*
* This function allows you to provide an implementation for a service
* dynamically by using another effect. The provided effect is executed to
* produce the service implementation, which is then made available to the
* consuming effect. This is particularly useful when the service implementation
* itself requires asynchronous or resource-intensive initialization.
*
* For example, you can use this function to lazily initialize a database
* connection or fetch configuration values from an external source before
* making the service available to your effect.
*
* @since 2.0.0
* @category Context
*/
const provideServiceEffect = provideServiceEffect$1;
/**
* Creates a function that uses a service from the context to produce a value.
*
* @see {@link serviceFunctionEffect} for a version that returns an effect.
*
* @since 2.0.0
* @category Context
*/
const serviceFunction = serviceFunction$1;
/**
* Creates a function that uses a service from the context to produce an effect.
*
* @see {@link serviceFunction} for a version that returns a value.
*
* @since 2.0.0
* @category Context
*/
const serviceFunctionEffect = serviceFunctionEffect$1;
/**
* @since 2.0.0
* @category Context
*/
const serviceFunctions = serviceFunctions$1;
/**
* @since 2.0.0
* @category Context
*/
const serviceConstants = serviceConstants$1;
/**
* @since 2.0.0
* @category Context
*/
const serviceMembers = serviceMembers$1;
/**
* Retrieves an optional service from the context as an `Option`.
*
* **Details**
*
* This function retrieves a service from the context and wraps it in an
* `Option`. If the service is available, it returns a `Some` containing the
* service. If the service is not found, it returns a `None`. This approach is
* useful when you want to handle the absence of a service gracefully without
* causing an error.
*
* **When to Use**
*
* Use this function when:
* - You need to access a service that may or may not be present in the context.
* - You want to handle the absence of a service using the `Option` type instead
*   of throwing an error.
*
* @see {@link serviceOptional} for a version that throws an error if the service is missing.
*
* @since 2.0.0
* @category Context
*/
const serviceOption = serviceOption$1;
/**
* Retrieves a service from the context, throwing an error if it is missing.
*
* **Details**
*
* This function retrieves a required service from the context. If the service
* is available, it returns the service. If the service is missing, it throws a
* `NoSuchElementException`, which can be handled using Effect's error-handling
* mechanisms. This is useful for services that are critical to the execution of
* your effect.
*
* @see {@link serviceOption} for a version that returns an `Option` instead of throwing an error.
*
* @since 2.0.0
* @category Context
*/
const serviceOptional = serviceOptional$1;
/**
* Updates a service in the context with a new implementation.
*
* **Details**
*
* This function modifies the existing implementation of a service in the
* context. It retrieves the current service, applies the provided
* transformation function `f`, and replaces the old service with the
* transformed one.
*
* **When to Use**
*
* This is useful for adapting or extending a service's behavior during the
* execution of an effect.
*
* @since 2.0.0
* @category Context
*/
const updateService = updateService$1;
/**
* The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.
*
* Here's how the do simulation works:
*
* 1. Start the do simulation using the `Do` value
* 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values
* 3. You can accumulate multiple `bind` statements to define multiple variables within the scope
* 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
*
* **Example**
*
* ```ts
* import * as assert from "node:assert"
* import { Effect, pipe } from "effect"
*
* const result = pipe(
*   Effect.Do,
*   Effect.bind("x", () => Effect.succeed(2)),
*   Effect.bind("y", () => Effect.succeed(3)),
*   Effect.let("sum", ({ x, y }) => x + y)
* )
* assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })
* ```
*
* @see {@link bind}
* @see {@link bindTo}
* @see {@link let_ let}
*
* @category Do notation
* @since 2.0.0
*/
const Do = Do$1;
/**
* The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.
*
* Here's how the do simulation works:
*
* 1. Start the do simulation using the `Do` value
* 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values
* 3. You can accumulate multiple `bind` statements to define multiple variables within the scope
* 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
*
* **Example**
*
* ```ts
* import * as assert from "node:assert"
* import { Effect, pipe } from "effect"
*
* const result = pipe(
*   Effect.Do,
*   Effect.bind("x", () => Effect.succeed(2)),
*   Effect.bind("y", () => Effect.succeed(3)),
*   Effect.let("sum", ({ x, y }) => x + y)
* )
* assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })
* ```
*
* @see {@link Do}
* @see {@link bindTo}
* @see {@link let_ let}
*
* @category Do notation
* @since 2.0.0
*/
const bind = bind$1;
/**
* `bindAll` combines `all` with `bind`. It is useful
* when you want to concurrently run multiple effects and then combine their
* results in a Do notation pipeline.
*
* **Example**
*
* ```ts
* import * as assert from "node:assert"
* import { Effect, Either, pipe } from "effect"
*
* const result = pipe(
*   Effect.Do,
*   Effect.bind("x", () => Effect.succeed(2)),
*   Effect.bindAll(({ x }) => ({
*     a: Effect.succeed(x),
*     b: Effect.fail("oops"),
*   }), { concurrency: 2, mode: "either" })
* )
* assert.deepStrictEqual(Effect.runSync(result), { x: 2, a: Either.right(2), b: Either.left("oops") })
* ```
*
* @category Do notation
* @since 3.7.0
*/
const bindAll = bindAll$1;
/**
* The "do simulation" in Effect allows you to write code in a more declarative style, similar to the "do notation" in other programming languages. It provides a way to define variables and perform operations on them using functions like `bind` and `let`.
*
* Here's how the do simulation works:
*
* 1. Start the do simulation using the `Do` value
* 2. Within the do simulation scope, you can use the `bind` function to define variables and bind them to `Effect` values
* 3. You can accumulate multiple `bind` statements to define multiple variables within the scope
* 4. Inside the do simulation scope, you can also use the `let` function to define variables and bind them to simple values
*
* **Example**
*
* ```ts
* import * as assert from "node:assert"
* import { Effect, pipe } from "effect"
*
* const result = pipe(
*   Effect.Do,
*   Effect.bind("x", () => Effect.succeed(2)),
*   Effect.bind("y", () => Effect.succeed(3)),
*   Effect.let("sum", ({ x, y }) => x + y)
* )
* assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })
* ```
*
* @see {@link Do}
* @see {@link bind}
* @see {@link let_ let}
*
* @category Do notation
* @since 2.0.0
*/
const bindTo = bindTo$1;
const let_ = let_$1;
/**
* Encapsulates the result of an effect in an `Option`.
*
* **Details**
*
* This function wraps the outcome of an effect in an `Option` type. If the
* original effect succeeds, the success value is wrapped in `Option.some`. If
* the effect fails, the failure is converted to `Option.none`.
*
* This is particularly useful for scenarios where you want to represent the
* absence of a value explicitly, without causing the resulting effect to fail.
* The resulting effect has an error type of `never`, meaning it cannot fail
* directly. However, unrecoverable errors, also referred to as defects, are
* not captured and will still result in failure.
*
* **Example** (Using Effect.option to Handle Errors)
*
* ```ts
* import { Effect } from "effect"
*
* const maybe1 = Effect.option(Effect.succeed(1))
*
* Effect.runPromiseExit(maybe1).then(console.log)
* // Output:
* // {
* //   _id: 'Exit',
* //   _tag: 'Success',
* //   value: { _id: 'Option', _tag: 'Some', value: 1 }
* // }
*
* const maybe2 = Effect.option(Effect.fail("Uh oh!"))
*
* Effect.runPromiseExit(maybe2).then(console.log)
* // Output:
* // {
* //   _id: 'Exit',
* //   _tag: 'Success',
* //   value: { _id: 'Option', _tag: 'None' }
* // }
*
* const maybe3 = Effect.option(Effect.die("Boom!"))
*
* Effect.runPromiseExit(maybe3).then(console.log)
* // Output:
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: { _id: 'Cause', _tag: 'Die', defect: 'Boom!' }
* // }
* ```
*
* @see {@link either} for a version that uses `Either` instead.
* @see {@link exit} for a version that encapsulates both recoverable errors and defects in an `Exit`.
*
* @since 2.0.0
* @category Outcome Encapsulation
*/
const option = option$1;
/**
* Encapsulates both success and failure of an `Effect` into an `Either` type.
*
* **Details**
*
* This function converts an effect that may fail into an effect that always
* succeeds, wrapping the outcome in an `Either` type. The result will be
* `Either.Left` if the effect fails, containing the recoverable error, or
* `Either.Right` if it succeeds, containing the result.
*
* Using this function, you can handle recoverable errors explicitly without
* causing the effect to fail. This is particularly useful in scenarios where
* you want to chain effects and manage both success and failure in the same
* logical flow.
*
* It's important to note that unrecoverable errors, often referred to as
* "defects," are still thrown and not captured within the `Either` type. Only
* failures that are explicitly represented as recoverable errors in the effect
* are encapsulated.
*
* The resulting effect cannot fail directly because all recoverable failures
* are represented inside the `Either` type.
*
* **Example**
*
* ```ts
* import { Effect, Either, Random } from "effect"
*
* class HttpError {
*   readonly _tag = "HttpError"
* }
*
* class ValidationError {
*   readonly _tag = "ValidationError"
* }
*
* //      ┌─── Effect<string, HttpError | ValidationError, never>
* //      ▼
* const program = Effect.gen(function* () {
*   const n1 = yield* Random.next
*   const n2 = yield* Random.next
*   if (n1 < 0.5) {
*     yield* Effect.fail(new HttpError())
*   }
*   if (n2 < 0.5) {
*     yield* Effect.fail(new ValidationError())
*   }
*   return "some result"
* })
*
* //      ┌─── Effect<string, never, never>
* //      ▼
* const recovered = Effect.gen(function* () {
*   //      ┌─── Either<string, HttpError | ValidationError>
*   //      ▼
*   const failureOrSuccess = yield* Effect.either(program)
*   return Either.match(failureOrSuccess, {
*     onLeft: (error) => `Recovering from ${error._tag}`,
*     onRight: (value) => value // Do nothing in case of success
*   })
* })
* ```
*
* @see {@link option} for a version that uses `Option` instead.
* @see {@link exit} for a version that encapsulates both recoverable errors and defects in an `Exit`.
*
* @since 2.0.0
* @category Outcome Encapsulation
*/
const either = either$1;
/**
* Encapsulates both success and failure of an `Effect` using the `Exit` type.
*
* **Details**
*
* This function converts an effect into one that always succeeds, wrapping its
* outcome in the `Exit` type. The `Exit` type provides explicit handling of
* both success (`Exit.Success`) and failure (`Exit.Failure`) cases, including
* defects (unrecoverable errors).
*
* Unlike {@link either} or {@link option}, this function also encapsulates
* defects, which are typically unrecoverable and would otherwise terminate the
* effect. With the `Exit` type, defects are represented in `Exit.Failure`,
* allowing for detailed introspection and structured error handling.
*
* This makes the resulting effect robust and incapable of direct failure (its
* error type is `never`). It is particularly useful for workflows where all
* outcomes, including unexpected defects, must be managed and analyzed.
*
* **Example**
*
* ```ts
* import { Effect, Cause, Console, Exit } from "effect"
*
* // Simulating a runtime error
* const task = Effect.dieMessage("Boom!")
*
* const program = Effect.gen(function* () {
*   const exit = yield* Effect.exit(task)
*   if (Exit.isFailure(exit)) {
*     const cause = exit.cause
*     if (
*       Cause.isDieType(cause) &&
*       Cause.isRuntimeException(cause.defect)
*     ) {
*       yield* Console.log(
*         `RuntimeException defect caught: ${cause.defect.message}`
*       )
*     } else {
*       yield* Console.log("Unknown failure caught.")
*     }
*   }
* })
*
* // We get an Exit.Success because we caught all failures
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // RuntimeException defect caught: Boom!
* // {
* //   _id: "Exit",
* //   _tag: "Success",
* //   value: undefined
* // }
* ```
*
* @see {@link option} for a version that uses `Option` instead.
* @see {@link either} for a version that uses `Either` instead.
*
* @since 2.0.0
* @category Outcome Encapsulation
*/
const exit = exit$2;
/**
* Converts an `Effect` into an operation that completes a `Deferred` with its result.
*
* **Details**
*
* The `intoDeferred` function takes an effect and a `Deferred` and ensures that the `Deferred`
* is completed based on the outcome of the effect. If the effect succeeds, the `Deferred` is
* completed with the success value. If the effect fails, the `Deferred` is completed with the
* failure. Additionally, if the effect is interrupted, the `Deferred` will also be interrupted.
*
* **Example**
*
* ```ts
* import { Deferred, Effect } from "effect"
*
* // Define an effect that succeeds
* const successEffect = Effect.succeed(42)
*
* const program = Effect.gen(function*() {
*   // Create a deferred
*   const deferred = yield* Deferred.make<number, string>()
*
*   // Complete the deferred using the successEffect
*   const isCompleted = yield* Effect.intoDeferred(successEffect, deferred)
*
*   // Access the value of the deferred
*   const value = yield* Deferred.await(deferred)
*   console.log(value)
*
*   return isCompleted
* })
*
* Effect.runPromise(program).then(console.log)
* // Output:
* // 42
* // true
* ```
*
* @since 2.0.0
* @category Synchronization Utilities
*/
const intoDeferred = intoDeferred$1;
const if_ = if_$1;
/**
* Filters an effect, dying with a custom defect if the predicate fails.
*
* **Details**
*
* This function applies a predicate to the result of an effect. If the
* predicate evaluates to `false`, the effect dies with a custom defect
* generated by the `orDieWith` function.
*
* **When to Use**
*
* This is useful for enforcing constraints on values and treating violations as
* fatal program errors.
*
* @since 2.0.0
* @category Filtering
*/
const filterOrDie = filterOrDie$1;
/**
* Filters an effect, dying with a custom message if the predicate fails.
*
* **Details**
*
* This function works like {@link filterOrDie} but allows you to specify a
* custom error message to describe the reason for the failure. The message is
* included in the defect when the predicate evaluates to `false`.
*
* @since 2.0.0
* @category Filtering
*/
const filterOrDieMessage = filterOrDieMessage$1;
/**
* Filters an effect, providing an alternative effect if the predicate fails.
*
* **Details**
*
* This function applies a predicate to the result of an effect. If the
* predicate evaluates to `false`, it executes the `orElse` effect instead. The
* `orElse` effect can produce an alternative value or perform additional
* computations.
*
* @since 2.0.0
* @category Filtering
*/
const filterOrElse = filterOrElse$1;
/**
* Filters an effect, failing with a custom error if the predicate fails.
*
* **Details**
*
* This function applies a predicate to the result of an effect. If the
* predicate evaluates to `false`, the effect fails with a custom error
* generated by the `orFailWith` function.
*
* **When to Use**
*
* This is useful for enforcing constraints and treating violations as
* recoverable errors.
*
* **Providing a Guard**
*
* In addition to the filtering capabilities discussed earlier, you have the
* option to further refine and narrow down the type of the success channel by
* providing a [user-defined type
* guard](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates).
* Let's explore this concept through an example:
*
* **Example**
*
* ```ts
* import { Effect, pipe } from "effect"
*
* // Define a user interface
* interface User {
*   readonly name: string
* }
*
* // Simulate an asynchronous authentication function
* declare const auth: () => Promise<User | null>
*
* const program = pipe(
*   Effect.promise(() => auth()),
*   // Use filterOrFail with a custom type guard to ensure user is not null
*   Effect.filterOrFail(
*     (user): user is User => user !== null, // Type guard
*     () => new Error("Unauthorized")
*   ),
*   // 'user' now has the type `User` (not `User | null`)
*   Effect.andThen((user) => user.name)
* )
* ```
*
* @since 2.0.0
* @category Filtering
*/
const filterOrFail = filterOrFail$1;
/**
* Filters an effect with an effectful predicate, falling back to an alternative
* effect if the predicate fails.
*
* **Details**
*
* This function applies a predicate to the result of an effect. If the
* predicate evaluates to `false`, the effect falls back to the `orElse`
* effect. The `orElse` effect can produce an alternative value or perform
* additional computations.
*
* **Example**
*
* ```ts
* import { Effect, pipe } from "effect"
*
* // Define a user interface
* interface User {
*   readonly name: string
* }
*
* // Simulate an asynchronous authentication function
* declare const auth: () => Promise<User | null>
*
* const program = pipe(
*   Effect.promise(() => auth()),
*   // Use filterEffectOrElse with an effectful predicate
*   Effect.filterEffectOrElse({
*     predicate: (user) => Effect.succeed(user !== null),
*     orElse: (user) => Effect.fail(new Error(`Unauthorized user: ${user}`))
*   }),
* )
* ```
*
* @since 3.13.0
* @category Filtering
*/
const filterEffectOrElse = filterEffectOrElse$1;
/**
* Filters an effect with an effectful predicate, failing with a custom error if the predicate fails.
*
* **Details**
*
* This function applies a predicate to the result of an effect. If the
* predicate evaluates to `false`, the effect fails with a custom error
* generated by the `orFailWith` function.
*
* **When to Use**
*
* This is useful for enforcing constraints and treating violations as
* recoverable errors.
*
* **Example**
*
* ```ts
* import { Effect, pipe } from "effect"
*
* // Define a user interface
* interface User {
*   readonly name: string
* }
*
* // Simulate an asynchronous authentication function
* declare const auth: () => Promise<User | null>
*
* const program = pipe(
*   Effect.promise(() => auth()),
*   // Use filterEffectOrFail with an effectful predicate
*   Effect.filterEffectOrFail({
*     predicate: (user) => Effect.succeed(user !== null),
*     orFailWith: () => new Error("Unauthorized")
*   }),
* )
* ```
*
* @since 3.13.0
* @category Filtering
*/
const filterEffectOrFail = filterEffectOrFail$1;
/**
* Executes an effect only if the condition is `false`.
*
* @see {@link unlessEffect} for a version that allows the condition to be an effect.
* @see {@link when} for a version that executes the effect when the condition is `true`.
*
* @since 2.0.0
* @category Conditional Operators
*/
const unless = unless$1;
/**
* Conditionally execute an effect based on the result of another effect.
*
* @see {@link unless} for a version that allows the condition to be a boolean.
* @see {@link whenEffect} for a version that executes the effect when the condition is `true`.
*
* @since 2.0.0
* @category Conditional Operators
*/
const unlessEffect = unlessEffect$1;
/**
* Conditionally executes an effect based on a boolean condition.
*
* **Details**
*
* This function allows you to run an effect only if a given condition evaluates
* to `true`. If the condition is `true`, the effect is executed, and its result
* is wrapped in an `Option.some`. If the condition is `false`, the effect is
* skipped, and the result is `Option.none`.
*
* **When to Use**
*
* This function is useful for scenarios where you need to dynamically decide
* whether to execute an effect based on runtime logic, while also representing
* the skipped case explicitly.
*
* **Example** (Conditional Effect Execution)
*
* ```ts
* import { Effect, Option } from "effect"
*
* const validateWeightOption = (
*   weight: number
* ): Effect.Effect<Option.Option<number>> =>
*   // Conditionally execute the effect if the weight is non-negative
*   Effect.succeed(weight).pipe(Effect.when(() => weight >= 0))
*
* // Run with a valid weight
* Effect.runPromise(validateWeightOption(100)).then(console.log)
* // Output:
* // {
* //   _id: "Option",
* //   _tag: "Some",
* //   value: 100
* // }
*
* // Run with an invalid weight
* Effect.runPromise(validateWeightOption(-5)).then(console.log)
* // Output:
* // {
* //   _id: "Option",
* //   _tag: "None"
* // }
* ```
*
* @see {@link whenEffect} for a version that allows the condition to be an effect.
* @see {@link unless} for a version that executes the effect when the condition is `false`.
*
* @since 2.0.0
* @category Conditional Operators
*/
const when = when$1;
/**
* Conditionally executes an effect based on the result of another effect.
*
* **Details**
*
* This function allows you to run an effect only if a conditional effect
* evaluating to a boolean resolves to `true`. If the conditional effect
* evaluates to `true`, the specified effect is executed, and its result is
* wrapped in `Option.some`. If the conditional effect evaluates to `false`, the
* effect is skipped, and the result is `Option.none`.
*
* **When to Use**
*
* This function is particularly useful when the decision to execute an effect
* depends on the result of another effect, such as a random value, a
* user-provided input, or a network request result.
*
* **Example** (Using an Effect as a Condition)
*
* ```ts
* import { Effect, Random } from "effect"
*
* const randomIntOption = Random.nextInt.pipe(
*   Effect.whenEffect(Random.nextBoolean)
* )
*
* console.log(Effect.runSync(randomIntOption))
* // Example Output:
* // { _id: 'Option', _tag: 'Some', value: 8609104974198840 }
* ```
*
* @see {@link when} for a version that allows the condition to be a boolean.
* @see {@link unlessEffect} for a version that executes the effect when the condition is `false`.
*
* @since 2.0.0
* @category Conditional Operators
*/
const whenEffect = whenEffect$1;
/**
* Executes an effect conditionally based on the value of a `FiberRef` that
* satisfies a predicate.
*
* **Details**
*
* This function enables you to execute an effect only when the value of a
* specified `FiberRef` meets a certain condition defined by a predicate. If the
* value satisfies the predicate, the effect is executed, and the result is
* wrapped in an `Option.some`. If the predicate is not satisfied, the effect is
* skipped, and the result is `Option.none`. In both cases, the current value of
* the `FiberRef` is included in the result.
*
* @since 2.0.0
* @category Conditional Operators
*/
const whenFiberRef = whenFiberRef$1;
/**
* Executes an effect conditionally based on the value of a `Ref` that satisfies
* a predicate.
*
* **Details**
*
* This function allows you to execute an effect only when the value of a
* specified `Ref` meets a condition defined by a predicate. If the value
* satisfies the predicate, the effect is executed, and the result is wrapped in
* an `Option.some`. If the predicate is not satisfied, the effect is skipped,
* and the result is `Option.none`. In both cases, the current value of the
* `Ref` is included in the result.
*
* @since 2.0.0
* @category Conditional Operators
*/
const whenRef = whenRef$1;
/**
* Chains effects to produce new `Effect` instances, useful for combining
* operations that depend on previous results.
*
* **Syntax**
*
* ```ts skip-type-checking
* const flatMappedEffect = pipe(myEffect, Effect.flatMap(transformation))
* // or
* const flatMappedEffect = Effect.flatMap(myEffect, transformation)
* // or
* const flatMappedEffect = myEffect.pipe(Effect.flatMap(transformation))
* ```
*
* **Details**
*
* `flatMap` lets you sequence effects so that the result of one effect can be
* used in the next step. It is similar to `flatMap` used with arrays but works
* specifically with `Effect` instances, allowing you to avoid deeply nested
* effect structures.
*
* Since effects are immutable, `flatMap` always returns a new effect instead of
* changing the original one.
*
* **When to Use**
*
* Use `flatMap` when you need to chain multiple effects, ensuring that each
* step produces a new `Effect` while flattening any nested effects that may
* occur.
*
* **Example**
*
* ```ts
* import { pipe, Effect } from "effect"
*
* // Function to apply a discount safely to a transaction amount
* const applyDiscount = (
*   total: number,
*   discountRate: number
* ): Effect.Effect<number, Error> =>
*   discountRate === 0
*     ? Effect.fail(new Error("Discount rate cannot be zero"))
*     : Effect.succeed(total - (total * discountRate) / 100)
*
* // Simulated asynchronous task to fetch a transaction amount from database
* const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))
*
* // Chaining the fetch and discount application using `flatMap`
* const finalAmount = pipe(
*   fetchTransactionAmount,
*   Effect.flatMap((amount) => applyDiscount(amount, 5))
* )
*
* Effect.runPromise(finalAmount).then(console.log)
* // Output: 95
* ```
*
* @see {@link tap} for a version that ignores the result of the effect.
*
* @since 2.0.0
* @category Sequencing
*/
const flatMap$1 = flatMap$5;
/**
* Chains two actions, where the second action can depend on the result of the
* first.
*
* **Syntax**
*
* ```ts skip-type-checking
* const transformedEffect = pipe(myEffect, Effect.andThen(anotherEffect))
* // or
* const transformedEffect = Effect.andThen(myEffect, anotherEffect)
* // or
* const transformedEffect = myEffect.pipe(Effect.andThen(anotherEffect))
* ```
*
* **When to Use**
*
* Use `andThen` when you need to run multiple actions in sequence, with the
* second action depending on the result of the first. This is useful for
* combining effects or handling computations that must happen in order.
*
* **Details**
*
* The second action can be:
*
* - A constant value (similar to {@link as})
* - A function returning a value (similar to {@link map})
* - A `Promise`
* - A function returning a `Promise`
* - An `Effect`
* - A function returning an `Effect` (similar to {@link flatMap})
*
* **Note:** `andThen` works well with both `Option` and `Either` types,
* treating them as effects.
*
* **Example** (Applying a Discount Based on Fetched Amount)
*
* ```ts
* import { pipe, Effect } from "effect"
*
* // Function to apply a discount safely to a transaction amount
* const applyDiscount = (
*   total: number,
*   discountRate: number
* ): Effect.Effect<number, Error> =>
*   discountRate === 0
*     ? Effect.fail(new Error("Discount rate cannot be zero"))
*     : Effect.succeed(total - (total * discountRate) / 100)
*
* // Simulated asynchronous task to fetch a transaction amount from database
* const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))
*
* // Using Effect.map and Effect.flatMap
* const result1 = pipe(
*   fetchTransactionAmount,
*   Effect.map((amount) => amount * 2),
*   Effect.flatMap((amount) => applyDiscount(amount, 5))
* )
*
* Effect.runPromise(result1).then(console.log)
* // Output: 190
*
* // Using Effect.andThen
* const result2 = pipe(
*   fetchTransactionAmount,
*   Effect.andThen((amount) => amount * 2),
*   Effect.andThen((amount) => applyDiscount(amount, 5))
* )
*
* Effect.runPromise(result2).then(console.log)
* // Output: 190
* ```
*
* @since 2.0.0
* @category Sequencing
*/
const andThen = andThen$2;
/**
* @since 2.0.0
* @category Sequencing
*/
const flatten = flatten$3;
/**
* Races two effects and returns the result of the first successful one.
*
* **Details**
*
* This function takes two effects and runs them concurrently. The first effect
* that successfully completes will determine the result of the race, and the
* other effect will be interrupted.
*
* If neither effect succeeds, the function will fail with a `Cause`
* containing all the errors.
*
* **When to Use**
*
* This is useful when you want to run two effects concurrently, but only care
* about the first one to succeed. It is commonly used in cases like timeouts,
* retries, or when you want to optimize for the faster response without
* worrying about the other effect.
*
* **Handling Success or Failure with Either**
*
* If you want to handle the result of whichever task completes first, whether
* it succeeds or fails, you can use the `Effect.either` function. This function
* wraps the result in an `Either` type, allowing you to see if the result
* was a success (`Right`) or a failure (`Left`).
*
* **Example** (Both Tasks Succeed)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const task1 = Effect.succeed("task1").pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Console.log("task1 done")),
*   Effect.onInterrupt(() => Console.log("task1 interrupted"))
* )
* const task2 = Effect.succeed("task2").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Console.log("task2 done")),
*   Effect.onInterrupt(() => Console.log("task2 interrupted"))
* )
*
* const program = Effect.race(task1, task2)
*
* Effect.runFork(program)
* // Output:
* // task1 done
* // task2 interrupted
* ```
*
* **Example** (One Task Fails, One Succeeds)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const task1 = Effect.fail("task1").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Console.log("task1 done")),
*   Effect.onInterrupt(() => Console.log("task1 interrupted"))
* )
* const task2 = Effect.succeed("task2").pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Console.log("task2 done")),
*   Effect.onInterrupt(() => Console.log("task2 interrupted"))
* )
*
* const program = Effect.race(task1, task2)
*
* Effect.runFork(program)
* // Output:
* // task2 done
* ```
*
* **Example** (Both Tasks Fail)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const task1 = Effect.fail("task1").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Console.log("task1 done")),
*   Effect.onInterrupt(() => Console.log("task1 interrupted"))
* )
* const task2 = Effect.fail("task2").pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Console.log("task2 done")),
*   Effect.onInterrupt(() => Console.log("task2 interrupted"))
* )
*
* const program = Effect.race(task1, task2)
*
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: {
* //     _id: 'Cause',
* //     _tag: 'Parallel',
* //     left: { _id: 'Cause', _tag: 'Fail', failure: 'task1' },
* //     right: { _id: 'Cause', _tag: 'Fail', failure: 'task2' }
* //   }
* // }
* ```
*
* **Example** (Handling Success or Failure with Either)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const task1 = Effect.fail("task1").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Console.log("task1 done")),
*   Effect.onInterrupt(() => Console.log("task1 interrupted"))
* )
* const task2 = Effect.succeed("task2").pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Console.log("task2 done")),
*   Effect.onInterrupt(() => Console.log("task2 interrupted"))
* )
*
* // Run both tasks concurrently, wrapping the result
* // in Either to capture success or failure
* const program = Effect.race(Effect.either(task1), Effect.either(task2))
*
* Effect.runPromise(program).then(console.log)
* // Output:
* // task2 interrupted
* // { _id: 'Either', _tag: 'Left', left: 'task1' }
* ```
*
* @see {@link raceAll} for a version that handles multiple effects.
* @see {@link raceFirst} for a version that returns the result of the first effect to complete.
*
* @since 2.0.0
* @category Racing
*/
const race = race$1;
/**
* Races multiple effects and returns the first successful result.
*
* **Details**
*
* This function runs multiple effects concurrently and returns the result of
* the first one to succeed. If one effect succeeds, the others will be
* interrupted.
*
* If none of the effects succeed, the function will fail with the last error
* encountered.
*
* **When to Use**
*
* This is useful when you want to race multiple effects, but only care about
* the first one to succeed. It is commonly used in cases like timeouts,
* retries, or when you want to optimize for the faster response without
* worrying about the other effects.
*
* **Example** (All Tasks Succeed)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const task1 = Effect.succeed("task1").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Console.log("task1 done")),
*   Effect.onInterrupt(() => Console.log("task1 interrupted"))
* )
* const task2 = Effect.succeed("task2").pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Console.log("task2 done")),
*   Effect.onInterrupt(() => Console.log("task2 interrupted"))
* )
*
* const task3 = Effect.succeed("task3").pipe(
*   Effect.delay("150 millis"),
*   Effect.tap(Console.log("task3 done")),
*   Effect.onInterrupt(() => Console.log("task3 interrupted"))
* )
*
* const program = Effect.raceAll([task1, task2, task3])
*
* Effect.runFork(program)
* // Output:
* // task1 done
* // task2 interrupted
* // task3 interrupted
* ```
*
* **Example** (One Task Fails, Two Tasks Succeed)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const task1 = Effect.fail("task1").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Console.log("task1 done")),
*   Effect.onInterrupt(() => Console.log("task1 interrupted"))
* )
* const task2 = Effect.succeed("task2").pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Console.log("task2 done")),
*   Effect.onInterrupt(() => Console.log("task2 interrupted"))
* )
*
* const task3 = Effect.succeed("task3").pipe(
*   Effect.delay("150 millis"),
*   Effect.tap(Console.log("task3 done")),
*   Effect.onInterrupt(() => Console.log("task3 interrupted"))
* )
*
* const program = Effect.raceAll([task1, task2, task3])
*
* Effect.runFork(program)
* // Output:
* // task3 done
* // task2 interrupted
* ```
*
* **Example** (All Tasks Fail)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const task1 = Effect.fail("task1").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Console.log("task1 done")),
*   Effect.onInterrupt(() => Console.log("task1 interrupted"))
* )
* const task2 = Effect.fail("task2").pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Console.log("task2 done")),
*   Effect.onInterrupt(() => Console.log("task2 interrupted"))
* )
*
* const task3 = Effect.fail("task3").pipe(
*   Effect.delay("150 millis"),
*   Effect.tap(Console.log("task3 done")),
*   Effect.onInterrupt(() => Console.log("task3 interrupted"))
* )
*
* const program = Effect.raceAll([task1, task2, task3])
*
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: { _id: 'Cause', _tag: 'Fail', failure: 'task2' }
* // }
* ```
*
* @see {@link race} for a version that handles only two effects.
*
* @since 2.0.0
* @category Racing
*/
const raceAll = raceAll$1;
/**
* Races two effects and returns the result of the first one to complete.
*
* **Details**
*
* This function takes two effects and runs them concurrently, returning the
* result of the first one that completes, regardless of whether it succeeds or
* fails.
*
* **When to Use**
*
* This function is useful when you want to race two operations, and you want to
* proceed with whichever one finishes first, regardless of whether it succeeds
* or fails.
*
* **Disconnecting Effects**
*
* The `Effect.raceFirst` function safely interrupts the “loser” effect once the other completes, but it will not resume until the loser is cleanly terminated.
*
* If you want a quicker return, you can disconnect the interrupt signal for both effects. Instead of calling:
*
* ```ts skip-type-checking
* Effect.raceFirst(task1, task2)
* ```
*
* You can use:
*
* ```ts skip-type-checking
* Effect.raceFirst(Effect.disconnect(task1), Effect.disconnect(task2))
* ```
*
* This allows both effects to complete independently while still terminating the losing effect in the background.
*
* **Example** (Both Tasks Succeed)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const task1 = Effect.succeed("task1").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Console.log("task1 done")),
*   Effect.onInterrupt(() =>
*     Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))
*   )
* )
* const task2 = Effect.succeed("task2").pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Console.log("task2 done")),
*   Effect.onInterrupt(() =>
*     Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))
*   )
* )
*
* const program = Effect.raceFirst(task1, task2).pipe(
*   Effect.tap(Console.log("more work..."))
* )
*
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // task1 done
* // task2 interrupted
* // more work...
* // { _id: 'Exit', _tag: 'Success', value: 'task1' }
* ```
*
* **Example** (One Task Fails, One Succeeds)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const task1 = Effect.fail("task1").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Console.log("task1 done")),
*   Effect.onInterrupt(() =>
*     Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))
*   )
* )
* const task2 = Effect.succeed("task2").pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Console.log("task2 done")),
*   Effect.onInterrupt(() =>
*     Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))
*   )
* )
*
* const program = Effect.raceFirst(task1, task2).pipe(
*   Effect.tap(Console.log("more work..."))
* )
*
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // task2 interrupted
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: { _id: 'Cause', _tag: 'Fail', failure: 'task1' }
* // }
* ```
*
* **Example** (Using Effect.disconnect for Quicker Return)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const task1 = Effect.succeed("task1").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Console.log("task1 done")),
*   Effect.onInterrupt(() =>
*     Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))
*   )
* )
* const task2 = Effect.succeed("task2").pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Console.log("task2 done")),
*   Effect.onInterrupt(() =>
*     Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))
*   )
* )
*
* // Race the two tasks with disconnect to allow quicker return
* const program = Effect.raceFirst(
*   Effect.disconnect(task1),
*   Effect.disconnect(task2)
* ).pipe(Effect.tap(Console.log("more work...")))
*
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // task1 done
* // more work...
* // { _id: 'Exit', _tag: 'Success', value: 'task1' }
* // task2 interrupted
* ```
*
* @since 2.0.0
* @category Racing
*/
const raceFirst = raceFirst$1;
/**
* Races two effects and calls a finisher when the first one completes.
*
* **Details**
*
* This function runs two effects concurrently and calls a specified “finisher”
* function once one of the effects completes, regardless of whether it succeeds
* or fails.
*
* The finisher functions for each effect allow you to handle the results of
* each effect as soon as they complete.
*
* The function takes two finisher callbacks, one for each effect, and allows
* you to specify how to handle the result of the race.
*
* **When to Use**
*
* This function is useful when you need to react to the completion of either
* effect without waiting for both to finish. It can be used whenever you want
* to take action based on the first available result.
*
* **Example** (Handling Results of Concurrent Tasks)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const task1 = Effect.succeed("task1").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Console.log("task1 done")),
*   Effect.onInterrupt(() =>
*     Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))
*   )
* )
* const task2 = Effect.succeed("task2").pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Console.log("task2 done")),
*   Effect.onInterrupt(() =>
*     Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))
*   )
* )
*
* const program = Effect.raceWith(task1, task2, {
*   onSelfDone: (exit) => Console.log(`task1 exited with ${exit}`),
*   onOtherDone: (exit) => Console.log(`task2 exited with ${exit}`)
* })
*
* Effect.runFork(program)
* // Output:
* // task1 done
* // task1 exited with {
* //   "_id": "Exit",
* //   "_tag": "Success",
* //   "value": "task1"
* // }
* // task2 interrupted
* ```
*
* @since 2.0.0
* @category Racing
*/
const raceWith = raceWith$1;
/**
* Summarizes a effect by computing some value before and after execution, and
* then combining the values to produce a summary, together with the result of
* execution.
*
* @since 2.0.0
* @category Sequencing
*/
const summarized = summarized$1;
/**
* Runs a side effect with the result of an effect without changing the original
* value.
*
* **Details**
*
* This function works similarly to `flatMap`, but it ignores the result of the
* function passed to it. The value from the previous effect remains available
* for the next part of the chain. Note that if the side effect fails, the
* entire chain will fail too.
*
* **When to Use**
*
* Use this function when you want to perform a side effect, like logging or
* tracking, without modifying the main value. This is useful when you need to
* observe or record an action but want the original value to be passed to the
* next step.
*
* **Example** (Logging a step in a pipeline)
*
* ```ts
* import { Console, Effect, pipe } from "effect"
*
* // Function to apply a discount safely to a transaction amount
* const applyDiscount = (
*   total: number,
*   discountRate: number
* ): Effect.Effect<number, Error> =>
*   discountRate === 0
*     ? Effect.fail(new Error("Discount rate cannot be zero"))
*     : Effect.succeed(total - (total * discountRate) / 100)
*
* // Simulated asynchronous task to fetch a transaction amount from database
* const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))
*
* const finalAmount = pipe(
*   fetchTransactionAmount,
*   // Log the fetched transaction amount
*   Effect.tap((amount) => Console.log(`Apply a discount to: ${amount}`)),
*   // `amount` is still available!
*   Effect.flatMap((amount) => applyDiscount(amount, 5))
* )
*
* Effect.runPromise(finalAmount).then(console.log)
* // Output:
* // Apply a discount to: 100
* // 95
* ```
*
* @see {@link flatMap} for a version that allows you to change the value.
*
* @since 2.0.0
* @category Sequencing
*/
const tap = tap$1;
/**
* Allows you to inspect both success and failure outcomes of an effect and
* perform side effects for each.
*
* **Details**
*
* This function enables you to handle both success and failure cases
* separately, without modifying the main effect's result. It is particularly
* useful for scenarios where you need to log, monitor, or perform additional
* actions depending on whether the effect succeeded or failed.
*
* When the effect succeeds, the `onSuccess` handler is executed with the
* success value. When the effect fails, the `onFailure` handler is executed
* with the failure value. Both handlers can include side effects such as
* logging or analytics, and neither modifies the original effect's output.
*
* If either the success or failure handler fails, the overall effect will also
* fail.
*
* **Example**
*
* ```ts
* import { Effect, Random, Console } from "effect"
*
* // Simulate a task that might fail
* const task = Effect.filterOrFail(
*   Random.nextRange(-1, 1),
*   (n) => n >= 0,
*   () => "random number is negative"
* )
*
* // Use tapBoth to log both success and failure outcomes
* const tapping = Effect.tapBoth(task, {
*   onFailure: (error) => Console.log(`failure: ${error}`),
*   onSuccess: (randomNumber) =>
*     Console.log(`random number: ${randomNumber}`)
* })
*
* Effect.runFork(tapping)
* // Example Output:
* // failure: random number is negative
* ```
*
* @since 2.0.0
* @category Sequencing
*/
const tapBoth = tapBoth$1;
/**
* Inspect severe errors or defects (non-recoverable failures) in an effect.
*
* **Details**
*
* This function is specifically designed to handle and inspect defects, which
* are critical failures in your program, such as unexpected runtime exceptions
* or system-level errors. Unlike normal recoverable errors, defects typically
* indicate serious issues that cannot be addressed through standard error
* handling.
*
* When a defect occurs in an effect, the function you provide to this function
* will be executed, allowing you to log, monitor, or handle the defect in some
* way. Importantly, this does not alter the main result of the effect. If no
* defect occurs, the effect behaves as if this function was not used.
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* // Simulate a task that fails with a recoverable error
* const task1: Effect.Effect<number, string> = Effect.fail("NetworkError")
*
* // tapDefect won't log anything because NetworkError is not a defect
* const tapping1 = Effect.tapDefect(task1, (cause) =>
*   Console.log(`defect: ${cause}`)
* )
*
* Effect.runFork(tapping1)
* // No Output
*
* // Simulate a severe failure in the system
* const task2: Effect.Effect<number, string> = Effect.dieMessage(
*   "Something went wrong"
* )
*
* // Log the defect using tapDefect
* const tapping2 = Effect.tapDefect(task2, (cause) =>
*   Console.log(`defect: ${cause}`)
* )
*
* Effect.runFork(tapping2)
* // Output:
* // defect: RuntimeException: Something went wrong
* //   ... stack trace ...
* ```
*
* @since 2.0.0
* @category Sequencing
*/
const tapDefect = tapDefect$1;
/**
* Execute a side effect on failure without modifying the original effect.
*
* **Details**
*
* This function allows you to inspect and react to the failure of an effect by
* executing an additional effect. The failure value is passed to the provided
* function, enabling you to log it, track it, or perform any other operation.
* Importantly, the original failure remains intact and is re-propagated, so the
* effect's behavior is unchanged.
*
* The side effect you provide is only executed when the effect fails. If the
* effect succeeds, the function is ignored, and the success value is propagated
* as usual.
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* // Simulate a task that fails with an error
* const task: Effect.Effect<number, string> = Effect.fail("NetworkError")
*
* // Use tapError to log the error message when the task fails
* const tapping = Effect.tapError(task, (error) =>
*   Console.log(`expected error: ${error}`)
* )
*
* Effect.runFork(tapping)
* // Output:
* // expected error: NetworkError
* ```
*
* @since 2.0.0
* @category Sequencing
*/
const tapError = tapError$1;
/**
* Inspect errors matching a specific tag without altering the original effect.
*
* **Details**
*
* This function allows you to inspect and handle specific error types based on
* their `_tag` property. It is particularly useful in applications where errors
* are modeled with tagged types (e.g., union types with discriminating tags).
* By targeting errors with a specific `_tag`, you can log or perform actions on
* them while leaving the error channel and overall effect unchanged.
*
* If the error doesn't match the specified tag, this function does nothing, and
* the effect proceeds as usual.
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* class NetworkError {
*   readonly _tag = "NetworkError"
*   constructor(readonly statusCode: number) {}
* }
*
* class ValidationError {
*   readonly _tag = "ValidationError"
*   constructor(readonly field: string) {}
* }
*
* // Create a task that fails with a NetworkError
* const task: Effect.Effect<number, NetworkError | ValidationError> =
*   Effect.fail(new NetworkError(504))
*
* // Use tapErrorTag to inspect only NetworkError types and log the status code
* const tapping = Effect.tapErrorTag(task, "NetworkError", (error) =>
*   Console.log(`expected error: ${error.statusCode}`)
* )
*
* Effect.runFork(tapping)
* // Output:
* // expected error: 504
* ```
*
* @since 2.0.0
* @category Sequencing
*/
const tapErrorTag = tapErrorTag$1;
/**
* Inspect the complete cause of an error, including failures and defects.
*
* **Details**
*
* This function provides access to the full cause of an error, including both
* recoverable failures and irrecoverable defects. It allows you to handle, log,
* or monitor specific error causes without modifying the result of the effect.
* The full `Cause` object encapsulates the error and its contextual
* information, making it useful for debugging and understanding failure
* scenarios in complex workflows.
*
* The effect itself is not modified, and any errors or defects remain in the
* error channel of the original effect.
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* // Create a task that fails with a NetworkError
* const task1: Effect.Effect<number, string> = Effect.fail("NetworkError")
*
* const tapping1 = Effect.tapErrorCause(task1, (cause) =>
*   Console.log(`error cause: ${cause}`)
* )
*
* Effect.runFork(tapping1)
* // Output:
* // error cause: Error: NetworkError
*
* // Simulate a severe failure in the system
* const task2: Effect.Effect<number, string> = Effect.dieMessage(
*   "Something went wrong"
* )
*
* const tapping2 = Effect.tapErrorCause(task2, (cause) =>
*   Console.log(`error cause: ${cause}`)
* )
*
* Effect.runFork(tapping2)
* // Output:
* // error cause: RuntimeException: Something went wrong
* //   ... stack trace ...
* ```
*
* @since 2.0.0
* @category Sequencing
*/
const tapErrorCause = tapErrorCause$1;
/**
* Repeats an effect indefinitely until an error occurs.
*
* **Details**
*
* This function executes an effect repeatedly in an infinite loop. Each
* iteration is executed sequentially, and the loop continues until the first
* error occurs. If the effect succeeds, it starts over from the beginning. If
* the effect fails, the error is propagated, and the loop stops.
*
* Be cautious when using this function, as it will run indefinitely unless an
* error interrupts it. This makes it suitable for long-running processes or
* continuous polling tasks, but you should ensure proper error handling or
* combine it with other operators like `timeout` or `schedule` to prevent
* unintentional infinite loops.
*
* @since 2.0.0
* @category Repetition / Recursion
*/
const forever = forever$2;
/**
* Repeatedly updates a state through an effectful operation until a condition
* is no longer met.
*
* **Details**
*
* This function provides a way to implement effectful loops, similar to a
* `while` loop in JavaScript.
*
* ```ts skip-type-checking
* let result = initial
*
* while (options.while(result)) {
*   result = options.body(result)
* }
*
* return result
* ```
*
* It starts with an initial state, checks a
* condition (`while`), and executes a body operation to update the state if the
* condition evaluates to `true`. The process repeats until the condition
* returns `false`.
*
* The state is passed between iterations, allowing the body operation to modify
* it dynamically. The final state after the loop ends is returned as the result
* of the effect.
*
* **When to Use**
*
* This is particularly useful for scenarios where looping logic involves
* asynchronous or side-effectful operations, such as polling or iterative
* computations that depend on external factors.
*
* **Example** (Effectful Iteration)
*
* ```ts
* import { Effect } from "effect"
*
* const result = Effect.iterate(
*   // Initial result
*   1,
*   {
*     // Condition to continue iterating
*     while: (result) => result <= 5,
*     // Operation to change the result
*     body: (result) => Effect.succeed(result + 1)
*   }
* )
*
* Effect.runPromise(result).then(console.log)
* // Output: 6
* ```
*
* @since 2.0.0
* @category Looping
*/
const iterate = iterate$1;
/**
* Repeatedly executes a loop with a state, collecting results or discarding
* them based on configuration.
*
* **Details**
*
* This function performs an effectful loop, starting with an initial state and
* iterating as long as the `while` condition evaluates to `true`, similar to a
* `while` loop in JavaScript.
*
* ```ts skip-type-checking
* let state = initial
* const result = []
*
* while (options.while(state)) {
*   result.push(options.body(state)) // Perform the effectful operation
*   state = options.step(state) // Update the state
* }
*
* return result
* ```
*
* During each iteration, the `step` function updates the state, and the `body`
* effect is executed.
*
* The results of the body effect can be collected in an array or discarded
* based on the `discard` option.
*
* **Discarding Intermediate Results**
*
* - If `discard` is `false` or not provided, the intermediate results are
*   collected into an array and returned as the final result.
* - If `discard` is `true`, the intermediate results are ignored, and the
*   effect returns `void`.
*
* **When to Use**
*
* This is useful for implementing loops where you need to perform effectful
* computations repeatedly, such as processing items in a list, generating
* values, or performing iterative updates.
*
* **Example** (Looping with Collected Results)
*
* ```ts
* import { Effect } from "effect"
*
* // A loop that runs 5 times, collecting each iteration's result
* const result = Effect.loop(
*   // Initial state
*   1,
*   {
*     // Condition to continue looping
*     while: (state) => state <= 5,
*     // State update function
*     step: (state) => state + 1,
*     // Effect to be performed on each iteration
*     body: (state) => Effect.succeed(state)
*   }
* )
*
* Effect.runPromise(result).then(console.log)
* // Output: [1, 2, 3, 4, 5]
* ```
*
* **Example** (Loop with Discarded Results)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const result = Effect.loop(
*   // Initial state
*   1,
*   {
*     // Condition to continue looping
*     while: (state) => state <= 5,
*     // State update function
*     step: (state) => state + 1,
*     // Effect to be performed on each iteration
*     body: (state) => Console.log(`Currently at state ${state}`),
*     // Discard intermediate results
*     discard: true
*   }
* )
*
* Effect.runPromise(result).then(console.log)
* // Output:
* // Currently at state 1
* // Currently at state 2
* // Currently at state 3
* // Currently at state 4
* // Currently at state 5
* // undefined
* ```
*
* @since 2.0.0
* @category Looping
*/
const loop = loop$1;
/**
* Repeats an effect based on a specified schedule or until the first failure.
*
* **Details**
*
* This function executes an effect repeatedly according to the given schedule.
* Each repetition occurs after the initial execution of the effect, meaning
* that the schedule determines the number of additional repetitions. For
* example, using `Schedule.once` will result in the effect being executed twice
* (once initially and once as part of the repetition).
*
* If the effect succeeds, it is repeated according to the schedule. If it
* fails, the repetition stops immediately, and the failure is returned.
*
* The schedule can also specify delays between repetitions, making it useful
* for tasks like retrying operations with backoff, periodic execution, or
* performing a series of dependent actions.
*
* You can combine schedules for more advanced repetition logic, such as adding
* delays, limiting recursions, or dynamically adjusting based on the outcome of
* each execution.
*
* **Example** (Success Example)
*
* ```ts
* import { Effect, Schedule, Console } from "effect"
*
* const action = Console.log("success")
* const policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")
* const program = Effect.repeat(action, policy)
*
* Effect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))
* ```
*
* **Example** (Failure Example)
*
* ```ts
* import { Effect, Schedule } from "effect"
*
* let count = 0
*
* // Define an async effect that simulates an action with possible failures
* const action = Effect.async<string, string>((resume) => {
*   if (count > 1) {
*     console.log("failure")
*     resume(Effect.fail("Uh oh!"))
*   } else {
*     count++
*     console.log("success")
*     resume(Effect.succeed("yay!"))
*   }
* })
*
* const policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")
* const program = Effect.repeat(action, policy)
*
* Effect.runPromiseExit(program).then(console.log)
* ```
*
* @since 2.0.0
* @category Repetition / Recursion
*/
const repeat = repeat_combined;
/**
* Repeats an effect a specified number of times or until the first failure.
*
* **Details**
*
* This function executes an effect initially and then repeats it the specified
* number of times, as long as it succeeds. For example, calling
* `repeatN(action, 2)` will execute `action` once initially and then repeat it
* two additional times if there are no failures.
*
* If the effect fails during any repetition, the failure is returned, and no
* further repetitions are attempted.
*
* **When to Use**
*
* This function is useful for tasks that need to be retried a fixed number of
* times or for performing repeated actions without requiring a schedule.
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* const action = Console.log("success")
* const program = Effect.repeatN(action, 2)
*
* Effect.runPromise(program)
* ```
*
* @since 2.0.0
* @category Repetition / Recursion
*/
const repeatN = repeatN$1;
/**
* Repeats an effect with a schedule, handling failures using a custom handler.
*
* **Details**
*
* This function allows you to execute an effect repeatedly based on a specified
* schedule. If the effect fails at any point, a custom failure handler is
* invoked. The handler is provided with both the failure value and the output
* of the schedule at the time of failure. This enables advanced error recovery
* or alternative fallback logic while maintaining flexibility in how
* repetitions are handled.
*
* For example, using a schedule with `recurs(2)` will allow for two additional
* repetitions after the initial execution, provided the effect succeeds. If a
* failure occurs during any iteration, the failure handler is invoked to handle
* the situation.
*
* **Example**
*
* ```ts
* import { Effect, Schedule } from "effect"
*
* let count = 0
*
* // Define an async effect that simulates an action with possible failures
* const action = Effect.async<string, string>((resume) => {
*   if (count > 1) {
*     console.log("failure")
*     resume(Effect.fail("Uh oh!"))
*   } else {
*     count++
*     console.log("success")
*     resume(Effect.succeed("yay!"))
*   }
* })
*
* const policy = Schedule.addDelay(
*   Schedule.recurs(2), // Repeat for a maximum of 2 times
*   () => "100 millis" // Add a delay of 100 milliseconds between repetitions
* )
*
* const program = Effect.repeatOrElse(action, policy, () =>
*   Effect.sync(() => {
*     console.log("orElse")
*     return count - 1
*   })
* )
*
* Effect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))
* ```
*
* @since 2.0.0
* @category Repetition / Recursion
*/
const repeatOrElse = repeatOrElse_Effect;
/**
* Repeats an effect based on a specified schedule.
*
* **Details**
*
* This function allows you to execute an effect repeatedly according to a given
* schedule. The schedule determines the timing and number of repetitions. Each
* repetition can also depend on the decision of the schedule, providing
* flexibility for complex workflows. This function does not modify the effect's
* success or failure; it only controls its repetition.
*
* For example, you can use a schedule that recurs a specific number of times,
* adds delays between repetitions, or customizes repetition behavior based on
* external inputs. The effect runs initially and is repeated according to the
* schedule.
*
* @see {@link scheduleFrom} for a variant that allows the schedule's decision
* to depend on the result of this effect.
*
* @since 2.0.0
* @category Repetition / Recursion
*/
const schedule = schedule_Effect;
/**
* Runs an effect repeatedly on a new fiber according to a given schedule.
*
* **Details**
*
* This function starts the provided effect on a new fiber and runs it
* repeatedly based on the specified schedule. The repetitions are managed by
* the schedule's rules, which define the timing and number of iterations. The
* fiber is attached to the current scope, meaning it is automatically managed
* and cleaned up when the scope is closed.
*
* The function returns a `RuntimeFiber` that allows you to monitor or interact
* with the running fiber.
*
* **When to Use**
*
* This is particularly useful for concurrent execution of scheduled tasks or
* when you want to continue processing without waiting for the repetitions to
* complete.
*
* @since 2.0.0
* @category Repetition / Recursion
*/
const scheduleForked = scheduleForked$1;
/**
* Runs an effect repeatedly according to a schedule, starting from a specified
* input value.
*
* **Details**
*
* This function allows you to repeatedly execute an effect based on a schedule.
* The schedule starts with the given `initial` input value, which is passed to
* the first execution. Subsequent executions of the effect are controlled by
* the schedule's rules, using the output of the previous iteration as the input
* for the next one.
*
* The returned effect will complete when the schedule ends or the effect fails,
* propagating the error.
*
* @since 2.0.0
* @category Repetition / Recursion
*/
const scheduleFrom = scheduleFrom_Effect;
/**
* @since 2.0.0
* @category Repetition / Recursion
*/
const whileLoop = whileLoop$2;
/**
* Returns a collection of all `FiberRef` values for the fiber running this
* effect.
*
* @since 2.0.0
* @category Fiber Refs
*/
const getFiberRefs = fiberRefs;
/**
* Inherits values from all `FiberRef` instances into current fiber.
*
* @since 2.0.0
* @category Fiber Refs
*/
const inheritFiberRefs = inheritFiberRefs$1;
/**
* @since 2.0.0
* @category Fiber Refs
*/
const locally = fiberRefLocally;
/**
* @since 2.0.0
* @category Fiber Refs
*/
const locallyWith = fiberRefLocallyWith;
/**
* @since 2.0.0
* @category Fiber Refs
*/
const locallyScoped = fiberRefLocallyScoped;
/**
* @since 2.0.0
* @category Fiber Refs
*/
const locallyScopedWith = fiberRefLocallyScopedWith;
/**
* Applies the specified changes to the `FiberRef` values for the fiber
* running this workflow.
*
* @since 2.0.0
* @category Fiber Refs
*/
const patchFiberRefs = patchFiberRefs$1;
/**
* Sets the `FiberRef` values for the fiber running this effect to the values
* in the specified collection of `FiberRef` values.
*
* @since 2.0.0
* @category Fiber Refs
*/
const setFiberRefs = setFiberRefs$1;
/**
* Updates the `FiberRef` values for the fiber running this effect using the
* specified function.
*
* @since 2.0.0
* @category Fiber Refs
*/
const updateFiberRefs = updateFiberRefs$1;
/**
* Checks if an effect has failed.
*
* **Details**
*
* This function evaluates whether an effect has resulted in a failure. It
* returns a boolean value wrapped in an effect, with `true` indicating the
* effect failed and `false` otherwise.
*
* The resulting effect cannot fail (`never` in the error channel) but retains
* the context of the original effect.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const failure = Effect.fail("Uh oh!")
*
* console.log(Effect.runSync(Effect.isFailure(failure)))
* // Output: true
*
* const defect = Effect.dieMessage("BOOM!")
*
* Effect.runSync(Effect.isFailure(defect))
* // throws: BOOM!
* ```
*
* @since 2.0.0
* @category Condition Checking
*/
const isFailure = isFailure$2;
/**
* Checks if an effect has succeeded.
*
* **Details**
*
* This function evaluates whether an effect has resulted in a success. It
* returns a boolean value wrapped in an effect, with `true` indicating the
* effect succeeded and `false` otherwise.
*
* The resulting effect cannot fail (`never` in the error channel) but retains
* the context of the original effect.
*
* @since 2.0.0
* @category Condition Checking
*/
const isSuccess = isSuccess$1;
/**
* Handles both success and failure cases of an effect without performing side
* effects.
*
* **Details**
*
* `match` lets you define custom handlers for both success and failure
* scenarios. You provide separate functions to handle each case, allowing you
* to process the result if the effect succeeds, or handle the error if the
* effect fails.
*
* **When to Use**
*
* This is useful for structuring your code to respond differently to success or
* failure without triggering side effects.
*
* **Example** (Handling Both Success and Failure Cases)
*
* ```ts
* import { Effect } from "effect"
*
* const success: Effect.Effect<number, Error> = Effect.succeed(42)
*
* const program1 = Effect.match(success, {
*   onFailure: (error) => `failure: ${error.message}`,
*   onSuccess: (value) => `success: ${value}`
* })
*
* // Run and log the result of the successful effect
* Effect.runPromise(program1).then(console.log)
* // Output: "success: 42"
*
* const failure: Effect.Effect<number, Error> = Effect.fail(
*   new Error("Uh oh!")
* )
*
* const program2 = Effect.match(failure, {
*   onFailure: (error) => `failure: ${error.message}`,
*   onSuccess: (value) => `success: ${value}`
* })
*
* // Run and log the result of the failed effect
* Effect.runPromise(program2).then(console.log)
* // Output: "failure: Uh oh!"
* ```
*
* @see {@link matchEffect} if you need to perform side effects in the handlers.
*
* @since 2.0.0
* @category Matching
*/
const match = match$7;
/**
* Handles failures by matching the cause of failure.
*
* **Details**
*
* The `matchCause` function allows you to handle failures with access to the
* full cause of the failure within a fiber.
*
* **When to Use**
*
* This is useful for differentiating between different types of errors, such as
* regular failures, defects, or interruptions. You can provide specific
* handling logic for each failure type based on the cause.
*
* **Example** (Handling Different Failure Causes)
*
* ```ts
* import { Effect } from "effect"
*
* const task: Effect.Effect<number, Error> = Effect.die("Uh oh!")
*
* const program = Effect.matchCause(task, {
*   onFailure: (cause) => {
*     switch (cause._tag) {
*       case "Fail":
*         // Handle standard failure
*         return `Fail: ${cause.error.message}`
*       case "Die":
*         // Handle defects (unexpected errors)
*         return `Die: ${cause.defect}`
*       case "Interrupt":
*         // Handle interruption
*         return `${cause.fiberId} interrupted!`
*     }
*     // Fallback for other causes
*     return "failed due to other causes"
*   },
*   onSuccess: (value) =>
*     // task completes successfully
*     `succeeded with ${value} value`
* })
*
* Effect.runPromise(program).then(console.log)
* // Output: "Die: Uh oh!"
* ```
*
* @see {@link matchCauseEffect} if you need to perform side effects in the
* handlers.
* @see {@link match} if you don't need to handle the cause of the failure.
*
* @since 2.0.0
* @category Matching
*/
const matchCause = matchCause$2;
/**
* Handles failures with access to the cause and allows performing side effects.
*
* **Details**
*
* The `matchCauseEffect` function works similarly to {@link matchCause}, but it
* also allows you to perform additional side effects based on the failure
* cause. This function provides access to the complete cause of the failure,
* making it possible to differentiate between various failure types, and allows
* you to respond accordingly while performing side effects (like logging or
* other operations).
*
* **Example** (Handling Different Failure Causes with Side Effects)
*
* ```ts
* import { Effect, Console } from "effect"
*
* const task: Effect.Effect<number, Error> = Effect.die("Uh oh!")
*
* const program = Effect.matchCauseEffect(task, {
*   onFailure: (cause) => {
*     switch (cause._tag) {
*       case "Fail":
*         // Handle standard failure with a logged message
*         return Console.log(`Fail: ${cause.error.message}`)
*       case "Die":
*         // Handle defects (unexpected errors) by logging the defect
*         return Console.log(`Die: ${cause.defect}`)
*       case "Interrupt":
*         // Handle interruption and log the fiberId that was interrupted
*         return Console.log(`${cause.fiberId} interrupted!`)
*     }
*     // Fallback for other causes
*     return Console.log("failed due to other causes")
*   },
*   onSuccess: (value) =>
*     // Log success if the task completes successfully
*     Console.log(`succeeded with ${value} value`)
* })
*
* Effect.runPromise(program)
* // Output: "Die: Uh oh!"
* ```
*
* @see {@link matchCause} if you don't need side effects and only want to handle the result or failure.
* @see {@link matchEffect} if you don't need to handle the cause of the failure.
*
* @since 2.0.0
* @category Matching
*/
const matchCauseEffect = matchCauseEffect$2;
/**
* Handles both success and failure cases of an effect, allowing for additional
* side effects.
*
* **Details**
*
* The `matchEffect` function is similar to {@link match}, but it enables you to
* perform side effects in the handlers for both success and failure outcomes.
*
* **When to Use**
*
* This is useful when you need to execute additional actions, like logging or
* notifying users, based on whether an effect succeeds or fails.
*
* **Example** (Handling Both Success and Failure Cases with Side Effects)
*
* ```ts
* import { Effect } from "effect"
*
* const success: Effect.Effect<number, Error> = Effect.succeed(42)
* const failure: Effect.Effect<number, Error> = Effect.fail(
*   new Error("Uh oh!")
* )
*
* const program1 = Effect.matchEffect(success, {
*   onFailure: (error) =>
*     Effect.succeed(`failure: ${error.message}`).pipe(
*       Effect.tap(Effect.log)
*     ),
*   onSuccess: (value) =>
*     Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))
* })
*
* console.log(Effect.runSync(program1))
* // Output:
* // timestamp=... level=INFO fiber=#0 message="success: 42"
* // success: 42
*
* const program2 = Effect.matchEffect(failure, {
*   onFailure: (error) =>
*     Effect.succeed(`failure: ${error.message}`).pipe(
*       Effect.tap(Effect.log)
*     ),
*   onSuccess: (value) =>
*     Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))
* })
*
* console.log(Effect.runSync(program2))
* // Output:
* // timestamp=... level=INFO fiber=#1 message="failure: Uh oh!"
* // failure: Uh oh!
* ```
*
* @see {@link match} if you don't need side effects and only want to handle the
* result or failure.
*
* @since 2.0.0
* @category Matching
*/
const matchEffect = matchEffect$2;
/**
* Logs one or more messages or error causes at the current log level.
*
* **Details**
*
* This function provides a simple way to log messages or error causes during
* the execution of your effects. By default, logs are recorded at the `INFO`
* level, but this can be adjusted using other logging utilities
* (`Logger.withMinimumLogLevel`). Multiple items, including `Cause` instances,
* can be logged in a single call. When logging `Cause` instances, detailed
* error information is included in the log output.
*
* The log output includes useful metadata like the current timestamp, log
* level, and fiber ID, making it suitable for debugging and tracking purposes.
* This function does not interrupt or alter the effect's execution flow.
*
* **Example**
*
* ```ts
* import { Cause, Effect } from "effect"
*
* const program = Effect.log(
*   "message1",
*   "message2",
*   Cause.die("Oh no!"),
*   Cause.die("Oh uh!")
* )
*
* Effect.runFork(program)
* // Output:
* // timestamp=... level=INFO fiber=#0 message=message1 message=message2 cause="Error: Oh no!
* // Error: Oh uh!"
* ```
*
* @since 2.0.0
* @category Logging
*/
const log = log$1;
/**
* Logs messages at the TRACE log level.
*
* **Details**
*
* This function logs the specified messages at the TRACE level. TRACE logs are
* typically used for very detailed diagnostic information. These messages are
* not displayed by default. To view them, you must adjust the logging
* configuration by setting the minimum log level to `LogLevel.Trace` using
* `Logger.withMinimumLogLevel`.
*
* **Example**
*
* ```ts
* import { Effect, Logger, LogLevel } from "effect"
*
* const program = Effect.logTrace("message1").pipe(Logger.withMinimumLogLevel(LogLevel.Trace))
*
* Effect.runFork(program)
* // timestamp=... level=TRACE fiber=#0 message=message1
* ```
*
* @since 2.0.0
* @category Logging
*/
const logTrace = logTrace$1;
/**
* Logs messages at the DEBUG log level.
*
* **Details**
*
* This function logs messages at the DEBUG level, which is typically used for
* diagnosing application behavior during development. DEBUG messages provide
* less detailed information than TRACE logs but are still not shown by default.
* To view these logs, adjust the log level using `Logger.withMinimumLogLevel`.
*
* **Example**
*
* ```ts
* import { Effect, Logger, LogLevel } from "effect"
*
* const program = Effect.logDebug("message1").pipe(Logger.withMinimumLogLevel(LogLevel.Debug))
*
* Effect.runFork(program)
* // timestamp=... level=DEBUG fiber=#0 message=message1
* ```
*
* @since 2.0.0
* @category Logging
*/
const logDebug = logDebug$1;
/**
* Logs messages at the INFO log level.
*
* **Details**
*
* This function logs messages at the INFO level, suitable for general
* application events or operational messages. INFO logs are shown by default
* and are commonly used for highlighting normal, non-error operations.
*
* @since 2.0.0
* @category Logging
*/
const logInfo = logInfo$1;
/**
* Logs messages at the WARNING log level.
*
* **Details**
*
* This function logs messages at the WARNING level, suitable for highlighting
* potential issues that are not errors but may require attention. These
* messages indicate that something unexpected occurred or might lead to errors
* in the future.
*
* @since 2.0.0
* @category Logging
*/
const logWarning = logWarning$1;
/**
* Logs messages at the ERROR log level.
*
* **Details**
*
* This function logs messages at the ERROR level, suitable for reporting
* application errors or failures. These logs are typically used for unexpected
* issues that need immediate attention.
*
* @since 2.0.0
* @category Logging
*/
const logError = logError$1;
/**
* Logs messages at the FATAL log level.
*
* **Details**
*
* This function logs messages at the FATAL level, suitable for reporting
* critical errors that cause the application to terminate or stop functioning.
* These logs are typically used for unrecoverable errors that require immediate
* attention.
*
* @since 2.0.0
* @category Logging
*/
const logFatal = logFatal$1;
/**
* Adds a log span to an effect for tracking and logging its execution duration.
*
* **Details**
*
* This function wraps an effect with a log span, providing performance
* monitoring and debugging capabilities. The log span tracks the duration of
* the wrapped effect and logs it with the specified label. This is particularly
* useful when analyzing time-sensitive operations or understanding the
* execution time of specific tasks in your application.
*
* The logged output will include the label and the total time taken for the
* operation. The span information is included in the log metadata, making it
* easy to trace performance metrics in logs.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const program = Effect.gen(function*() {
*   yield* Effect.sleep("1 second")
*   yield* Effect.log("The job is finished!")
* }).pipe(Effect.withLogSpan("myspan"))
*
* Effect.runFork(program)
* // timestamp=... level=INFO fiber=#0 message="The job is finished!" myspan=1011ms
* ```
*
* @since 2.0.0
* @category Logging
*/
const withLogSpan = withLogSpan$1;
/**
* Adds custom annotations to log entries generated within an effect.
*
* **Details**
*
* This function allows you to enhance log messages by appending additional
* context in the form of key-value pairs. These annotations are included in
* every log message created during the execution of the effect, making the logs
* more informative and easier to trace.
*
* The annotations can be specified as a single key-value pair or as a record of
* multiple key-value pairs. This is particularly useful for tracking
* operations, debugging, or associating specific metadata with logs for better
* observability.
*
* The annotated key-value pairs will appear alongside the log message in the
* output.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const program = Effect.gen(function*() {
*   yield* Effect.log("message1")
*   yield* Effect.log("message2")
* }).pipe(Effect.annotateLogs("taskId", "1234")) // Annotation as key/value pair
*
* Effect.runFork(program)
* // timestamp=... level=INFO fiber=#0 message=message1 taskId=1234
* // timestamp=... level=INFO fiber=#0 message=message2 taskId=1234
* ```
*
* @see {@link annotateLogsScoped} to add log annotations with a limited scope.
*
* @since 2.0.0
* @category Logging
*/
const annotateLogs = annotateLogs$1;
/**
* Adds log annotations with a limited scope to enhance contextual logging.
*
* **Details**
*
* This function allows you to apply key-value annotations to log entries
* generated within a specific scope of your effect computations. The
* annotations are restricted to the defined `Scope`, ensuring that they are
* only applied to logs produced during that scope. Once the scope ends, the
* annotations are automatically removed, making it easier to manage
* context-specific logging without affecting other parts of your application.
*
* The annotations can be provided as a single key-value pair or as a record of
* multiple key-value pairs. This flexibility enables fine-grained control over
* the additional metadata included in logs for specific tasks or operations.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const program = Effect.gen(function*() {
*   yield* Effect.log("no annotations")
*   yield* Effect.annotateLogsScoped({ key: "value" })
*   yield* Effect.log("message1") // Annotation is applied to this log
*   yield* Effect.log("message2") // Annotation is applied to this log
* }).pipe(Effect.scoped, Effect.andThen(Effect.log("no annotations again")))
*
* Effect.runFork(program)
* // timestamp=... level=INFO fiber=#0 message="no annotations"
* // timestamp=... level=INFO fiber=#0 message=message1 key=value
* // timestamp=... level=INFO fiber=#0 message=message2 key=value
* // timestamp=... level=INFO fiber=#0 message="no annotations again"
* ```
*
* @see {@link annotateLogs} to add custom annotations to log entries generated within an effect.
*
* @since 3.1.0
* @category Logging
*/
const annotateLogsScoped = annotateLogsScoped$1;
/**
* Retrieves the current log annotations for the current scope.
*
* **Details**
*
* This function provides access to the log annotations associated with the
* current scope. Log annotations are key-value pairs that provide additional
* context to log entries. They are often used to add metadata such as tags,
* identifiers, or extra debugging information to logs.
*
* By using this function, you can inspect or utilize the annotations applied to
* the current scope, making it easier to trace and debug specific sections of
* your application.
*
* @see {@link annotateLogs} to add custom annotations to log entries generated within an effect.
* @see {@link annotateLogsScoped} to add log annotations with a limited scope.
*
* @since 2.0.0
* @category Logging
*/
const logAnnotations = logAnnotations$1;
/**
* Configures whether child fibers will log unhandled errors and at what log
* level.
*
* **Details**
*
* This function allows you to control whether unhandled errors from child
* fibers are logged and to specify the log level for these errors. By default,
* unhandled errors are reported via the logger. However, using this function,
* you can choose to suppress these logs by passing `Option.none` or adjust the
* log level to a specific severity, such as `Error`, `Warning`, or `Info`.
*
* This configuration is scoped to the effect it is applied to, meaning the
* changes only apply to the child fibers created within that effect's context.
* It is especially useful when you want to reduce noise in logs or prioritize
* certain types of errors.
*
* **Example**
*
* ```ts
* import { Effect, Fiber, LogLevel, Option } from "effect"
*
* const program = Effect.gen(function*() {
*   const fiber = yield* Effect.fork(Effect.fail("Unhandled error!"))
*   yield* Fiber.join(fiber)
* })
*
* Effect.runFork(program.pipe(Effect.withUnhandledErrorLogLevel(Option.some(LogLevel.Error))))
* // Output:
* // timestamp=... level=ERROR fiber=#1 message="Fiber terminated with an unhandled error" cause="Error: Unhandled error!"
* ```
*
* @since 2.0.0
* @category Logging
*/
const withUnhandledErrorLogLevel = withUnhandledErrorLogLevel$1;
/**
* Conditionally executes an effect based on the specified log level and currently enabled log level.
*
* **Details**
*
* This function runs the provided effect only if the specified log level is
* enabled. If the log level is enabled, the effect is executed and its result
* is wrapped in `Some`. If the log level is not enabled, the effect is not
* executed and `None` is returned.
*
* This function is useful for conditionally executing logging-related effects
* or other operations that depend on the current log level configuration.
*
* **Example**
*
* ```ts
* import { Effect, Logger, LogLevel } from "effect"
*
* const program = Effect.gen(function* () {
*   yield* Effect.whenLogLevel(Effect.logTrace("message1"), LogLevel.Trace); // returns `None`
*   yield* Effect.whenLogLevel(Effect.logDebug("message2"), LogLevel.Debug); // returns `Some`
* }).pipe(Logger.withMinimumLogLevel(LogLevel.Debug));
*
* Effect.runFork(program)
* // timestamp=... level=DEBUG fiber=#0 message=message2
* ```
*
* @see {@link FiberRef.currentMinimumLogLevel} to retrieve the current minimum log level.
*
* @since 3.13.0
* @category Logging
*/
const whenLogLevel = whenLogLevel$1;
/**
* Converts an effect's failure into a fiber termination, removing the error
* from the effect's type.
*
* **Details**
*
* The `orDie` function is used when you encounter errors that you do not want
* to handle or recover from. It removes the error type from the effect and
* ensures that any failure will terminate the fiber. This is useful for
* propagating failures as defects, signaling that they should not be handled
* within the effect.
*
* **When to Use*
*
* Use `orDie` when failures should be treated as unrecoverable defects and no
* error handling is required.
*
* **Example** (Propagating an Error as a Defect)
*
* ```ts
* import { Effect } from "effect"
*
* const divide = (a: number, b: number) =>
*   b === 0
*     ? Effect.fail(new Error("Cannot divide by zero"))
*     : Effect.succeed(a / b)
*
* //      ┌─── Effect<number, never, never>
* //      ▼
* const program = Effect.orDie(divide(1, 0))
*
* Effect.runPromise(program).catch(console.error)
* // Output:
* // (FiberFailure) Error: Cannot divide by zero
* //   ...stack trace...
* ```
*
* @see {@link orDieWith} if you need to customize the error.
*
* @since 2.0.0
* @category Converting Failures to Defects
*/
const orDie = orDie$1;
/**
* Converts an effect's failure into a fiber termination with a custom error.
*
* **Details**
*
* The `orDieWith` function behaves like {@link orDie}, but it allows you to provide a mapping
* function to transform the error before terminating the fiber. This is useful for cases where
* you want to include a more detailed or user-friendly error when the failure is propagated
* as a defect.
*
* **When to Use**
*
* Use `orDieWith` when failures should terminate the fiber as defects, and you want to customize
* the error for clarity or debugging purposes.
*
* **Example** (Customizing Defect)
*
* ```ts
* import { Effect } from "effect"
*
* const divide = (a: number, b: number) =>
*   b === 0
*     ? Effect.fail(new Error("Cannot divide by zero"))
*     : Effect.succeed(a / b)
*
* //      ┌─── Effect<number, never, never>
* //      ▼
* const program = Effect.orDieWith(
*   divide(1, 0),
*   (error) => new Error(`defect: ${error.message}`)
* )
*
* Effect.runPromise(program).catch(console.error)
* // Output:
* // (FiberFailure) Error: defect: Cannot divide by zero
* //   ...stack trace...
* ```
*
* @see {@link orDie} if you don't need to customize the error.
*
* @since 2.0.0
* @category Converting Failures to Defects
*/
const orDieWith = orDieWith$1;
/**
* Attempts one effect, and if it fails, falls back to another effect.
*
* **Details**
*
* This function allows you to try executing an effect, and if it fails
* (produces an error), a fallback effect is executed instead. The fallback
* effect is defined as a lazy argument, meaning it will only be evaluated if
* the first effect fails. This provides a way to recover from errors by
* specifying an alternative path of execution.
*
* The error type of the resulting effect will be that of the fallback effect,
* as the first effect's error is replaced when the fallback is executed.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const success = Effect.succeed("success")
* const failure = Effect.fail("failure")
* const fallback = Effect.succeed("fallback")
*
* // Try the success effect first, fallback is not used
* const program1 = Effect.orElse(success, () => fallback)
* console.log(Effect.runSync(program1))
* // Output: "success"
*
* // Try the failure effect first, fallback is used
* const program2 = Effect.orElse(failure, () => fallback)
* console.log(Effect.runSync(program2))
* // Output: "fallback"
* ```
*
* @see {@link catchAll} if you need to access the error in the fallback effect.
*
* @since 2.0.0
* @category Fallback
*/
const orElse$1 = orElse$4;
/**
* Replaces the failure of an effect with a custom failure value.
*
* **Details**
*
* This function allows you to handle the failure of an effect by replacing it
* with a predefined failure value. If the effect fails, the new failure value
* provided by the `evaluate` function will be returned instead of the original
* failure. If the effect succeeds, the original success value is returned
* unchanged.
*
* **When to Use**
*
* This is particularly useful when you want to standardize error handling or
* provide a consistent failure value for specific operations. It simplifies
* error management by ensuring that all failures are replaced with a controlled
* alternative.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const validate = (age: number): Effect.Effect<number, string> => {
*   if (age < 0) {
*     return Effect.fail("NegativeAgeError")
*   } else if (age < 18) {
*     return Effect.fail("IllegalAgeError")
*   } else {
*     return Effect.succeed(age)
*   }
* }
*
* const program = Effect.orElseFail(validate(-1), () => "invalid age")
*
* console.log(Effect.runSyncExit(program))
* // Output:
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: { _id: 'Cause', _tag: 'Fail', failure: 'invalid age' }
* // }
* ```
*
* @see {@link mapError} if you need to access the error to transform it.
*
* @since 2.0.0
* @category Fallback
*/
const orElseFail = orElseFail$1;
/**
* Ensures the effect always succeeds by replacing failures with a default
* success value.
*
* **Details**
*
* This function transforms an effect that may fail into one that cannot fail by
* replacing any failure with a provided success value. If the original effect
* fails, the failure is "swallowed," and the specified success value is
* returned instead. If the original effect succeeds, its value remains
* unchanged.
*
* **When to Use**
*
* This is especially useful for providing default values in case of failure,
* ensuring that an effect always completes successfully. By using this
* function, you can avoid the need for complex error handling and guarantee a
* fallback result.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const validate = (age: number): Effect.Effect<number, string> => {
*   if (age < 0) {
*     return Effect.fail("NegativeAgeError")
*   } else if (age < 18) {
*     return Effect.fail("IllegalAgeError")
*   } else {
*     return Effect.succeed(age)
*   }
* }
*
* const program = Effect.orElseSucceed(validate(-1), () => 18)
*
* console.log(Effect.runSyncExit(program))
* // Output:
* // { _id: 'Exit', _tag: 'Success', value: 18 }
* ```
*
* @since 2.0.0
* @category Fallback
*/
const orElseSucceed = orElseSucceed$1;
/**
* Runs a sequence of effects and returns the result of the first successful
* one.
*
* **Details**
*
* This function allows you to execute a collection of effects in sequence,
* stopping at the first success. If an effect succeeds, its result is
* immediately returned, and no further effects in the sequence are executed.
* However, if all the effects fail, the function will return the error of the
* last effect.
*
* The execution is sequential, meaning that effects are evaluated one at a time
* in the order they are provided. This ensures predictable behavior and avoids
* unnecessary computations.
*
* If the collection of effects is empty, an `IllegalArgumentException` is
* thrown, indicating that the operation is invalid without any effects to try.
*
* **When to Use**
*
* This is particularly useful when you have multiple fallback strategies or
* alternative sources to obtain a result, such as attempting multiple APIs,
* retrieving configurations, or accessing resources in a prioritized manner.
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* interface Config {
*   host: string
*   port: number
*   apiKey: string
* }
*
* // Create a configuration object with sample values
* const makeConfig = (name: string): Config => ({
*   host: `${name}.example.com`,
*   port: 8080,
*   apiKey: "12345-abcde"
* })
*
* // Simulate retrieving configuration from a remote node
* const remoteConfig = (name: string): Effect.Effect<Config, Error> =>
*   Effect.gen(function* () {
*     // Simulate node3 being the only one with available config
*     if (name === "node3") {
*       yield* Console.log(`Config for ${name} found`)
*       return makeConfig(name)
*     } else {
*       yield* Console.log(`Unavailable config for ${name}`)
*       return yield* Effect.fail(new Error(`Config not found for ${name}`))
*     }
*   })
*
* // Define the master configuration and potential fallback nodes
* const masterConfig = remoteConfig("master")
* const nodeConfigs = ["node1", "node2", "node3", "node4"].map(remoteConfig)
*
* // Attempt to find a working configuration,
* // starting with the master and then falling back to other nodes
* const config = Effect.firstSuccessOf([masterConfig, ...nodeConfigs])
*
* // Run the effect to retrieve the configuration
* const result = Effect.runSync(config)
*
* console.log(result)
* // Output:
* // Unavailable config for master
* // Unavailable config for node1
* // Unavailable config for node2
* // Config for node3 found
* // { host: 'node3.example.com', port: 8080, apiKey: '12345-abcde' }
* ```
*
* @since 2.0.0
* @category Fallback
*/
const firstSuccessOf = firstSuccessOf$1;
/**
* Retrieves the `Random` service from the context.
*
* @since 2.0.0
* @category Random
*/
const random = random$1;
/**
* Retrieves the `Random` service from the context and uses it to run the
* specified effect.
*
* @since 2.0.0
* @category Random
*/
const randomWith = randomWith$1;
/**
* Executes the specified effect with the specified implementation of the
* `Random` service.
*
* @since 2.0.0
* @category Random
*/
const withRandom = withRandom$1;
/**
* Sets the implementation of the `Random` service to the specified value and
* restores it to its original value when the scope is closed.
*
* @since 2.0.0
* @category Random
*/
const withRandomScoped = withRandomScoped$1;
/**
* Returns an effect that accesses the runtime, which can be used to (unsafely)
* execute tasks.
*
* **When to Use**
*
* This is useful for integration with legacy code that must call back into
* Effect code.
*
* @since 2.0.0
* @category Runtime
*/
const runtime = runtime$1;
/**
* Retrieves an effect that succeeds with the current runtime flags, which
* govern behavior and features of the runtime system.
*
* @since 2.0.0
* @category Runtime
*/
const getRuntimeFlags = runtimeFlags;
/**
* @since 2.0.0
* @category Runtime
*/
const patchRuntimeFlags = updateRuntimeFlags;
/**
* @since 2.0.0
* @category Runtime
*/
const withRuntimeFlagsPatch = withRuntimeFlags;
/**
* @since 2.0.0
* @category Runtime
*/
const withRuntimeFlagsPatchScoped = withRuntimeFlagsScoped;
/**
* Tags each metric in an effect with specific key-value pairs.
*
* **Details**
*
* This function allows you to tag all metrics in an effect with a set of
* key-value pairs or a single key-value pair. Tags help you add metadata to
* metrics, making it easier to filter and categorize them in monitoring
* systems. The provided tags will apply to all metrics generated within the
* effect's scope.
*
* @since 2.0.0
* @category Metrics
*/
const tagMetrics = tagMetrics$1;
/**
* Adds labels to metrics within an effect using `MetricLabel` objects.
*
* **Details**
*
* This function allows you to label metrics using `MetricLabel` objects. Labels
* help add structured metadata to metrics for categorization and filtering in
* monitoring systems. The provided labels will apply to all metrics within the
* effect's execution.
*
* @since 2.0.0
* @category Metrics
*/
const labelMetrics = labelMetrics$1;
/**
* Tags metrics within a scope with a specific key-value pair.
*
* **Details**
*
* This function tags all metrics within a scope with the provided key-value
* pair. Once the scope is closed, the tag is automatically removed. This is
* useful for applying temporary context-specific tags to metrics during scoped
* operations.
*
* @since 2.0.0
* @category Metrics
*/
const tagMetricsScoped = tagMetricsScoped$1;
/**
* Adds labels to metrics within a scope using `MetricLabel` objects.
*
* **Details**
*
* This function allows you to apply labels to all metrics generated within a
* specific scope using an array of `MetricLabel` objects. These labels provide
* additional metadata to metrics, which can be used for categorization,
* filtering, or monitoring purposes. The labels are scoped and will be removed
* automatically once the scope is closed, ensuring they are only applied
* temporarily within the defined context.
*
* @since 2.0.0
* @category Metrics
*/
const labelMetricsScoped = labelMetricsScoped$1;
/**
* Retrieves the metric labels associated with the current scope.
*
* @since 2.0.0
* @category Metrics
*/
const metricLabels = metricLabels$1;
/**
* Associates a metric with the current effect, updating it as the effect progresses.
*
* @since 2.0.0
* @category Metrics
*/
const withMetric = withMetric$1;
/**
* Unsafely creates a new Semaphore.
*
* @since 2.0.0
* @category Semaphore
*/
const unsafeMakeSemaphore = unsafeMakeSemaphore$1;
/**
* Creates a new semaphore with the specified number of permits.
*
* **Details**
*
* This function initializes a semaphore that controls concurrent access to a
* shared resource. The number of permits determines how many tasks can access
* the resource concurrently.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* // Create a semaphore with 3 permits
* const mutex = Effect.makeSemaphore(3)
* ```
*
* @since 2.0.0
* @category Semaphore
*/
const makeSemaphore = makeSemaphore$1;
/**
* @category Latch
* @since 3.8.0
*/
const unsafeMakeLatch = unsafeMakeLatch$1;
/**
* Creates a new `Latch`, starting in the specified state.
*
* **Details**
*
* This function initializes a `Latch` safely, ensuring proper runtime
* guarantees. By default, the latch starts in the closed state.
*
* **Example**
*
* ```ts
* import { Console, Effect } from "effect"
*
* const program = Effect.gen(function*() {
*   // Create a latch, starting in the closed state
*   const latch = yield* Effect.makeLatch(false)
*
*   // Fork a fiber that logs "open sesame" when the latch is opened
*   const fiber = yield* Console.log("open sesame").pipe(
*     latch.whenOpen,
*     Effect.fork
*   )
*
*   yield* Effect.sleep("1 second")
*
*   // Open the latch
*   yield* latch.open
*   yield* fiber.await
* })
*
* Effect.runFork(program)
* // Output: open sesame (after 1 second)
* ```
*
* @category Latch
* @since 3.8.0
*/
const makeLatch = makeLatch$1;
/**
* Runs an effect in the background, returning a fiber that can be observed or
* interrupted.
*
* Unless you specifically need a `Promise` or synchronous operation, `runFork`
* is a good default choice.
*
* **Details**
*
* This function is the foundational way to execute an effect in the background.
* It creates a "fiber," a lightweight, cooperative thread of execution that can
* be observed (to access its result), interrupted, or joined. Fibers are useful
* for concurrent programming and allow effects to run independently of the main
* program flow.
*
* Once the effect is running in a fiber, you can monitor its progress, cancel
* it if necessary, or retrieve its result when it completes. If the effect
* fails, the fiber will propagate the failure, which you can observe and
* handle.
*
* **When to Use**
*
* Use this function when you need to run an effect in the background,
* especially if the effect is long-running or performs periodic tasks. It's
* suitable for tasks that need to run independently but might still need
* observation or management, like logging, monitoring, or scheduled tasks.
*
* This function is ideal if you don't need the result immediately or if the
* effect is part of a larger concurrent workflow.
*
* **Example** (Running an Effect in the Background)
*
* ```ts
* import { Effect, Console, Schedule, Fiber } from "effect"
*
* //      ┌─── Effect<number, never, never>
* //      ▼
* const program = Effect.repeat(
*   Console.log("running..."),
*   Schedule.spaced("200 millis")
* )
*
* //      ┌─── RuntimeFiber<number, never>
* //      ▼
* const fiber = Effect.runFork(program)
*
* setTimeout(() => {
*   Effect.runFork(Fiber.interrupt(fiber))
* }, 500)
* ```
*
* @since 2.0.0
* @category Running Effects
*/
const runFork = unsafeForkEffect;
/**
* Executes an effect asynchronously and handles the result using a callback.
*
* **Details**
*
* This function runs an effect asynchronously and passes the result (`Exit`) to
* a specified callback. The callback is invoked with the outcome of the effect:
* - On success, the callback receives the successful result.
* - On failure, the callback receives the failure information.
*
* **When to Use**
*
* This function is effectful and should only be invoked at the edges of your
* program.
*
* @since 2.0.0
* @category Running Effects
*/
const runCallback = unsafeRunEffect;
/**
* Executes an effect and returns the result as a `Promise`.
*
* **Details**
*
* This function runs an effect and converts its result into a `Promise`. If the
* effect succeeds, the `Promise` will resolve with the successful result. If
* the effect fails, the `Promise` will reject with an error, which includes the
* failure details of the effect.
*
* The optional `options` parameter allows you to pass an `AbortSignal` for
* cancellation, enabling more fine-grained control over asynchronous tasks.
*
* **When to Use**
*
* Use this function when you need to execute an effect and work with its result
* in a promise-based system, such as when integrating with third-party
* libraries that expect `Promise` results.
*
* **Example** (Running a Successful Effect as a Promise)
*
* ```ts
* import { Effect } from "effect"
*
* Effect.runPromise(Effect.succeed(1)).then(console.log)
* // Output: 1
* ```
*
* **Example** (Handling a Failing Effect as a Rejected Promise)
*
* ```ts
* import { Effect } from "effect"
*
* Effect.runPromise(Effect.fail("my error")).catch(console.error)
* // Output:
* // (FiberFailure) Error: my error
* ```
*
* @see {@link runPromiseExit} for a version that returns an `Exit` type instead
* of rejecting.
*
* @since 2.0.0
* @category Running Effects
*/
const runPromise = unsafeRunPromiseEffect;
/**
* Runs an effect and returns a `Promise` that resolves to an `Exit`,
* representing the outcome.
*
* **Details**
*
* This function executes an effect and resolves to an `Exit` object. The `Exit`
* type provides detailed information about the result of the effect:
* - If the effect succeeds, the `Exit` will be of type `Success` and include
*   the value produced by the effect.
* - If the effect fails, the `Exit` will be of type `Failure` and contain a
*   `Cause` object, detailing the failure.
*
* Using this function allows you to examine both successful results and failure
* cases in a unified way, while still leveraging `Promise` for handling the
* asynchronous behavior of the effect.
*
* **When to Use**
*
* Use this function when you need to understand the outcome of an effect,
* whether it succeeded or failed, and want to work with this result using
* `Promise` syntax. This is particularly useful when integrating with systems
* that rely on promises but need more detailed error handling than a simple
* rejection.
*
* **Example** (Handling Results as Exit)
*
* ```ts
* import { Effect } from "effect"
*
* // Execute a successful effect and get the Exit result as a Promise
* Effect.runPromiseExit(Effect.succeed(1)).then(console.log)
* // Output:
* // {
* //   _id: "Exit",
* //   _tag: "Success",
* //   value: 1
* // }
*
* // Execute a failing effect and get the Exit result as a Promise
* Effect.runPromiseExit(Effect.fail("my error")).then(console.log)
* // Output:
* // {
* //   _id: "Exit",
* //   _tag: "Failure",
* //   cause: {
* //     _id: "Cause",
* //     _tag: "Fail",
* //     failure: "my error"
* //   }
* // }
* ```
*
* @since 2.0.0
* @category Running Effects
*/
const runPromiseExit = unsafeRunPromiseExitEffect;
/**
* Executes an effect synchronously, running it immediately and returning the
* result.
*
* **Details**
*
* This function evaluates the provided effect synchronously, returning its
* result directly. It is ideal for effects that do not fail or include
* asynchronous operations. If the effect does fail or involves async tasks, it
* will throw an error. Execution stops at the point of failure or asynchronous
* operation, making it unsuitable for effects that require asynchronous
* handling.
*
* **Important**: Attempting to run effects that involve asynchronous operations
* or failures will result in exceptions being thrown, so use this function with
* care for purely synchronous and error-free effects.
*
* **When to Use**
*
* Use this function when:
* - You are sure that the effect will not fail or involve asynchronous
*   operations.
* - You need a direct, synchronous result from the effect.
* - You are working within a context where asynchronous effects are not
*   allowed.
*
* Avoid using this function for effects that can fail or require asynchronous
* handling. For such cases, consider using {@link runPromise} or
* {@link runSyncExit}.
*
* **Example** (Synchronous Logging)
*
* ```ts
* import { Effect } from "effect"
*
* const program = Effect.sync(() => {
*   console.log("Hello, World!")
*   return 1
* })
*
* const result = Effect.runSync(program)
* // Output: Hello, World!
*
* console.log(result)
* // Output: 1
* ```
*
* **Example** (Incorrect Usage with Failing or Async Effects)
*
* ```ts
* import { Effect } from "effect"
*
* try {
*   // Attempt to run an effect that fails
*   Effect.runSync(Effect.fail("my error"))
* } catch (e) {
*   console.error(e)
* }
* // Output:
* // (FiberFailure) Error: my error
*
* try {
*   // Attempt to run an effect that involves async work
*   Effect.runSync(Effect.promise(() => Promise.resolve(1)))
* } catch (e) {
*   console.error(e)
* }
* // Output:
* // (FiberFailure) AsyncFiberException: Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work
* ```
*
* @see {@link runSyncExit} for a version that returns an `Exit` type instead of
* throwing an error.
*
* @since 2.0.0
* @category Running Effects
*/
const runSync = unsafeRunSyncEffect;
/**
* Runs an effect synchronously and returns the result as an `Exit` type.
*
* **Details**
*
* This function executes the provided effect synchronously and returns an `Exit`
* type that encapsulates the outcome of the effect:
* - If the effect succeeds, the result is wrapped in a `Success`.
* - If the effect fails, it returns a `Failure` containing a `Cause` that explains
*   the failure.
*
* If the effect involves asynchronous operations, this function will return a `Failure`
* with a `Die` cause, indicating that it cannot resolve the effect synchronously.
* This makes the function suitable for use only with effects that are synchronous
* in nature.
*
* **When to Use**
*
* Use this function when:
* - You want to handle both success and failure outcomes in a structured way using the `Exit` type.
* - You are working with effects that are purely synchronous and do not involve asynchronous operations.
* - You need to debug or inspect failures, including their causes, in a detailed manner.
*
* Avoid using this function for effects that involve asynchronous operations, as it will fail with a `Die` cause.
*
* **Example** (Handling Results as Exit)
*
* ```ts
* import { Effect } from "effect"
*
* console.log(Effect.runSyncExit(Effect.succeed(1)))
* // Output:
* // {
* //   _id: "Exit",
* //   _tag: "Success",
* //   value: 1
* // }
*
* console.log(Effect.runSyncExit(Effect.fail("my error")))
* // Output:
* // {
* //   _id: "Exit",
* //   _tag: "Failure",
* //   cause: {
* //     _id: "Cause",
* //     _tag: "Fail",
* //     failure: "my error"
* //   }
* // }
* ```
*
* **Example** (Asynchronous Operation Resulting in Die)
*
* ```ts
* import { Effect } from "effect"
*
* console.log(Effect.runSyncExit(Effect.promise(() => Promise.resolve(1))))
* // Output:
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: {
* //     _id: 'Cause',
* //     _tag: 'Die',
* //     defect: [Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work] {
* //       fiber: [FiberRuntime],
* //       _tag: 'AsyncFiberException',
* //       name: 'AsyncFiberException'
* //     }
* //   }
* // }
* ```
*
* @since 2.0.0
* @category Running Effects
*/
const runSyncExit = unsafeRunSyncExitEffect;
/**
* Combines multiple effects and accumulates both successes and failures.
*
* **Details**
*
* This function allows you to combine multiple effects, continuing through all
* effects even if some of them fail. Unlike other functions that stop execution
* upon encountering an error, this function collects all errors into a `Cause`.
* The final result includes all successes and the accumulated failures.
*
* By default, effects are executed sequentially, but you can control
* concurrency and batching behavior using the `options` parameter. This
* provides flexibility in scenarios where you want to maximize performance or
* ensure specific ordering.
*
* **Example**
*
* ```ts
* import { Effect, Console } from "effect"
*
* const task1 = Console.log("task1").pipe(Effect.as(1))
* const task2 = Effect.fail("Oh uh!").pipe(Effect.as(2))
* const task3 = Console.log("task2").pipe(Effect.as(3))
* const task4 = Effect.fail("Oh no!").pipe(Effect.as(4))
*
* const program = task1.pipe(
*   Effect.validate(task2),
*   Effect.validate(task3),
*   Effect.validate(task4)
* )
*
* Effect.runPromiseExit(program).then(console.log)
* // Output:
* // task1
* // task2
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: {
* //     _id: 'Cause',
* //     _tag: 'Sequential',
* //     left: { _id: 'Cause', _tag: 'Fail', failure: 'Oh uh!' },
* //     right: { _id: 'Cause', _tag: 'Fail', failure: 'Oh no!' }
* //   }
* // }
* ```
*
* @see {@link zip} for a version that stops at the first error.
*
* @since 2.0.0
* @category Error Accumulation
*/
const validate = validate$1;
/**
* Sequentially combines two effects using a specified combiner function while
* accumulating errors.
*
* **Details**
*
* This function combines two effects, `self` and `that`, into a single effect
* by applying the provided combiner function to their results. If both effects
* succeed, the combiner function is applied to their results to produce the
* final value. If either effect fails, the failures are accumulated into a
* combined `Cause`.
*
* By default, effects are executed sequentially. However, the execution mode
* can be controlled using the `options` parameter to enable concurrency,
* batching, or customized finalizer behavior.
*
* @since 2.0.0
* @category Error Accumulation
*/
const validateWith = validateWith$1;
/**
* Combines two effects into a single effect, producing a tuple of their
* results.
*
* **Details**
*
* This function combines two effects, `self` and `that`, into one. It executes
* the first effect (`self`) and then the second effect (`that`), collecting
* their results into a tuple. Both effects must succeed for the resulting
* effect to succeed. If either effect fails, the entire operation fails.
*
* By default, the effects are executed sequentially. If the `concurrent` option
* is set to `true`, the effects will run concurrently, potentially improving
* performance for independent operations.
*
* **Example** (Combining Two Effects Sequentially)
*
* ```ts
* import { Effect } from "effect"
*
* const task1 = Effect.succeed(1).pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Effect.log("task1 done"))
* )
* const task2 = Effect.succeed("hello").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Effect.log("task2 done"))
* )
*
* // Combine the two effects together
* //
* //      ┌─── Effect<[number, string], never, never>
* //      ▼
* const program = Effect.zip(task1, task2)
*
* Effect.runPromise(program).then(console.log)
* // Output:
* // timestamp=... level=INFO fiber=#0 message="task1 done"
* // timestamp=... level=INFO fiber=#0 message="task2 done"
* // [ 1, 'hello' ]
* ```
*
* **Example** (Combining Two Effects Concurrently)
*
* ```ts
* import { Effect } from "effect"
*
* const task1 = Effect.succeed(1).pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Effect.log("task1 done"))
* )
* const task2 = Effect.succeed("hello").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Effect.log("task2 done"))
* )
*
* // Run both effects concurrently using the concurrent option
* const program = Effect.zip(task1, task2, { concurrent: true })
*
* Effect.runPromise(program).then(console.log)
* // Output:
* // timestamp=... level=INFO fiber=#0 message="task2 done"
* // timestamp=... level=INFO fiber=#0 message="task1 done"
* // [ 1, 'hello' ]
* ```
*
* @see {@link zipWith} for a version that combines the results with a custom
* function.
* @see {@link validate} for a version that accumulates errors.
*
* @since 2.0.0
* @category Zipping
*/
const zip = zipOptions;
/**
* Executes two effects sequentially, returning the result of the first effect
* and ignoring the result of the second.
*
* **Details**
*
* This function allows you to run two effects in sequence, where the result of
* the first effect is preserved, and the result of the second effect is
* discarded. By default, the two effects are executed sequentially. If you need
* them to run concurrently, you can pass the `{ concurrent: true }` option.
*
* The second effect will always be executed, even though its result is ignored.
* This makes it useful for cases where you want to execute an effect for its
* side effects while keeping the result of another effect.
*
* **When to Use**
*
* Use this function when you are only interested in the result of the first
* effect but still need to run the second effect for its side effects, such as
* logging or performing a cleanup action.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const task1 = Effect.succeed(1).pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Effect.log("task1 done"))
* )
* const task2 = Effect.succeed("hello").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Effect.log("task2 done"))
* )
*
* const program = Effect.zipLeft(task1, task2)
*
* Effect.runPromise(program).then(console.log)
* // Output:
* // timestamp=... level=INFO fiber=#0 message="task1 done"
* // timestamp=... level=INFO fiber=#0 message="task2 done"
* // 1
* ```
*
* @see {@link zipRight} for a version that returns the result of the second
* effect.
*
* @since 2.0.0
* @category Zipping
*/
const zipLeft = zipLeftOptions;
/**
* Executes two effects sequentially, returning the result of the second effect
* while ignoring the result of the first.
*
* **Details**
*
* This function allows you to run two effects in sequence, keeping the result
* of the second effect and discarding the result of the first. By default, the
* two effects are executed sequentially. If you need them to run concurrently,
* you can pass the `{ concurrent: true }` option.
*
* The first effect will always be executed, even though its result is ignored.
* This makes it useful for scenarios where the first effect is needed for its
* side effects, but only the result of the second effect is important.
*
* **When to Use**
*
* Use this function when you are only interested in the result of the second
* effect but still need to run the first effect for its side effects, such as
* initialization or setup tasks.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const task1 = Effect.succeed(1).pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Effect.log("task1 done"))
* )
* const task2 = Effect.succeed("hello").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Effect.log("task2 done"))
* )
*
* const program = Effect.zipRight(task1, task2)
*
* Effect.runPromise(program).then(console.log)
* // Output:
* // timestamp=... level=INFO fiber=#0 message="task1 done"
* // timestamp=... level=INFO fiber=#0 message="task2 done"
* // hello
* ```
*
* @see {@link zipLeft} for a version that returns the result of the first
* effect.
*
* @since 2.0.0
* @category Zipping
*/
const zipRight = zipRightOptions;
/**
* Combines two effects sequentially and applies a function to their results to
* produce a single value.
*
* **Details**
*
* This function runs two effects in sequence (or concurrently, if the `{
* concurrent: true }` option is provided) and combines their results using a
* provided function. Unlike {@link zip}, which returns a tuple of the results,
* this function processes the results with a custom function to produce a
* single output.
*
* **Example** (Combining Effects with a Custom Function)
*
* ```ts
* import { Effect } from "effect"
*
* const task1 = Effect.succeed(1).pipe(
*   Effect.delay("200 millis"),
*   Effect.tap(Effect.log("task1 done"))
* )
* const task2 = Effect.succeed("hello").pipe(
*   Effect.delay("100 millis"),
*   Effect.tap(Effect.log("task2 done"))
* )
*
* const task3 = Effect.zipWith(
*   task1,
*   task2,
*   // Combines results into a single value
*   (number, string) => number + string.length
* )
*
* Effect.runPromise(task3).then(console.log)
* // Output:
* // timestamp=... level=INFO fiber=#3 message="task1 done"
* // timestamp=... level=INFO fiber=#2 message="task2 done"
* // 6
* ```
*
* @since 2.0.0
* @category Zipping
*/
const zipWith = zipWithOptions;
/**
* @category Requests & Batching
* @since 2.0.0
*/
const blocked = blocked$1;
/**
* @category Requests & Batching
* @since 2.0.0
*/
const runRequestBlock = runRequestBlock$1;
/**
* @category Requests & Batching
* @since 2.0.0
*/
const step = step$1;
/**
* @since 2.0.0
* @category Requests & Batching
*/
const request = /* @__PURE__ */ dual$1((args$2) => isRequest(args$2[0]), fromRequest);
/**
* @since 2.0.0
* @category Requests & Batching
*/
const cacheRequestResult = cacheRequest;
/**
* @since 2.0.0
* @category Requests & Batching
*/
const withRequestBatching = withRequestBatching$1;
/**
* @since 2.0.0
* @category Requests & Batching
*/
const withRequestCaching = withRequestCaching$1;
/**
* @since 2.0.0
* @category Requests & Batching
*/
const withRequestCache = withRequestCache$1;
/**
* @since 2.0.0
* @category Tracing
*/
const tracer = tracer$1;
/**
* @since 2.0.0
* @category Tracing
*/
const tracerWith = tracerWith$3;
/**
* @since 2.0.0
* @category Tracing
*/
const withTracer = withTracer$1;
/**
* @since 2.0.0
* @category Tracing
*/
const withTracerScoped = withTracerScoped$1;
/**
* Disable the tracer for the given Effect.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* Effect.succeed(42).pipe(
*   Effect.withSpan("my-span"),
*   // the span will not be registered with the tracer
*   Effect.withTracerEnabled(false)
* )
* ```
*
* @since 2.0.0
* @category Tracing
*/
const withTracerEnabled = withTracerEnabled$1;
/**
* @since 2.0.0
* @category Tracing
*/
const withTracerTiming = withTracerTiming$1;
/**
* Adds annotations to each span in the effect for enhanced traceability.
*
* **Details**
*
* This function lets you attach key-value annotations to all spans generated
* during the execution of an effect. Annotations provide additional context,
* such as metadata or labels, which can help you understand and debug
* asynchronous workflows more effectively.
*
* You can either pass a single key-value pair or a record of key-value pairs to
* annotate the spans. These annotations can then be visualized in tracing tools
* that support span annotations.
*
* @since 2.0.0
* @category Tracing
*/
const annotateSpans = annotateSpans$1;
/**
* Adds annotations to the currently active span for traceability.
*
* **Details**
*
* This function adds key-value annotations to the currently active span in the
* effect's trace. These annotations help provide more context about the
* operation being executed at a specific point in time. Unlike
* {@link annotateSpans}, which applies to all spans in an effect, this function
* focuses solely on the active span.
*
* You can either pass a single key-value pair or a record of key-value pairs to
* annotate the span. These annotations are useful for adding metadata to
* operations, especially in systems with detailed observability requirements.
*
* @since 2.0.0
* @category Tracing
*/
const annotateCurrentSpan = annotateCurrentSpan$1;
/**
* @since 2.0.0
* @category Tracing
*/
const currentSpan = currentSpan$1;
/**
* @since 2.0.0
* @category Tracing
*/
const currentParentSpan = currentParentSpan$1;
/**
* @since 2.0.0
* @category Tracing
*/
const spanAnnotations = spanAnnotations$1;
/**
* @since 2.0.0
* @category Tracing
*/
const spanLinks = spanLinks$1;
/**
* For all spans in this effect, add a link with the provided span.
*
* @since 2.0.0
* @category Tracing
*/
const linkSpans = linkSpans$1;
/**
* Add span links to the current span.
*
* @since 3.14.0
* @category Tracing
*/
const linkSpanCurrent = linkSpanCurrent$1;
/**
* Create a new span for tracing.
*
* @since 2.0.0
* @category Tracing
*/
const makeSpan = makeSpan$1;
/**
* Create a new span for tracing, and automatically close it when the Scope
* finalizes.
*
* The span is not added to the current span stack, so no child spans will be
* created for it.
*
* @since 2.0.0
* @category Tracing
*/
const makeSpanScoped = makeSpanScoped$1;
/**
* Create a new span for tracing, and automatically close it when the effect
* completes.
*
* The span is not added to the current span stack, so no child spans will be
* created for it.
*
* @since 2.0.0
* @category Tracing
*/
const useSpan = useSpan$1;
/**
* Wraps the effect with a new span for tracing.
*
* @since 2.0.0
* @category Tracing
*/
const withSpan = withSpan$1;
/**
* Wraps a function that returns an effect with a new span for tracing.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* const getTodo = Effect.functionWithSpan({
*   body: (id: number) => Effect.succeed(`Got todo ${id}!`),
*   options: (id) => ({
*     name: `getTodo-${id}`,
*     attributes: { id }
*   })
* })
* ```
*
* @since 3.2.0
* @category Tracing
*/
const functionWithSpan = functionWithSpan$1;
/**
* Wraps the effect with a new span for tracing.
*
* The span is ended when the Scope is finalized.
*
* @since 2.0.0
* @category Tracing
*/
const withSpanScoped = withSpanScoped$1;
/**
* Adds the provided span to the current span stack.
*
* @since 2.0.0
* @category Tracing
*/
const withParentSpan = withParentSpan$1;
/**
* Safely handles nullable values by creating an effect that fails for `null` or
* `undefined`.
*
* **Details**
*
* This function ensures that an input value is non-null and non-undefined
* before processing it. If the value is valid, the effect succeeds with the
* value. If the value is `null` or `undefined`, the effect fails with a
* `NoSuchElementException`. This is particularly useful for avoiding
* null-related errors by clearly separating valid values from invalid ones in
* effectful computations.
*
* The failure with `NoSuchElementException` allows you to explicitly handle
* cases where a value is expected but not provided, leading to safer and more
* predictable code.
*
* **When to Use**
*
* Use this function when working with values that may be `null` or `undefined`
* and you want to ensure that only non-null values are processed. It helps
* enforce null-safety and makes error handling more explicit.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* //      ┌─── Effect<number, NoSuchElementException, never>
* //      ▼
* const maybe1 = Effect.fromNullable(1)
*
* Effect.runPromiseExit(maybe1).then(console.log)
* // Output:
* // { _id: 'Exit', _tag: 'Success', value: 1 }
*
* //      ┌─── Effect<number, NoSuchElementException, never>
* //      ▼
* const maybe2 = Effect.fromNullable(null as number | null)
*
* Effect.runPromiseExit(maybe2).then(console.log)
* // Output:
* // {
* //   _id: 'Exit',
* //   _tag: 'Failure',
* //   cause: {
* //     _id: 'Cause',
* //     _tag: 'Fail',
* //     failure: { _tag: 'NoSuchElementException' }
* //   }
* // }
* ```
*
* @since 2.0.0
* @category Optional Wrapping & Unwrapping
*/
const fromNullable = fromNullable$1;
/**
* Converts an effect that may fail with a `NoSuchElementException` into an
* effect that succeeds with an `Option`.
*
* **Details**
*
* This function transforms an effect that might fail with
* `Cause.NoSuchElementException` into an effect that succeeds with an `Option`
* type. If the original effect succeeds, its value is wrapped in `Option.some`.
* If it fails specifically due to a `NoSuchElementException`, the failure is
* mapped to `Option.none`. Other types of failures remain unchanged and are
* passed through as they are.
*
* This is useful when working with effects where you want to gracefully handle
* the absence of a value while preserving other potential failures.
*
* **When to Use**
*
* Use this function when you need to handle missing values as `Option.none`
* rather than throwing or propagating errors like `NoSuchElementException`.
* It’s ideal for scenarios where you want to explicitly represent optionality
* in a type-safe way while retaining other failure information.
*
* **Example**
*
* ```ts
* import { Effect } from "effect"
*
* //      ┌─── Effect<number, NoSuchElementException, never>
* //      ▼
* const maybe1 = Effect.fromNullable(1)
*
* //      ┌─── Effect<Option<number>, never, never>
* //      ▼
* const option1 = Effect.optionFromOptional(maybe1)
*
* Effect.runPromise(option1).then(console.log)
* // Output: { _id: 'Option', _tag: 'Some', value: 1 }
*
* //      ┌─── Effect<number, NoSuchElementException, never>
* //      ▼
* const maybe2 = Effect.fromNullable(null as number | null)
*
* //      ┌─── Effect<Option<number>, never, never>
* //      ▼
* const option2 = Effect.optionFromOptional(maybe2)
*
* Effect.runPromise(option2).then(console.log)
* // Output: { _tag: 'None' }
* ```
*
* @since 2.0.0
* @category Optional Wrapping & Unwrapping
*/
const optionFromOptional = optionFromOptional$1;
/**
* Same as {@link fn}, but allows you to create a function that is not traced, for when performance is critical.
*
* @see {@link fn} for a version that includes tracing.
*
* @since 3.12.0
* @category Tracing
*/
const fnUntraced = fnUntraced$1;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/encoding/common.js
/** @internal */
const DecodeExceptionTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Encoding/errors/Decode");
/** @internal */
const DecodeException$1 = (input, message) => {
	const out = {
		_tag: "DecodeException",
		[DecodeExceptionTypeId$1]: DecodeExceptionTypeId$1,
		input
	};
	if (isString(message)) out.message = message;
	return out;
};
/** @internal */
const isDecodeException$1 = (u$1) => hasProperty(u$1, DecodeExceptionTypeId$1);
/** @internal */
const EncodeExceptionTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Encoding/errors/Encode");
/** @internal */
const EncodeException$1 = (input, message) => {
	const out = {
		_tag: "EncodeException",
		[EncodeExceptionTypeId$1]: EncodeExceptionTypeId$1,
		input
	};
	if (isString(message)) out.message = message;
	return out;
};
/** @internal */
const isEncodeException$1 = (u$1) => hasProperty(u$1, EncodeExceptionTypeId$1);
/** @interal */
const encoder = /* @__PURE__ */ new TextEncoder();
/** @interal */
const decoder = /* @__PURE__ */ new TextDecoder();

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/encoding/base64.js
/** @internal */
const encode$2 = (bytes) => {
	const length$1 = bytes.length;
	let result = "";
	let i$1;
	for (i$1 = 2; i$1 < length$1; i$1 += 3) {
		result += base64abc[bytes[i$1 - 2] >> 2];
		result += base64abc[(bytes[i$1 - 2] & 3) << 4 | bytes[i$1 - 1] >> 4];
		result += base64abc[(bytes[i$1 - 1] & 15) << 2 | bytes[i$1] >> 6];
		result += base64abc[bytes[i$1] & 63];
	}
	if (i$1 === length$1 + 1) {
		result += base64abc[bytes[i$1 - 2] >> 2];
		result += base64abc[(bytes[i$1 - 2] & 3) << 4];
		result += "==";
	}
	if (i$1 === length$1) {
		result += base64abc[bytes[i$1 - 2] >> 2];
		result += base64abc[(bytes[i$1 - 2] & 3) << 4 | bytes[i$1 - 1] >> 4];
		result += base64abc[(bytes[i$1 - 1] & 15) << 2];
		result += "=";
	}
	return result;
};
/** @internal */
const decode$2 = (str) => {
	const stripped = stripCrlf(str);
	const length$1 = stripped.length;
	if (length$1 % 4 !== 0) return left(DecodeException$1(stripped, `Length must be a multiple of 4, but is ${length$1}`));
	const index = stripped.indexOf("=");
	if (index !== -1 && (index < length$1 - 2 || index === length$1 - 2 && stripped[length$1 - 1] !== "=")) return left(DecodeException$1(stripped, "Found a '=' character, but it is not at the end"));
	try {
		const missingOctets = stripped.endsWith("==") ? 2 : stripped.endsWith("=") ? 1 : 0;
		const result = new Uint8Array(3 * (length$1 / 4) - missingOctets);
		for (let i$1 = 0, j = 0; i$1 < length$1; i$1 += 4, j += 3) {
			const buffer = getBase64Code(stripped.charCodeAt(i$1)) << 18 | getBase64Code(stripped.charCodeAt(i$1 + 1)) << 12 | getBase64Code(stripped.charCodeAt(i$1 + 2)) << 6 | getBase64Code(stripped.charCodeAt(i$1 + 3));
			result[j] = buffer >> 16;
			result[j + 1] = buffer >> 8 & 255;
			result[j + 2] = buffer & 255;
		}
		return right(result);
	} catch (e) {
		return left(DecodeException$1(stripped, e instanceof Error ? e.message : "Invalid input"));
	}
};
/** @internal */
const stripCrlf = (str) => str.replace(/[\n\r]/g, "");
/** @internal */
function getBase64Code(charCode) {
	if (charCode >= base64codes.length) throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
	const code = base64codes[charCode];
	if (code === 255) throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
	return code;
}
/** @internal */
const base64abc = [
	"A",
	"B",
	"C",
	"D",
	"E",
	"F",
	"G",
	"H",
	"I",
	"J",
	"K",
	"L",
	"M",
	"N",
	"O",
	"P",
	"Q",
	"R",
	"S",
	"T",
	"U",
	"V",
	"W",
	"X",
	"Y",
	"Z",
	"a",
	"b",
	"c",
	"d",
	"e",
	"f",
	"g",
	"h",
	"i",
	"j",
	"k",
	"l",
	"m",
	"n",
	"o",
	"p",
	"q",
	"r",
	"s",
	"t",
	"u",
	"v",
	"w",
	"x",
	"y",
	"z",
	"0",
	"1",
	"2",
	"3",
	"4",
	"5",
	"6",
	"7",
	"8",
	"9",
	"+",
	"/"
];
/** @internal */
const base64codes = [
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	255,
	62,
	255,
	255,
	255,
	63,
	52,
	53,
	54,
	55,
	56,
	57,
	58,
	59,
	60,
	61,
	255,
	255,
	255,
	0,
	255,
	255,
	255,
	0,
	1,
	2,
	3,
	4,
	5,
	6,
	7,
	8,
	9,
	10,
	11,
	12,
	13,
	14,
	15,
	16,
	17,
	18,
	19,
	20,
	21,
	22,
	23,
	24,
	25,
	255,
	255,
	255,
	255,
	255,
	255,
	26,
	27,
	28,
	29,
	30,
	31,
	32,
	33,
	34,
	35,
	36,
	37,
	38,
	39,
	40,
	41,
	42,
	43,
	44,
	45,
	46,
	47,
	48,
	49,
	50,
	51
];

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/encoding/base64Url.js
/** @internal */
const encode$1 = (data) => encode$2(data).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
/** @internal */
const decode$1 = (str) => {
	const stripped = stripCrlf(str);
	const length$1 = stripped.length;
	if (length$1 % 4 === 1) return left(DecodeException$1(stripped, `Length should be a multiple of 4, but is ${length$1}`));
	if (!/^[-_A-Z0-9]*?={0,2}$/i.test(stripped)) return left(DecodeException$1(stripped, "Invalid input"));
	let sanitized = length$1 % 4 === 2 ? `${stripped}==` : length$1 % 4 === 3 ? `${stripped}=` : stripped;
	sanitized = sanitized.replace(/-/g, "+").replace(/_/g, "/");
	return decode$2(sanitized);
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/internal/encoding/hex.js
/** @internal */
const encode = (bytes) => {
	let result = "";
	for (let i$1 = 0; i$1 < bytes.length; ++i$1) result += bytesToHex[bytes[i$1]];
	return result;
};
/** @internal */
const decode = (str) => {
	const bytes = new TextEncoder().encode(str);
	if (bytes.length % 2 !== 0) return left(DecodeException$1(str, `Length must be a multiple of 2, but is ${bytes.length}`));
	try {
		const length$1 = bytes.length / 2;
		const result = new Uint8Array(length$1);
		for (let i$1 = 0; i$1 < length$1; i$1++) {
			const a$1 = fromHexChar(bytes[i$1 * 2]);
			const b$1 = fromHexChar(bytes[i$1 * 2 + 1]);
			result[i$1] = a$1 << 4 | b$1;
		}
		return right(result);
	} catch (e) {
		return left(DecodeException$1(str, e instanceof Error ? e.message : "Invalid input"));
	}
};
/** @internal */
const bytesToHex = [
	"00",
	"01",
	"02",
	"03",
	"04",
	"05",
	"06",
	"07",
	"08",
	"09",
	"0a",
	"0b",
	"0c",
	"0d",
	"0e",
	"0f",
	"10",
	"11",
	"12",
	"13",
	"14",
	"15",
	"16",
	"17",
	"18",
	"19",
	"1a",
	"1b",
	"1c",
	"1d",
	"1e",
	"1f",
	"20",
	"21",
	"22",
	"23",
	"24",
	"25",
	"26",
	"27",
	"28",
	"29",
	"2a",
	"2b",
	"2c",
	"2d",
	"2e",
	"2f",
	"30",
	"31",
	"32",
	"33",
	"34",
	"35",
	"36",
	"37",
	"38",
	"39",
	"3a",
	"3b",
	"3c",
	"3d",
	"3e",
	"3f",
	"40",
	"41",
	"42",
	"43",
	"44",
	"45",
	"46",
	"47",
	"48",
	"49",
	"4a",
	"4b",
	"4c",
	"4d",
	"4e",
	"4f",
	"50",
	"51",
	"52",
	"53",
	"54",
	"55",
	"56",
	"57",
	"58",
	"59",
	"5a",
	"5b",
	"5c",
	"5d",
	"5e",
	"5f",
	"60",
	"61",
	"62",
	"63",
	"64",
	"65",
	"66",
	"67",
	"68",
	"69",
	"6a",
	"6b",
	"6c",
	"6d",
	"6e",
	"6f",
	"70",
	"71",
	"72",
	"73",
	"74",
	"75",
	"76",
	"77",
	"78",
	"79",
	"7a",
	"7b",
	"7c",
	"7d",
	"7e",
	"7f",
	"80",
	"81",
	"82",
	"83",
	"84",
	"85",
	"86",
	"87",
	"88",
	"89",
	"8a",
	"8b",
	"8c",
	"8d",
	"8e",
	"8f",
	"90",
	"91",
	"92",
	"93",
	"94",
	"95",
	"96",
	"97",
	"98",
	"99",
	"9a",
	"9b",
	"9c",
	"9d",
	"9e",
	"9f",
	"a0",
	"a1",
	"a2",
	"a3",
	"a4",
	"a5",
	"a6",
	"a7",
	"a8",
	"a9",
	"aa",
	"ab",
	"ac",
	"ad",
	"ae",
	"af",
	"b0",
	"b1",
	"b2",
	"b3",
	"b4",
	"b5",
	"b6",
	"b7",
	"b8",
	"b9",
	"ba",
	"bb",
	"bc",
	"bd",
	"be",
	"bf",
	"c0",
	"c1",
	"c2",
	"c3",
	"c4",
	"c5",
	"c6",
	"c7",
	"c8",
	"c9",
	"ca",
	"cb",
	"cc",
	"cd",
	"ce",
	"cf",
	"d0",
	"d1",
	"d2",
	"d3",
	"d4",
	"d5",
	"d6",
	"d7",
	"d8",
	"d9",
	"da",
	"db",
	"dc",
	"dd",
	"de",
	"df",
	"e0",
	"e1",
	"e2",
	"e3",
	"e4",
	"e5",
	"e6",
	"e7",
	"e8",
	"e9",
	"ea",
	"eb",
	"ec",
	"ed",
	"ee",
	"ef",
	"f0",
	"f1",
	"f2",
	"f3",
	"f4",
	"f5",
	"f6",
	"f7",
	"f8",
	"f9",
	"fa",
	"fb",
	"fc",
	"fd",
	"fe",
	"ff"
];
/** @internal */
const fromHexChar = (byte) => {
	if (48 <= byte && byte <= 57) return byte - 48;
	if (97 <= byte && byte <= 102) return byte - 97 + 10;
	if (65 <= byte && byte <= 70) return byte - 65 + 10;
	throw new TypeError("Invalid input");
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Encoding.js
/**
* Encodes the given value into a base64 (RFC4648) `string`.
*
* @category encoding
* @since 2.0.0
*/
const encodeBase64 = (input) => typeof input === "string" ? encode$2(encoder.encode(input)) : encode$2(input);
/**
* Decodes a base64 (RFC4648) encoded `string` into a `Uint8Array`.
*
* @category decoding
* @since 2.0.0
*/
const decodeBase64 = (str) => decode$2(str);
/**
* Decodes a base64 (RFC4648) encoded `string` into a UTF-8 `string`.
*
* @category decoding
* @since 2.0.0
*/
const decodeBase64String = (str) => map$17(decodeBase64(str), (_$1) => decoder.decode(_$1));
/**
* Encodes the given value into a base64 (URL) `string`.
*
* @category encoding
* @since 2.0.0
*/
const encodeBase64Url = (input) => typeof input === "string" ? encode$1(encoder.encode(input)) : encode$1(input);
/**
* Decodes a base64 (URL) encoded `string` into a `Uint8Array`.
*
* @category decoding
* @since 2.0.0
*/
const decodeBase64Url = (str) => decode$1(str);
/**
* Decodes a base64 (URL) encoded `string` into a UTF-8 `string`.
*
* @category decoding
* @since 2.0.0
*/
const decodeBase64UrlString = (str) => map$17(decodeBase64Url(str), (_$1) => decoder.decode(_$1));
/**
* Encodes the given value into a hex `string`.
*
* @category encoding
* @since 2.0.0
*/
const encodeHex = (input) => typeof input === "string" ? encode(encoder.encode(input)) : encode(input);
/**
* Decodes a hex encoded `string` into a `Uint8Array`.
*
* @category decoding
* @since 2.0.0
*/
const decodeHex = (str) => decode(str);
/**
* Decodes a hex encoded `string` into a UTF-8 `string`.
*
* @category decoding
* @since 2.0.0
*/
const decodeHexString = (str) => map$17(decodeHex(str), (_$1) => decoder.decode(_$1));
/**
* @since 2.0.0
* @category symbols
*/
const DecodeExceptionTypeId = DecodeExceptionTypeId$1;
/**
* Creates a checked exception which occurs when decoding fails.
*
* @since 2.0.0
* @category errors
*/
const DecodeException = DecodeException$1;
/**
* Returns `true` if the specified value is an `DecodeException`, `false` otherwise.
*
* @since 2.0.0
* @category refinements
*/
const isDecodeException = isDecodeException$1;
/**
* @since 3.12.0
* @category symbols
*/
const EncodeExceptionTypeId = EncodeExceptionTypeId$1;
/**
* Creates a checked exception which occurs when encoding fails.
*
* @since 3.12.0
* @category errors
*/
const EncodeException = EncodeException$1;
/**
* Returns `true` if the specified value is an `EncodeException`, `false` otherwise.
*
* @since 3.12.0
* @category refinements
*/
const isEncodeException = isEncodeException$1;

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/ParseResult.js
/**
* @category model
* @since 3.10.0
*/
var Pointer = class {
	path;
	actual;
	issue;
	/**
	* @since 3.10.0
	*/
	_tag = "Pointer";
	constructor(path, actual, issue) {
		this.path = path;
		this.actual = actual;
		this.issue = issue;
	}
};
/**
* Error that occurs when an unexpected key or index is present.
*
* @category model
* @since 3.10.0
*/
var Unexpected = class {
	actual;
	message;
	/**
	* @since 3.10.0
	*/
	_tag = "Unexpected";
	constructor(actual, message) {
		this.actual = actual;
		this.message = message;
	}
};
/**
* Error that occurs when a required key or index is missing.
*
* @category model
* @since 3.10.0
*/
var Missing = class {
	ast;
	message;
	/**
	* @since 3.10.0
	*/
	_tag = "Missing";
	/**
	* @since 3.10.0
	*/
	actual = void 0;
	constructor(ast, message) {
		this.ast = ast;
		this.message = message;
	}
};
/**
* Error that contains multiple issues.
*
* @category model
* @since 3.10.0
*/
var Composite = class {
	ast;
	actual;
	issues;
	output;
	/**
	* @since 3.10.0
	*/
	_tag = "Composite";
	constructor(ast, actual, issues, output) {
		this.ast = ast;
		this.actual = actual;
		this.issues = issues;
		this.output = output;
	}
};
/**
* Error that occurs when a refinement has an error.
*
* @category model
* @since 3.10.0
*/
var Refinement = class {
	ast;
	actual;
	kind;
	issue;
	/**
	* @since 3.10.0
	*/
	_tag = "Refinement";
	constructor(ast, actual, kind, issue) {
		this.ast = ast;
		this.actual = actual;
		this.kind = kind;
		this.issue = issue;
	}
};
/**
* Error that occurs when a transformation has an error.
*
* @category model
* @since 3.10.0
*/
var Transformation = class {
	ast;
	actual;
	kind;
	issue;
	/**
	* @since 3.10.0
	*/
	_tag = "Transformation";
	constructor(ast, actual, kind, issue) {
		this.ast = ast;
		this.actual = actual;
		this.kind = kind;
		this.issue = issue;
	}
};
/**
* The `Type` variant of the `ParseIssue` type represents an error that occurs when the `actual` value is not of the expected type.
* The `ast` field specifies the expected type, and the `actual` field contains the value that caused the error.
*
* @category model
* @since 3.10.0
*/
var Type = class {
	ast;
	actual;
	message;
	/**
	* @since 3.10.0
	*/
	_tag = "Type";
	constructor(ast, actual, message) {
		this.ast = ast;
		this.actual = actual;
		this.message = message;
	}
};
/**
* The `Forbidden` variant of the `ParseIssue` type represents a forbidden operation, such as when encountering an Effect that is not allowed to execute (e.g., using `runSync`).
*
* @category model
* @since 3.10.0
*/
var Forbidden = class {
	ast;
	actual;
	message;
	/**
	* @since 3.10.0
	*/
	_tag = "Forbidden";
	constructor(ast, actual, message) {
		this.ast = ast;
		this.actual = actual;
		this.message = message;
	}
};
/**
* @category type id
* @since 3.10.0
*/
const ParseErrorTypeId = /* @__PURE__ */ Symbol.for("effect/Schema/ParseErrorTypeId");
/**
* @since 3.10.0
*/
var ParseError = class extends TaggedError("ParseError") {
	/**
	* @since 3.10.0
	*/
	[ParseErrorTypeId] = ParseErrorTypeId;
	get message() {
		return this.toString();
	}
	/**
	* @since 3.10.0
	*/
	toString() {
		return TreeFormatter.formatIssueSync(this.issue);
	}
	/**
	* @since 3.10.0
	*/
	toJSON() {
		return {
			_id: "ParseError",
			message: this.toString()
		};
	}
	/**
	* @since 3.10.0
	*/
	[NodeInspectSymbol]() {
		return this.toJSON();
	}
};
/**
* @category constructors
* @since 3.10.0
*/
const parseError = (issue) => new ParseError({ issue });
/**
* @category constructors
* @since 3.10.0
*/
const succeed = right;
/**
* @category constructors
* @since 3.10.0
*/
const fail = left;
const _try = try_$2;
/**
* @category constructors
* @since 3.10.0
*/
const fromOption = fromOption$3;
const isEither = isEither$1;
/**
* @category optimisation
* @since 3.10.0
*/
const flatMap = /* @__PURE__ */ dual$1(2, (self, f$1) => {
	return isEither(self) ? match$12(self, {
		onLeft: left,
		onRight: f$1
	}) : flatMap$1(self, f$1);
});
/**
* @category optimisation
* @since 3.10.0
*/
const map = /* @__PURE__ */ dual$1(2, (self, f$1) => {
	return isEither(self) ? map$17(self, f$1) : map$1(self, f$1);
});
/**
* @category optimisation
* @since 3.10.0
*/
const mapError = /* @__PURE__ */ dual$1(2, (self, f$1) => {
	return isEither(self) ? mapLeft(self, f$1) : mapError$1(self, f$1);
});
/**
* @category optimisation
* @since 3.10.0
*/
const orElse = /* @__PURE__ */ dual$1(2, (self, f$1) => {
	return isEither(self) ? match$12(self, {
		onLeft: f$1,
		onRight: right
	}) : catchAll(self, f$1);
});
/** @internal */
const mergeInternalOptions = (options, overrideOptions) => {
	if (overrideOptions === void 0 || isNumber(overrideOptions)) return options;
	if (options === void 0) return overrideOptions;
	return {
		...options,
		...overrideOptions
	};
};
const getEffect = (ast, isDecoding, options) => {
	const parser = goMemo(ast, isDecoding);
	return (input, overrideOptions) => parser(input, {
		...mergeInternalOptions(options, overrideOptions),
		isEffectAllowed: true
	});
};
/**
* @category decoding
* @since 3.10.0
*/
const decodeUnknown$1 = (schema, options) => getEffect(schema.ast, true, options);
const decodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/decodeMemoMap"), () => /* @__PURE__ */ new WeakMap());
const encodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/encodeMemoMap"), () => /* @__PURE__ */ new WeakMap());
const goMemo = (ast, isDecoding) => {
	const memoMap = isDecoding ? decodeMemoMap : encodeMemoMap;
	const memo = memoMap.get(ast);
	if (memo) return memo;
	const raw = go(ast, isDecoding);
	const parseOptionsAnnotation = getParseOptionsAnnotation(ast);
	const parserWithOptions = isSome(parseOptionsAnnotation) ? (i$1, options) => raw(i$1, mergeInternalOptions(options, parseOptionsAnnotation.value)) : raw;
	const decodingFallbackAnnotation = getDecodingFallbackAnnotation(ast);
	const parser = isDecoding && isSome(decodingFallbackAnnotation) ? (i$1, options) => handleForbidden(orElse(parserWithOptions(i$1, options), decodingFallbackAnnotation.value), ast, i$1, options) : parserWithOptions;
	memoMap.set(ast, parser);
	return parser;
};
const getConcurrency = (ast) => getOrUndefined(getConcurrencyAnnotation(ast));
const getBatching = (ast) => getOrUndefined(getBatchingAnnotation(ast));
const go = (ast, isDecoding) => {
	switch (ast._tag) {
		case "Refinement": if (isDecoding) {
			const from = goMemo(ast.from, true);
			return (i$1, options) => {
				options = options ?? defaultParseOption;
				const allErrors = options?.errors === "all";
				return handleForbidden(flatMap(orElse(from(i$1, options), (ef) => {
					const issue = new Refinement(ast, i$1, "From", ef);
					if (allErrors && hasStableFilter(ast) && isComposite(ef)) return match$11(ast.filter(i$1, options, ast), {
						onNone: () => left(issue),
						onSome: (ep) => left(new Composite(ast, i$1, [issue, new Refinement(ast, i$1, "Predicate", ep)]))
					});
					return left(issue);
				}), (a$1) => match$11(ast.filter(a$1, options, ast), {
					onNone: () => right(a$1),
					onSome: (ep) => left(new Refinement(ast, i$1, "Predicate", ep))
				})), ast, i$1, options);
			};
		} else {
			const from = goMemo(typeAST(ast), true);
			const to = goMemo(dropRightRefinement(ast.from), false);
			return (i$1, options) => handleForbidden(flatMap(from(i$1, options), (a$1) => to(a$1, options)), ast, i$1, options);
		}
		case "Transformation": {
			const transform$2 = getFinalTransformation(ast.transformation, isDecoding);
			const from = isDecoding ? goMemo(ast.from, true) : goMemo(ast.to, false);
			const to = isDecoding ? goMemo(ast.to, true) : goMemo(ast.from, false);
			return (i$1, options) => handleForbidden(flatMap(mapError(from(i$1, options), (e) => new Transformation(ast, i$1, isDecoding ? "Encoded" : "Type", e)), (a$1) => flatMap(mapError(transform$2(a$1, options ?? defaultParseOption, ast, i$1), (e) => new Transformation(ast, i$1, "Transformation", e)), (i2) => mapError(to(i2, options), (e) => new Transformation(ast, i$1, isDecoding ? "Type" : "Encoded", e)))), ast, i$1, options);
		}
		case "Declaration": {
			const parse = isDecoding ? ast.decodeUnknown(...ast.typeParameters) : ast.encodeUnknown(...ast.typeParameters);
			return (i$1, options) => handleForbidden(parse(i$1, options ?? defaultParseOption, ast), ast, i$1, options);
		}
		case "Literal": return fromRefinement(ast, (u$1) => u$1 === ast.literal);
		case "UniqueSymbol": return fromRefinement(ast, (u$1) => u$1 === ast.symbol);
		case "UndefinedKeyword": return fromRefinement(ast, isUndefined);
		case "NeverKeyword": return fromRefinement(ast, isNever);
		case "UnknownKeyword":
		case "AnyKeyword":
		case "VoidKeyword": return right;
		case "StringKeyword": return fromRefinement(ast, isString);
		case "NumberKeyword": return fromRefinement(ast, isNumber);
		case "BooleanKeyword": return fromRefinement(ast, isBoolean$1);
		case "BigIntKeyword": return fromRefinement(ast, isBigInt);
		case "SymbolKeyword": return fromRefinement(ast, isSymbol);
		case "ObjectKeyword": return fromRefinement(ast, isObject);
		case "Enums": return fromRefinement(ast, (u$1) => ast.enums.some(([_$1, value]) => value === u$1));
		case "TemplateLiteral": {
			const regex$1 = getTemplateLiteralRegExp(ast);
			return fromRefinement(ast, (u$1) => isString(u$1) && regex$1.test(u$1));
		}
		case "TupleType": {
			const elements = ast.elements.map((e) => goMemo(e.type, isDecoding));
			const rest = ast.rest.map((annotatedAST) => goMemo(annotatedAST.type, isDecoding));
			let requiredTypes = ast.elements.filter((e) => !e.isOptional);
			if (ast.rest.length > 0) requiredTypes = requiredTypes.concat(ast.rest.slice(1));
			const requiredLen = requiredTypes.length;
			const expectedIndexes = ast.elements.length > 0 ? ast.elements.map((_$1, i$1) => i$1).join(" | ") : "never";
			const concurrency = getConcurrency(ast);
			const batching = getBatching(ast);
			return (input, options) => {
				if (!isArray(input)) return left(new Type(ast, input));
				const allErrors = options?.errors === "all";
				const es = [];
				let stepKey = 0;
				const output = [];
				const len = input.length;
				for (let i$2 = len; i$2 <= requiredLen - 1; i$2++) {
					const e = new Pointer(i$2, input, new Missing(requiredTypes[i$2 - len]));
					if (allErrors) {
						es.push([stepKey++, e]);
						continue;
					} else return left(new Composite(ast, input, e, output));
				}
				if (ast.rest.length === 0) for (let i$2 = ast.elements.length; i$2 <= len - 1; i$2++) {
					const e = new Pointer(i$2, input, new Unexpected(input[i$2], `is unexpected, expected: ${expectedIndexes}`));
					if (allErrors) {
						es.push([stepKey++, e]);
						continue;
					} else return left(new Composite(ast, input, e, output));
				}
				let i$1 = 0;
				let queue$1 = void 0;
				for (; i$1 < elements.length; i$1++) if (len < i$1 + 1) {
					if (ast.elements[i$1].isOptional) continue;
				} else {
					const parser = elements[i$1];
					const te = parser(input[i$1], options);
					if (isEither(te)) {
						if (isLeft(te)) {
							const e = new Pointer(i$1, input, te.left);
							if (allErrors) {
								es.push([stepKey++, e]);
								continue;
							} else return left(new Composite(ast, input, e, sortByIndex(output)));
						}
						output.push([stepKey++, te.right]);
					} else {
						const nk = stepKey++;
						const index = i$1;
						if (!queue$1) queue$1 = [];
						queue$1.push(({ es: es$1, output: output$1 }) => flatMap$1(either(te), (t$1) => {
							if (isLeft(t$1)) {
								const e = new Pointer(index, input, t$1.left);
								if (allErrors) {
									es$1.push([nk, e]);
									return _void;
								} else return left(new Composite(ast, input, e, sortByIndex(output$1)));
							}
							output$1.push([nk, t$1.right]);
							return _void;
						}));
					}
				}
				if (isNonEmptyReadonlyArray(rest)) {
					const [head$4, ...tail] = rest;
					for (; i$1 < len - tail.length; i$1++) {
						const te = head$4(input[i$1], options);
						if (isEither(te)) if (isLeft(te)) {
							const e = new Pointer(i$1, input, te.left);
							if (allErrors) {
								es.push([stepKey++, e]);
								continue;
							} else return left(new Composite(ast, input, e, sortByIndex(output)));
						} else output.push([stepKey++, te.right]);
						else {
							const nk = stepKey++;
							const index = i$1;
							if (!queue$1) queue$1 = [];
							queue$1.push(({ es: es$1, output: output$1 }) => flatMap$1(either(te), (t$1) => {
								if (isLeft(t$1)) {
									const e = new Pointer(index, input, t$1.left);
									if (allErrors) {
										es$1.push([nk, e]);
										return _void;
									} else return left(new Composite(ast, input, e, sortByIndex(output$1)));
								} else {
									output$1.push([nk, t$1.right]);
									return _void;
								}
							}));
						}
					}
					for (let j = 0; j < tail.length; j++) {
						i$1 += j;
						if (len < i$1 + 1) continue;
						else {
							const te = tail[j](input[i$1], options);
							if (isEither(te)) {
								if (isLeft(te)) {
									const e = new Pointer(i$1, input, te.left);
									if (allErrors) {
										es.push([stepKey++, e]);
										continue;
									} else return left(new Composite(ast, input, e, sortByIndex(output)));
								}
								output.push([stepKey++, te.right]);
							} else {
								const nk = stepKey++;
								const index = i$1;
								if (!queue$1) queue$1 = [];
								queue$1.push(({ es: es$1, output: output$1 }) => flatMap$1(either(te), (t$1) => {
									if (isLeft(t$1)) {
										const e = new Pointer(index, input, t$1.left);
										if (allErrors) {
											es$1.push([nk, e]);
											return _void;
										} else return left(new Composite(ast, input, e, sortByIndex(output$1)));
									}
									output$1.push([nk, t$1.right]);
									return _void;
								}));
							}
						}
					}
				}
				const computeResult = ({ es: es$1, output: output$1 }) => isNonEmptyArray(es$1) ? left(new Composite(ast, input, sortByIndex(es$1), sortByIndex(output$1))) : right(sortByIndex(output$1));
				if (queue$1 && queue$1.length > 0) {
					const cqueue = queue$1;
					return suspend(() => {
						const state = {
							es: copy$2(es),
							output: copy$2(output)
						};
						return flatMap$1(forEach(cqueue, (f$1) => f$1(state), {
							concurrency,
							batching,
							discard: true
						}), () => computeResult(state));
					});
				}
				return computeResult({
					output,
					es
				});
			};
		}
		case "TypeLiteral": {
			if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) return fromRefinement(ast, isNotNullable);
			const propertySignatures = [];
			const expectedKeysMap = {};
			const expectedKeys = [];
			for (const ps of ast.propertySignatures) {
				propertySignatures.push([goMemo(ps.type, isDecoding), ps]);
				expectedKeysMap[ps.name] = null;
				expectedKeys.push(ps.name);
			}
			const indexSignatures = ast.indexSignatures.map((is) => [
				goMemo(is.parameter, isDecoding),
				goMemo(is.type, isDecoding),
				is.parameter
			]);
			const expectedAST = Union.make(ast.indexSignatures.map((is) => is.parameter).concat(expectedKeys.map((key) => isSymbol(key) ? new UniqueSymbol(key) : new Literal$1(key))));
			const expected = goMemo(expectedAST, isDecoding);
			const concurrency = getConcurrency(ast);
			const batching = getBatching(ast);
			return (input, options) => {
				if (!isRecord(input)) return left(new Type(ast, input));
				const allErrors = options?.errors === "all";
				const es = [];
				let stepKey = 0;
				const onExcessPropertyError = options?.onExcessProperty === "error";
				const onExcessPropertyPreserve = options?.onExcessProperty === "preserve";
				const output = {};
				let inputKeys;
				if (onExcessPropertyError || onExcessPropertyPreserve) {
					inputKeys = Reflect.ownKeys(input);
					for (const key of inputKeys) {
						const te = expected(key, options);
						if (isEither(te) && isLeft(te)) if (onExcessPropertyError) {
							const e = new Pointer(key, input, new Unexpected(input[key], `is unexpected, expected: ${String(expectedAST)}`));
							if (allErrors) {
								es.push([stepKey++, e]);
								continue;
							} else return left(new Composite(ast, input, e, output));
						} else output[key] = input[key];
					}
				}
				let queue$1 = void 0;
				const isExact = options?.exact === true;
				for (let i$1 = 0; i$1 < propertySignatures.length; i$1++) {
					const ps = propertySignatures[i$1][1];
					const name = ps.name;
					const hasKey = Object.prototype.hasOwnProperty.call(input, name);
					if (!hasKey) {
						if (ps.isOptional) continue;
						else if (isExact) {
							const e = new Pointer(name, input, new Missing(ps));
							if (allErrors) {
								es.push([stepKey++, e]);
								continue;
							} else return left(new Composite(ast, input, e, output));
						}
					}
					const parser = propertySignatures[i$1][0];
					const te = parser(input[name], options);
					if (isEither(te)) {
						if (isLeft(te)) {
							const e = new Pointer(name, input, hasKey ? te.left : new Missing(ps));
							if (allErrors) {
								es.push([stepKey++, e]);
								continue;
							} else return left(new Composite(ast, input, e, output));
						}
						output[name] = te.right;
					} else {
						const nk = stepKey++;
						const index = name;
						if (!queue$1) queue$1 = [];
						queue$1.push(({ es: es$1, output: output$1 }) => flatMap$1(either(te), (t$1) => {
							if (isLeft(t$1)) {
								const e = new Pointer(index, input, hasKey ? t$1.left : new Missing(ps));
								if (allErrors) {
									es$1.push([nk, e]);
									return _void;
								} else return left(new Composite(ast, input, e, output$1));
							}
							output$1[index] = t$1.right;
							return _void;
						}));
					}
				}
				for (let i$1 = 0; i$1 < indexSignatures.length; i$1++) {
					const indexSignature = indexSignatures[i$1];
					const parameter = indexSignature[0];
					const type = indexSignature[1];
					const keys$5 = getKeysForIndexSignature(input, indexSignature[2]);
					for (const key of keys$5) {
						const keu = parameter(key, options);
						if (isEither(keu) && isRight(keu)) {
							const vpr = type(input[key], options);
							if (isEither(vpr)) {
								if (isLeft(vpr)) {
									const e = new Pointer(key, input, vpr.left);
									if (allErrors) {
										es.push([stepKey++, e]);
										continue;
									} else return left(new Composite(ast, input, e, output));
								} else if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) output[key] = vpr.right;
							} else {
								const nk = stepKey++;
								const index = key;
								if (!queue$1) queue$1 = [];
								queue$1.push(({ es: es$1, output: output$1 }) => flatMap$1(either(vpr), (tv) => {
									if (isLeft(tv)) {
										const e = new Pointer(index, input, tv.left);
										if (allErrors) {
											es$1.push([nk, e]);
											return _void;
										} else return left(new Composite(ast, input, e, output$1));
									} else {
										if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) output$1[key] = tv.right;
										return _void;
									}
								}));
							}
						}
					}
				}
				const computeResult = ({ es: es$1, output: output$1 }) => {
					if (isNonEmptyArray(es$1)) return left(new Composite(ast, input, sortByIndex(es$1), output$1));
					if (options?.propertyOrder === "original") {
						const keys$5 = inputKeys || Reflect.ownKeys(input);
						for (const name of expectedKeys) if (keys$5.indexOf(name) === -1) keys$5.push(name);
						const out = {};
						for (const key of keys$5) if (Object.prototype.hasOwnProperty.call(output$1, key)) out[key] = output$1[key];
						return right(out);
					}
					return right(output$1);
				};
				if (queue$1 && queue$1.length > 0) {
					const cqueue = queue$1;
					return suspend(() => {
						const state = {
							es: copy$2(es),
							output: Object.assign({}, output)
						};
						return flatMap$1(forEach(cqueue, (f$1) => f$1(state), {
							concurrency,
							batching,
							discard: true
						}), () => computeResult(state));
					});
				}
				return computeResult({
					es,
					output
				});
			};
		}
		case "Union": {
			const searchTree = getSearchTree(ast.types, isDecoding);
			const ownKeys$1 = Reflect.ownKeys(searchTree.keys);
			const ownKeysLen = ownKeys$1.length;
			const astTypesLen = ast.types.length;
			const map$18 = /* @__PURE__ */ new Map();
			for (let i$1 = 0; i$1 < astTypesLen; i$1++) map$18.set(ast.types[i$1], goMemo(ast.types[i$1], isDecoding));
			const concurrency = getConcurrency(ast) ?? 1;
			const batching = getBatching(ast);
			return (input, options) => {
				const es = [];
				let stepKey = 0;
				let candidates = [];
				if (ownKeysLen > 0) if (isRecordOrArray(input)) for (let i$1 = 0; i$1 < ownKeysLen; i$1++) {
					const name = ownKeys$1[i$1];
					const buckets = searchTree.keys[name].buckets;
					if (Object.prototype.hasOwnProperty.call(input, name)) {
						const literal = String(input[name]);
						if (Object.prototype.hasOwnProperty.call(buckets, literal)) candidates = candidates.concat(buckets[literal]);
						else {
							const { candidates: candidates$1, literals } = searchTree.keys[name];
							const literalsUnion = Union.make(literals);
							const errorAst = candidates$1.length === astTypesLen ? new TypeLiteral([new PropertySignature(name, literalsUnion, false, true)], []) : Union.make(candidates$1);
							es.push([stepKey++, new Composite(errorAst, input, new Pointer(name, input, new Type(literalsUnion, input[name])))]);
						}
					} else {
						const { candidates: candidates$1, literals } = searchTree.keys[name];
						const fakePropertySignature = new PropertySignature(name, Union.make(literals), false, true);
						const errorAst = candidates$1.length === astTypesLen ? new TypeLiteral([fakePropertySignature], []) : Union.make(candidates$1);
						es.push([stepKey++, new Composite(errorAst, input, new Pointer(name, input, new Missing(fakePropertySignature)))]);
					}
				}
				else {
					const errorAst = searchTree.candidates.length === astTypesLen ? ast : Union.make(searchTree.candidates);
					es.push([stepKey++, new Type(errorAst, input)]);
				}
				if (searchTree.otherwise.length > 0) candidates = candidates.concat(searchTree.otherwise);
				let queue$1 = void 0;
				for (let i$1 = 0; i$1 < candidates.length; i$1++) {
					const candidate = candidates[i$1];
					const pr = map$18.get(candidate)(input, options);
					if (isEither(pr) && (!queue$1 || queue$1.length === 0)) if (isRight(pr)) return pr;
					else es.push([stepKey++, pr.left]);
					else {
						const nk = stepKey++;
						if (!queue$1) queue$1 = [];
						queue$1.push((state) => suspend(() => {
							if ("finalResult" in state) return _void;
							else return flatMap$1(either(pr), (t$1) => {
								if (isRight(t$1)) state.finalResult = t$1;
								else state.es.push([nk, t$1.left]);
								return _void;
							});
						}));
					}
				}
				const computeResult = (es$1) => isNonEmptyArray(es$1) ? es$1.length === 1 && es$1[0][1]._tag === "Type" ? left(es$1[0][1]) : left(new Composite(ast, input, sortByIndex(es$1))) : left(new Type(ast, input));
				if (queue$1 && queue$1.length > 0) {
					const cqueue = queue$1;
					return suspend(() => {
						const state = { es: copy$2(es) };
						return flatMap$1(forEach(cqueue, (f$1) => f$1(state), {
							concurrency,
							batching,
							discard: true
						}), () => {
							if ("finalResult" in state) return state.finalResult;
							return computeResult(state.es);
						});
					});
				}
				return computeResult(es);
			};
		}
		case "Suspend": {
			const get$12 = memoizeThunk(() => goMemo(ast.f(), isDecoding));
			return (a$1, options) => get$12()(a$1, options);
		}
	}
};
const fromRefinement = (ast, refinement) => (u$1) => refinement(u$1) ? right(u$1) : left(new Type(ast, u$1));
/** @internal */
const getLiterals = (ast, isDecoding) => {
	switch (ast._tag) {
		case "Declaration": {
			const annotation = getSurrogateAnnotation(ast);
			if (isSome(annotation)) return getLiterals(annotation.value, isDecoding);
			break;
		}
		case "TypeLiteral": {
			const out = [];
			for (let i$1 = 0; i$1 < ast.propertySignatures.length; i$1++) {
				const propertySignature = ast.propertySignatures[i$1];
				const type = isDecoding ? encodedAST(propertySignature.type) : typeAST(propertySignature.type);
				if (isLiteral(type) && !propertySignature.isOptional) out.push([propertySignature.name, type]);
			}
			return out;
		}
		case "TupleType": {
			const out = [];
			for (let i$1 = 0; i$1 < ast.elements.length; i$1++) {
				const element = ast.elements[i$1];
				const type = isDecoding ? encodedAST(element.type) : typeAST(element.type);
				if (isLiteral(type) && !element.isOptional) out.push([i$1, type]);
			}
			return out;
		}
		case "Refinement": return getLiterals(ast.from, isDecoding);
		case "Suspend": return getLiterals(ast.f(), isDecoding);
		case "Transformation": return getLiterals(isDecoding ? ast.from : ast.to, isDecoding);
	}
	return [];
};
/**
* The purpose of the algorithm is to narrow down the pool of possible
* candidates for decoding as much as possible.
*
* This function separates the schemas into two groups, `keys` and `otherwise`:
*
* - `keys`: the schema has at least one property with a literal value
* - `otherwise`: the schema has no properties with a literal value
*
* If a schema has at least one property with a literal value, so it ends up in
* `keys`, first a namespace is created for the name of the property containing
* the literal, and then within this namespace a "bucket" is created for the
* literal value in which to store all the schemas that have the same property
* and literal value.
*
* @internal
*/
const getSearchTree = (members, isDecoding) => {
	const keys$5 = {};
	const otherwise = [];
	const candidates = [];
	for (let i$1 = 0; i$1 < members.length; i$1++) {
		const member = members[i$1];
		const tags = getLiterals(member, isDecoding);
		if (tags.length > 0) {
			candidates.push(member);
			for (let j = 0; j < tags.length; j++) {
				const [key, literal] = tags[j];
				const hash$1 = String(literal.literal);
				keys$5[key] = keys$5[key] || {
					buckets: {},
					literals: [],
					candidates: []
				};
				const buckets = keys$5[key].buckets;
				if (Object.prototype.hasOwnProperty.call(buckets, hash$1)) {
					if (j < tags.length - 1) continue;
					buckets[hash$1].push(member);
					keys$5[key].literals.push(literal);
					keys$5[key].candidates.push(member);
				} else {
					buckets[hash$1] = [member];
					keys$5[key].literals.push(literal);
					keys$5[key].candidates.push(member);
					break;
				}
			}
		} else otherwise.push(member);
	}
	return {
		keys: keys$5,
		otherwise,
		candidates
	};
};
const dropRightRefinement = (ast) => isRefinement$1(ast) ? dropRightRefinement(ast.from) : ast;
const handleForbidden = (effect, ast, actual, options) => {
	if (options?.isEffectAllowed === true) return effect;
	if (isEither(effect)) return effect;
	const scheduler = new SyncScheduler();
	const fiber = runFork(effect, { scheduler });
	scheduler.flush();
	const exit$3 = fiber.unsafePoll();
	if (exit$3) {
		if (isSuccess$2(exit$3)) return right(exit$3.value);
		const cause$2 = exit$3.cause;
		if (isFailType(cause$2)) return left(cause$2.error);
		return left(new Forbidden(ast, actual, pretty$1(cause$2)));
	}
	return left(new Forbidden(ast, actual, "cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work"));
};
const compare = ([a$1], [b$1]) => a$1 > b$1 ? 1 : a$1 < b$1 ? -1 : 0;
function sortByIndex(es) {
	return es.sort(compare).map((t$1) => t$1[1]);
}
/** @internal */
const getFinalTransformation = (transformation, isDecoding) => {
	switch (transformation._tag) {
		case "FinalTransformation": return isDecoding ? transformation.decode : transformation.encode;
		case "ComposeTransformation": return right;
		case "TypeLiteralTransformation": return (input) => {
			let out = right(input);
			for (const pst of transformation.propertySignatureTransformations) {
				const [from, to] = isDecoding ? [pst.from, pst.to] : [pst.to, pst.from];
				const transformation$1 = isDecoding ? pst.decode : pst.encode;
				const f$1 = (input$1) => {
					const o$1 = transformation$1(Object.prototype.hasOwnProperty.call(input$1, from) ? some$4(input$1[from]) : none$7());
					delete input$1[from];
					if (isSome(o$1)) input$1[to] = o$1.value;
					return input$1;
				};
				out = map(out, f$1);
			}
			return out;
		};
	}
};
const makeTree = (value, forest = []) => ({
	value,
	forest
});
/**
* @category formatting
* @since 3.10.0
*/
const TreeFormatter = {
	formatIssue: (issue) => map(formatTree(issue), drawTree),
	formatIssueSync: (issue) => {
		const e = TreeFormatter.formatIssue(issue);
		return isEither(e) ? getOrThrow$1(e) : runSync(e);
	},
	formatError: (error) => TreeFormatter.formatIssue(error.issue),
	formatErrorSync: (error) => TreeFormatter.formatIssueSync(error.issue)
};
const drawTree = (tree) => tree.value + draw("\n", tree.forest);
const draw = (indentation, forest) => {
	let r$1 = "";
	const len = forest.length;
	let tree;
	for (let i$1 = 0; i$1 < len; i$1++) {
		tree = forest[i$1];
		const isLast = i$1 === len - 1;
		r$1 += indentation + (isLast ? "└" : "├") + "─ " + tree.value;
		r$1 += draw(indentation + (len > 1 && !isLast ? "│  " : "   "), tree.forest);
	}
	return r$1;
};
const formatTransformationKind = (kind) => {
	switch (kind) {
		case "Encoded": return "Encoded side transformation failure";
		case "Transformation": return "Transformation process failure";
		case "Type": return "Type side transformation failure";
	}
};
const formatRefinementKind = (kind) => {
	switch (kind) {
		case "From": return "From side refinement failure";
		case "Predicate": return "Predicate refinement failure";
	}
};
const getAnnotated = (issue) => "ast" in issue ? some$4(issue.ast) : none$7();
const Either_void = /* @__PURE__ */ right(void 0);
const getCurrentMessage = (issue) => getAnnotated(issue).pipe(flatMap$12(getMessageAnnotation), match$11({
	onNone: () => Either_void,
	onSome: (messageAnnotation) => {
		const union$9 = messageAnnotation(issue);
		if (isString(union$9)) return right({
			message: union$9,
			override: false
		});
		if (isEffect(union$9)) return map$1(union$9, (message) => ({
			message,
			override: false
		}));
		if (isString(union$9.message)) return right({
			message: union$9.message,
			override: union$9.override
		});
		return map$1(union$9.message, (message) => ({
			message,
			override: union$9.override
		}));
	}
}));
const createParseIssueGuard = (tag$1) => (issue) => issue._tag === tag$1;
/**
* Returns `true` if the value is a `Composite`.
*
* @category guards
* @since 3.10.0
*/
const isComposite = /* @__PURE__ */ createParseIssueGuard("Composite");
const isRefinement = /* @__PURE__ */ createParseIssueGuard("Refinement");
const isTransformation = /* @__PURE__ */ createParseIssueGuard("Transformation");
const getMessage = (issue) => flatMap(getCurrentMessage(issue), (currentMessage) => {
	if (currentMessage !== void 0) return !currentMessage.override && (isComposite(issue) || isRefinement(issue) && issue.kind === "From" || isTransformation(issue) && issue.kind !== "Transformation") ? isTransformation(issue) || isRefinement(issue) ? getMessage(issue.issue) : Either_void : right(currentMessage.message);
	return Either_void;
});
const getParseIssueTitleAnnotation = (issue) => getAnnotated(issue).pipe(flatMap$12(getParseIssueTitleAnnotation$1), flatMapNullable((annotation) => annotation(issue)), getOrUndefined);
/** @internal */
function getRefinementExpected(ast) {
	return getDescriptionAnnotation(ast).pipe(orElse$5(() => getTitleAnnotation(ast)), orElse$5(() => getAutoTitleAnnotation(ast)), orElse$5(() => getIdentifierAnnotation(ast)), getOrElse$5(() => `{ ${ast.from} | filter }`));
}
function getDefaultTypeMessage(issue) {
	if (issue.message !== void 0) return issue.message;
	return `Expected ${isRefinement$1(issue.ast) ? getRefinementExpected(issue.ast) : String(issue.ast)}, actual ${formatUnknown(issue.actual)}`;
}
const formatTypeMessage = (issue) => map(getMessage(issue), (message) => message ?? getParseIssueTitleAnnotation(issue) ?? getDefaultTypeMessage(issue));
const getParseIssueTitle = (issue) => getParseIssueTitleAnnotation(issue) ?? String(issue.ast);
const formatForbiddenMessage = (issue) => issue.message ?? "is forbidden";
const formatUnexpectedMessage = (issue) => issue.message ?? "is unexpected";
const formatMissingMessage = (issue) => {
	const missingMessageAnnotation = getMissingMessageAnnotation(issue.ast);
	if (isSome(missingMessageAnnotation)) {
		const annotation = missingMessageAnnotation.value();
		return isString(annotation) ? right(annotation) : annotation;
	}
	return right(issue.message ?? "is missing");
};
const formatTree = (issue) => {
	switch (issue._tag) {
		case "Type": return map(formatTypeMessage(issue), makeTree);
		case "Forbidden": return right(makeTree(getParseIssueTitle(issue), [makeTree(formatForbiddenMessage(issue))]));
		case "Unexpected": return right(makeTree(formatUnexpectedMessage(issue)));
		case "Missing": return map(formatMissingMessage(issue), makeTree);
		case "Transformation": return flatMap(getMessage(issue), (message) => {
			if (message !== void 0) return right(makeTree(message));
			return map(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatTransformationKind(issue.kind), [tree])]));
		});
		case "Refinement": return flatMap(getMessage(issue), (message) => {
			if (message !== void 0) return right(makeTree(message));
			return map(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatRefinementKind(issue.kind), [tree])]));
		});
		case "Pointer": return map(formatTree(issue.issue), (tree) => makeTree(formatPath(issue.path), [tree]));
		case "Composite": return flatMap(getMessage(issue), (message) => {
			if (message !== void 0) return right(makeTree(message));
			const parseIssueTitle = getParseIssueTitle(issue);
			return isNonEmpty$5(issue.issues) ? map(forEach(issue.issues, formatTree), (forest) => makeTree(parseIssueTitle, forest)) : map(formatTree(issue.issues), (tree) => makeTree(parseIssueTitle, [tree]));
		});
	}
};

//#endregion
//#region node_modules/.pnpm/effect@3.18.4/node_modules/effect/dist/esm/Schema.js
/**
* @since 3.10.0
* @category symbol
*/
const TypeId$2 = /* @__PURE__ */ Symbol.for("effect/Schema");
/**
* @category constructors
* @since 3.10.0
*/
function make$4(ast) {
	return class SchemaClass {
		[TypeId$2] = variance;
		static ast = ast;
		static annotations(annotations$1) {
			return make$4(mergeSchemaAnnotations(this.ast, annotations$1));
		}
		static pipe() {
			return pipeArguments(this, arguments);
		}
		static toString() {
			return String(ast);
		}
		static Type;
		static Encoded;
		static Context;
		static [TypeId$2] = variance;
	};
}
const variance = {
	_A: (_$1) => _$1,
	_I: (_$1) => _$1,
	_R: (_$1) => _$1
};
const builtInAnnotations = {
	schemaId: SchemaIdAnnotationId,
	message: MessageAnnotationId,
	missingMessage: MissingMessageAnnotationId,
	identifier: IdentifierAnnotationId,
	title: TitleAnnotationId,
	description: DescriptionAnnotationId,
	examples: ExamplesAnnotationId,
	default: DefaultAnnotationId,
	documentation: DocumentationAnnotationId,
	jsonSchema: JSONSchemaAnnotationId,
	arbitrary: ArbitraryAnnotationId,
	pretty: PrettyAnnotationId,
	equivalence: EquivalenceAnnotationId,
	concurrency: ConcurrencyAnnotationId,
	batching: BatchingAnnotationId,
	parseIssueTitle: ParseIssueTitleAnnotationId,
	parseOptions: ParseOptionsAnnotationId,
	decodingFallback: DecodingFallbackAnnotationId
};
const toASTAnnotations = (annotations$1) => {
	if (!annotations$1) return {};
	const out = { ...annotations$1 };
	for (const key in builtInAnnotations) if (key in annotations$1) {
		const id$2 = builtInAnnotations[key];
		out[id$2] = annotations$1[key];
		delete out[key];
	}
	return out;
};
const mergeSchemaAnnotations = (ast, annotations$1) => annotations(ast, toASTAnnotations(annotations$1));
/**
* @category decoding
* @since 3.10.0
*/
const decodeUnknown = (schema, options) => {
	const decodeUnknown$2 = decodeUnknown$1(schema, options);
	return (u$1, overrideOptions) => mapError(decodeUnknown$2(u$1, overrideOptions), parseError);
};
/**
* Tests if a value is a `Schema`.
*
* @category guards
* @since 3.10.0
*/
const isSchema = (u$1) => hasProperty(u$1, TypeId$2) && isObject(u$1[TypeId$2]);
function getDefaultLiteralAST(literals) {
	return isMembers(literals) ? Union.make(mapMembers(literals, (literal) => new Literal$1(literal))) : new Literal$1(literals[0]);
}
function makeLiteralClass(literals, ast = getDefaultLiteralAST(literals)) {
	return class LiteralClass extends make$4(ast) {
		static annotations(annotations$1) {
			return makeLiteralClass(this.literals, mergeSchemaAnnotations(this.ast, annotations$1));
		}
		static literals = [...literals];
	};
}
function Literal(...literals) {
	return isNonEmptyReadonlyArray(literals) ? makeLiteralClass(literals) : Never;
}
const declareConstructor = (typeParameters, options, annotations$1) => makeDeclareClass(typeParameters, new Declaration(typeParameters.map((tp) => tp.ast), (...typeParameters$1) => options.decode(...typeParameters$1.map(make$4)), (...typeParameters$1) => options.encode(...typeParameters$1.map(make$4)), toASTAnnotations(annotations$1)));
const declarePrimitive = (is, annotations$1) => {
	const decodeUnknown$2 = () => (input, _$1, ast) => is(input) ? succeed(input) : fail(new Type(ast, input));
	const encodeUnknown = decodeUnknown$2;
	return makeDeclareClass([], new Declaration([], decodeUnknown$2, encodeUnknown, toASTAnnotations(annotations$1)));
};
function makeDeclareClass(typeParameters, ast) {
	return class DeclareClass extends make$4(ast) {
		static annotations(annotations$1) {
			return makeDeclareClass(this.typeParameters, mergeSchemaAnnotations(this.ast, annotations$1));
		}
		static typeParameters = [...typeParameters];
	};
}
/**
* The constraint `R extends Schema.Context<P[number]>` enforces dependencies solely from `typeParameters`.
* This ensures that when you call `Schema.to` or `Schema.from`, you receive a schema with a `never` context.
*
* @category constructors
* @since 3.10.0
*/
const declare = function() {
	if (Array.isArray(arguments[0])) {
		const typeParameters = arguments[0];
		const options = arguments[1];
		const annotations$2 = arguments[2];
		return declareConstructor(typeParameters, options, annotations$2);
	}
	const is = arguments[0];
	const annotations$1 = arguments[1];
	return declarePrimitive(is, annotations$1);
};
/**
* @category primitives
* @since 3.10.0
*/
var Never = class extends make$4(neverKeyword) {};
/** @ignore */
var String$ = class extends make$4(stringKeyword) {};
var ElementImpl = class ElementImpl {
	ast;
	from;
	[TypeId$2];
	_Token;
	constructor(ast, from) {
		this.ast = ast;
		this.from = from;
	}
	annotations(annotations$1) {
		return new ElementImpl(new OptionalType(this.ast.type, this.ast.isOptional, {
			...this.ast.annotations,
			...toASTAnnotations(annotations$1)
		}), this.from);
	}
	toString() {
		return `${this.ast.type}${this.ast.isOptional ? "?" : ""}`;
	}
};
const formatPropertySignatureToken = (isOptional) => isOptional ? "\"?:\"" : "\":\"";
/**
* @category PropertySignature
* @since 3.10.0
*/
var PropertySignatureDeclaration = class extends OptionalType {
	isReadonly;
	defaultValue;
	/**
	* @since 3.10.0
	*/
	_tag = "PropertySignatureDeclaration";
	constructor(type, isOptional, isReadonly, annotations$1, defaultValue) {
		super(type, isOptional, annotations$1);
		this.isReadonly = isReadonly;
		this.defaultValue = defaultValue;
	}
	/**
	* @since 3.10.0
	*/
	toString() {
		const token = formatPropertySignatureToken(this.isOptional);
		const type = String(this.type);
		return `PropertySignature<${token}, ${type}, never, ${token}, ${type}>`;
	}
};
/**
* @category PropertySignature
* @since 3.10.0
*/
var ToPropertySignature = class extends OptionalType {
	isReadonly;
	defaultValue;
	constructor(type, isOptional, isReadonly, annotations$1, defaultValue) {
		super(type, isOptional, annotations$1);
		this.isReadonly = isReadonly;
		this.defaultValue = defaultValue;
	}
};
const formatPropertyKey = (p) => {
	if (p === void 0) return "never";
	if (isString(p)) return JSON.stringify(p);
	return String(p);
};
/**
* @category PropertySignature
* @since 3.10.0
*/
var PropertySignatureTransformation = class {
	from;
	to;
	decode;
	encode;
	/**
	* @since 3.10.0
	*/
	_tag = "PropertySignatureTransformation";
	constructor(from, to, decode$4, encode$3) {
		this.from = from;
		this.to = to;
		this.decode = decode$4;
		this.encode = encode$3;
	}
	/**
	* @since 3.10.0
	*/
	toString() {
		return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${formatPropertyKey(this.from.fromKey)}, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`;
	}
};
const mergeSignatureAnnotations = (ast, annotations$1) => {
	switch (ast._tag) {
		case "PropertySignatureDeclaration": return new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, {
			...ast.annotations,
			...annotations$1
		}, ast.defaultValue);
		case "PropertySignatureTransformation": return new PropertySignatureTransformation(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {
			...ast.to.annotations,
			...annotations$1
		}, ast.to.defaultValue), ast.decode, ast.encode);
	}
};
/**
* @since 3.10.0
* @category symbol
*/
const PropertySignatureTypeId = /* @__PURE__ */ Symbol.for("effect/PropertySignature");
var PropertySignatureImpl = class PropertySignatureImpl {
	ast;
	[TypeId$2];
	[PropertySignatureTypeId] = null;
	_TypeToken;
	_Key;
	_EncodedToken;
	_HasDefault;
	constructor(ast) {
		this.ast = ast;
	}
	pipe() {
		return pipeArguments(this, arguments);
	}
	annotations(annotations$1) {
		return new PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations$1)));
	}
	toString() {
		return String(this.ast);
	}
};
const preserveMissingMessageAnnotation = /* @__PURE__ */ pickAnnotations([MissingMessageAnnotationId]);
const preserveRefinementAnnotations = /* @__PURE__ */ omitAnnotations([IdentifierAnnotationId]);
function makeTransformationClass(from, to, ast) {
	return class TransformationClass extends make$4(ast) {
		static annotations(annotations$1) {
			return makeTransformationClass(this.from, this.to, mergeSchemaAnnotations(this.ast, annotations$1));
		}
		static from = from;
		static to = to;
	};
}
/**
* Create a new `Schema` by transforming the input and output of an existing `Schema`
* using the provided decoding functions.
*
* @category transformations
* @since 3.10.0
*/
const transformOrFail = /* @__PURE__ */ dual$1((args$2) => isSchema(args$2[0]) && isSchema(args$2[1]), (from, to, options) => makeTransformationClass(from, to, new Transformation$1(from.ast, to.ast, new FinalTransformation(options.decode, options.encode))));
/**
* @category schema id
* @since 3.10.0
*/
const MaxLengthSchemaId = MaxLengthSchemaId$1;
/**
* @category schema id
* @since 3.10.0
*/
const MinLengthSchemaId = MinLengthSchemaId$1;
/**
* @category schema id
* @since 3.10.0
*/
const LengthSchemaId = LengthSchemaId$1;
/**
* @category schema id
* @since 3.10.0
*/
const FiniteSchemaId = FiniteSchemaId$1;
/**
* @category schema id
* @since 3.10.0
*/
const GreaterThanSchemaId = GreaterThanSchemaId$1;
/**
* @category schema id
* @since 3.10.0
*/
const GreaterThanOrEqualToSchemaId = GreaterThanOrEqualToSchemaId$1;
/**
* @category schema id
* @since 3.10.0
*/
const IntSchemaId = IntSchemaId$1;
/**
* @category schema id
* @since 3.10.0
*/
const LessThanSchemaId = LessThanSchemaId$1;
/**
* @category schema id
* @since 3.10.0
*/
const LessThanOrEqualToSchemaId = LessThanOrEqualToSchemaId$1;
/**
* @category schema id
* @since 3.10.0
*/
const BetweenSchemaId = BetweenSchemaId$1;
/**
* @category schema id
* @since 3.10.0
*/
const NonNaNSchemaId = NonNaNSchemaId$1;
/**
* @category schema id
* @since 3.10.0
*/
const JsonNumberSchemaId = JsonNumberSchemaId$1;
/**
* @category schema id
* @since 3.10.0
*/
const GreaterThanBigIntSchemaId = GreaterThanBigintSchemaId;
/**
* @category schema id
* @since 3.10.0
*/
const GreaterThanOrEqualToBigIntSchemaId = GreaterThanOrEqualToBigIntSchemaId$1;
/**
* @category schema id
* @since 3.10.0
*/
const LessThanBigIntSchemaId = LessThanBigIntSchemaId$1;
/**
* @category schema id
* @since 3.10.0
*/
const LessThanOrEqualToBigIntSchemaId = LessThanOrEqualToBigIntSchemaId$1;
/**
* @category schema id
* @since 3.10.0
*/
const BetweenBigIntSchemaId = BetweenBigintSchemaId;
/**
* @category Uint8Array constructors
* @since 3.10.0
*/
var Uint8ArrayFromSelf = class extends declare(isUint8Array, {
	identifier: "Uint8ArrayFromSelf",
	pretty: () => (u8arr) => `new Uint8Array(${JSON.stringify(Array.from(u8arr))})`,
	arbitrary: () => (fc) => fc.uint8Array(),
	equivalence: () => getEquivalence$2(equals)
}) {};
const makeUint8ArrayTransformation = (id$2, decode$4, encode$3) => transformOrFail(String$.annotations({ description: "a string to be decoded into a Uint8Array" }), Uint8ArrayFromSelf, {
	strict: true,
	decode: (i$1, _$1, ast) => mapLeft(decode$4(i$1), (decodeException) => new Type(ast, i$1, decodeException.message)),
	encode: (a$1) => succeed(encode$3(a$1))
}).annotations({ identifier: id$2 });
/**
* Decodes a base64 (RFC4648) encoded string into a `Uint8Array`.
*
* @category Uint8Array transformations
* @since 3.10.0
*/
const Uint8ArrayFromBase64 = /* @__PURE__ */ makeUint8ArrayTransformation("Uint8ArrayFromBase64", decodeBase64, encodeBase64);
/**
* Decodes a base64 (URL) encoded string into a `Uint8Array`.
*
* @category Uint8Array transformations
* @since 3.10.0
*/
const Uint8ArrayFromBase64Url = /* @__PURE__ */ makeUint8ArrayTransformation("Uint8ArrayFromBase64Url", decodeBase64Url, encodeBase64Url);
/**
* Decodes a hex encoded string into a `Uint8Array`.
*
* @category Uint8Array transformations
* @since 3.10.0
*/
const Uint8ArrayFromHex = /* @__PURE__ */ makeUint8ArrayTransformation("Uint8ArrayFromHex", decodeHex, encodeHex);
const makeEncodingTransformation = (id$2, decode$4, encode$3) => transformOrFail(String$.annotations({ description: `A string that is interpreted as being ${id$2}-encoded and will be decoded into a UTF-8 string` }), String$, {
	strict: true,
	decode: (i$1, _$1, ast) => mapLeft(decode$4(i$1), (decodeException) => new Type(ast, i$1, decodeException.message)),
	encode: (a$1) => succeed(encode$3(a$1))
}).annotations({ identifier: `StringFrom${id$2}` });
/**
* Decodes a base64 (RFC4648) encoded string into a UTF-8 string.
*
* @category string transformations
* @since 3.10.0
*/
const StringFromBase64 = /* @__PURE__ */ makeEncodingTransformation("Base64", decodeBase64String, encodeBase64);
/**
* Decodes a base64 (URL) encoded string into a UTF-8 string.
*
* @category string transformations
* @since 3.10.0
*/
const StringFromBase64Url = /* @__PURE__ */ makeEncodingTransformation("Base64Url", decodeBase64UrlString, encodeBase64Url);
/**
* Decodes a hex encoded string into a UTF-8 string.
*
* @category string transformations
* @since 3.10.0
*/
const StringFromHex = /* @__PURE__ */ makeEncodingTransformation("Hex", decodeHexString, encodeHex);
/**
* @category schema id
* @since 3.10.0
*/
const MinItemsSchemaId = MinItemsSchemaId$1;
/**
* @category schema id
* @since 3.10.0
*/
const MaxItemsSchemaId = MaxItemsSchemaId$1;
/**
* @category schema id
* @since 3.10.0
*/
const ItemsCountSchemaId = ItemsCountSchemaId$1;
/**
* @category schema id
* @since 3.11.8
*/
const DateFromSelfSchemaId = DateFromSelfSchemaId$1;
const getEquivalenceAnnotation = /* @__PURE__ */ getAnnotation(EquivalenceAnnotationId);

//#endregion
//#region src/schemas.ts
const PackageManager = Literal("npm", "yarn", "pnpm", "bun", "deno");

//#endregion
//#region node_modules/.pnpm/@effect+platform@0.92.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/Error.js
/**
* @since 1.0.0
* @category type id
*/
const TypeId$1 = /* @__PURE__ */ Symbol.for("@effect/platform/Error");
/**
* @since 1.0.0
* @category Models
*/
const Module = /* @__PURE__ */ effect_Schema.Literal("Clipboard", "Command", "FileSystem", "KeyValueStore", "Path", "Stream", "Terminal");
/**
* @since 1.0.0
* @category Models
*/
var BadArgument$1 = class extends effect_Schema.TaggedError("@effect/platform/Error/BadArgument")("BadArgument", {
	module: Module,
	method: effect_Schema.String,
	description: /* @__PURE__ */ effect_Schema.optional(effect_Schema.String),
	cause: /* @__PURE__ */ effect_Schema.optional(effect_Schema.Defect)
}) {
	/**
	* @since 1.0.0
	*/
	[TypeId$1] = TypeId$1;
	/**
	* @since 1.0.0
	*/
	get message() {
		return `${this.module}.${this.method}${this.description ? `: ${this.description}` : ""}`;
	}
};
/**
* @since 1.0.0
* @category Model
*/
const SystemErrorReason = /* @__PURE__ */ effect_Schema.Literal("AlreadyExists", "BadResource", "Busy", "InvalidData", "NotFound", "PermissionDenied", "TimedOut", "UnexpectedEof", "Unknown", "WouldBlock", "WriteZero");
/**
* @since 1.0.0
* @category models
*/
var SystemError$2 = class extends effect_Schema.TaggedError("@effect/platform/Error/SystemError")("SystemError", {
	reason: SystemErrorReason,
	module: Module,
	method: effect_Schema.String,
	description: /* @__PURE__ */ effect_Schema.optional(effect_Schema.String),
	syscall: /* @__PURE__ */ effect_Schema.optional(effect_Schema.String),
	pathOrDescriptor: /* @__PURE__ */ effect_Schema.optional(/* @__PURE__ */ effect_Schema.Union(effect_Schema.String, effect_Schema.Number)),
	cause: /* @__PURE__ */ effect_Schema.optional(effect_Schema.Defect)
}) {
	/**
	* @since 1.0.0
	*/
	[TypeId$1] = TypeId$1;
	/**
	* @since 1.0.0
	*/
	get message() {
		return `${this.reason}: ${this.module}.${this.method}${this.pathOrDescriptor !== void 0 ? ` (${this.pathOrDescriptor})` : ""}${this.description ? `: ${this.description}` : ""}`;
	}
};

//#endregion
//#region node_modules/.pnpm/@effect+platform@0.92.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/internal/fileSystem.js
/** @internal */
const tag = /* @__PURE__ */ (0, effect_Context.GenericTag)("@effect/platform/FileSystem");
/** @internal */
const Size$1 = (bytes) => typeof bytes === "bigint" ? bytes : BigInt(bytes);
/** @internal */
const KiB$1 = (n$1) => Size$1(n$1 * 1024);
/** @internal */
const MiB$1 = (n$1) => Size$1(n$1 * 1024 * 1024);
/** @internal */
const GiB$1 = (n$1) => Size$1(n$1 * 1024 * 1024 * 1024);
/** @internal */
const TiB$1 = (n$1) => Size$1(n$1 * 1024 * 1024 * 1024 * 1024);
const bigint1024 = /* @__PURE__ */ BigInt(1024);
const bigintPiB = bigint1024 * bigint1024 * bigint1024 * bigint1024 * bigint1024;
/** @internal */
const PiB$1 = (n$1) => Size$1(BigInt(n$1) * bigintPiB);
/** @internal */
const make$3 = (impl) => {
	return tag.of({
		...impl,
		exists: (path) => (0, effect_Function.pipe)(impl.access(path), effect_Effect.as(true), effect_Effect.catchTag("SystemError", (e) => e.reason === "NotFound" ? effect_Effect.succeed(false) : effect_Effect.fail(e))),
		readFileString: (path, encoding) => effect_Effect.tryMap(impl.readFile(path), {
			try: (_$1) => new TextDecoder(encoding).decode(_$1),
			catch: (cause$2) => new BadArgument$1({
				module: "FileSystem",
				method: "readFileString",
				description: "invalid encoding",
				cause: cause$2
			})
		}),
		stream: (path, options) => (0, effect_Function.pipe)(impl.open(path, { flag: "r" }), options?.offset ? effect_Effect.tap((file) => file.seek(options.offset, "start")) : effect_Function.identity, effect_Effect.map((file) => stream(file, options)), effect_Stream.unwrapScoped),
		sink: (path, options) => (0, effect_Function.pipe)(impl.open(path, {
			flag: "w",
			...options
		}), effect_Effect.map((file) => effect_Sink.forEach((_$1) => file.writeAll(_$1))), effect_Sink.unwrapScoped),
		writeFileString: (path, data, options) => effect_Effect.flatMap(effect_Effect.try({
			try: () => new TextEncoder().encode(data),
			catch: (cause$2) => new BadArgument$1({
				module: "FileSystem",
				method: "writeFileString",
				description: "could not encode string",
				cause: cause$2
			})
		}), (_$1) => impl.writeFile(path, _$1, options))
	});
};
const notFound = (method, path) => new SystemError$2({
	module: "FileSystem",
	method,
	reason: "NotFound",
	description: "No such file or directory",
	pathOrDescriptor: path
});
/** @internal */
const makeNoop$1 = (fileSystem) => {
	return {
		access(path) {
			return effect_Effect.fail(notFound("access", path));
		},
		chmod(path) {
			return effect_Effect.fail(notFound("chmod", path));
		},
		chown(path) {
			return effect_Effect.fail(notFound("chown", path));
		},
		copy(path) {
			return effect_Effect.fail(notFound("copy", path));
		},
		copyFile(path) {
			return effect_Effect.fail(notFound("copyFile", path));
		},
		exists() {
			return effect_Effect.succeed(false);
		},
		link(path) {
			return effect_Effect.fail(notFound("link", path));
		},
		makeDirectory() {
			return effect_Effect.die("not implemented");
		},
		makeTempDirectory() {
			return effect_Effect.die("not implemented");
		},
		makeTempDirectoryScoped() {
			return effect_Effect.die("not implemented");
		},
		makeTempFile() {
			return effect_Effect.die("not implemented");
		},
		makeTempFileScoped() {
			return effect_Effect.die("not implemented");
		},
		open(path) {
			return effect_Effect.fail(notFound("open", path));
		},
		readDirectory(path) {
			return effect_Effect.fail(notFound("readDirectory", path));
		},
		readFile(path) {
			return effect_Effect.fail(notFound("readFile", path));
		},
		readFileString(path) {
			return effect_Effect.fail(notFound("readFileString", path));
		},
		readLink(path) {
			return effect_Effect.fail(notFound("readLink", path));
		},
		realPath(path) {
			return effect_Effect.fail(notFound("realPath", path));
		},
		remove() {
			return effect_Effect.void;
		},
		rename(oldPath) {
			return effect_Effect.fail(notFound("rename", oldPath));
		},
		sink(path) {
			return effect_Sink.fail(notFound("sink", path));
		},
		stat(path) {
			return effect_Effect.fail(notFound("stat", path));
		},
		stream(path) {
			return effect_Stream.fail(notFound("stream", path));
		},
		symlink(fromPath) {
			return effect_Effect.fail(notFound("symlink", fromPath));
		},
		truncate(path) {
			return effect_Effect.fail(notFound("truncate", path));
		},
		utimes(path) {
			return effect_Effect.fail(notFound("utimes", path));
		},
		watch(path) {
			return effect_Stream.fail(notFound("watch", path));
		},
		writeFile(path) {
			return effect_Effect.fail(notFound("writeFile", path));
		},
		writeFileString(path) {
			return effect_Effect.fail(notFound("writeFileString", path));
		},
		...fileSystem
	};
};
/** @internal */
const layerNoop$1 = (fileSystem) => effect_Layer.succeed(tag, makeNoop$1(fileSystem));
/** @internal */
const stream = (file, { bufferSize = 16, bytesToRead: bytesToRead_, chunkSize: chunkSize_ = Size$1(64 * 1024) } = {}) => {
	const bytesToRead = bytesToRead_ !== void 0 ? Size$1(bytesToRead_) : void 0;
	const chunkSize = Size$1(chunkSize_);
	function loop$2(totalBytesRead) {
		if (bytesToRead !== void 0 && bytesToRead <= totalBytesRead) return effect_Channel.void;
		const toRead = bytesToRead !== void 0 && bytesToRead - totalBytesRead < chunkSize ? bytesToRead - totalBytesRead : chunkSize;
		return effect_Channel.flatMap(file.readAlloc(toRead), effect_Option.match({
			onNone: () => effect_Channel.void,
			onSome: (buf) => effect_Channel.flatMap(effect_Channel.write(effect_Chunk.of(buf)), (_$1) => loop$2(totalBytesRead + BigInt(buf.length)))
		}));
	}
	return effect_Stream.bufferChunks(effect_Stream.fromChannel(loop$2(BigInt(0))), { capacity: bufferSize });
};

//#endregion
//#region node_modules/.pnpm/@effect+platform@0.92.1_effect@3.18.4/node_modules/@effect/platform/dist/esm/FileSystem.js
/**
* @since 1.0.0
* @category sizes
*/
const Size = Size$1;
/**
* @since 1.0.0
* @category sizes
*/
const KiB = KiB$1;
/**
* @since 1.0.0
* @category sizes
*/
const MiB = MiB$1;
/**
* @since 1.0.0
* @category sizes
*/
const GiB = GiB$1;
/**
* @since 1.0.0
* @category sizes
*/
const TiB = TiB$1;
/**
* @since 1.0.0
* @category sizes
*/
const PiB = PiB$1;
/**
* @since 1.0.0
* @category tag
*/
const FileSystem = tag;
/**
* @since 1.0.0
* @category constructor
*/
const make$2 = make$3;
/**
* Create a no-op file system that can be used for testing.
*
* @since 1.0.0
* @category constructor
*/
const makeNoop = makeNoop$1;
/**
* Create a no-op file system that can be used for testing.
*
* @since 1.0.0
* @category layers
*/
const layerNoop = layerNoop$1;

//#endregion
//#region src/utils.ts
const packageManagers = [
	{
		name: "npm",
		lockFiles: ["package-lock.json"]
	},
	{
		name: "yarn",
		lockFiles: ["yarn.lock"]
	},
	{
		name: "pnpm",
		lockFiles: ["pnpm-lock.yaml"]
	},
	{
		name: "bun",
		lockFiles: ["bun.lockb", "bun.lock"]
	},
	{
		name: "deno",
		lockFiles: ["deno.lock"]
	}
];
const detectPackageManager = gen(function* () {
	const fs$1 = yield* FileSystem;
	consola.start("Detecting package manager...");
	let foundPackageManager = "unknown";
	if (pkg?.packageManager) foundPackageManager = yield* decodeUnknown(PackageManager)(pkg.packageManager.split("@")[0]);
	const files = yield* fs$1.readDirectory(process.cwd());
	for (const { lockFiles, name } of packageManagers) if (lockFiles.some((lockFile) => files.includes(lockFile))) foundPackageManager = name;
	if (foundPackageManager === "unknown") {
		consola.warn("Couldn't find package manager, using default");
		foundPackageManager = "bun";
	}
	consola.success(`Using package manager: ${foundPackageManager}`);
	return foundPackageManager;
});
function $(str) {
	consola.box(str);
	const d = (0, node_child_process.execSync)(str);
	console.log(d.toString());
}

//#endregion
//#region node_modules/.pnpm/chalk@5.6.2/node_modules/chalk/source/vendor/ansi-styles/index.js
const ANSI_BACKGROUND_OFFSET = 10;
const wrapAnsi16 = (offset = 0) => (code) => `\u001B[${code + offset}m`;
const wrapAnsi256 = (offset = 0) => (code) => `\u001B[${38 + offset};5;${code}m`;
const wrapAnsi16m = (offset = 0) => (red, green, blue) => `\u001B[${38 + offset};2;${red};${green};${blue}m`;
const styles$1 = {
	modifier: {
		reset: [0, 0],
		bold: [1, 22],
		dim: [2, 22],
		italic: [3, 23],
		underline: [4, 24],
		overline: [53, 55],
		inverse: [7, 27],
		hidden: [8, 28],
		strikethrough: [9, 29]
	},
	color: {
		black: [30, 39],
		red: [31, 39],
		green: [32, 39],
		yellow: [33, 39],
		blue: [34, 39],
		magenta: [35, 39],
		cyan: [36, 39],
		white: [37, 39],
		blackBright: [90, 39],
		gray: [90, 39],
		grey: [90, 39],
		redBright: [91, 39],
		greenBright: [92, 39],
		yellowBright: [93, 39],
		blueBright: [94, 39],
		magentaBright: [95, 39],
		cyanBright: [96, 39],
		whiteBright: [97, 39]
	},
	bgColor: {
		bgBlack: [40, 49],
		bgRed: [41, 49],
		bgGreen: [42, 49],
		bgYellow: [43, 49],
		bgBlue: [44, 49],
		bgMagenta: [45, 49],
		bgCyan: [46, 49],
		bgWhite: [47, 49],
		bgBlackBright: [100, 49],
		bgGray: [100, 49],
		bgGrey: [100, 49],
		bgRedBright: [101, 49],
		bgGreenBright: [102, 49],
		bgYellowBright: [103, 49],
		bgBlueBright: [104, 49],
		bgMagentaBright: [105, 49],
		bgCyanBright: [106, 49],
		bgWhiteBright: [107, 49]
	}
};
const modifierNames = Object.keys(styles$1.modifier);
const foregroundColorNames = Object.keys(styles$1.color);
const backgroundColorNames = Object.keys(styles$1.bgColor);
const colorNames = [...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
	const codes = /* @__PURE__ */ new Map();
	for (const [groupName, group] of Object.entries(styles$1)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles$1[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};
			group[styleName] = styles$1[styleName];
			codes.set(style[0], style[1]);
		}
		Object.defineProperty(styles$1, groupName, {
			value: group,
			enumerable: false
		});
	}
	Object.defineProperty(styles$1, "codes", {
		value: codes,
		enumerable: false
	});
	styles$1.color.close = "\x1B[39m";
	styles$1.bgColor.close = "\x1B[49m";
	styles$1.color.ansi = wrapAnsi16();
	styles$1.color.ansi256 = wrapAnsi256();
	styles$1.color.ansi16m = wrapAnsi16m();
	styles$1.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
	styles$1.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
	styles$1.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
	Object.defineProperties(styles$1, {
		rgbToAnsi256: {
			value(red, green, blue) {
				if (red === green && green === blue) {
					if (red < 8) return 16;
					if (red > 248) return 231;
					return Math.round((red - 8) / 247 * 24) + 232;
				}
				return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
			},
			enumerable: false
		},
		hexToRgb: {
			value(hex) {
				const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
				if (!matches) return [
					0,
					0,
					0
				];
				let [colorString] = matches;
				if (colorString.length === 3) colorString = [...colorString].map((character) => character + character).join("");
				const integer = Number.parseInt(colorString, 16);
				return [
					integer >> 16 & 255,
					integer >> 8 & 255,
					integer & 255
				];
			},
			enumerable: false
		},
		hexToAnsi256: {
			value: (hex) => styles$1.rgbToAnsi256(...styles$1.hexToRgb(hex)),
			enumerable: false
		},
		ansi256ToAnsi: {
			value(code) {
				if (code < 8) return 30 + code;
				if (code < 16) return 90 + (code - 8);
				let red;
				let green;
				let blue;
				if (code >= 232) {
					red = ((code - 232) * 10 + 8) / 255;
					green = red;
					blue = red;
				} else {
					code -= 16;
					const remainder = code % 36;
					red = Math.floor(code / 36) / 5;
					green = Math.floor(remainder / 6) / 5;
					blue = remainder % 6 / 5;
				}
				const value = Math.max(red, green, blue) * 2;
				if (value === 0) return 30;
				let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
				if (value === 2) result += 60;
				return result;
			},
			enumerable: false
		},
		rgbToAnsi: {
			value: (red, green, blue) => styles$1.ansi256ToAnsi(styles$1.rgbToAnsi256(red, green, blue)),
			enumerable: false
		},
		hexToAnsi: {
			value: (hex) => styles$1.ansi256ToAnsi(styles$1.hexToAnsi256(hex)),
			enumerable: false
		}
	});
	return styles$1;
}
const ansiStyles = assembleStyles();
var ansi_styles_default = ansiStyles;

//#endregion
//#region node_modules/.pnpm/chalk@5.6.2/node_modules/chalk/source/vendor/supports-color/index.js
function hasFlag(flag, argv$1 = globalThis.Deno ? globalThis.Deno.args : node_process.default.argv) {
	const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
	const position = argv$1.indexOf(prefix + flag);
	const terminatorPosition = argv$1.indexOf("--");
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
const { env } = node_process.default;
let flagForceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) flagForceColor = 0;
else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) flagForceColor = 1;
function envForceColor() {
	if ("FORCE_COLOR" in env) {
		if (env.FORCE_COLOR === "true") return 1;
		if (env.FORCE_COLOR === "false") return 0;
		return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
	}
}
function translateLevel(level) {
	if (level === 0) return false;
	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
	const noFlagForceColor = envForceColor();
	if (noFlagForceColor !== void 0) flagForceColor = noFlagForceColor;
	const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
	if (forceColor === 0) return 0;
	if (sniffFlags) {
		if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) return 3;
		if (hasFlag("color=256")) return 2;
	}
	if ("TF_BUILD" in env && "AGENT_NAME" in env) return 1;
	if (haveStream && !streamIsTTY && forceColor === void 0) return 0;
	const min$2 = forceColor || 0;
	if (env.TERM === "dumb") return min$2;
	if (node_process.default.platform === "win32") {
		const osRelease = node_os.default.release().split(".");
		if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) return Number(osRelease[2]) >= 14931 ? 3 : 2;
		return 1;
	}
	if ("CI" in env) {
		if ([
			"GITHUB_ACTIONS",
			"GITEA_ACTIONS",
			"CIRCLECI"
		].some((key) => key in env)) return 3;
		if ([
			"TRAVIS",
			"APPVEYOR",
			"GITLAB_CI",
			"BUILDKITE",
			"DRONE"
		].some((sign) => sign in env) || env.CI_NAME === "codeship") return 1;
		return min$2;
	}
	if ("TEAMCITY_VERSION" in env) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	if (env.COLORTERM === "truecolor") return 3;
	if (env.TERM === "xterm-kitty") return 3;
	if (env.TERM === "xterm-ghostty") return 3;
	if (env.TERM === "wezterm") return 3;
	if ("TERM_PROGRAM" in env) {
		const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
		switch (env.TERM_PROGRAM) {
			case "iTerm.app": return version >= 3 ? 3 : 2;
			case "Apple_Terminal": return 2;
		}
	}
	if (/-256(color)?$/i.test(env.TERM)) return 2;
	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) return 1;
	if ("COLORTERM" in env) return 1;
	return min$2;
}
function createSupportsColor(stream$1, options = {}) {
	return translateLevel(_supportsColor(stream$1, {
		streamIsTTY: stream$1 && stream$1.isTTY,
		...options
	}));
}
const supportsColor = {
	stdout: createSupportsColor({ isTTY: node_tty.default.isatty(1) }),
	stderr: createSupportsColor({ isTTY: node_tty.default.isatty(2) })
};
var supports_color_default = supportsColor;

//#endregion
//#region node_modules/.pnpm/chalk@5.6.2/node_modules/chalk/source/utilities.js
function stringReplaceAll(string$1, substring, replacer) {
	let index = string$1.indexOf(substring);
	if (index === -1) return string$1;
	const substringLength = substring.length;
	let endIndex = 0;
	let returnValue = "";
	do {
		returnValue += string$1.slice(endIndex, index) + substring + replacer;
		endIndex = index + substringLength;
		index = string$1.indexOf(substring, endIndex);
	} while (index !== -1);
	returnValue += string$1.slice(endIndex);
	return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string$1, prefix, postfix, index) {
	let endIndex = 0;
	let returnValue = "";
	do {
		const gotCR = string$1[index - 1] === "\r";
		returnValue += string$1.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
		endIndex = index + 1;
		index = string$1.indexOf("\n", endIndex);
	} while (index !== -1);
	returnValue += string$1.slice(endIndex);
	return returnValue;
}

//#endregion
//#region node_modules/.pnpm/chalk@5.6.2/node_modules/chalk/source/index.js
const { stdout: stdoutColor, stderr: stderrColor } = supports_color_default;
const GENERATOR = Symbol("GENERATOR");
const STYLER = Symbol("STYLER");
const IS_EMPTY = Symbol("IS_EMPTY");
const levelMapping = [
	"ansi",
	"ansi",
	"ansi256",
	"ansi16m"
];
const styles = Object.create(null);
const applyOptions = (object, options = {}) => {
	if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) throw new Error("The `level` option should be an integer from 0 to 3");
	const colorLevel = stdoutColor ? stdoutColor.level : 0;
	object.level = options.level === void 0 ? colorLevel : options.level;
};
const chalkFactory = (options) => {
	const chalk$1 = (...strings) => strings.join(" ");
	applyOptions(chalk$1, options);
	Object.setPrototypeOf(chalk$1, createChalk.prototype);
	return chalk$1;
};
function createChalk(options) {
	return chalkFactory(options);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansi_styles_default)) styles[styleName] = { get() {
	const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
	Object.defineProperty(this, styleName, { value: builder });
	return builder;
} };
styles.visible = { get() {
	const builder = createBuilder(this, this[STYLER], true);
	Object.defineProperty(this, "visible", { value: builder });
	return builder;
} };
const getModelAnsi = (model, level, type, ...arguments_) => {
	if (model === "rgb") {
		if (level === "ansi16m") return ansi_styles_default[type].ansi16m(...arguments_);
		if (level === "ansi256") return ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
		return ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
	}
	if (model === "hex") return getModelAnsi("rgb", level, type, ...ansi_styles_default.hexToRgb(...arguments_));
	return ansi_styles_default[type][model](...arguments_);
};
for (const model of [
	"rgb",
	"hex",
	"ansi256"
]) {
	styles[model] = { get() {
		const { level } = this;
		return function(...arguments_) {
			const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
			return createBuilder(this, styler, this[IS_EMPTY]);
		};
	} };
	const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = { get() {
		const { level } = this;
		return function(...arguments_) {
			const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
			return createBuilder(this, styler, this[IS_EMPTY]);
		};
	} };
}
const proto = Object.defineProperties(() => {}, {
	...styles,
	level: {
		enumerable: true,
		get() {
			return this[GENERATOR].level;
		},
		set(level) {
			this[GENERATOR].level = level;
		}
	}
});
const createStyler = (open$1, close$1, parent) => {
	let openAll;
	let closeAll;
	if (parent === void 0) {
		openAll = open$1;
		closeAll = close$1;
	} else {
		openAll = parent.openAll + open$1;
		closeAll = close$1 + parent.closeAll;
	}
	return {
		open: open$1,
		close: close$1,
		openAll,
		closeAll,
		parent
	};
};
const createBuilder = (self, _styler, _isEmpty) => {
	const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
	Object.setPrototypeOf(builder, proto);
	builder[GENERATOR] = self;
	builder[STYLER] = _styler;
	builder[IS_EMPTY] = _isEmpty;
	return builder;
};
const applyStyle = (self, string$1) => {
	if (self.level <= 0 || !string$1) return self[IS_EMPTY] ? "" : string$1;
	let styler = self[STYLER];
	if (styler === void 0) return string$1;
	const { openAll, closeAll } = styler;
	if (string$1.includes("\x1B")) while (styler !== void 0) {
		string$1 = stringReplaceAll(string$1, styler.close, styler.open);
		styler = styler.parent;
	}
	const lfIndex = string$1.indexOf("\n");
	if (lfIndex !== -1) string$1 = stringEncaseCRLFWithFirstIndex(string$1, closeAll, openAll, lfIndex);
	return openAll + string$1 + closeAll;
};
Object.defineProperties(createChalk.prototype, styles);
const chalk = createChalk();
const chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
var source_default = chalk;

//#endregion
//#region node_modules/.pnpm/dedent@1.7.0/node_modules/dedent/dist/dedent.mjs
function ownKeys(object, enumerableOnly) {
	var keys$5 = Object.keys(object);
	if (Object.getOwnPropertySymbols) {
		var symbols = Object.getOwnPropertySymbols(object);
		enumerableOnly && (symbols = symbols.filter(function(sym) {
			return Object.getOwnPropertyDescriptor(object, sym).enumerable;
		})), keys$5.push.apply(keys$5, symbols);
	}
	return keys$5;
}
function _objectSpread(target) {
	for (var i$1 = 1; i$1 < arguments.length; i$1++) {
		var source = null != arguments[i$1] ? arguments[i$1] : {};
		i$1 % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
			_defineProperty(target, key, source[key]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
			Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
		});
	}
	return target;
}
function _defineProperty(obj, key, value) {
	key = _toPropertyKey(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _toPropertyKey(arg) {
	var key = _toPrimitive(arg, "string");
	return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
	if (typeof input !== "object" || input === null) return input;
	var prim = input[Symbol.toPrimitive];
	if (prim !== void 0) {
		var res = prim.call(input, hint || "default");
		if (typeof res !== "object") return res;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return (hint === "string" ? String : Number)(input);
}
const dedent = createDedent({});
var dedent_default = dedent;
function createDedent(options) {
	dedent$1.withOptions = (newOptions) => createDedent(_objectSpread(_objectSpread({}, options), newOptions));
	return dedent$1;
	function dedent$1(strings, ...values$6) {
		const raw = typeof strings === "string" ? [strings] : strings.raw;
		const { alignValues = false, escapeSpecialCharacters = Array.isArray(strings), trimWhitespace = true } = options;
		let result = "";
		for (let i$1 = 0; i$1 < raw.length; i$1++) {
			let next = raw[i$1];
			if (escapeSpecialCharacters) next = next.replace(/\\\n[ \t]*/g, "").replace(/\\`/g, "`").replace(/\\\$/g, "$").replace(/\\\{/g, "{");
			result += next;
			if (i$1 < values$6.length) {
				const value = alignValues ? alignValue(values$6[i$1], result) : values$6[i$1];
				result += value;
			}
		}
		const lines = result.split("\n");
		let mindent = null;
		for (const l$1 of lines) {
			const m = l$1.match(/^(\s+)\S+/);
			if (m) {
				const indent = m[1].length;
				if (!mindent) mindent = indent;
				else mindent = Math.min(mindent, indent);
			}
		}
		if (mindent !== null) {
			const m = mindent;
			result = lines.map((l$1) => l$1[0] === " " || l$1[0] === "	" ? l$1.slice(m) : l$1).join("\n");
		}
		if (trimWhitespace) result = result.trim();
		if (escapeSpecialCharacters) result = result.replace(/\\n/g, "\n");
		return result;
	}
}
/**
* Adjusts the indentation of a multi-line interpolated value to match the current line.
*/
function alignValue(value, precedingText) {
	if (typeof value !== "string" || !value.includes("\n")) return value;
	const indentMatch = precedingText.slice(precedingText.lastIndexOf("\n") + 1).match(/^(\s+)/);
	if (indentMatch) {
		const indent = indentMatch[1];
		return value.replace(/\n/g, `\n${indent}`);
	}
	return value;
}

//#endregion
//#region \0@oxc-project+runtime@0.95.0/helpers/decorate.js
function __decorate(decorators, target, key, desc) {
	var c$1 = arguments.length, r$1 = c$1 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r$1 = Reflect.decorate(decorators, target, key, desc);
	else for (var i$1 = decorators.length - 1; i$1 >= 0; i$1--) if (d = decorators[i$1]) r$1 = (c$1 < 3 ? d(r$1) : c$1 > 3 ? d(target, key, r$1) : d(target, key)) || r$1;
	return c$1 > 3 && r$1 && Object.defineProperty(target, key, r$1), r$1;
}

//#endregion
//#region src/yawn.ts
const commands = [];
function command(c$1) {
	return (_$1, propertyKey) => {
		commands.push({
			id: propertyKey,
			aliases: [propertyKey, ...c$1.aliases],
			description: c$1.description
		});
	};
}
var Yawn = class Yawn {
	constructor(pm, pkg$1) {
		this.pm = pm;
		this.pkg = pkg$1;
	}
	static init = gen(function* () {
		const packageManager = yield* detectPackageManager;
		if (!packageManager) return yield* fail$1(/* @__PURE__ */ new Error("No package manager found"));
		if (!pkg) return yield* fail$1(/* @__PURE__ */ new Error("No package.json found"));
		return new Yawn(packageManager, pkg);
	});
	info() {
		return gen(this, function* () {
			consola.box({
				title: "Yawn",
				message: dedent_default`
					${commands.map((command$1) => {
					return dedent_default`
  							${source_default.bold(command$1.id)}
  							${source_default.gray(command$1.aliases.join(", "))}${" ".repeat(Math.max(0, 40 - command$1.aliases.join(", ").length))} ${command$1.description}
         \n

					`;
				}).join("\n")}
				`
			});
		});
	}
	install(deps) {
		return gen(this, function* () {
			if (deps && deps.length) {
				$(`${this.pm} install ${deps.join(" ")}`);
				return;
			}
			$(`${this.pm} install`);
		});
	}
	run(script) {
		return gen(this, function* () {
			$(`${this.pm} run ${script[0]}`);
		});
	}
	remove(deps) {
		return gen(this, function* () {
			if (deps && deps.length) {
				$(`${this.pm} remove ${deps.join(" ")}`);
				return;
			}
			const options = pipe$3({
				...this.pkg.dependencies,
				...this.pkg.devDependencies
			}, (v) => Object.entries(v).map(([key, val]) => ({
				label: key,
				value: key,
				hint: val
			})));
			const depsToDelete = yield* tryPromise({
				try: () => consola.prompt("Select dependencies to remove:", {
					type: "multiselect",
					options
				}),
				catch: (error) => {
					consola.error(error);
					return [];
				}
			});
			if (!depsToDelete.length) {
				console.log("No dependencies selected");
				return;
			}
			$(`${this.pm} remove ${depsToDelete.join(" ")}`);
		});
	}
	dlx(script) {
		let template = "npx";
		switch (this.pm) {
			case "bun":
				template = "bun x %s";
				break;
			case "npm":
				template = "npx %s";
				break;
			case "pnpm":
				template = "pnpm dlx %s";
				break;
			case "yarn":
				template = "npx %s";
				break;
			case "deno":
				template = "deno run -A npm:%s";
				break;
		}
		return gen(this, function* () {
			$(template.replace("%s", script.join(" ")));
		});
	}
};
__decorate([command({
	aliases: ["help"],
	description: "Display info"
})], Yawn.prototype, "info", null);
__decorate([command({
	aliases: [
		"i",
		"a",
		"add"
	],
	description: "Install dependencies"
})], Yawn.prototype, "install", null);
__decorate([command({
	aliases: ["r"],
	description: "Run a script"
})], Yawn.prototype, "run", null);
__decorate([command({
	aliases: [
		"rm",
		"delete",
		"un",
		"uninstall"
	],
	description: "Remove dependencies"
})], Yawn.prototype, "remove", null);
__decorate([command({
	aliases: ["x"],
	description: "Run a script from a package"
})], Yawn.prototype, "dlx", null);

//#endregion
//#region node_modules/.pnpm/@effect+platform-node-shared@0.51.6_@effect+cluster@0.50.6_@effect+platform@0.92.1_effe_5910e813a334008fa44d72e3c39ef97b/node_modules/@effect/platform-node-shared/dist/esm/internal/stream.js
/** @internal */
const fromReadable = (evaluate$1, onError$2, options) => effect_Stream.fromChannel(fromReadableChannel(evaluate$1, onError$2, options));
/** @internal */
const fromReadableChannel = (evaluate$1, onError$2, options) => effect_Channel.suspend(() => unsafeReadableRead(evaluate$1(), onError$2, effect_MutableRef.make(void 0), options));
/** @internal */
const writeInput = (writable, onFailure, { encoding, endOnDone = true } = {}, onDone = effect_Effect.void) => {
	const write = writeEffect(writable, encoding);
	const close$1 = endOnDone ? effect_Effect.async((resume$1) => {
		if ("closed" in writable && writable.closed) resume$1(effect_Effect.void);
		else {
			writable.once("finish", () => resume$1(effect_Effect.void));
			writable.end();
		}
	}) : effect_Effect.void;
	return {
		awaitRead: () => effect_Effect.void,
		emit: write,
		error: (cause$2) => effect_Effect.zipRight(close$1, onFailure(cause$2)),
		done: (_$1) => effect_Effect.zipRight(close$1, onDone)
	};
};
/** @internal */
const writeEffect = (writable, encoding) => (chunk$2) => chunk$2.length === 0 ? effect_Effect.void : effect_Effect.async((resume$1) => {
	const iterator = chunk$2[Symbol.iterator]();
	let next = iterator.next();
	function loop$2() {
		const item = next;
		next = iterator.next();
		const success = writable.write(item.value, encoding);
		if (next.done) resume$1(effect_Effect.void);
		else if (success) loop$2();
		else writable.once("drain", loop$2);
	}
	loop$2();
});
const unsafeReadableRead = (readable, onError$2, exit$3, options) => {
	if (!readable.readable) return effect_Channel.void;
	const latch = effect_Effect.unsafeMakeLatch(false);
	function onReadable() {
		latch.unsafeOpen();
	}
	function onErr(err) {
		exit$3.current = effect_Exit.fail(onError$2(err));
		latch.unsafeOpen();
	}
	function onEnd() {
		exit$3.current = effect_Exit.void;
		latch.unsafeOpen();
	}
	readable.on("readable", onReadable);
	readable.on("error", onErr);
	readable.on("end", onEnd);
	const chunkSize = options?.chunkSize ? Number(options.chunkSize) : void 0;
	const read = effect_Channel.suspend(function loop$2() {
		let item = readable.read(chunkSize);
		if (item === null) {
			if (exit$3.current) return effect_Channel.fromEffect(exit$3.current);
			latch.unsafeClose();
			return effect_Channel.flatMap(latch.await, loop$2);
		}
		const arr = [item];
		while (true) {
			item = readable.read(chunkSize);
			if (item === null) return effect_Channel.flatMap(effect_Channel.write(effect_Chunk.unsafeFromArray(arr)), loop$2);
			arr.push(item);
		}
	});
	return effect_Channel.ensuring(read, effect_Effect.sync(() => {
		readable.off("readable", onReadable);
		readable.off("error", onErr);
		readable.off("end", onEnd);
		if (options?.closeOnDone !== false && "closed" in readable && !readable.closed) readable.destroy();
	}));
};

//#endregion
//#region node_modules/.pnpm/@effect+platform-node-shared@0.51.6_@effect+cluster@0.50.6_@effect+platform@0.92.1_effe_5910e813a334008fa44d72e3c39ef97b/node_modules/@effect/platform-node-shared/dist/esm/internal/sink.js
/** @internal */
const fromWritable = (evaluate$1, onError$2, options) => effect_Sink.fromChannel(fromWritableChannel(evaluate$1, onError$2, options));
/** @internal */
const fromWritableChannel = (writable, onError$2, options) => effect_Channel.flatMap(effect_Effect.zip(effect_Effect.sync(() => writable()), effect_Deferred.make()), ([writable$1, deferred]) => effect_Channel.embedInput(writableOutput(writable$1, deferred, onError$2), writeInput(writable$1, (cause$2) => effect_Deferred.failCause(deferred, cause$2), options, effect_Deferred.complete(deferred, effect_Effect.void))));
const writableOutput = (writable, deferred, onError$2) => effect_Effect.suspend(() => {
	function handleError(err) {
		effect_Deferred.unsafeDone(deferred, effect_Effect.fail(onError$2(err)));
	}
	writable.on("error", handleError);
	return effect_Effect.ensuring(effect_Deferred.await(deferred), effect_Effect.sync(() => {
		writable.removeListener("error", handleError);
	}));
});

//#endregion
//#region node_modules/.pnpm/@effect+platform-node-shared@0.51.6_@effect+cluster@0.50.6_@effect+platform@0.92.1_effe_5910e813a334008fa44d72e3c39ef97b/node_modules/@effect/platform-node-shared/dist/esm/internal/error.js
/** @internal */
const handleErrnoException = (module$1, method) => (err, [path]) => {
	let reason = "Unknown";
	switch (err.code) {
		case "ENOENT":
			reason = "NotFound";
			break;
		case "EACCES":
			reason = "PermissionDenied";
			break;
		case "EEXIST":
			reason = "AlreadyExists";
			break;
		case "EISDIR":
			reason = "BadResource";
			break;
		case "ENOTDIR":
			reason = "BadResource";
			break;
		case "EBUSY":
			reason = "Busy";
			break;
		case "ELOOP":
			reason = "BadResource";
			break;
	}
	return new __effect_platform_Error.SystemError({
		reason,
		module: module$1,
		method,
		pathOrDescriptor: path,
		syscall: err.syscall,
		description: err.message,
		cause: err
	});
};

//#endregion
//#region node_modules/.pnpm/@effect+platform-node-shared@0.51.6_@effect+cluster@0.50.6_@effect+platform@0.92.1_effe_5910e813a334008fa44d72e3c39ef97b/node_modules/@effect/platform-node-shared/dist/esm/internal/commandExecutor.js
const inputToStdioOption = (stdin) => typeof stdin === "string" ? stdin : "pipe";
const outputToStdioOption = (output) => typeof output === "string" ? output : "pipe";
const toError = (err) => err instanceof globalThis.Error ? err : new globalThis.Error(String(err));
const toPlatformError = (method, error, command$1) => {
	const flattened = __effect_platform_Command.flatten(command$1).reduce((acc, curr) => {
		const command$2 = `${curr.command} ${curr.args.join(" ")}`;
		return acc.length === 0 ? command$2 : `${acc} | ${command$2}`;
	}, "");
	return handleErrnoException("Command", method)(error, [flattened]);
};
const ProcessProto = {
	[__effect_platform_CommandExecutor.ProcessTypeId]: __effect_platform_CommandExecutor.ProcessTypeId,
	...effect_Inspectable.BaseProto,
	toJSON() {
		return {
			_id: "@effect/platform/CommandExecutor/Process",
			pid: this.pid
		};
	}
};
const runCommand = (fileSystem) => (command$1) => {
	switch (command$1._tag) {
		case "StandardCommand": {
			const spawn = effect_Effect.flatMap(effect_Deferred.make(), (exitCode) => effect_Effect.async((resume$1) => {
				const handle = node_child_process.spawn(command$1.command, command$1.args, {
					stdio: [
						inputToStdioOption(command$1.stdin),
						outputToStdioOption(command$1.stdout),
						outputToStdioOption(command$1.stderr)
					],
					cwd: effect_Option.getOrElse(command$1.cwd, effect_Function.constUndefined),
					shell: command$1.shell,
					env: {
						...process.env,
						...Object.fromEntries(command$1.env)
					},
					detached: process.platform !== "win32"
				});
				handle.on("error", (err) => {
					resume$1(effect_Effect.fail(toPlatformError("spawn", err, command$1)));
				});
				handle.on("exit", (...args$2) => {
					effect_Deferred.unsafeDone(exitCode, effect_Effect.succeed(args$2));
				});
				handle.on("spawn", () => {
					resume$1(effect_Effect.succeed([handle, exitCode]));
				});
				return effect_Effect.sync(() => {
					handle.kill("SIGTERM");
				});
			}));
			const killProcessGroup = process.platform === "win32" ? (handle, _$1) => effect_Effect.async((resume$1) => {
				node_child_process.exec(`taskkill /pid ${handle.pid} /T /F`, (error) => {
					if (error) resume$1(effect_Effect.fail(toPlatformError("kill", toError(error), command$1)));
					else resume$1(effect_Effect.void);
				});
			}) : (handle, signal) => effect_Effect.try({
				try: () => process.kill(-handle.pid, signal),
				catch: (error) => toPlatformError("kill", toError(error), command$1)
			});
			const killProcess = (handle, signal) => effect_Effect.suspend(() => handle.kill(signal) ? effect_Effect.void : effect_Effect.fail(toPlatformError("kill", new globalThis.Error("Failed to kill process"), command$1)));
			return (0, effect_Function.pipe)(effect_Option.match(command$1.cwd, {
				onNone: () => effect_Effect.void,
				onSome: (dir) => fileSystem.access(dir)
			}), effect_Effect.zipRight(effect_Effect.acquireRelease(spawn, ([handle, exitCode]) => effect_Effect.flatMap(effect_Deferred.isDone(exitCode), (done$8) => {
				if (!done$8) return killProcessGroup(handle, "SIGTERM").pipe(effect_Effect.orElse(() => killProcess(handle, "SIGTERM")), effect_Effect.zipRight(effect_Deferred.await(exitCode)), effect_Effect.ignore);
				return effect_Effect.flatMap(effect_Deferred.await(exitCode), ([code]) => {
					if (code !== 0 && code !== null) return killProcessGroup(handle, "SIGTERM").pipe(effect_Effect.ignore);
					return effect_Effect.void;
				});
			}))), effect_Effect.map(([handle, exitCodeDeferred]) => {
				let stdin = effect_Sink.drain;
				if (handle.stdin !== null) stdin = fromWritable(() => handle.stdin, (err) => toPlatformError("toWritable", toError(err), command$1));
				const exitCode = effect_Effect.flatMap(effect_Deferred.await(exitCodeDeferred), ([code, signal]) => {
					if (code !== null) return effect_Effect.succeed(__effect_platform_CommandExecutor.ExitCode(code));
					return effect_Effect.fail(toPlatformError("exitCode", new globalThis.Error(`Process interrupted due to receipt of signal: ${signal}`), command$1));
				});
				const isRunning$2 = effect_Effect.negate(effect_Deferred.isDone(exitCodeDeferred));
				const kill = (signal = "SIGTERM") => killProcessGroup(handle, signal).pipe(effect_Effect.orElse(() => killProcess(handle, signal)), effect_Effect.zipRight(effect_Effect.asVoid(effect_Deferred.await(exitCodeDeferred))));
				const pid = __effect_platform_CommandExecutor.ProcessId(handle.pid);
				const stderr = fromReadable(() => handle.stderr, (err) => toPlatformError("fromReadable(stderr)", toError(err), command$1));
				let stdout = fromReadable(() => handle.stdout, (err) => toPlatformError("fromReadable(stdout)", toError(err), command$1));
				if (typeof command$1.stdout !== "string") stdout = effect_Stream.transduce(stdout, command$1.stdout);
				return Object.assign(Object.create(ProcessProto), {
					pid,
					exitCode,
					isRunning: isRunning$2,
					kill,
					stdin,
					stderr,
					stdout
				});
			}), typeof command$1.stdin === "string" ? effect_Function.identity : effect_Effect.tap((process$2) => effect_Effect.forkDaemon(effect_Stream.run(command$1.stdin, process$2.stdin))));
		}
		case "PipedCommand": {
			const flattened = __effect_platform_Command.flatten(command$1);
			if (flattened.length === 1) return (0, effect_Function.pipe)(flattened[0], runCommand(fileSystem));
			const head$4 = flattened[0];
			const tail = flattened.slice(1);
			const initial = tail.slice(0, tail.length - 1);
			const last$3 = tail[tail.length - 1];
			const stream$1 = initial.reduce((stdin, command$2) => (0, effect_Function.pipe)(__effect_platform_Command.stdin(command$2, stdin), runCommand(fileSystem), effect_Effect.map((process$2) => process$2.stdout), effect_Stream.unwrapScoped), (0, effect_Function.pipe)(runCommand(fileSystem)(head$4), effect_Effect.map((process$2) => process$2.stdout), effect_Stream.unwrapScoped));
			return (0, effect_Function.pipe)(__effect_platform_Command.stdin(last$3, stream$1), runCommand(fileSystem));
		}
	}
};
/** @internal */
const layer$10 = /* @__PURE__ */ effect_Layer.effect(__effect_platform_CommandExecutor.CommandExecutor, /* @__PURE__ */ (0, effect_Function.pipe)(__effect_platform_FileSystem.FileSystem, /* @__PURE__ */ effect_Effect.map((fileSystem) => __effect_platform_CommandExecutor.makeExecutor(runCommand(fileSystem)))));

//#endregion
//#region node_modules/.pnpm/@effect+platform-node-shared@0.51.6_@effect+cluster@0.50.6_@effect+platform@0.92.1_effe_5910e813a334008fa44d72e3c39ef97b/node_modules/@effect/platform-node-shared/dist/esm/NodeCommandExecutor.js
/**
* @since 1.0.0
* @category layer
*/
const layer$9 = layer$10;

//#endregion
//#region node_modules/.pnpm/@effect+platform-node-shared@0.51.6_@effect+cluster@0.50.6_@effect+platform@0.92.1_effe_5910e813a334008fa44d72e3c39ef97b/node_modules/@effect/platform-node-shared/dist/esm/internal/fileSystem.js
const handleBadArgument = (method) => (cause$2) => new __effect_platform_Error.BadArgument({
	module: "FileSystem",
	method,
	cause: cause$2
});
const access = /* @__PURE__ */ (() => {
	const nodeAccess = /* @__PURE__ */ (0, __effect_platform_Effectify.effectify)(node_fs.access, /* @__PURE__ */ handleErrnoException("FileSystem", "access"), /* @__PURE__ */ handleBadArgument("access"));
	return (path, options) => {
		let mode = node_fs.constants.F_OK;
		if (options?.readable) mode |= node_fs.constants.R_OK;
		if (options?.writable) mode |= node_fs.constants.W_OK;
		return nodeAccess(path, mode);
	};
})();
const copy = /* @__PURE__ */ (() => {
	const nodeCp = /* @__PURE__ */ (0, __effect_platform_Effectify.effectify)(node_fs.cp, /* @__PURE__ */ handleErrnoException("FileSystem", "copy"), /* @__PURE__ */ handleBadArgument("copy"));
	return (fromPath, toPath, options) => nodeCp(fromPath, toPath, {
		force: options?.overwrite ?? false,
		preserveTimestamps: options?.preserveTimestamps ?? false,
		recursive: true
	});
})();
const copyFile = /* @__PURE__ */ (() => {
	const nodeCopyFile = /* @__PURE__ */ (0, __effect_platform_Effectify.effectify)(node_fs.copyFile, /* @__PURE__ */ handleErrnoException("FileSystem", "copyFile"), /* @__PURE__ */ handleBadArgument("copyFile"));
	return (fromPath, toPath) => nodeCopyFile(fromPath, toPath);
})();
const chmod = /* @__PURE__ */ (() => {
	const nodeChmod = /* @__PURE__ */ (0, __effect_platform_Effectify.effectify)(node_fs.chmod, /* @__PURE__ */ handleErrnoException("FileSystem", "chmod"), /* @__PURE__ */ handleBadArgument("chmod"));
	return (path, mode) => nodeChmod(path, mode);
})();
const chown = /* @__PURE__ */ (() => {
	const nodeChown = /* @__PURE__ */ (0, __effect_platform_Effectify.effectify)(node_fs.chown, /* @__PURE__ */ handleErrnoException("FileSystem", "chown"), /* @__PURE__ */ handleBadArgument("chown"));
	return (path, uid, gid) => nodeChown(path, uid, gid);
})();
const link = /* @__PURE__ */ (() => {
	const nodeLink = /* @__PURE__ */ (0, __effect_platform_Effectify.effectify)(node_fs.link, /* @__PURE__ */ handleErrnoException("FileSystem", "link"), /* @__PURE__ */ handleBadArgument("link"));
	return (existingPath, newPath) => nodeLink(existingPath, newPath);
})();
const makeDirectory = /* @__PURE__ */ (() => {
	const nodeMkdir = /* @__PURE__ */ (0, __effect_platform_Effectify.effectify)(node_fs.mkdir, /* @__PURE__ */ handleErrnoException("FileSystem", "makeDirectory"), /* @__PURE__ */ handleBadArgument("makeDirectory"));
	return (path, options) => nodeMkdir(path, {
		recursive: options?.recursive ?? false,
		mode: options?.mode
	});
})();
const makeTempDirectoryFactory = (method) => {
	const nodeMkdtemp = (0, __effect_platform_Effectify.effectify)(node_fs.mkdtemp, handleErrnoException("FileSystem", method), handleBadArgument(method));
	return (options) => effect_Effect.suspend(() => {
		const prefix = options?.prefix ?? "";
		const directory = typeof options?.directory === "string" ? node_path.join(options.directory, ".") : node_os.tmpdir();
		return nodeMkdtemp(prefix ? node_path.join(directory, prefix) : directory + "/");
	});
};
const makeTempDirectory = /* @__PURE__ */ makeTempDirectoryFactory("makeTempDirectory");
const removeFactory = (method) => {
	const nodeRm = (0, __effect_platform_Effectify.effectify)(node_fs.rm, handleErrnoException("FileSystem", method), handleBadArgument(method));
	return (path, options) => nodeRm(path, {
		recursive: options?.recursive ?? false,
		force: options?.force ?? false
	});
};
const remove = /* @__PURE__ */ removeFactory("remove");
const makeTempDirectoryScoped = /* @__PURE__ */ (() => {
	const makeDirectory$1 = /* @__PURE__ */ makeTempDirectoryFactory("makeTempDirectoryScoped");
	const removeDirectory = /* @__PURE__ */ removeFactory("makeTempDirectoryScoped");
	return (options) => effect_Effect.acquireRelease(makeDirectory$1(options), (directory) => effect_Effect.orDie(removeDirectory(directory, { recursive: true })));
})();
const openFactory = (method) => {
	const nodeOpen = (0, __effect_platform_Effectify.effectify)(node_fs.open, handleErrnoException("FileSystem", method), handleBadArgument(method));
	const nodeClose = (0, __effect_platform_Effectify.effectify)(node_fs.close, handleErrnoException("FileSystem", method), handleBadArgument(method));
	return (path, options) => (0, effect_Function.pipe)(effect_Effect.acquireRelease(nodeOpen(path, options?.flag ?? "r", options?.mode), (fd) => effect_Effect.orDie(nodeClose(fd))), effect_Effect.map((fd) => makeFile(__effect_platform_FileSystem.FileDescriptor(fd), options?.flag?.startsWith("a") ?? false)));
};
const open = /* @__PURE__ */ openFactory("open");
const makeFile = /* @__PURE__ */ (() => {
	const nodeReadFactory = (method) => (0, __effect_platform_Effectify.effectify)(node_fs.read, handleErrnoException("FileSystem", method), handleBadArgument(method));
	const nodeRead = /* @__PURE__ */ nodeReadFactory("read");
	const nodeReadAlloc = /* @__PURE__ */ nodeReadFactory("readAlloc");
	const nodeStat = /* @__PURE__ */ (0, __effect_platform_Effectify.effectify)(node_fs.fstat, /* @__PURE__ */ handleErrnoException("FileSystem", "stat"), /* @__PURE__ */ handleBadArgument("stat"));
	const nodeTruncate = /* @__PURE__ */ (0, __effect_platform_Effectify.effectify)(node_fs.ftruncate, /* @__PURE__ */ handleErrnoException("FileSystem", "truncate"), /* @__PURE__ */ handleBadArgument("truncate"));
	const nodeSync = /* @__PURE__ */ (0, __effect_platform_Effectify.effectify)(node_fs.fsync, /* @__PURE__ */ handleErrnoException("FileSystem", "sync"), /* @__PURE__ */ handleBadArgument("sync"));
	const nodeWriteFactory = (method) => (0, __effect_platform_Effectify.effectify)(node_fs.write, handleErrnoException("FileSystem", method), handleBadArgument(method));
	const nodeWrite = /* @__PURE__ */ nodeWriteFactory("write");
	const nodeWriteAll = /* @__PURE__ */ nodeWriteFactory("writeAll");
	class FileImpl {
		fd;
		append;
		[__effect_platform_FileSystem.FileTypeId];
		semaphore = /* @__PURE__ */ effect_Effect.unsafeMakeSemaphore(1);
		position = 0n;
		constructor(fd, append$3) {
			this.fd = fd;
			this.append = append$3;
			this[__effect_platform_FileSystem.FileTypeId] = __effect_platform_FileSystem.FileTypeId;
		}
		get stat() {
			return effect_Effect.map(nodeStat(this.fd), makeFileInfo);
		}
		get sync() {
			return nodeSync(this.fd);
		}
		seek(offset, from) {
			const offsetSize = __effect_platform_FileSystem.Size(offset);
			return this.semaphore.withPermits(1)(effect_Effect.sync(() => {
				if (from === "start") this.position = offsetSize;
				else if (from === "current") this.position = this.position + offsetSize;
				return this.position;
			}));
		}
		read(buffer) {
			return this.semaphore.withPermits(1)(effect_Effect.map(effect_Effect.suspend(() => nodeRead(this.fd, {
				buffer,
				position: this.position
			})), (bytesRead) => {
				const sizeRead = __effect_platform_FileSystem.Size(bytesRead);
				this.position = this.position + sizeRead;
				return sizeRead;
			}));
		}
		readAlloc(size$11) {
			const sizeNumber = Number(size$11);
			return this.semaphore.withPermits(1)(effect_Effect.flatMap(effect_Effect.sync(() => Buffer.allocUnsafeSlow(sizeNumber)), (buffer) => effect_Effect.map(nodeReadAlloc(this.fd, {
				buffer,
				position: this.position
			}), (bytesRead) => {
				if (bytesRead === 0) return effect_Option.none();
				this.position = this.position + BigInt(bytesRead);
				if (bytesRead === sizeNumber) return effect_Option.some(buffer);
				const dst = Buffer.allocUnsafeSlow(bytesRead);
				buffer.copy(dst, 0, 0, bytesRead);
				return effect_Option.some(dst);
			})));
		}
		truncate(length$1) {
			return this.semaphore.withPermits(1)(effect_Effect.map(nodeTruncate(this.fd, length$1 ? Number(length$1) : void 0), () => {
				if (!this.append) {
					const len = BigInt(length$1 ?? 0);
					if (this.position > len) this.position = len;
				}
			}));
		}
		write(buffer) {
			return this.semaphore.withPermits(1)(effect_Effect.map(effect_Effect.suspend(() => nodeWrite(this.fd, buffer, void 0, void 0, this.append ? void 0 : Number(this.position))), (bytesWritten) => {
				const sizeWritten = __effect_platform_FileSystem.Size(bytesWritten);
				if (!this.append) this.position = this.position + sizeWritten;
				return sizeWritten;
			}));
		}
		writeAllChunk(buffer) {
			return effect_Effect.flatMap(effect_Effect.suspend(() => nodeWriteAll(this.fd, buffer, void 0, void 0, this.append ? void 0 : Number(this.position))), (bytesWritten) => {
				if (bytesWritten === 0) return effect_Effect.fail(new __effect_platform_Error.SystemError({
					module: "FileSystem",
					method: "writeAll",
					reason: "WriteZero",
					pathOrDescriptor: this.fd,
					description: "write returned 0 bytes written"
				}));
				if (!this.append) this.position = this.position + BigInt(bytesWritten);
				return bytesWritten < buffer.length ? this.writeAllChunk(buffer.subarray(bytesWritten)) : effect_Effect.void;
			});
		}
		writeAll(buffer) {
			return this.semaphore.withPermits(1)(this.writeAllChunk(buffer));
		}
	}
	return (fd, append$3) => new FileImpl(fd, append$3);
})();
const makeTempFileFactory = (method) => {
	const makeDirectory$1 = makeTempDirectoryFactory(method);
	const open$1 = openFactory(method);
	const randomHexString$1 = (bytes) => effect_Effect.sync(() => node_crypto.randomBytes(bytes).toString("hex"));
	return (options) => (0, effect_Function.pipe)(effect_Effect.zip(makeDirectory$1(options), randomHexString$1(6)), effect_Effect.map(([directory, random$3]) => node_path.join(directory, random$3 + (options?.suffix ?? ""))), effect_Effect.tap((path) => effect_Effect.scoped(open$1(path, { flag: "w+" }))));
};
const makeTempFile = /* @__PURE__ */ makeTempFileFactory("makeTempFile");
const makeTempFileScoped = /* @__PURE__ */ (() => {
	const makeFile$1 = /* @__PURE__ */ makeTempFileFactory("makeTempFileScoped");
	const removeDirectory = /* @__PURE__ */ removeFactory("makeTempFileScoped");
	return (options) => effect_Effect.acquireRelease(makeFile$1(options), (file) => effect_Effect.orDie(removeDirectory(node_path.dirname(file), { recursive: true })));
})();
const readDirectory = (path, options) => effect_Effect.tryPromise({
	try: () => node_fs.promises.readdir(path, options),
	catch: (err) => handleErrnoException("FileSystem", "readDirectory")(err, [path])
});
const readFile = (path) => effect_Effect.async((resume$1, signal) => {
	try {
		node_fs.readFile(path, { signal }, (err, data) => {
			if (err) resume$1(effect_Effect.fail(handleErrnoException("FileSystem", "readFile")(err, [path])));
			else resume$1(effect_Effect.succeed(data));
		});
	} catch (err) {
		resume$1(effect_Effect.fail(handleBadArgument("readFile")(err)));
	}
});
const readLink = /* @__PURE__ */ (() => {
	const nodeReadLink = /* @__PURE__ */ (0, __effect_platform_Effectify.effectify)(node_fs.readlink, /* @__PURE__ */ handleErrnoException("FileSystem", "readLink"), /* @__PURE__ */ handleBadArgument("readLink"));
	return (path) => nodeReadLink(path);
})();
const realPath = /* @__PURE__ */ (() => {
	const nodeRealPath = /* @__PURE__ */ (0, __effect_platform_Effectify.effectify)(node_fs.realpath, /* @__PURE__ */ handleErrnoException("FileSystem", "realPath"), /* @__PURE__ */ handleBadArgument("realPath"));
	return (path) => nodeRealPath(path);
})();
const rename = /* @__PURE__ */ (() => {
	const nodeRename = /* @__PURE__ */ (0, __effect_platform_Effectify.effectify)(node_fs.rename, /* @__PURE__ */ handleErrnoException("FileSystem", "rename"), /* @__PURE__ */ handleBadArgument("rename"));
	return (oldPath, newPath) => nodeRename(oldPath, newPath);
})();
const makeFileInfo = (stat$1) => ({
	type: stat$1.isFile() ? "File" : stat$1.isDirectory() ? "Directory" : stat$1.isSymbolicLink() ? "SymbolicLink" : stat$1.isBlockDevice() ? "BlockDevice" : stat$1.isCharacterDevice() ? "CharacterDevice" : stat$1.isFIFO() ? "FIFO" : stat$1.isSocket() ? "Socket" : "Unknown",
	mtime: effect_Option.fromNullable(stat$1.mtime),
	atime: effect_Option.fromNullable(stat$1.atime),
	birthtime: effect_Option.fromNullable(stat$1.birthtime),
	dev: stat$1.dev,
	rdev: effect_Option.fromNullable(stat$1.rdev),
	ino: effect_Option.fromNullable(stat$1.ino),
	mode: stat$1.mode,
	nlink: effect_Option.fromNullable(stat$1.nlink),
	uid: effect_Option.fromNullable(stat$1.uid),
	gid: effect_Option.fromNullable(stat$1.gid),
	size: __effect_platform_FileSystem.Size(stat$1.size),
	blksize: effect_Option.map(effect_Option.fromNullable(stat$1.blksize), __effect_platform_FileSystem.Size),
	blocks: effect_Option.fromNullable(stat$1.blocks)
});
const stat = /* @__PURE__ */ (() => {
	const nodeStat = /* @__PURE__ */ (0, __effect_platform_Effectify.effectify)(node_fs.stat, /* @__PURE__ */ handleErrnoException("FileSystem", "stat"), /* @__PURE__ */ handleBadArgument("stat"));
	return (path) => effect_Effect.map(nodeStat(path), makeFileInfo);
})();
const symlink = /* @__PURE__ */ (() => {
	const nodeSymlink = /* @__PURE__ */ (0, __effect_platform_Effectify.effectify)(node_fs.symlink, /* @__PURE__ */ handleErrnoException("FileSystem", "symlink"), /* @__PURE__ */ handleBadArgument("symlink"));
	return (target, path) => nodeSymlink(target, path);
})();
const truncate = /* @__PURE__ */ (() => {
	const nodeTruncate = /* @__PURE__ */ (0, __effect_platform_Effectify.effectify)(node_fs.truncate, /* @__PURE__ */ handleErrnoException("FileSystem", "truncate"), /* @__PURE__ */ handleBadArgument("truncate"));
	return (path, length$1) => nodeTruncate(path, length$1 !== void 0 ? Number(length$1) : void 0);
})();
const utimes = /* @__PURE__ */ (() => {
	const nodeUtimes = /* @__PURE__ */ (0, __effect_platform_Effectify.effectify)(node_fs.utimes, /* @__PURE__ */ handleErrnoException("FileSystem", "utime"), /* @__PURE__ */ handleBadArgument("utime"));
	return (path, atime, mtime) => nodeUtimes(path, atime, mtime);
})();
const watchNode = (path, options) => effect_Stream.asyncScoped((emit) => effect_Effect.acquireRelease(effect_Effect.sync(() => {
	const watcher = node_fs.watch(path, { recursive: options?.recursive }, (event, path$1) => {
		if (!path$1) return;
		switch (event) {
			case "rename":
				emit.fromEffect(effect_Effect.matchEffect(stat(path$1), {
					onSuccess: (_$1) => effect_Effect.succeed(__effect_platform_FileSystem.WatchEventCreate({ path: path$1 })),
					onFailure: (err) => err._tag === "SystemError" && err.reason === "NotFound" ? effect_Effect.succeed(__effect_platform_FileSystem.WatchEventRemove({ path: path$1 })) : effect_Effect.fail(err)
				}));
				return;
			case "change":
				emit.single(__effect_platform_FileSystem.WatchEventUpdate({ path: path$1 }));
				return;
		}
	});
	watcher.on("error", (error) => {
		emit.fail(new __effect_platform_Error.SystemError({
			module: "FileSystem",
			reason: "Unknown",
			method: "watch",
			pathOrDescriptor: path,
			cause: error
		}));
	});
	watcher.on("close", () => {
		emit.end();
	});
	return watcher;
}), (watcher) => effect_Effect.sync(() => watcher.close())));
const watch = (backend, path, options) => stat(path).pipe(effect_Effect.map((stat$1) => backend.pipe(effect_Option.flatMap((_$1) => _$1.register(path, stat$1, options)), effect_Option.getOrElse(() => watchNode(path, options)))), effect_Stream.unwrap);
const writeFile = (path, data, options) => effect_Effect.async((resume$1, signal) => {
	try {
		node_fs.writeFile(path, data, {
			signal,
			flag: options?.flag,
			mode: options?.mode
		}, (err) => {
			if (err) resume$1(effect_Effect.fail(handleErrnoException("FileSystem", "writeFile")(err, [path])));
			else resume$1(effect_Effect.void);
		});
	} catch (err) {
		resume$1(effect_Effect.fail(handleBadArgument("writeFile")(err)));
	}
});
const makeFileSystem = /* @__PURE__ */ effect_Effect.map(/* @__PURE__ */ effect_Effect.serviceOption(__effect_platform_FileSystem.WatchBackend), (backend) => __effect_platform_FileSystem.make({
	access,
	chmod,
	chown,
	copy,
	copyFile,
	link,
	makeDirectory,
	makeTempDirectory,
	makeTempDirectoryScoped,
	makeTempFile,
	makeTempFileScoped,
	open,
	readDirectory,
	readFile,
	readLink,
	realPath,
	remove,
	rename,
	stat,
	symlink,
	truncate,
	utimes,
	watch(path, options) {
		return watch(backend, path, options);
	},
	writeFile
}));
/** @internal */
const layer$8 = /* @__PURE__ */ effect_Layer.effect(__effect_platform_FileSystem.FileSystem, makeFileSystem);

//#endregion
//#region node_modules/.pnpm/@effect+platform-node-shared@0.51.6_@effect+cluster@0.50.6_@effect+platform@0.92.1_effe_5910e813a334008fa44d72e3c39ef97b/node_modules/@effect/platform-node-shared/dist/esm/NodeFileSystem.js
/**
* @since 1.0.0
* @category layer
*/
const layer$7 = layer$8;

//#endregion
//#region node_modules/.pnpm/@effect+platform-node-shared@0.51.6_@effect+cluster@0.50.6_@effect+platform@0.92.1_effe_5910e813a334008fa44d72e3c39ef97b/node_modules/@effect/platform-node-shared/dist/esm/internal/path.js
const fromFileUrl = (url) => effect_Effect.try({
	try: () => node_url.fileURLToPath(url),
	catch: (error) => new __effect_platform_Error.BadArgument({
		module: "Path",
		method: "fromFileUrl",
		description: `Invalid file URL: ${url}`,
		cause: error
	})
});
const toFileUrl = (path) => effect_Effect.try({
	try: () => node_url.pathToFileURL(path),
	catch: (error) => new __effect_platform_Error.BadArgument({
		module: "Path",
		method: "toFileUrl",
		description: `Invalid path: ${path}`,
		cause: error
	})
});
/** @internal */
const layerPosix$1 = /* @__PURE__ */ effect_Layer.succeed(__effect_platform_Path.Path, /* @__PURE__ */ __effect_platform_Path.Path.of({
	[__effect_platform_Path.TypeId]: __effect_platform_Path.TypeId,
	...node_path.posix,
	fromFileUrl,
	toFileUrl
}));
/** @internal */
const layerWin32$1 = /* @__PURE__ */ effect_Layer.succeed(__effect_platform_Path.Path, /* @__PURE__ */ __effect_platform_Path.Path.of({
	[__effect_platform_Path.TypeId]: __effect_platform_Path.TypeId,
	...node_path.win32,
	fromFileUrl,
	toFileUrl
}));
/** @internal */
const layer$6 = /* @__PURE__ */ effect_Layer.succeed(__effect_platform_Path.Path, /* @__PURE__ */ __effect_platform_Path.Path.of({
	[__effect_platform_Path.TypeId]: __effect_platform_Path.TypeId,
	...node_path,
	fromFileUrl,
	toFileUrl
}));

//#endregion
//#region node_modules/.pnpm/@effect+platform-node-shared@0.51.6_@effect+cluster@0.50.6_@effect+platform@0.92.1_effe_5910e813a334008fa44d72e3c39ef97b/node_modules/@effect/platform-node-shared/dist/esm/NodePath.js
/**
* @since 1.0.0
* @category layer
*/
const layer$5 = layer$6;
/**
* @since 1.0.0
* @category layer
*/
const layerPosix = layerPosix$1;
/**
* @since 1.0.0
* @category layer
*/
const layerWin32 = layerWin32$1;

//#endregion
//#region node_modules/.pnpm/@effect+platform-node-shared@0.51.6_@effect+cluster@0.50.6_@effect+platform@0.92.1_effe_5910e813a334008fa44d72e3c39ef97b/node_modules/@effect/platform-node-shared/dist/esm/internal/terminal.js
const defaultShouldQuit = (input) => input.key.ctrl && (input.key.name === "c" || input.key.name === "d");
/** @internal */
const make$1 = /* @__PURE__ */ effect_Effect.fnUntraced(function* (shouldQuit = defaultShouldQuit) {
	const stdin = process.stdin;
	const stdout = process.stdout;
	const rlRef = yield* effect_RcRef.make({ acquire: effect_Effect.acquireRelease(effect_Effect.sync(() => {
		const rl = node_readline.createInterface({
			input: stdin,
			escapeCodeTimeout: 50
		});
		node_readline.emitKeypressEvents(stdin, rl);
		if (stdin.isTTY) stdin.setRawMode(true);
		return rl;
	}), (rl) => effect_Effect.sync(() => {
		if (stdin.isTTY) stdin.setRawMode(false);
		rl.close();
	})) });
	const columns = effect_Effect.sync(() => stdout.columns ?? 0);
	const readInput = effect_Effect.gen(function* () {
		yield* effect_RcRef.get(rlRef);
		const mailbox = yield* effect_Mailbox.make();
		const handleKeypress = (s$1, k) => {
			const userInput = {
				input: effect_Option.fromNullable(s$1),
				key: {
					name: k.name ?? "",
					ctrl: !!k.ctrl,
					meta: !!k.meta,
					shift: !!k.shift
				}
			};
			mailbox.unsafeOffer(userInput);
			if (shouldQuit(userInput)) mailbox.unsafeDone(effect_Exit.void);
		};
		yield* effect_Effect.addFinalizer(() => effect_Effect.sync(() => stdin.off("keypress", handleKeypress)));
		stdin.on("keypress", handleKeypress);
		return mailbox;
	});
	const readLine = effect_RcRef.get(rlRef).pipe(effect_Effect.flatMap((readlineInterface) => effect_Effect.async((resume$1) => {
		const onLine = (line) => resume$1(effect_Effect.succeed(line));
		readlineInterface.once("line", onLine);
		return effect_Effect.sync(() => readlineInterface.off("line", onLine));
	})), effect_Effect.scoped);
	const display = (prompt) => effect_Effect.uninterruptible(effect_Effect.async((resume$1) => {
		stdout.write(prompt, (err) => err ? resume$1(effect_Effect.fail(new __effect_platform_Error.BadArgument({
			module: "Terminal",
			method: "display",
			description: "Failed to write prompt to stdout",
			cause: err
		}))) : resume$1(effect_Effect.void));
	}));
	return __effect_platform_Terminal.Terminal.of({
		columns,
		readInput,
		readLine,
		display
	});
});
/** @internal */
const layer$4 = /* @__PURE__ */ effect_Layer.scoped(__effect_platform_Terminal.Terminal, /* @__PURE__ */ make$1(defaultShouldQuit));

//#endregion
//#region node_modules/.pnpm/@effect+platform-node-shared@0.51.6_@effect+cluster@0.50.6_@effect+platform@0.92.1_effe_5910e813a334008fa44d72e3c39ef97b/node_modules/@effect/platform-node-shared/dist/esm/NodeTerminal.js
/**
* @since 1.0.0
* @category constructors
*/
const make = make$1;
/**
* @since 1.0.0
* @category layer
*/
const layer$3 = layer$4;

//#endregion
//#region node_modules/.pnpm/@effect+platform-node@0.98.4_@effect+cluster@0.50.6_@effect+platform@0.92.1_effect@3.18_093e0e62dcff7652658471c1268ec537/node_modules/@effect/platform-node/dist/esm/internal/worker.js
const platformWorkerImpl = /* @__PURE__ */ __effect_platform_Worker.makePlatform()({
	setup({ scope: scope$2, worker }) {
		return effect_Effect.flatMap(effect_Deferred.make(), (exitDeferred) => {
			const thing = "postMessage" in worker ? {
				postMessage(msg, t$1) {
					worker.postMessage(msg, t$1);
				},
				kill: () => worker.terminate(),
				worker
			} : {
				postMessage(msg, _$1) {
					worker.send(msg);
				},
				kill: () => worker.kill("SIGKILL"),
				worker
			};
			worker.on("exit", () => {
				effect_Deferred.unsafeDone(exitDeferred, effect_Exit.void);
			});
			return effect_Effect.as(effect_Scope.addFinalizer(scope$2, effect_Effect.suspend(() => {
				thing.postMessage([1]);
				return effect_Deferred.await(exitDeferred);
			}).pipe(effect_Effect.interruptible, effect_Effect.timeout(5e3), effect_Effect.catchAllCause(() => effect_Effect.sync(() => thing.kill())))), thing);
		});
	},
	listen({ deferred, emit, port }) {
		port.worker.on("message", (message) => {
			emit(message);
		});
		port.worker.on("messageerror", (cause$2) => {
			effect_Deferred.unsafeDone(deferred, new __effect_platform_WorkerError.WorkerError({
				reason: "decode",
				cause: cause$2
			}));
		});
		port.worker.on("error", (cause$2) => {
			effect_Deferred.unsafeDone(deferred, new __effect_platform_WorkerError.WorkerError({
				reason: "unknown",
				cause: cause$2
			}));
		});
		port.worker.on("exit", (code) => {
			effect_Deferred.unsafeDone(deferred, new __effect_platform_WorkerError.WorkerError({
				reason: "unknown",
				cause: /* @__PURE__ */ new Error(`exited with code ${code}`)
			}));
		});
		return effect_Effect.void;
	}
});
/** @internal */
const layerWorker$1 = /* @__PURE__ */ effect_Layer.succeed(__effect_platform_Worker.PlatformWorker, platformWorkerImpl);
/** @internal */
const layerManager$1 = /* @__PURE__ */ effect_Layer.provide(__effect_platform_Worker.layerManager, layerWorker$1);
/** @internal */
const layer$2 = (spawn) => effect_Layer.merge(layerManager$1, __effect_platform_Worker.layerSpawner(spawn));
/** @internal */
const layerPlatform$1 = (spawn) => effect_Layer.merge(layerWorker$1, __effect_platform_Worker.layerSpawner(spawn));

//#endregion
//#region node_modules/.pnpm/@effect+platform-node@0.98.4_@effect+cluster@0.50.6_@effect+platform@0.92.1_effect@3.18_093e0e62dcff7652658471c1268ec537/node_modules/@effect/platform-node/dist/esm/NodeWorker.js
/**
* @since 1.0.0
* @category layers
*/
const layerManager = layerManager$1;
/**
* @since 1.0.0
* @category layers
*/
const layerWorker = layerWorker$1;
/**
* @since 1.0.0
* @category layers
*/
const layer$1 = layer$2;
/**
* @since 1.0.0
* @category layers
*/
const layerPlatform = layerPlatform$1;

//#endregion
//#region node_modules/.pnpm/@effect+platform-node@0.98.4_@effect+cluster@0.50.6_@effect+platform@0.92.1_effect@3.18_093e0e62dcff7652658471c1268ec537/node_modules/@effect/platform-node/dist/esm/NodeContext.js
/**
* @since 1.0.0
* @category layer
*/
const layer = /* @__PURE__ */ (0, effect_Function.pipe)(/* @__PURE__ */ effect_Layer.mergeAll(layer$5, layer$9, layer$3, layerManager), /* @__PURE__ */ effect_Layer.provideMerge(layer$7));

//#endregion
//#region node_modules/.pnpm/@effect+platform-node-shared@0.51.6_@effect+cluster@0.50.6_@effect+platform@0.92.1_effe_5910e813a334008fa44d72e3c39ef97b/node_modules/@effect/platform-node-shared/dist/esm/internal/runtime.js
/** @internal */
const runMain$2 = /* @__PURE__ */ (0, __effect_platform_Runtime.makeRunMain)(({ fiber, teardown }) => {
	const keepAlive = setInterval(effect_Function.constVoid, 2 ** 31 - 1);
	let receivedSignal = false;
	fiber.addObserver((exit$3) => {
		if (!receivedSignal) {
			process.removeListener("SIGINT", onSigint);
			process.removeListener("SIGTERM", onSigint);
		}
		clearInterval(keepAlive);
		teardown(exit$3, (code) => {
			if (receivedSignal || code !== 0) process.exit(code);
		});
	});
	function onSigint() {
		receivedSignal = true;
		process.removeListener("SIGINT", onSigint);
		process.removeListener("SIGTERM", onSigint);
		fiber.unsafeInterruptAsFork(fiber.id());
	}
	process.on("SIGINT", onSigint);
	process.on("SIGTERM", onSigint);
});

//#endregion
//#region node_modules/.pnpm/@effect+platform-node-shared@0.51.6_@effect+cluster@0.50.6_@effect+platform@0.92.1_effe_5910e813a334008fa44d72e3c39ef97b/node_modules/@effect/platform-node-shared/dist/esm/NodeRuntime.js
/**
* @since 1.0.0
* @category runtime
*/
const runMain$1 = runMain$2;

//#endregion
//#region node_modules/.pnpm/@effect+platform-node@0.98.4_@effect+cluster@0.50.6_@effect+platform@0.92.1_effect@3.18_093e0e62dcff7652658471c1268ec537/node_modules/@effect/platform-node/dist/esm/NodeRuntime.js
/**
* @since 1.0.0
* @category runtime
*/
const runMain = runMain$1;

//#endregion
//#region src/main.ts
const args = process.argv.slice(2);
const verb = args[0];
const params = args.slice(1);
const program = gen(function* () {
	const yawn = yield* Yawn.init;
	if (!verb) {
		yield* yawn.install(params);
		return;
	}
	const command$1 = commands.find((command$2) => command$2.aliases.includes(verb));
	if (!command$1) {
		consola.error(`Unknown command: ${verb}`);
		process.exit(1);
	}
	yield* yawn[command$1.id](params);
});
runMain(program.pipe(provide(layer)));

//#endregion