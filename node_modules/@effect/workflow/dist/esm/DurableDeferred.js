import * as Context from "effect/Context";
import * as Effect from "effect/Effect";
import * as Encoding from "effect/Encoding";
import * as Exit from "effect/Exit";
import { dual } from "effect/Function";
import * as Option from "effect/Option";
import * as Schema from "effect/Schema";
import * as Workflow from "./Workflow.js";
/**
 * @since 1.0.0
 * @category Symbols
 */
export const TypeId = /*#__PURE__*/Symbol.for("@effect/workflow/DurableDeferred");
/**
 * @since 1.0.0
 * @category Constructors
 */
export const make = (name, options) => ({
  [TypeId]: TypeId,
  name,
  successSchema: options?.success ?? Schema.Void,
  errorSchema: options?.error ?? Schema.Never,
  exitSchema: Schema.Exit({
    success: options?.success ?? Schema.Void,
    failure: options?.error ?? Schema.Never,
    defect: Schema.Defect
  }),
  withActivityAttempt: Effect.gen(function* () {
    const attempt = yield* CurrentAttempt;
    return make(`${name}/${attempt}`, {
      success: options?.success,
      error: options?.error
    });
  })
});
const EngineTag = /*#__PURE__*/Context.GenericTag("@effect/workflow/WorkflowEngine");
const InstanceTag = /*#__PURE__*/Context.GenericTag("@effect/workflow/WorkflowEngine/WorkflowInstance");
const CurrentAttempt = /*#__PURE__*/Context.Reference()("@effect/workflow/Activity/CurrentAttempt", {
  defaultValue: () => 1
});
const await_ = /*#__PURE__*/Effect.fnUntraced(function* (self) {
  const engine = yield* EngineTag;
  const instance = yield* InstanceTag;
  const oexit = yield* Workflow.wrapActivityResult(engine.deferredResult(self), Option.isNone);
  if (Option.isNone(oexit)) {
    return yield* Workflow.suspend(instance);
  }
  return yield* Effect.flatten(Effect.orDie(Schema.decodeUnknown(self.exitSchema)(oexit.value)));
});
export {
/**
 * @since 1.0.0
 * @category Combinators
 */
await_ as await };
/**
 * @since 1.0.0
 * @category Combinators
 */
export const into = /*#__PURE__*/dual(2, (effect, self) => Effect.contextWithEffect(context => {
  const engine = Context.get(context, EngineTag);
  const instance = Context.get(context, InstanceTag);
  return Effect.onExit(effect, Effect.fnUntraced(function* (exit) {
    if (instance.suspended) return;
    const encodedExit = yield* Effect.orDie(Schema.encode(self.exitSchema)(exit));
    yield* engine.deferredDone({
      workflowName: instance.workflow.name,
      executionId: instance.executionId,
      deferredName: self.name,
      exit: encodedExit
    });
  }));
}));
/**
 * @since 1.0.0
 * @category Racing
 */
export const raceAll = options => {
  const deferred = make(`raceAll/${options.name}`, {
    success: options.success,
    error: options.error
  });
  return Effect.gen(function* () {
    const engine = yield* EngineTag;
    const oexit = yield* Workflow.wrapActivityResult(engine.deferredResult(deferred), Option.isNone);
    if (Option.isSome(oexit)) {
      return yield* Effect.flatten(Effect.orDie(Schema.decodeUnknown(deferred.exitSchema)(oexit.value)));
    }
    return yield* into(Effect.raceAll(options.effects), deferred);
  });
};
/**
 * @since 1.0.0
 * @category Token
 */
export const TokenTypeId = /*#__PURE__*/Symbol.for("@effect/workflow/DurableDeferred/Token");
/**
 * @since 1.0.0
 * @category Token
 */
export const Token = /*#__PURE__*/Schema.String.pipe(/*#__PURE__*/Schema.brand(TokenTypeId));
/**
 * @since 1.0.0
 * @category Token
 */
export class TokenParsed extends /*#__PURE__*/Schema.Class("@effect/workflow/DurableDeferred/TokenParsed")({
  workflowName: Schema.String,
  executionId: Schema.String,
  deferredName: Schema.String
}) {
  /**
   * @since 1.0.0
   */
  get asToken() {
    return Encoding.encodeBase64Url(JSON.stringify([this.workflowName, this.executionId, this.deferredName]));
  }
  /**
   * @since 1.0.0
   */
  static FromString = /*#__PURE__*/Schema.StringFromBase64Url.pipe(/*#__PURE__*/Schema.compose(/*#__PURE__*/Schema.parseJson(/*#__PURE__*/Schema.Tuple(Schema.String, Schema.String, Schema.String))), /*#__PURE__*/Schema.transform(TokenParsed, {
    decode: ([workflowName, executionId, deferredName]) => new TokenParsed({
      workflowName,
      executionId,
      deferredName
    }),
    encode: parsed => [parsed.workflowName, parsed.executionId, parsed.deferredName]
  }));
  /**
   * @since 1.0.0
   */
  static fromString = /*#__PURE__*/Schema.decodeSync(TokenParsed.FromString);
  /**
   * @since 1.0.0
   */
  static encode = /*#__PURE__*/Schema.encodeSync(TokenParsed.FromString);
}
/**
 * @since 1.0.0
 * @category Token
 */
export const token = /*#__PURE__*/Effect.fnUntraced(function* (self) {
  const instance = yield* InstanceTag;
  return tokenFromExecutionId(self, instance);
});
/**
 * @since 1.0.0
 * @category Token
 */
export const tokenFromExecutionId = /*#__PURE__*/dual(2, (self, options) => new TokenParsed({
  workflowName: options.workflow.name,
  executionId: options.executionId,
  deferredName: self.name
}).asToken);
/**
 * @since 1.0.0
 * @category Token
 */
export const tokenFromPayload = /*#__PURE__*/dual(2, (self, options) => Effect.map(options.workflow.executionId(options.payload), executionId => tokenFromExecutionId(self, {
  workflow: options.workflow,
  executionId
})));
/**
 * @since 1.0.0
 * @category Combinators
 */
export const done = /*#__PURE__*/dual(2, /*#__PURE__*/Effect.fnUntraced(function* (self, options) {
  const engine = yield* EngineTag;
  const token = TokenParsed.fromString(options.token);
  const exit = yield* Schema.encode(self.exitSchema)(options.exit);
  yield* engine.deferredDone({
    workflowName: token.workflowName,
    executionId: token.executionId,
    deferredName: token.deferredName,
    exit: exit
  });
}, Effect.orDie));
/**
 * @since 1.0.0
 * @category Combinators
 */
export const succeed = /*#__PURE__*/dual(2, (self, options) => done(self, {
  token: options.token,
  exit: Exit.succeed(options.value)
}));
/**
 * @since 1.0.0
 * @category Combinators
 */
export const fail = /*#__PURE__*/dual(2, (self, options) => done(self, {
  token: options.token,
  exit: Exit.fail(options.error)
}));
/**
 * @since 1.0.0
 * @category Combinators
 */
export const failCause = /*#__PURE__*/dual(2, (self, options) => done(self, {
  token: options.token,
  exit: Exit.failCause(options.cause)
}));
//# sourceMappingURL=DurableDeferred.js.map