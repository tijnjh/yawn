import * as Context from "effect/Context";
import * as Effect from "effect/Effect";
import * as Effectable from "effect/Effectable";
import { dual } from "effect/Function";
import * as Schema from "effect/Schema";
import * as DurableDeferred from "./DurableDeferred.js";
import { makeHashDigest } from "./internal/crypto.js";
import * as Workflow from "./Workflow.js";
/**
 * @since 1.0.0
 * @category Symbols
 */
export const TypeId = /*#__PURE__*/Symbol.for("@effect/workflow/Activity");
/**
 * @since 1.0.0
 * @category Constructors
 */
export const make = options => {
  const successSchema = options.success ?? Schema.Void;
  const errorSchema = options.error ?? Schema.Never;
  // eslint-disable-next-line prefer-const
  let execute;
  const self = {
    ...Effectable.CommitPrototype,
    [TypeId]: TypeId,
    name: options.name,
    successSchema,
    errorSchema,
    exitSchema: Schema.ExitFromSelf({
      success: successSchema,
      failure: errorSchema,
      defect: Schema.Defect
    }),
    execute: options.execute,
    executeEncoded: Effect.matchEffect(options.execute, {
      onFailure: error => Effect.flatMap(Effect.orDie(Schema.encode(self.errorSchema)(error)), Effect.fail),
      onSuccess: value => Effect.orDie(Schema.encode(self.successSchema)(value))
    }),
    commit() {
      return execute;
    }
  };
  execute = makeExecute(self);
  return self;
};
/**
 * @since 1.0.0
 * @category Error handling
 */
export const retry = /*#__PURE__*/dual(2, (effect, options) => Effect.suspend(() => {
  let attempt = 1;
  return Effect.suspend(() => Effect.provideService(effect, CurrentAttempt, attempt++)).pipe(Effect.retry(options));
}));
/**
 * @since 1.0.0
 * @category Attempts
 */
export class CurrentAttempt extends /*#__PURE__*/Context.Reference()("@effect/workflow/Activity/CurrentAttempt", {
  defaultValue: () => 1
}) {}
/**
 * @since 1.0.0
 * @category Execution ID
 */
export const executionIdWithAttempt = /*#__PURE__*/Effect.gen(function* () {
  const instance = yield* InstanceTag;
  const attempt = yield* CurrentAttempt;
  return yield* makeHashDigest(`${instance.executionId}-${attempt}`);
});
/**
 * @since 1.0.0
 * @category Racing
 */
export const raceAll = (name, activities) => DurableDeferred.raceAll({
  name: `Activity/${name}`,
  success: Schema.Union(...activities.map(activity => activity.successSchema)),
  error: Schema.Union(...activities.map(activity => activity.errorSchema)),
  effects: activities
});
// -----------------------------------------------------------------------------
// internal
// -----------------------------------------------------------------------------
const EngineTag = /*#__PURE__*/Context.GenericTag("@effect/workflow/WorkflowEngine");
const InstanceTag = /*#__PURE__*/Context.GenericTag("@effect/workflow/WorkflowEngine/WorkflowInstance");
const makeExecute = /*#__PURE__*/Effect.fnUntraced(function* (activity) {
  const engine = yield* EngineTag;
  const instance = yield* InstanceTag;
  const attempt = yield* CurrentAttempt;
  const result = yield* Workflow.wrapActivityResult(engine.activityExecute({
    activity,
    attempt
  }), _ => _._tag === "Suspended");
  if (result._tag === "Suspended") {
    return yield* Workflow.suspend(instance);
  }
  const exit = yield* Effect.orDie(Schema.decode(activity.exitSchema)(result.exit));
  return yield* exit;
});
//# sourceMappingURL=Activity.js.map