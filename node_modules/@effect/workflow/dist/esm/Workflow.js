/**
 * @since 1.0.0
 */
import * as Cause from "effect/Cause";
import * as Context from "effect/Context";
import * as Data from "effect/Data";
import * as Effect from "effect/Effect";
import * as Exit from "effect/Exit";
import * as Fiber from "effect/Fiber";
import { constFalse, constTrue, dual, identity } from "effect/Function";
import * as Layer from "effect/Layer";
import * as Option from "effect/Option";
import * as Predicate from "effect/Predicate";
import * as PrimaryKey from "effect/PrimaryKey";
import * as Schedule from "effect/Schedule";
import * as Schema from "effect/Schema";
import { makeHashDigest } from "./internal/crypto.js";
/**
 * @since 1.0.0
 * @category Symbols
 */
export const TypeId = /*#__PURE__*/Symbol.for("@effect/workflow/Workflow");
const EngineTag = /*#__PURE__*/Context.GenericTag("@effect/workflow/WorkflowEngine");
const InstanceTag = /*#__PURE__*/Context.GenericTag("@effect/workflow/WorkflowEngine/WorkflowInstance");
/**
 * @since 1.0.0
 * @category Constructors
 */
export const make = options => {
  const suspendedRetrySchedule = options.suspendedRetrySchedule ?? defaultRetrySchedule;
  const makeExecutionId = payload => makeHashDigest(`${options.name}-${options.idempotencyKey(payload)}`);
  const self = {
    [TypeId]: TypeId,
    name: options.name,
    payloadSchema: Schema.isSchema(options.payload) ? options.payload : Schema.Struct(options.payload),
    successSchema: options.success ?? Schema.Void,
    errorSchema: options.error ?? Schema.Never,
    annotations: options.annotations ?? Context.empty(),
    annotate(tag, value) {
      return make({
        ...options,
        annotations: Context.add(self.annotations, tag, value)
      });
    },
    annotateContext(context) {
      return make({
        ...options,
        annotations: Context.merge(self.annotations, context)
      });
    },
    execute: Effect.fnUntraced(function* (fields, opts) {
      const payload = self.payloadSchema.make(fields);
      const engine = yield* EngineTag;
      const executionId = yield* makeExecutionId(payload);
      yield* Effect.annotateCurrentSpan({
        executionId
      });
      const parentInstance = yield* Effect.serviceOption(InstanceTag);
      let result;
      if (Option.isSome(parentInstance)) {
        const instance = parentInstance.value;
        yield* Effect.addFinalizer(() => {
          if (!instance.interrupted || result?._tag === "Complete") {
            return Effect.void;
          }
          return engine.interrupt(self, executionId);
        });
      }
      if (opts?.discard) {
        yield* engine.execute({
          workflow: self,
          executionId,
          payload,
          discard: true
        });
        return executionId;
      }
      const run = engine.execute({
        workflow: self,
        executionId,
        payload,
        discard: false,
        parent: Option.getOrUndefined(parentInstance)
      });
      if (Option.isSome(parentInstance)) {
        result = yield* wrapActivityResult(run, result => result._tag === "Suspended");
        if (result._tag === "Suspended") {
          return yield* suspend(parentInstance.value);
        }
        return yield* result.exit;
      }
      let sleep;
      while (true) {
        result = yield* run;
        if (result._tag === "Complete") {
          return yield* result.exit;
        }
        sleep ??= (yield* Schedule.driver(suspendedRetrySchedule)).next(void 0).pipe(Effect.catchAll(() => Effect.dieMessage(`${options.name}.execute: suspendedRetrySchedule exhausted`)));
        yield* sleep;
      }
    }, Effect.withSpan(`${options.name}.execute`, {
      captureStackTrace: false
    })),
    poll: Effect.fnUntraced(function* (executionId) {
      const engine = yield* EngineTag;
      return yield* engine.poll({
        workflow: self,
        executionId
      });
    }, (effect, executionId) => Effect.withSpan(effect, `${options.name}.poll`, {
      captureStackTrace: false,
      attributes: {
        executionId
      }
    })),
    interrupt: Effect.fnUntraced(function* (executionId) {
      const engine = yield* EngineTag;
      yield* engine.interrupt(self, executionId);
    }, (effect, executionId) => Effect.withSpan(effect, `${options.name}.interrupt`, {
      captureStackTrace: false,
      attributes: {
        executionId
      }
    })),
    resume: Effect.fnUntraced(function* (executionId) {
      const engine = yield* EngineTag;
      yield* engine.resume(self, executionId);
    }, (effect, executionId) => Effect.withSpan(effect, `${options.name}.resume`, {
      captureStackTrace: false,
      attributes: {
        executionId
      }
    })),
    toLayer: execute => Layer.effectContext(Effect.gen(function* () {
      const context = yield* Effect.context();
      const engine = Context.get(context, EngineTag);
      yield* engine.register(self, (payload, executionId) => Effect.suspend(() => execute(payload, executionId)).pipe(Effect.mapInputContext(input => Context.merge(context, input))));
      return EngineTag.context(engine);
    })),
    executionId: payload => makeExecutionId(self.payloadSchema.make(payload)),
    withCompensation
  };
  return self;
};
const defaultRetrySchedule = /*#__PURE__*/Schedule.exponential(200, 1.5).pipe(/*#__PURE__*/Schedule.union(/*#__PURE__*/Schedule.spaced(30000)));
/**
 * @since 1.0.0
 * @category Constructors
 */
export const fromTaggedRequest = (schema, options) => make({
  name: schema._tag,
  payload: schema,
  success: schema.success,
  error: schema.failure,
  idempotencyKey: PrimaryKey.value,
  suspendedRetrySchedule: options?.suspendedRetrySchedule
});
/**
 * @since 1.0.0
 * @category Result
 */
export const ResultTypeId = /*#__PURE__*/Symbol.for("@effect/workflow/Workflow/Result");
/**
 * @since 1.0.0
 * @category Result
 */
export const isResult = u => Predicate.hasProperty(u, ResultTypeId);
/**
 * @since 1.0.0
 * @category Result
 */
export class Complete extends /*#__PURE__*/Data.TaggedClass("Complete") {
  /**
   * @since 1.0.0
   */
  [ResultTypeId] = ResultTypeId;
  /**
   * @since 1.0.0
   */
  static SchemaFromSelf(_options) {
    return Schema.declare(u => isResult(u) && u._tag === "Complete");
  }
  /**
   * @since 1.0.0
   */
  static SchemaEncoded(options) {
    return Schema.Struct({
      _tag: Schema.tag("Complete"),
      exit: Schema.Exit({
        success: options.success,
        failure: options.error,
        defect: Schema.Defect
      })
    });
  }
  /**
   * @since 1.0.0
   */
  static Schema(options) {
    return Schema.transform(this.SchemaEncoded(options), this.SchemaFromSelf(options), {
      decode(fromA) {
        return new Complete({
          exit: fromA.exit
        });
      },
      encode(toI) {
        return toI;
      }
    });
  }
}
/**
 * @since 1.0.0
 * @category Result
 */
export class Suspended extends /*#__PURE__*/Schema.TaggedClass("@effect/workflow/Workflow/Suspended")("Suspended", {
  cause: /*#__PURE__*/Schema.optional(/*#__PURE__*/Schema.Cause({
    error: Schema.Never,
    defect: Schema.Defect
  }))
}) {
  /**
   * @since 1.0.0
   */
  [ResultTypeId] = ResultTypeId;
}
/**
 * @since 1.0.0
 * @category Result
 */
export const Result = options => Schema.Union(Complete.Schema(options), Suspended);
/**
 * @since 1.0.0
 * @category Result
 */
export const intoResult = effect => Effect.contextWithEffect(context => {
  const instance = Context.get(context, InstanceTag);
  const captureDefects = Context.get(instance.workflow.annotations, CaptureDefects);
  const suspendOnFailure = Context.get(instance.workflow.annotations, SuspendOnFailure);
  return Effect.uninterruptibleMask(restore => restore(effect).pipe(
  // So we can use external interruption to suspend a workflow
  Effect.fork, Effect.flatMap(fiber => Effect.onInterrupt(Fiber.join(fiber), () => Fiber.interrupt(fiber))), suspendOnFailure ? Effect.catchAllCause(cause => {
    instance.suspended = true;
    if (!Cause.isInterruptedOnly(cause)) {
      instance.cause = Cause.die(Cause.squash(cause));
    }
    return Effect.interrupt;
  }) : identity, Effect.scoped, Effect.matchCauseEffect({
    onSuccess: value => Effect.succeed(new Complete({
      exit: Exit.succeed(value)
    })),
    onFailure: cause => instance.suspended ? Effect.succeed(new Suspended({
      cause: instance.cause
    })) : !instance.interrupted && Cause.isInterruptedOnly(cause) || !captureDefects && Cause.isDie(cause) ? Effect.failCause(cause) : Effect.succeed(new Complete({
      exit: Exit.failCause(cause)
    }))
  })));
});
/**
 * @since 1.0.0
 * @category Result
 */
export const wrapActivityResult = (effect, isSuspend) => Effect.contextWithEffect(context => {
  const instance = Context.get(context, InstanceTag);
  const state = instance.activityState;
  if (instance.suspended) {
    return state.count > 0 ? state.latch.await.pipe(Effect.andThen(Effect.yieldNow()), Effect.andThen(suspend(instance))) : suspend(instance);
  }
  if (state.count === 0) state.latch.unsafeClose();
  state.count++;
  return Effect.onExit(effect, exit => {
    state.count--;
    const isSuspended = Exit.isSuccess(exit) && isSuspend(exit.value);
    if (Exit.isSuccess(exit) && isResult(exit.value) && exit.value._tag === "Suspended" && exit.value.cause) {
      instance.cause = instance.cause ? Cause.sequential(instance.cause, exit.value.cause) : exit.value.cause;
    }
    return state.count === 0 ? state.latch.open : isSuspended ? state.latch.await : Effect.void;
  });
});
/**
 * Add compensation logic to an effect inside a Workflow. The compensation finalizer will be
 * called if the entire workflow fails, allowing you to perform cleanup or
 * other actions based on the success value and the cause of the workflow failure.
 *
 * NOTE: Compensation will not work for nested activities. Compensation
 * finalizers are only registered for top-level effects in the workflow.
 *
 * @since 1.0.0
 * @category Compensation
 */
export const withCompensation = /*#__PURE__*/dual(2, (effect, compensation) => Effect.uninterruptibleMask(restore => Effect.tap(restore(effect), value => Effect.contextWithEffect(context => Effect.addFinalizer(exit => Exit.isSuccess(exit) || Context.get(context, InstanceTag).suspended ? Effect.void : compensation(value, exit.cause))))));
/**
 * @since 1.0.0
 */
export const suspend = instance => Effect.interruptible(Effect.async(() => {
  instance.suspended = true;
  const fiber = Option.getOrThrow(Fiber.getCurrentFiber());
  fiber.unsafeInterruptAsFork(fiber.id());
}));
/**
 * If you set this annotation to `true` for a workflow, it will capture defects
 * and include them in the result of the workflow or it's activities.
 *
 * By default, this is set to `true`, meaning that defects will be captured.
 *
 * @since 1.0.0
 * @category Annotations
 */
export class CaptureDefects extends /*#__PURE__*/Context.Reference()("@effect/workflow/Workflow/CaptureDefects", {
  defaultValue: constTrue
}) {}
/**
 * If you set this annotation to `true` for a workflow, it will suspend if it
 * encounters any kind of error.
 *
 * You can then manually resume the workflow later with
 * `Workflow.resume(executionId)`.
 *
 * @since 1.0.0
 * @category Annotations
 */
export class SuspendOnFailure extends /*#__PURE__*/Context.Reference()("@effect/workflow/Workflow/SuspendOnFailure", {
  defaultValue: constFalse
}) {}
//# sourceMappingURL=Workflow.js.map