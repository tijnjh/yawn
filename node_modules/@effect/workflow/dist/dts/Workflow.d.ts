/**
 * @since 1.0.0
 */
import * as Cause from "effect/Cause";
import * as Context from "effect/Context";
import * as Effect from "effect/Effect";
import * as Exit from "effect/Exit";
import * as Layer from "effect/Layer";
import type { Pipeable } from "effect/Pipeable";
import * as PrimaryKey from "effect/PrimaryKey";
import * as Schedule from "effect/Schedule";
import * as Schema from "effect/Schema";
import type * as AST from "effect/SchemaAST";
import type * as Scope from "effect/Scope";
import type { WorkflowEngine, WorkflowInstance } from "./WorkflowEngine.js";
/**
 * @since 1.0.0
 * @category Symbols
 */
export declare const TypeId: unique symbol;
/**
 * @since 1.0.0
 * @category Symbols
 */
export type TypeId = typeof TypeId;
/**
 * @since 1.0.0
 * @category Models
 */
export interface Workflow<Name extends string, Payload extends AnyStructSchema, Success extends Schema.Schema.Any, Error extends Schema.Schema.All> {
    readonly [TypeId]: TypeId;
    readonly name: Name;
    readonly payloadSchema: Payload;
    readonly successSchema: Success;
    readonly errorSchema: Error;
    readonly annotations: Context.Context<never>;
    /**
     * Add an annotation to the workflow.
     */
    annotate<I, S>(tag: Context.Tag<I, S>, value: S): Workflow<Name, Payload, Success, Error>;
    /**
     * Add the annotations from a Context object to the workflow.
     */
    annotateContext<I>(context: Context.Context<I>): Workflow<Name, Payload, Success, Error>;
    /**
     * Execute the workflow with the given payload.
     */
    readonly execute: <const Discard extends boolean = false>(payload: [keyof Payload["fields"]] extends [never] ? void : Schema.Simplify<Schema.Struct.Constructor<Payload["fields"]>>, options?: {
        readonly discard?: Discard;
    }) => Effect.Effect<Discard extends true ? string : Success["Type"], Discard extends true ? never : Error["Type"], WorkflowEngine | Payload["Context"] | Success["Context"] | Error["Context"]>;
    /**
     * Poll a workflow execution for its current status.
     *
     * If the workflow has not run yet, it will return `undefined`, otherwise it
     * will return the current `Workflow.Result`.
     */
    readonly poll: (executionId: string) => Effect.Effect<Result<Success["Type"], Error["Type"]> | undefined, never, WorkflowEngine | Success["Context"] | Error["Context"]>;
    /**
     * Interrupt a workflow execution for the given execution ID.
     */
    readonly interrupt: (executionId: string) => Effect.Effect<void, never, WorkflowEngine>;
    /**
     * Manually resume a workflow execution for the given execution ID.
     */
    readonly resume: (executionId: string) => Effect.Effect<void, never, WorkflowEngine>;
    /**
     * Create a layer that registers the workflow and provides an effect to
     * execute it.
     */
    readonly toLayer: <R>(execute: (payload: Payload["Type"], executionId: string) => Effect.Effect<Success["Type"], Error["Type"], R>) => Layer.Layer<WorkflowEngine, never, WorkflowEngine | Exclude<R, WorkflowEngine | WorkflowInstance | Execution<Name> | Scope.Scope> | Payload["Context"] | Success["Context"] | Error["Context"]>;
    /**
     * For the given payload, compute the deterministic execution ID.
     */
    readonly executionId: (payload: Schema.Simplify<Schema.Struct.Constructor<Payload["fields"]>>) => Effect.Effect<string>;
    /**
     * Add compensation logic to an effect inside a Workflow. The compensation finalizer will be
     * called if the entire workflow fails, allowing you to perform cleanup or
     * other actions based on the success value and the cause of the workflow failure.
     *
     * NOTE: Compensation will not work for nested activities. Compensation
     * finalizers are only registered for top-level effects in the workflow.
     */
    readonly withCompensation: {
        <A, R2>(compensation: (value: A, cause: Cause.Cause<Error["Type"]>) => Effect.Effect<void, never, R2>): <E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R | R2 | WorkflowInstance | Execution<Name> | Scope.Scope>;
        <A, E, R, R2>(effect: Effect.Effect<A, E, R>, compensation: (value: A, cause: Cause.Cause<Error["Type"]>) => Effect.Effect<void, never, R2>): Effect.Effect<A, E, R | R2 | WorkflowInstance | Execution<Name> | Scope.Scope>;
    };
}
/**
 * @since 1.0.0
 */
export interface AnyStructSchema extends Pipeable {
    readonly [Schema.TypeId]: any;
    readonly make: any;
    readonly Type: any;
    readonly Encoded: any;
    readonly Context: any;
    readonly ast: AST.AST;
    readonly fields: Schema.Struct.Fields;
    readonly annotations: any;
}
/**
 * @since 1.0.0
 * @category constructors
 */
export interface AnyTaggedRequestSchema extends AnyStructSchema {
    readonly _tag: string;
    readonly Type: PrimaryKey.PrimaryKey;
    readonly success: Schema.Schema.Any;
    readonly failure: Schema.Schema.All;
}
/**
 * @since 1.0.0
 * @category Models
 */
export interface Execution<Name extends string> {
    readonly _: unique symbol;
    readonly name: Name;
}
/**
 * @since 1.0.0
 * @category Models
 */
export interface Any {
    readonly [TypeId]: TypeId;
    readonly name: string;
    readonly payloadSchema: AnyStructSchema;
    readonly successSchema: Schema.Schema.Any;
    readonly errorSchema: Schema.Schema.All;
    readonly annotations: Context.Context<never>;
    readonly executionId: (payload: any) => Effect.Effect<string>;
}
/**
 * @since 1.0.0
 * @category Models
 */
export type Requirements<Workflows extends Any> = Workflows extends Workflow<infer _Name, infer _Payload, infer _Success, infer _Error> ? _Payload["Context"] | _Success["Context"] | _Error["Context"] : never;
/**
 * @since 1.0.0
 * @category Constructors
 */
export declare const make: <const Name extends string, Payload extends Schema.Struct.Fields | AnyStructSchema, Success extends Schema.Schema.Any = typeof Schema.Void, Error extends Schema.Schema.All = typeof Schema.Never>(options: {
    readonly name: Name;
    readonly payload: Payload;
    readonly idempotencyKey: (payload: Payload extends Schema.Struct.Fields ? Schema.Struct.Type<Payload> : Payload["Type"]) => string;
    readonly success?: Success;
    readonly error?: Error;
    readonly suspendedRetrySchedule?: Schedule.Schedule<any, unknown> | undefined;
    readonly annotations?: Context.Context<never>;
}) => Workflow<Name, Payload extends Schema.Struct.Fields ? Schema.Struct<Payload> : Payload, Success, Error>;
/**
 * @since 1.0.0
 * @category Constructors
 */
export declare const fromTaggedRequest: <S extends AnyTaggedRequestSchema>(schema: S, options?: {
    readonly suspendedRetrySchedule?: Schedule.Schedule<any, unknown> | undefined;
}) => Workflow<S["_tag"], S, S["success"], S["failure"]>;
/**
 * @since 1.0.0
 * @category Result
 */
export declare const ResultTypeId: unique symbol;
/**
 * @since 1.0.0
 * @category Result
 */
export type ResultTypeId = typeof ResultTypeId;
/**
 * @since 1.0.0
 * @category Result
 */
export declare const isResult: <A = unknown, E = unknown>(u: unknown) => u is Result<A, E>;
/**
 * @since 1.0.0
 * @category Result
 */
export type Result<A, E> = Complete<A, E> | Suspended;
/**
 * @since 1.0.0
 * @category Result
 */
export type ResultEncoded<A, E> = CompleteEncoded<A, E> | typeof Suspended.Encoded;
declare const Complete_base: new <A_1 extends Record<string, any> = {}>(args: import("effect/Types").Equals<A_1, {}> extends true ? void : { readonly [P in keyof A_1 as P extends "_tag" ? never : P]: A_1[P]; }) => Readonly<A_1> & {
    readonly _tag: "Complete";
};
/**
 * @since 1.0.0
 * @category Result
 */
export declare class Complete<A, E> extends Complete_base<{
    readonly exit: Exit.Exit<A, E>;
}> {
    /**
     * @since 1.0.0
     */
    readonly [ResultTypeId]: ResultTypeId;
    /**
     * @since 1.0.0
     */
    static SchemaFromSelf<Success extends Schema.Schema.Any, Error extends Schema.Schema.All>(_options: {
        readonly success: Success;
        readonly error: Error;
    }): Schema.Schema<Complete<Success["Type"], Error["Type"]>>;
    /**
     * @since 1.0.0
     */
    static SchemaEncoded<Success extends Schema.Schema.Any, Error extends Schema.Schema.All>(options: {
        readonly success: Success;
        readonly error: Error;
    }): Schema.Struct<{
        _tag: Schema.tag<"Complete">;
        exit: Schema.Exit<Success, Error, typeof Schema.Defect>;
    }>;
    /**
     * @since 1.0.0
     */
    static Schema<Success extends Schema.Schema.Any, Error extends Schema.Schema.All>(options: {
        readonly success: Success;
        readonly error: Error;
    }): Schema.Schema<Complete<Success["Type"], Error["Type"]>, CompleteEncoded<Success["Encoded"], Error["Encoded"]>>;
}
/**
 * @since 1.0.0
 * @category Result
 */
export interface CompleteEncoded<A, E> {
    readonly _tag: "Complete";
    readonly exit: Schema.ExitEncoded<A, E, unknown>;
}
declare const Suspended_base: Schema.TaggedClass<Suspended, "Suspended", {
    readonly _tag: Schema.tag<"Suspended">;
} & {
    cause: Schema.optional<Schema.Cause<typeof Schema.Never, typeof Schema.Defect>>;
}>;
/**
 * @since 1.0.0
 * @category Result
 */
export declare class Suspended extends Suspended_base {
    /**
     * @since 1.0.0
     */
    readonly [ResultTypeId]: ResultTypeId;
}
/**
 * @since 1.0.0
 * @category Result
 */
export declare const Result: <Success extends Schema.Schema.Any, Error extends Schema.Schema.All>(options: {
    readonly success: Success;
    readonly error: Error;
}) => Schema.Schema<Result<Success["Type"], Error["Type"]>, ResultEncoded<Success["Encoded"], Error["Encoded"]>, Success["Context"] | Error["Context"]>;
/**
 * @since 1.0.0
 * @category Result
 */
export declare const intoResult: <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<Result<A, E>, never, Exclude<R, Scope.Scope> | WorkflowInstance>;
/**
 * @since 1.0.0
 * @category Result
 */
export declare const wrapActivityResult: <A, E, R>(effect: Effect.Effect<A, E, R>, isSuspend: (value: A) => boolean) => Effect.Effect<A, E, R | WorkflowInstance>;
/**
 * Add compensation logic to an effect inside a Workflow. The compensation finalizer will be
 * called if the entire workflow fails, allowing you to perform cleanup or
 * other actions based on the success value and the cause of the workflow failure.
 *
 * NOTE: Compensation will not work for nested activities. Compensation
 * finalizers are only registered for top-level effects in the workflow.
 *
 * @since 1.0.0
 * @category Compensation
 */
export declare const withCompensation: {
    /**
     * Add compensation logic to an effect inside a Workflow. The compensation finalizer will be
     * called if the entire workflow fails, allowing you to perform cleanup or
     * other actions based on the success value and the cause of the workflow failure.
     *
     * NOTE: Compensation will not work for nested activities. Compensation
     * finalizers are only registered for top-level effects in the workflow.
     *
     * @since 1.0.0
     * @category Compensation
     */
    <A, R2>(compensation: (value: A, cause: Cause.Cause<unknown>) => Effect.Effect<void, never, R2>): <E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R | R2 | WorkflowInstance | Scope.Scope>;
    /**
     * Add compensation logic to an effect inside a Workflow. The compensation finalizer will be
     * called if the entire workflow fails, allowing you to perform cleanup or
     * other actions based on the success value and the cause of the workflow failure.
     *
     * NOTE: Compensation will not work for nested activities. Compensation
     * finalizers are only registered for top-level effects in the workflow.
     *
     * @since 1.0.0
     * @category Compensation
     */
    <A, E, R, R2>(effect: Effect.Effect<A, E, R>, compensation: (value: A, cause: Cause.Cause<unknown>) => Effect.Effect<void, never, R2>): Effect.Effect<A, E, R | R2 | WorkflowInstance | Scope.Scope>;
};
/**
 * @since 1.0.0
 */
export declare const suspend: (instance: WorkflowInstance["Type"]) => Effect.Effect<never>;
declare const CaptureDefects_base: Context.ReferenceClass<CaptureDefects, "@effect/workflow/Workflow/CaptureDefects", boolean>;
/**
 * If you set this annotation to `true` for a workflow, it will capture defects
 * and include them in the result of the workflow or it's activities.
 *
 * By default, this is set to `true`, meaning that defects will be captured.
 *
 * @since 1.0.0
 * @category Annotations
 */
export declare class CaptureDefects extends CaptureDefects_base {
}
declare const SuspendOnFailure_base: Context.ReferenceClass<SuspendOnFailure, "@effect/workflow/Workflow/SuspendOnFailure", boolean>;
/**
 * If you set this annotation to `true` for a workflow, it will suspend if it
 * encounters any kind of error.
 *
 * You can then manually resume the workflow later with
 * `Workflow.resume(executionId)`.
 *
 * @since 1.0.0
 * @category Annotations
 */
export declare class SuspendOnFailure extends SuspendOnFailure_base {
}
export {};
//# sourceMappingURL=Workflow.d.ts.map