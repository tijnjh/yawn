/**
 * @since 1.0.0
 */
import type { NonEmptyReadonlyArray } from "effect/Array";
import type * as Brand from "effect/Brand";
import type * as Cause from "effect/Cause";
import * as Effect from "effect/Effect";
import * as Exit from "effect/Exit";
import * as Schema from "effect/Schema";
import * as Workflow from "./Workflow.js";
import type { WorkflowEngine, WorkflowInstance } from "./WorkflowEngine.js";
/**
 * @since 1.0.0
 * @category Symbols
 */
export declare const TypeId: unique symbol;
/**
 * @since 1.0.0
 * @category Symbols
 */
export type TypeId = typeof TypeId;
/**
 * @since 1.0.0
 * @category Models
 */
export interface DurableDeferred<Success extends Schema.Schema.Any, Error extends Schema.Schema.All = typeof Schema.Never> {
    readonly [TypeId]: TypeId;
    readonly name: string;
    readonly successSchema: Success;
    readonly errorSchema: Error;
    readonly exitSchema: Schema.Exit<Success, Error, typeof Schema.Defect>;
    readonly withActivityAttempt: Effect.Effect<DurableDeferred<Success, Error>>;
}
/**
 * @since 1.0.0
 * @category Models
 */
export interface Any {
    readonly [TypeId]: TypeId;
    readonly name: string;
    readonly successSchema: Schema.Schema.Any;
    readonly errorSchema: Schema.Schema.All;
    readonly exitSchema: Schema.Exit<any, any, any>;
}
/**
 * @since 1.0.0
 * @category Constructors
 */
export declare const make: <Success extends Schema.Schema.Any = typeof Schema.Void, Error extends Schema.Schema.All = typeof Schema.Never>(name: string, options?: {
    readonly success?: Success | undefined;
    readonly error?: Error | undefined;
}) => DurableDeferred<Success, Error>;
declare const await_: <Success extends Schema.Schema.Any, Error extends Schema.Schema.All>(self: DurableDeferred<Success, Error>) => Effect.Effect<Success["Type"], Error["Type"], WorkflowEngine | WorkflowInstance | Success["Context"] | Error["Context"]>;
export { 
/**
 * @since 1.0.0
 * @category Combinators
 */
await_ as await };
/**
 * @since 1.0.0
 * @category Combinators
 */
export declare const into: {
    /**
     * @since 1.0.0
     * @category Combinators
     */
    <Success extends Schema.Schema.Any, Error extends Schema.Schema.All>(self: DurableDeferred<Success, Error>): <R>(effect: Effect.Effect<Success["Type"], Error["Type"], R>) => Effect.Effect<Success["Type"], Error["Type"], R | WorkflowEngine | WorkflowInstance | Success["Context"] | Error["Context"]>;
    /**
     * @since 1.0.0
     * @category Combinators
     */
    <Success extends Schema.Schema.Any, Error extends Schema.Schema.All, R>(effect: Effect.Effect<Success["Type"], Error["Type"], R>, self: DurableDeferred<Success, Error>): Effect.Effect<Success["Type"], Error["Type"], R | WorkflowEngine | WorkflowInstance | Success["Context"] | Error["Context"]>;
};
/**
 * @since 1.0.0
 * @category Racing
 */
export declare const raceAll: <const Effects extends NonEmptyReadonlyArray<Effect.Effect<any, any, any>>, SI, SR, EI, ER>(options: {
    name: string;
    success: Schema.Schema<Effects[number] extends Effect.Effect<infer S, infer _E_2, infer _R_3> ? S : never, SI, SR>;
    error: Schema.Schema<Effects[number] extends Effect.Effect<infer _S, infer E, infer _R_4> ? E : never, EI, ER>;
    effects: Effects;
}) => Effect.Effect<(Effects[number] extends Effect.Effect<infer _A, infer _E, infer _R> ? _A : never), (Effects[number] extends Effect.Effect<infer _A, infer _E_1, infer _R_1> ? _E_1 : never), (Effects[number] extends Effect.Effect<infer _A, infer _R_2, infer R> ? R : never) | SR | ER | WorkflowEngine | WorkflowInstance>;
/**
 * @since 1.0.0
 * @category Token
 */
export declare const TokenTypeId: unique symbol;
/**
 * @since 1.0.0
 * @category Token
 */
export type TokenTypeId = typeof TokenTypeId;
/**
 * @since 1.0.0
 * @category Token
 */
export type Token = Brand.Branded<string, TokenTypeId>;
/**
 * @since 1.0.0
 * @category Token
 */
export declare const Token: Schema.brand<typeof Schema.String, typeof TokenTypeId>;
declare const TokenParsed_base: Schema.Class<TokenParsed, {
    workflowName: typeof Schema.String;
    executionId: typeof Schema.String;
    deferredName: typeof Schema.String;
}, Schema.Struct.Encoded<{
    workflowName: typeof Schema.String;
    executionId: typeof Schema.String;
    deferredName: typeof Schema.String;
}>, never, {
    readonly executionId: string;
} & {
    readonly workflowName: string;
} & {
    readonly deferredName: string;
}, {}, {}>;
/**
 * @since 1.0.0
 * @category Token
 */
export declare class TokenParsed extends TokenParsed_base {
    /**
     * @since 1.0.0
     */
    get asToken(): Token;
    /**
     * @since 1.0.0
     */
    static readonly FromString: Schema.Schema<TokenParsed, string>;
    /**
     * @since 1.0.0
     */
    static readonly fromString: (i: string, overrideOptions?: import("effect/SchemaAST").ParseOptions) => TokenParsed;
    /**
     * @since 1.0.0
     */
    static readonly encode: (a: TokenParsed, overrideOptions?: import("effect/SchemaAST").ParseOptions) => string;
}
/**
 * @since 1.0.0
 * @category Token
 */
export declare const token: <Success extends Schema.Schema.Any, Error extends Schema.Schema.All>(self: DurableDeferred<Success, Error>) => Effect.Effect<Token, never, WorkflowInstance>;
/**
 * @since 1.0.0
 * @category Token
 */
export declare const tokenFromExecutionId: {
    /**
     * @since 1.0.0
     * @category Token
     */
    (options: {
        readonly workflow: Workflow.Any;
        readonly executionId: string;
    }): <Success extends Schema.Schema.Any, Error extends Schema.Schema.All>(self: DurableDeferred<Success, Error>) => Token;
    /**
     * @since 1.0.0
     * @category Token
     */
    <Success extends Schema.Schema.Any, Error extends Schema.Schema.All>(self: DurableDeferred<Success, Error>, options: {
        readonly workflow: Workflow.Any;
        readonly executionId: string;
    }): Token;
};
/**
 * @since 1.0.0
 * @category Token
 */
export declare const tokenFromPayload: {
    /**
     * @since 1.0.0
     * @category Token
     */
    <W extends Workflow.Any>(options: {
        readonly workflow: W;
        readonly payload: Schema.Simplify<Schema.Struct.Constructor<W["payloadSchema"]["fields"]>>;
    }): <Success extends Schema.Schema.Any, Error extends Schema.Schema.All>(self: DurableDeferred<Success, Error>) => Effect.Effect<Token>;
    /**
     * @since 1.0.0
     * @category Token
     */
    <Success extends Schema.Schema.Any, Error extends Schema.Schema.All, W extends Workflow.Any>(self: DurableDeferred<Success, Error>, options: {
        readonly workflow: W;
        readonly payload: Schema.Simplify<Schema.Struct.Constructor<W["payloadSchema"]["fields"]>>;
    }): Effect.Effect<Token>;
};
/**
 * @since 1.0.0
 * @category Combinators
 */
export declare const done: {
    /**
     * @since 1.0.0
     * @category Combinators
     */
    <Success extends Schema.Schema.Any, Error extends Schema.Schema.All>(options: {
        readonly token: Token;
        readonly exit: Exit.Exit<Success["Type"], Error["Type"]>;
    }): (self: DurableDeferred<Success, Error>) => Effect.Effect<void, never, WorkflowEngine | Success["Context"] | Error["Context"]>;
    /**
     * @since 1.0.0
     * @category Combinators
     */
    <Success extends Schema.Schema.Any, Error extends Schema.Schema.All>(self: DurableDeferred<Success, Error>, options: {
        readonly token: Token;
        readonly exit: Exit.Exit<Success["Type"], Error["Type"]>;
    }): Effect.Effect<void, never, WorkflowEngine | Success["Context"] | Error["Context"]>;
};
/**
 * @since 1.0.0
 * @category Combinators
 */
export declare const succeed: {
    /**
     * @since 1.0.0
     * @category Combinators
     */
    <Success extends Schema.Schema.Any, Error extends Schema.Schema.All>(options: {
        readonly token: Token;
        readonly value: Success["Type"];
    }): (self: DurableDeferred<Success, Error>) => Effect.Effect<void, never, WorkflowEngine | Success["Context"]>;
    /**
     * @since 1.0.0
     * @category Combinators
     */
    <Success extends Schema.Schema.Any, Error extends Schema.Schema.All>(self: DurableDeferred<Success, Error>, options: {
        readonly token: Token;
        readonly value: Success["Type"];
    }): Effect.Effect<void, never, WorkflowEngine | Success["Context"]>;
};
/**
 * @since 1.0.0
 * @category Combinators
 */
export declare const fail: {
    /**
     * @since 1.0.0
     * @category Combinators
     */
    <Success extends Schema.Schema.Any, Error extends Schema.Schema.All>(options: {
        readonly token: Token;
        readonly error: Error["Type"];
    }): (self: DurableDeferred<Success, Error>) => Effect.Effect<void, never, WorkflowEngine | Error["Context"]>;
    /**
     * @since 1.0.0
     * @category Combinators
     */
    <Success extends Schema.Schema.Any, Error extends Schema.Schema.All>(self: DurableDeferred<Success, Error>, options: {
        readonly token: Token;
        readonly error: Error["Type"];
    }): Effect.Effect<void, never, WorkflowEngine | Error["Context"]>;
};
/**
 * @since 1.0.0
 * @category Combinators
 */
export declare const failCause: {
    /**
     * @since 1.0.0
     * @category Combinators
     */
    <Success extends Schema.Schema.Any, Error extends Schema.Schema.All>(options: {
        readonly token: Token;
        readonly cause: Cause.Cause<Error["Type"]>;
    }): (self: DurableDeferred<Success, Error>) => Effect.Effect<void, never, WorkflowEngine | Error["Context"]>;
    /**
     * @since 1.0.0
     * @category Combinators
     */
    <Success extends Schema.Schema.Any, Error extends Schema.Schema.All>(self: DurableDeferred<Success, Error>, options: {
        readonly token: Token;
        readonly cause: Cause.Cause<Error["Type"]>;
    }): Effect.Effect<void, never, WorkflowEngine | Error["Context"]>;
};
//# sourceMappingURL=DurableDeferred.d.ts.map