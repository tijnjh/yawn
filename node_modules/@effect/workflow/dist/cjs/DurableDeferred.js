"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tokenFromPayload = exports.tokenFromExecutionId = exports.token = exports.succeed = exports.raceAll = exports.make = exports.into = exports.failCause = exports.fail = exports.done = exports.await = exports.TypeId = exports.TokenTypeId = exports.TokenParsed = exports.Token = void 0;
var Context = _interopRequireWildcard(require("effect/Context"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Encoding = _interopRequireWildcard(require("effect/Encoding"));
var Exit = _interopRequireWildcard(require("effect/Exit"));
var _Function = require("effect/Function");
var Option = _interopRequireWildcard(require("effect/Option"));
var Schema = _interopRequireWildcard(require("effect/Schema"));
var Workflow = _interopRequireWildcard(require("./Workflow.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * @since 1.0.0
 * @category Symbols
 */
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("@effect/workflow/DurableDeferred");
/**
 * @since 1.0.0
 * @category Constructors
 */
const make = (name, options) => ({
  [TypeId]: TypeId,
  name,
  successSchema: options?.success ?? Schema.Void,
  errorSchema: options?.error ?? Schema.Never,
  exitSchema: Schema.Exit({
    success: options?.success ?? Schema.Void,
    failure: options?.error ?? Schema.Never,
    defect: Schema.Defect
  }),
  withActivityAttempt: Effect.gen(function* () {
    const attempt = yield* CurrentAttempt;
    return make(`${name}/${attempt}`, {
      success: options?.success,
      error: options?.error
    });
  })
});
exports.make = make;
const EngineTag = /*#__PURE__*/Context.GenericTag("@effect/workflow/WorkflowEngine");
const InstanceTag = /*#__PURE__*/Context.GenericTag("@effect/workflow/WorkflowEngine/WorkflowInstance");
const CurrentAttempt = /*#__PURE__*/Context.Reference()("@effect/workflow/Activity/CurrentAttempt", {
  defaultValue: () => 1
});
const await_ = exports.await = /*#__PURE__*/Effect.fnUntraced(function* (self) {
  const engine = yield* EngineTag;
  const instance = yield* InstanceTag;
  const oexit = yield* Workflow.wrapActivityResult(engine.deferredResult(self), Option.isNone);
  if (Option.isNone(oexit)) {
    return yield* Workflow.suspend(instance);
  }
  return yield* Effect.flatten(Effect.orDie(Schema.decodeUnknown(self.exitSchema)(oexit.value)));
});
/**
 * @since 1.0.0
 * @category Combinators
 */
const into = exports.into = /*#__PURE__*/(0, _Function.dual)(2, (effect, self) => Effect.contextWithEffect(context => {
  const engine = Context.get(context, EngineTag);
  const instance = Context.get(context, InstanceTag);
  return Effect.onExit(effect, Effect.fnUntraced(function* (exit) {
    if (instance.suspended) return;
    const encodedExit = yield* Effect.orDie(Schema.encode(self.exitSchema)(exit));
    yield* engine.deferredDone({
      workflowName: instance.workflow.name,
      executionId: instance.executionId,
      deferredName: self.name,
      exit: encodedExit
    });
  }));
}));
/**
 * @since 1.0.0
 * @category Racing
 */
const raceAll = options => {
  const deferred = make(`raceAll/${options.name}`, {
    success: options.success,
    error: options.error
  });
  return Effect.gen(function* () {
    const engine = yield* EngineTag;
    const oexit = yield* Workflow.wrapActivityResult(engine.deferredResult(deferred), Option.isNone);
    if (Option.isSome(oexit)) {
      return yield* Effect.flatten(Effect.orDie(Schema.decodeUnknown(deferred.exitSchema)(oexit.value)));
    }
    return yield* into(Effect.raceAll(options.effects), deferred);
  });
};
/**
 * @since 1.0.0
 * @category Token
 */
exports.raceAll = raceAll;
const TokenTypeId = exports.TokenTypeId = /*#__PURE__*/Symbol.for("@effect/workflow/DurableDeferred/Token");
/**
 * @since 1.0.0
 * @category Token
 */
const Token = exports.Token = /*#__PURE__*/Schema.String.pipe(/*#__PURE__*/Schema.brand(TokenTypeId));
/**
 * @since 1.0.0
 * @category Token
 */
class TokenParsed extends /*#__PURE__*/Schema.Class("@effect/workflow/DurableDeferred/TokenParsed")({
  workflowName: Schema.String,
  executionId: Schema.String,
  deferredName: Schema.String
}) {
  /**
   * @since 1.0.0
   */
  get asToken() {
    return Encoding.encodeBase64Url(JSON.stringify([this.workflowName, this.executionId, this.deferredName]));
  }
  /**
   * @since 1.0.0
   */
  static FromString = /*#__PURE__*/Schema.StringFromBase64Url.pipe(/*#__PURE__*/Schema.compose(/*#__PURE__*/Schema.parseJson(/*#__PURE__*/Schema.Tuple(Schema.String, Schema.String, Schema.String))), /*#__PURE__*/Schema.transform(TokenParsed, {
    decode: ([workflowName, executionId, deferredName]) => new TokenParsed({
      workflowName,
      executionId,
      deferredName
    }),
    encode: parsed => [parsed.workflowName, parsed.executionId, parsed.deferredName]
  }));
  /**
   * @since 1.0.0
   */
  static fromString = /*#__PURE__*/Schema.decodeSync(TokenParsed.FromString);
  /**
   * @since 1.0.0
   */
  static encode = /*#__PURE__*/Schema.encodeSync(TokenParsed.FromString);
}
/**
 * @since 1.0.0
 * @category Token
 */
exports.TokenParsed = TokenParsed;
const token = exports.token = /*#__PURE__*/Effect.fnUntraced(function* (self) {
  const instance = yield* InstanceTag;
  return tokenFromExecutionId(self, instance);
});
/**
 * @since 1.0.0
 * @category Token
 */
const tokenFromExecutionId = exports.tokenFromExecutionId = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => new TokenParsed({
  workflowName: options.workflow.name,
  executionId: options.executionId,
  deferredName: self.name
}).asToken);
/**
 * @since 1.0.0
 * @category Token
 */
const tokenFromPayload = exports.tokenFromPayload = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => Effect.map(options.workflow.executionId(options.payload), executionId => tokenFromExecutionId(self, {
  workflow: options.workflow,
  executionId
})));
/**
 * @since 1.0.0
 * @category Combinators
 */
const done = exports.done = /*#__PURE__*/(0, _Function.dual)(2, /*#__PURE__*/Effect.fnUntraced(function* (self, options) {
  const engine = yield* EngineTag;
  const token = TokenParsed.fromString(options.token);
  const exit = yield* Schema.encode(self.exitSchema)(options.exit);
  yield* engine.deferredDone({
    workflowName: token.workflowName,
    executionId: token.executionId,
    deferredName: token.deferredName,
    exit: exit
  });
}, Effect.orDie));
/**
 * @since 1.0.0
 * @category Combinators
 */
const succeed = exports.succeed = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => done(self, {
  token: options.token,
  exit: Exit.succeed(options.value)
}));
/**
 * @since 1.0.0
 * @category Combinators
 */
const fail = exports.fail = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => done(self, {
  token: options.token,
  exit: Exit.fail(options.error)
}));
/**
 * @since 1.0.0
 * @category Combinators
 */
const failCause = exports.failCause = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => done(self, {
  token: options.token,
  exit: Exit.failCause(options.cause)
}));
//# sourceMappingURL=DurableDeferred.js.map