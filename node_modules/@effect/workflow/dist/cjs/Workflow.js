"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wrapActivityResult = exports.withCompensation = exports.suspend = exports.make = exports.isResult = exports.intoResult = exports.fromTaggedRequest = exports.TypeId = exports.Suspended = exports.SuspendOnFailure = exports.ResultTypeId = exports.Result = exports.Complete = exports.CaptureDefects = void 0;
var Cause = _interopRequireWildcard(require("effect/Cause"));
var Context = _interopRequireWildcard(require("effect/Context"));
var Data = _interopRequireWildcard(require("effect/Data"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Exit = _interopRequireWildcard(require("effect/Exit"));
var Fiber = _interopRequireWildcard(require("effect/Fiber"));
var _Function = require("effect/Function");
var Layer = _interopRequireWildcard(require("effect/Layer"));
var Option = _interopRequireWildcard(require("effect/Option"));
var Predicate = _interopRequireWildcard(require("effect/Predicate"));
var PrimaryKey = _interopRequireWildcard(require("effect/PrimaryKey"));
var Schedule = _interopRequireWildcard(require("effect/Schedule"));
var Schema = _interopRequireWildcard(require("effect/Schema"));
var _crypto = require("./internal/crypto.js");
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * @since 1.0.0
 */

/**
 * @since 1.0.0
 * @category Symbols
 */
const TypeId = exports.TypeId = /*#__PURE__*/Symbol.for("@effect/workflow/Workflow");
const EngineTag = /*#__PURE__*/Context.GenericTag("@effect/workflow/WorkflowEngine");
const InstanceTag = /*#__PURE__*/Context.GenericTag("@effect/workflow/WorkflowEngine/WorkflowInstance");
/**
 * @since 1.0.0
 * @category Constructors
 */
const make = options => {
  const suspendedRetrySchedule = options.suspendedRetrySchedule ?? defaultRetrySchedule;
  const makeExecutionId = payload => (0, _crypto.makeHashDigest)(`${options.name}-${options.idempotencyKey(payload)}`);
  const self = {
    [TypeId]: TypeId,
    name: options.name,
    payloadSchema: Schema.isSchema(options.payload) ? options.payload : Schema.Struct(options.payload),
    successSchema: options.success ?? Schema.Void,
    errorSchema: options.error ?? Schema.Never,
    annotations: options.annotations ?? Context.empty(),
    annotate(tag, value) {
      return make({
        ...options,
        annotations: Context.add(self.annotations, tag, value)
      });
    },
    annotateContext(context) {
      return make({
        ...options,
        annotations: Context.merge(self.annotations, context)
      });
    },
    execute: Effect.fnUntraced(function* (fields, opts) {
      const payload = self.payloadSchema.make(fields);
      const engine = yield* EngineTag;
      const executionId = yield* makeExecutionId(payload);
      yield* Effect.annotateCurrentSpan({
        executionId
      });
      const parentInstance = yield* Effect.serviceOption(InstanceTag);
      let result;
      if (Option.isSome(parentInstance)) {
        const instance = parentInstance.value;
        yield* Effect.addFinalizer(() => {
          if (!instance.interrupted || result?._tag === "Complete") {
            return Effect.void;
          }
          return engine.interrupt(self, executionId);
        });
      }
      if (opts?.discard) {
        yield* engine.execute({
          workflow: self,
          executionId,
          payload,
          discard: true
        });
        return executionId;
      }
      const run = engine.execute({
        workflow: self,
        executionId,
        payload,
        discard: false,
        parent: Option.getOrUndefined(parentInstance)
      });
      if (Option.isSome(parentInstance)) {
        result = yield* wrapActivityResult(run, result => result._tag === "Suspended");
        if (result._tag === "Suspended") {
          return yield* suspend(parentInstance.value);
        }
        return yield* result.exit;
      }
      let sleep;
      while (true) {
        result = yield* run;
        if (result._tag === "Complete") {
          return yield* result.exit;
        }
        sleep ??= (yield* Schedule.driver(suspendedRetrySchedule)).next(void 0).pipe(Effect.catchAll(() => Effect.dieMessage(`${options.name}.execute: suspendedRetrySchedule exhausted`)));
        yield* sleep;
      }
    }, Effect.withSpan(`${options.name}.execute`, {
      captureStackTrace: false
    })),
    poll: Effect.fnUntraced(function* (executionId) {
      const engine = yield* EngineTag;
      return yield* engine.poll({
        workflow: self,
        executionId
      });
    }, (effect, executionId) => Effect.withSpan(effect, `${options.name}.poll`, {
      captureStackTrace: false,
      attributes: {
        executionId
      }
    })),
    interrupt: Effect.fnUntraced(function* (executionId) {
      const engine = yield* EngineTag;
      yield* engine.interrupt(self, executionId);
    }, (effect, executionId) => Effect.withSpan(effect, `${options.name}.interrupt`, {
      captureStackTrace: false,
      attributes: {
        executionId
      }
    })),
    resume: Effect.fnUntraced(function* (executionId) {
      const engine = yield* EngineTag;
      yield* engine.resume(self, executionId);
    }, (effect, executionId) => Effect.withSpan(effect, `${options.name}.resume`, {
      captureStackTrace: false,
      attributes: {
        executionId
      }
    })),
    toLayer: execute => Layer.effectContext(Effect.gen(function* () {
      const context = yield* Effect.context();
      const engine = Context.get(context, EngineTag);
      yield* engine.register(self, (payload, executionId) => Effect.suspend(() => execute(payload, executionId)).pipe(Effect.mapInputContext(input => Context.merge(context, input))));
      return EngineTag.context(engine);
    })),
    executionId: payload => makeExecutionId(self.payloadSchema.make(payload)),
    withCompensation
  };
  return self;
};
exports.make = make;
const defaultRetrySchedule = /*#__PURE__*/Schedule.exponential(200, 1.5).pipe(/*#__PURE__*/Schedule.union(/*#__PURE__*/Schedule.spaced(30000)));
/**
 * @since 1.0.0
 * @category Constructors
 */
const fromTaggedRequest = (schema, options) => make({
  name: schema._tag,
  payload: schema,
  success: schema.success,
  error: schema.failure,
  idempotencyKey: PrimaryKey.value,
  suspendedRetrySchedule: options?.suspendedRetrySchedule
});
/**
 * @since 1.0.0
 * @category Result
 */
exports.fromTaggedRequest = fromTaggedRequest;
const ResultTypeId = exports.ResultTypeId = /*#__PURE__*/Symbol.for("@effect/workflow/Workflow/Result");
/**
 * @since 1.0.0
 * @category Result
 */
const isResult = u => Predicate.hasProperty(u, ResultTypeId);
/**
 * @since 1.0.0
 * @category Result
 */
exports.isResult = isResult;
class Complete extends /*#__PURE__*/Data.TaggedClass("Complete") {
  /**
   * @since 1.0.0
   */
  [ResultTypeId] = ResultTypeId;
  /**
   * @since 1.0.0
   */
  static SchemaFromSelf(_options) {
    return Schema.declare(u => isResult(u) && u._tag === "Complete");
  }
  /**
   * @since 1.0.0
   */
  static SchemaEncoded(options) {
    return Schema.Struct({
      _tag: Schema.tag("Complete"),
      exit: Schema.Exit({
        success: options.success,
        failure: options.error,
        defect: Schema.Defect
      })
    });
  }
  /**
   * @since 1.0.0
   */
  static Schema(options) {
    return Schema.transform(this.SchemaEncoded(options), this.SchemaFromSelf(options), {
      decode(fromA) {
        return new Complete({
          exit: fromA.exit
        });
      },
      encode(toI) {
        return toI;
      }
    });
  }
}
/**
 * @since 1.0.0
 * @category Result
 */
exports.Complete = Complete;
class Suspended extends /*#__PURE__*/Schema.TaggedClass("@effect/workflow/Workflow/Suspended")("Suspended", {
  cause: /*#__PURE__*/Schema.optional(/*#__PURE__*/Schema.Cause({
    error: Schema.Never,
    defect: Schema.Defect
  }))
}) {
  /**
   * @since 1.0.0
   */
  [ResultTypeId] = ResultTypeId;
}
/**
 * @since 1.0.0
 * @category Result
 */
exports.Suspended = Suspended;
const Result = options => Schema.Union(Complete.Schema(options), Suspended);
/**
 * @since 1.0.0
 * @category Result
 */
exports.Result = Result;
const intoResult = effect => Effect.contextWithEffect(context => {
  const instance = Context.get(context, InstanceTag);
  const captureDefects = Context.get(instance.workflow.annotations, CaptureDefects);
  const suspendOnFailure = Context.get(instance.workflow.annotations, SuspendOnFailure);
  return Effect.uninterruptibleMask(restore => restore(effect).pipe(
  // So we can use external interruption to suspend a workflow
  Effect.fork, Effect.flatMap(fiber => Effect.onInterrupt(Fiber.join(fiber), () => Fiber.interrupt(fiber))), suspendOnFailure ? Effect.catchAllCause(cause => {
    instance.suspended = true;
    if (!Cause.isInterruptedOnly(cause)) {
      instance.cause = Cause.die(Cause.squash(cause));
    }
    return Effect.interrupt;
  }) : _Function.identity, Effect.scoped, Effect.matchCauseEffect({
    onSuccess: value => Effect.succeed(new Complete({
      exit: Exit.succeed(value)
    })),
    onFailure: cause => instance.suspended ? Effect.succeed(new Suspended({
      cause: instance.cause
    })) : !instance.interrupted && Cause.isInterruptedOnly(cause) || !captureDefects && Cause.isDie(cause) ? Effect.failCause(cause) : Effect.succeed(new Complete({
      exit: Exit.failCause(cause)
    }))
  })));
});
/**
 * @since 1.0.0
 * @category Result
 */
exports.intoResult = intoResult;
const wrapActivityResult = (effect, isSuspend) => Effect.contextWithEffect(context => {
  const instance = Context.get(context, InstanceTag);
  const state = instance.activityState;
  if (instance.suspended) {
    return state.count > 0 ? state.latch.await.pipe(Effect.andThen(Effect.yieldNow()), Effect.andThen(suspend(instance))) : suspend(instance);
  }
  if (state.count === 0) state.latch.unsafeClose();
  state.count++;
  return Effect.onExit(effect, exit => {
    state.count--;
    const isSuspended = Exit.isSuccess(exit) && isSuspend(exit.value);
    if (Exit.isSuccess(exit) && isResult(exit.value) && exit.value._tag === "Suspended" && exit.value.cause) {
      instance.cause = instance.cause ? Cause.sequential(instance.cause, exit.value.cause) : exit.value.cause;
    }
    return state.count === 0 ? state.latch.open : isSuspended ? state.latch.await : Effect.void;
  });
});
/**
 * Add compensation logic to an effect inside a Workflow. The compensation finalizer will be
 * called if the entire workflow fails, allowing you to perform cleanup or
 * other actions based on the success value and the cause of the workflow failure.
 *
 * NOTE: Compensation will not work for nested activities. Compensation
 * finalizers are only registered for top-level effects in the workflow.
 *
 * @since 1.0.0
 * @category Compensation
 */
exports.wrapActivityResult = wrapActivityResult;
const withCompensation = exports.withCompensation = /*#__PURE__*/(0, _Function.dual)(2, (effect, compensation) => Effect.uninterruptibleMask(restore => Effect.tap(restore(effect), value => Effect.contextWithEffect(context => Effect.addFinalizer(exit => Exit.isSuccess(exit) || Context.get(context, InstanceTag).suspended ? Effect.void : compensation(value, exit.cause))))));
/**
 * @since 1.0.0
 */
const suspend = instance => Effect.interruptible(Effect.async(() => {
  instance.suspended = true;
  const fiber = Option.getOrThrow(Fiber.getCurrentFiber());
  fiber.unsafeInterruptAsFork(fiber.id());
}));
/**
 * If you set this annotation to `true` for a workflow, it will capture defects
 * and include them in the result of the workflow or it's activities.
 *
 * By default, this is set to `true`, meaning that defects will be captured.
 *
 * @since 1.0.0
 * @category Annotations
 */
exports.suspend = suspend;
class CaptureDefects extends /*#__PURE__*/Context.Reference()("@effect/workflow/Workflow/CaptureDefects", {
  defaultValue: _Function.constTrue
}) {}
/**
 * If you set this annotation to `true` for a workflow, it will suspend if it
 * encounters any kind of error.
 *
 * You can then manually resume the workflow later with
 * `Workflow.resume(executionId)`.
 *
 * @since 1.0.0
 * @category Annotations
 */
exports.CaptureDefects = CaptureDefects;
class SuspendOnFailure extends /*#__PURE__*/Context.Reference()("@effect/workflow/Workflow/SuspendOnFailure", {
  defaultValue: _Function.constFalse
}) {}
exports.SuspendOnFailure = SuspendOnFailure;
//# sourceMappingURL=Workflow.js.map