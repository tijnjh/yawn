import { DurableDeferred } from "@effect/workflow";
import * as Activity from "@effect/workflow/Activity";
import * as DurableClock from "@effect/workflow/DurableClock";
import * as Workflow from "@effect/workflow/Workflow";
import { WorkflowEngine, WorkflowInstance } from "@effect/workflow/WorkflowEngine";
import * as Effect from "effect/Effect";
import * as Layer from "effect/Layer";
import * as Option from "effect/Option";
import * as Schema from "effect/Schema";
import { MessageStorage } from "./MessageStorage.js";
import * as Sharding from "./Sharding.js";
/**
 * @since 1.0.0
 * @category Constructors
 */
export declare const make: Effect.Effect<{
    readonly register: (workflow: Workflow.Any, execute: (payload: object, executionId: string) => Effect.Effect<unknown, unknown, WorkflowInstance | WorkflowEngine>) => Effect.Effect<void>;
    readonly execute: <const Discard extends boolean>(options: {
        readonly workflow: Workflow.Any;
        readonly executionId: string;
        readonly payload: object;
        readonly discard: Discard;
        readonly parent?: WorkflowInstance["Type"] | undefined;
    }) => Effect.Effect<Discard extends true ? void : Workflow.Result<unknown, unknown>>;
    readonly poll: (options: {
        readonly workflow: Workflow.Any;
        readonly executionId: string;
    }) => Effect.Effect<Workflow.Result<unknown, unknown> | undefined>;
    readonly interrupt: (workflow: Workflow.Any, executionId: string) => Effect.Effect<void>;
    readonly resume: (workflow: Workflow.Any, executionId: string) => Effect.Effect<void>;
    readonly activityExecute: (options: {
        readonly activity: Activity.Any;
        readonly attempt: number;
    }) => Effect.Effect<Workflow.Result<unknown, unknown>, never, WorkflowInstance>;
    readonly deferredResult: (deferred: DurableDeferred.Any) => Effect.Effect<Option.Option<Schema.ExitEncoded<unknown, unknown, unknown>>, never, WorkflowInstance>;
    readonly deferredDone: (options: {
        readonly workflowName: string;
        readonly executionId: string;
        readonly deferredName: string;
        readonly exit: Schema.ExitEncoded<unknown, unknown, unknown>;
    }) => Effect.Effect<void>;
    readonly scheduleClock: (options: {
        readonly workflow: Workflow.Any;
        readonly executionId: string;
        readonly clock: DurableClock.DurableClock;
    }) => Effect.Effect<void>;
}, never, import("effect/Scope").Scope | MessageStorage | Sharding.Sharding>;
/**
 * @since 1.0.0
 * @category Layers
 */
export declare const layer: Layer.Layer<WorkflowEngine, never, Sharding.Sharding | MessageStorage>;
//# sourceMappingURL=ClusterWorkflowEngine.d.ts.map