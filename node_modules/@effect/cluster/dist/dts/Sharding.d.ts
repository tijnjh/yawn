/**
 * @since 1.0.0
 */
import type * as Rpc from "@effect/rpc/Rpc";
import * as RpcClient from "@effect/rpc/RpcClient";
import * as Context from "effect/Context";
import type { DurationInput } from "effect/Duration";
import * as Effect from "effect/Effect";
import * as Layer from "effect/Layer";
import * as Schedule from "effect/Schedule";
import * as Scope from "effect/Scope";
import * as Stream from "effect/Stream";
import type { MailboxFull, PersistenceError } from "./ClusterError.js";
import { AlreadyProcessingMessage, EntityNotAssignedToRunner, EntityNotManagedByRunner } from "./ClusterError.js";
import type { CurrentAddress, CurrentRunnerAddress, Entity, HandlersFrom } from "./Entity.js";
import { EntityId } from "./EntityId.js";
import * as Message from "./Message.js";
import * as MessageStorage from "./MessageStorage.js";
import { Runners } from "./Runners.js";
import { ShardId } from "./ShardId.js";
import { ShardingConfig } from "./ShardingConfig.js";
import { type ShardingRegistrationEvent } from "./ShardingRegistrationEvent.js";
import { ShardManagerClient } from "./ShardManager.js";
import { ShardStorage } from "./ShardStorage.js";
import * as Snowflake from "./Snowflake.js";
declare const Sharding_base: Context.TagClass<Sharding, "@effect/cluster/Sharding", {
    /**
     * Returns a stream of events that occur when the runner registers entities or
     * singletons.
     */
    readonly getRegistrationEvents: Stream.Stream<ShardingRegistrationEvent>;
    /**
     * Returns the `ShardId` of the shard to which the entity at the specified
     * `address` is assigned.
     */
    readonly getShardId: (entityId: EntityId, group: string) => ShardId;
    /**
     * Returns `true` if sharding is shutting down, `false` otherwise.
     */
    readonly isShutdown: Effect.Effect<boolean>;
    /**
     * Constructs a `RpcClient` which can be used to send messages to the
     * specified `Entity`.
     */
    readonly makeClient: <Type extends string, Rpcs extends Rpc.Any>(entity: Entity<Type, Rpcs>) => Effect.Effect<(entityId: string) => RpcClient.RpcClient.From<Rpcs, MailboxFull | AlreadyProcessingMessage | PersistenceError | EntityNotManagedByRunner>>;
    /**
     * Registers a new entity with the runner.
     */
    readonly registerEntity: <Type extends string, Rpcs extends Rpc.Any, Handlers extends HandlersFrom<Rpcs>, RX>(entity: Entity<Type, Rpcs>, handlers: Effect.Effect<Handlers, never, RX>, options?: {
        readonly maxIdleTime?: DurationInput | undefined;
        readonly concurrency?: number | "unbounded" | undefined;
        readonly mailboxCapacity?: number | "unbounded" | undefined;
        readonly disableFatalDefects?: boolean | undefined;
        readonly defectRetryPolicy?: Schedule.Schedule<any, unknown> | undefined;
        readonly spanAttributes?: Record<string, string> | undefined;
    }) => Effect.Effect<void, never, Rpc.Context<Rpcs> | Rpc.Middleware<Rpcs> | Exclude<RX, Scope.Scope | CurrentAddress | CurrentRunnerAddress>>;
    /**
     * Registers a new singleton with the runner.
     */
    readonly registerSingleton: <E, R>(name: string, run: Effect.Effect<void, E, R>, options?: {
        readonly shardGroup?: string | undefined;
    }) => Effect.Effect<void, never, Exclude<R, Scope.Scope>>;
    /**
     * Sends a message to the specified entity.
     */
    readonly send: (message: Message.Incoming<any>) => Effect.Effect<void, EntityNotManagedByRunner | EntityNotAssignedToRunner | MailboxFull | AlreadyProcessingMessage>;
    /**
     * Sends an outgoing message
     */
    readonly sendOutgoing: (message: Message.Outgoing<any>, discard: boolean) => Effect.Effect<void, EntityNotManagedByRunner | MailboxFull | AlreadyProcessingMessage | PersistenceError>;
    /**
     * Notify sharding that a message has been persisted to storage.
     */
    readonly notify: (message: Message.Incoming<any>) => Effect.Effect<void, EntityNotManagedByRunner | EntityNotAssignedToRunner | AlreadyProcessingMessage>;
    /**
     * Reset the state of a message
     */
    readonly reset: (requestId: Snowflake.Snowflake) => Effect.Effect<boolean>;
    /**
     * Trigger a storage read, which will read all unprocessed messages.
     */
    readonly pollStorage: Effect.Effect<void>;
    /**
     * Retrieves the active entity count for the current runner.
     */
    readonly activeEntityCount: Effect.Effect<number>;
}>;
/**
 * @since 1.0.0
 * @category models
 */
export declare class Sharding extends Sharding_base {
}
/**
 * @since 1.0.0
 * @category layers
 */
export declare const layer: Layer.Layer<Sharding, never, ShardingConfig | Runners | ShardManagerClient | MessageStorage.MessageStorage | ShardStorage>;
export {};
//# sourceMappingURL=Sharding.d.ts.map