/**
 * @since 1.0.0
 */
import * as Rpc from "@effect/rpc/Rpc";
import * as RpcClient from "@effect/rpc/RpcClient";
import * as RpcGroup from "@effect/rpc/RpcGroup";
import * as RpcServer from "@effect/rpc/RpcServer";
import * as Config_ from "effect/Config";
import type { ConfigError } from "effect/ConfigError";
import * as Context from "effect/Context";
import * as Data from "effect/Data";
import * as Duration from "effect/Duration";
import * as Effect from "effect/Effect";
import * as Layer from "effect/Layer";
import * as Mailbox from "effect/Mailbox";
import * as Option from "effect/Option";
import * as Queue from "effect/Queue";
import * as Schema from "effect/Schema";
import type { Scope } from "effect/Scope";
import { RunnerNotRegistered } from "./ClusterError.js";
import * as MachineId from "./MachineId.js";
import { Runner } from "./Runner.js";
import { RunnerAddress } from "./RunnerAddress.js";
import { RunnerHealth } from "./RunnerHealth.js";
import { RpcClientProtocol, Runners } from "./Runners.js";
import { ShardId } from "./ShardId.js";
import { ShardingConfig } from "./ShardingConfig.js";
import { ShardStorage } from "./ShardStorage.js";
declare const ShardManager_base: Context.TagClass<ShardManager, "@effect/cluster/ShardManager", {
    /**
     * Get all shard assignments.
     */
    readonly getAssignments: Effect.Effect<Iterable<readonly [ShardId, Option.Option<RunnerAddress>]>>;
    /**
     * Get a stream of sharding events emit by the shard manager.
     */
    readonly shardingEvents: (address: Option.Option<RunnerAddress>) => Effect.Effect<Queue.Dequeue<ShardingEvent>, RunnerNotRegistered, Scope>;
    /**
     * Register a new runner with the cluster.
     */
    readonly register: (runner: Runner) => Effect.Effect<MachineId.MachineId>;
    /**
     * Unregister a runner from the cluster.
     */
    readonly unregister: (address: RunnerAddress) => Effect.Effect<void>;
    /**
     * Rebalance shards assigned to runners within the cluster.
     */
    readonly rebalance: Effect.Effect<void>;
    /**
     * Notify the cluster of an unhealthy runner.
     */
    readonly notifyUnhealthyRunner: (address: RunnerAddress) => Effect.Effect<void>;
    /**
     * Check and repot on the health of all runners in the cluster.
     */
    readonly checkRunnerHealth: Effect.Effect<void>;
}>;
/**
 * @since 1.0.0
 * @category models
 */
export declare class ShardManager extends ShardManager_base {
}
declare const Config_base: Context.TagClass<Config, "@effect/cluster/ShardManager/Config", {
    /**
     * The duration to wait before rebalancing shards after a change.
     */
    readonly rebalanceDebounce: Duration.DurationInput;
    /**
     * The interval on which regular rebalancing of shards will occur.
     */
    readonly rebalanceInterval: Duration.DurationInput;
    /**
     * The interval on which rebalancing of shards which failed to be
     * rebalanced will be retried.
     */
    readonly rebalanceRetryInterval: Duration.DurationInput;
    /**
     * The maximum ratio of shards to rebalance at once.
     *
     * **Note**: this value should be a number between `0` and `1`.
     */
    readonly rebalanceRate: number;
    /**
     * The interval on which persistence of Runners will be retried if it fails.
     */
    readonly persistRetryInterval: Duration.DurationInput;
    /**
     * The number of times persistence of Runners will be retried if it fails.
     */
    readonly persistRetryCount: number;
    /**
     * The interval on which Runner health will be checked.
     */
    readonly runnerHealthCheckInterval: Duration.DurationInput;
    /**
     * The length of time to wait for a Runner to respond to a ping.
     */
    readonly runnerPingTimeout: Duration.DurationInput;
}>;
/**
 * @since 1.0.0
 * @category Config
 */
export declare class Config extends Config_base {
    /**
     * @since 1.0.0
     */
    static readonly defaults: Config["Type"];
}
/**
 * @since 1.0.0
 * @category Config
 */
export declare const configConfig: Config_.Config<Config["Type"]>;
/**
 * @since 1.0.0
 * @category Config
 */
export declare const configFromEnv: Effect.Effect<Config["Type"], ConfigError>;
/**
 * @since 1.0.0
 * @category Config
 */
export declare const layerConfig: (config?: Partial<Config["Type"]> | undefined) => Layer.Layer<Config>;
/**
 * @since 1.0.0
 * @category Config
 */
export declare const layerConfigFromEnv: (config?: Partial<Config["Type"]> | undefined) => Layer.Layer<Config, ConfigError>;
declare const ShardManagerClient_base: Context.TagClass<ShardManagerClient, "@effect/cluster/ShardManager/ShardManagerClient", {
    /**
     * Register a new runner with the cluster.
     */
    readonly register: (address: RunnerAddress, groups: ReadonlyArray<string>) => Effect.Effect<MachineId.MachineId>;
    /**
     * Unregister a runner from the cluster.
     */
    readonly unregister: (address: RunnerAddress) => Effect.Effect<void>;
    /**
     * Notify the cluster of an unhealthy runner.
     */
    readonly notifyUnhealthyRunner: (address: RunnerAddress) => Effect.Effect<void>;
    /**
     * Get all shard assignments.
     */
    readonly getAssignments: Effect.Effect<Iterable<readonly [ShardId, Option.Option<RunnerAddress>]>>;
    /**
     * Get a stream of sharding events emit by the shard manager.
     */
    readonly shardingEvents: (address: Option.Option<RunnerAddress>) => Effect.Effect<Mailbox.ReadonlyMailbox<ShardingEvent>, never, Scope>;
    /**
     * Get the current time on the shard manager.
     */
    readonly getTime: Effect.Effect<number>;
}>;
/**
 * Represents a client which can be used to communicate with the
 * `ShardManager`.
 *
 * @since 1.0.0
 * @category Client
 */
export declare class ShardManagerClient extends ShardManagerClient_base {
}
/**
 * @since 1.0.0
 * @category models
 */
export declare const ShardingEventSchema: Schema.Union<[Schema.TaggedStruct<"StreamStarted", {}>, Schema.TaggedStruct<"ShardsAssigned", {
    address: typeof RunnerAddress;
    shards: Schema.Array$<typeof ShardId>;
}>, Schema.TaggedStruct<"ShardsUnassigned", {
    address: typeof RunnerAddress;
    shards: Schema.Array$<typeof ShardId>;
}>, Schema.TaggedStruct<"RunnerRegistered", {
    address: typeof RunnerAddress;
}>, Schema.TaggedStruct<"RunnerUnregistered", {
    address: typeof RunnerAddress;
}>]>;
declare const Rpcs_base: RpcGroup.RpcGroup<Rpc.Rpc<"Register", Schema.Struct<{
    runner: typeof Runner;
}>, Schema.brand<typeof Schema.Int, "MachineId">, typeof Schema.Never, never> | Rpc.Rpc<"Unregister", Schema.Struct<{
    address: typeof RunnerAddress;
}>, typeof Schema.Void, typeof Schema.Never, never> | Rpc.Rpc<"NotifyUnhealthyRunner", Schema.Struct<{
    address: typeof RunnerAddress;
}>, typeof Schema.Void, typeof Schema.Never, never> | Rpc.Rpc<"GetAssignments", typeof Schema.Void, Schema.Array$<Schema.Tuple2<typeof ShardId, Schema.Option<typeof RunnerAddress>>>, typeof Schema.Never, never> | Rpc.Rpc<"ShardingEvents", Schema.Struct<{
    address: Schema.Option<typeof RunnerAddress>;
}>, import("@effect/rpc/RpcSchema").Stream<Schema.Union<[Schema.TaggedStruct<"StreamStarted", {}>, Schema.TaggedStruct<"ShardsAssigned", {
    address: typeof RunnerAddress;
    shards: Schema.Array$<typeof ShardId>;
}>, Schema.TaggedStruct<"ShardsUnassigned", {
    address: typeof RunnerAddress;
    shards: Schema.Array$<typeof ShardId>;
}>, Schema.TaggedStruct<"RunnerRegistered", {
    address: typeof RunnerAddress;
}>, Schema.TaggedStruct<"RunnerUnregistered", {
    address: typeof RunnerAddress;
}>]>, typeof RunnerNotRegistered>, typeof Schema.Never, never> | Rpc.Rpc<"GetTime", typeof Schema.Void, typeof Schema.Number, typeof Schema.Never, never>>;
/**
 * The messaging protocol for the `ShardManager`.
 *
 * @since 1.0.0
 * @category Rpcs
 */
export declare class Rpcs extends Rpcs_base {
}
/**
 * @since 1.0.0
 * @category models
 */
export type ShardingEvent = Data.TaggedEnum<{
    StreamStarted: {};
    ShardsAssigned: {
        address: RunnerAddress;
        shards: ReadonlyArray<ShardId>;
    };
    ShardsUnassigned: {
        address: RunnerAddress;
        shards: ReadonlyArray<ShardId>;
    };
    RunnerRegistered: {
        address: RunnerAddress;
    };
    RunnerUnregistered: {
        address: RunnerAddress;
    };
}>;
/**
 * @since 1.0.0
 * @category models
 */
export declare const ShardingEvent: {
    readonly StreamStarted: Data.Case.Constructor<{
        readonly _tag: "StreamStarted";
    }, "_tag">;
    readonly ShardsAssigned: Data.Case.Constructor<{
        readonly _tag: "ShardsAssigned";
        readonly address: RunnerAddress;
        readonly shards: ReadonlyArray<ShardId>;
    }, "_tag">;
    readonly ShardsUnassigned: Data.Case.Constructor<{
        readonly _tag: "ShardsUnassigned";
        readonly address: RunnerAddress;
        readonly shards: ReadonlyArray<ShardId>;
    }, "_tag">;
    readonly RunnerRegistered: Data.Case.Constructor<{
        readonly _tag: "RunnerRegistered";
        readonly address: RunnerAddress;
    }, "_tag">;
    readonly RunnerUnregistered: Data.Case.Constructor<{
        readonly _tag: "RunnerUnregistered";
        readonly address: RunnerAddress;
    }, "_tag">;
    readonly $is: <Tag extends "StreamStarted" | "ShardsAssigned" | "ShardsUnassigned" | "RunnerRegistered" | "RunnerUnregistered">(tag: Tag) => (u: unknown) => u is Extract<{
        readonly _tag: "StreamStarted";
    }, {
        readonly _tag: Tag;
    }> | Extract<{
        readonly _tag: "ShardsAssigned";
        readonly address: RunnerAddress;
        readonly shards: ReadonlyArray<ShardId>;
    }, {
        readonly _tag: Tag;
    }> | Extract<{
        readonly _tag: "ShardsUnassigned";
        readonly address: RunnerAddress;
        readonly shards: ReadonlyArray<ShardId>;
    }, {
        readonly _tag: Tag;
    }> | Extract<{
        readonly _tag: "RunnerRegistered";
        readonly address: RunnerAddress;
    }, {
        readonly _tag: Tag;
    }> | Extract<{
        readonly _tag: "RunnerUnregistered";
        readonly address: RunnerAddress;
    }, {
        readonly _tag: Tag;
    }>;
    readonly $match: {
        <const Cases extends {
            readonly StreamStarted: (args: {
                readonly _tag: "StreamStarted";
            }) => any;
            readonly ShardsAssigned: (args: {
                readonly _tag: "ShardsAssigned";
                readonly address: RunnerAddress;
                readonly shards: ReadonlyArray<ShardId>;
            }) => any;
            readonly ShardsUnassigned: (args: {
                readonly _tag: "ShardsUnassigned";
                readonly address: RunnerAddress;
                readonly shards: ReadonlyArray<ShardId>;
            }) => any;
            readonly RunnerRegistered: (args: {
                readonly _tag: "RunnerRegistered";
                readonly address: RunnerAddress;
            }) => any;
            readonly RunnerUnregistered: (args: {
                readonly _tag: "RunnerUnregistered";
                readonly address: RunnerAddress;
            }) => any;
        }>(cases: Cases & { [K in Exclude<keyof Cases, "StreamStarted" | "ShardsAssigned" | "ShardsUnassigned" | "RunnerRegistered" | "RunnerUnregistered">]: never; }): (value: {
            readonly _tag: "StreamStarted";
        } | {
            readonly _tag: "ShardsAssigned";
            readonly address: RunnerAddress;
            readonly shards: ReadonlyArray<ShardId>;
        } | {
            readonly _tag: "ShardsUnassigned";
            readonly address: RunnerAddress;
            readonly shards: ReadonlyArray<ShardId>;
        } | {
            readonly _tag: "RunnerRegistered";
            readonly address: RunnerAddress;
        } | {
            readonly _tag: "RunnerUnregistered";
            readonly address: RunnerAddress;
        }) => import("effect/Unify").Unify<ReturnType<Cases["StreamStarted" | "ShardsAssigned" | "ShardsUnassigned" | "RunnerRegistered" | "RunnerUnregistered"]>>;
        <const Cases extends {
            readonly StreamStarted: (args: {
                readonly _tag: "StreamStarted";
            }) => any;
            readonly ShardsAssigned: (args: {
                readonly _tag: "ShardsAssigned";
                readonly address: RunnerAddress;
                readonly shards: ReadonlyArray<ShardId>;
            }) => any;
            readonly ShardsUnassigned: (args: {
                readonly _tag: "ShardsUnassigned";
                readonly address: RunnerAddress;
                readonly shards: ReadonlyArray<ShardId>;
            }) => any;
            readonly RunnerRegistered: (args: {
                readonly _tag: "RunnerRegistered";
                readonly address: RunnerAddress;
            }) => any;
            readonly RunnerUnregistered: (args: {
                readonly _tag: "RunnerUnregistered";
                readonly address: RunnerAddress;
            }) => any;
        }>(value: {
            readonly _tag: "StreamStarted";
        } | {
            readonly _tag: "ShardsAssigned";
            readonly address: RunnerAddress;
            readonly shards: ReadonlyArray<ShardId>;
        } | {
            readonly _tag: "ShardsUnassigned";
            readonly address: RunnerAddress;
            readonly shards: ReadonlyArray<ShardId>;
        } | {
            readonly _tag: "RunnerRegistered";
            readonly address: RunnerAddress;
        } | {
            readonly _tag: "RunnerUnregistered";
            readonly address: RunnerAddress;
        }, cases: Cases & { [K in Exclude<keyof Cases, "StreamStarted" | "ShardsAssigned" | "ShardsUnassigned" | "RunnerRegistered" | "RunnerUnregistered">]: never; }): import("effect/Unify").Unify<ReturnType<Cases["StreamStarted" | "ShardsAssigned" | "ShardsUnassigned" | "RunnerRegistered" | "RunnerUnregistered"]>>;
    };
};
/**
 * @since 1.0.0
 * @category Client
 */
export declare const makeClientLocal: Effect.Effect<{
    /**
     * Register a new runner with the cluster.
     */
    readonly register: (address: RunnerAddress, groups: ReadonlyArray<string>) => Effect.Effect<MachineId.MachineId>;
    /**
     * Unregister a runner from the cluster.
     */
    readonly unregister: (address: RunnerAddress) => Effect.Effect<void>;
    /**
     * Notify the cluster of an unhealthy runner.
     */
    readonly notifyUnhealthyRunner: (address: RunnerAddress) => Effect.Effect<void>;
    /**
     * Get all shard assignments.
     */
    readonly getAssignments: Effect.Effect<Iterable<readonly [ShardId, Option.Option<RunnerAddress>]>>;
    /**
     * Get a stream of sharding events emit by the shard manager.
     */
    readonly shardingEvents: (address: Option.Option<RunnerAddress>) => Effect.Effect<Mailbox.ReadonlyMailbox<ShardingEvent>, never, Scope>;
    /**
     * Get the current time on the shard manager.
     */
    readonly getTime: Effect.Effect<number>;
}, never, ShardingConfig>;
/**
 * @since 1.0.0
 * @category Client
 */
export declare const makeClientRpc: Effect.Effect<ShardManagerClient["Type"], never, ShardingConfig | RpcClient.Protocol | Scope>;
/**
 * @since 1.0.0
 * @category Client
 */
export declare const layerClientLocal: Layer.Layer<ShardManagerClient, never, ShardingConfig>;
/**
 * @since 1.0.0
 * @category Client
 */
export declare const layerClientRpc: Layer.Layer<ShardManagerClient, never, ShardingConfig | RpcClientProtocol>;
/**
 * @since 1.0.0
 * @category Constructors
 */
export declare const make: Effect.Effect<{
    /**
     * Get all shard assignments.
     */
    readonly getAssignments: Effect.Effect<Iterable<readonly [ShardId, Option.Option<RunnerAddress>]>>;
    /**
     * Get a stream of sharding events emit by the shard manager.
     */
    readonly shardingEvents: (address: Option.Option<RunnerAddress>) => Effect.Effect<Queue.Dequeue<ShardingEvent>, RunnerNotRegistered, Scope>;
    /**
     * Register a new runner with the cluster.
     */
    readonly register: (runner: Runner) => Effect.Effect<MachineId.MachineId>;
    /**
     * Unregister a runner from the cluster.
     */
    readonly unregister: (address: RunnerAddress) => Effect.Effect<void>;
    /**
     * Rebalance shards assigned to runners within the cluster.
     */
    readonly rebalance: Effect.Effect<void>;
    /**
     * Notify the cluster of an unhealthy runner.
     */
    readonly notifyUnhealthyRunner: (address: RunnerAddress) => Effect.Effect<void>;
    /**
     * Check and repot on the health of all runners in the cluster.
     */
    readonly checkRunnerHealth: Effect.Effect<void>;
}, never, Scope | ShardingConfig | Runners | RunnerHealth | ShardStorage | Config>;
/**
 * @since 1.0.0
 * @category layer
 */
export declare const layer: Layer.Layer<ShardManager, never, ShardStorage | RunnerHealth | Runners | Config | ShardingConfig>;
/**
 * @since 1.0.0
 * @category Server
 */
export declare const layerServerHandlers: Layer.Layer<Rpc.Handler<"Register"> | Rpc.Handler<"Unregister"> | Rpc.Handler<"NotifyUnhealthyRunner"> | Rpc.Handler<"GetAssignments"> | Rpc.Handler<"ShardingEvents"> | Rpc.Handler<"GetTime">, never, ShardManager>;
/**
 * @since 1.0.0
 * @category Server
 */
export declare const layerServer: Layer.Layer<never, never, ShardManager | RpcServer.Protocol>;
export {};
//# sourceMappingURL=ShardManager.d.ts.map