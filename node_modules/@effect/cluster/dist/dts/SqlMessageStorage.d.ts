import * as SqlClient from "@effect/sql/SqlClient";
import type { DurationInput } from "effect/Duration";
import * as Effect from "effect/Effect";
import * as Layer from "effect/Layer";
import * as Option from "effect/Option";
import { PersistenceError } from "./ClusterError.js";
import * as MessageStorage from "./MessageStorage.js";
import type * as Reply from "./Reply.js";
import { ShardId } from "./ShardId.js";
import type { ShardingConfig } from "./ShardingConfig.js";
import * as Snowflake from "./Snowflake.js";
/**
 * @since 1.0.0
 * @category Constructors
 */
export declare const make: (options?: {
    readonly prefix?: string | undefined;
} | undefined) => Effect.Effect<{
    readonly saveRequest: <R extends import("@effect/rpc/Rpc").Any>(envelope: import("./Message.js").OutgoingRequest<R>) => Effect.Effect<MessageStorage.SaveResult<R>, PersistenceError | import("./ClusterError.js").MalformedMessage>;
    readonly saveEnvelope: (envelope: import("./Message.js").OutgoingEnvelope) => Effect.Effect<void, PersistenceError | import("./ClusterError.js").MalformedMessage>;
    readonly saveReply: <R extends import("@effect/rpc/Rpc").Any>(reply: Reply.ReplyWithContext<R>) => Effect.Effect<void, PersistenceError | import("./ClusterError.js").MalformedMessage>;
    readonly clearReplies: (requestId: Snowflake.Snowflake) => Effect.Effect<void, PersistenceError>;
    readonly repliesFor: <R extends import("@effect/rpc/Rpc").Any>(requests: Iterable<import("./Message.js").OutgoingRequest<R>>) => Effect.Effect<Array<Reply.Reply<R>>, PersistenceError | import("./ClusterError.js").MalformedMessage>;
    readonly repliesForUnfiltered: <R extends import("@effect/rpc/Rpc").Any>(requestIds: Iterable<Snowflake.Snowflake>) => Effect.Effect<Array<Reply.ReplyEncoded<R>>, PersistenceError | import("./ClusterError.js").MalformedMessage>;
    readonly requestIdForPrimaryKey: (options: {
        readonly address: import("./EntityAddress.js").EntityAddress;
        readonly tag: string;
        readonly id: string;
    }) => Effect.Effect<Option.Option<Snowflake.Snowflake>, PersistenceError>;
    readonly registerReplyHandler: <R extends import("@effect/rpc/Rpc").Any>(message: import("./Message.js").OutgoingRequest<R> | import("./Message.js").IncomingRequest<R>, onUnregister: Effect.Effect<void>) => Effect.Effect<void>;
    readonly unregisterReplyHandler: (requestId: Snowflake.Snowflake) => Effect.Effect<void>;
    readonly unprocessedMessages: (shardIds: Iterable<ShardId>) => Effect.Effect<Array<import("./Message.js").Incoming<any>>, PersistenceError>;
    readonly unprocessedMessagesById: <R extends import("@effect/rpc/Rpc").Any>(messageIds: Iterable<Snowflake.Snowflake>) => Effect.Effect<Array<import("./Message.js").Incoming<R>>, PersistenceError>;
    readonly resetShards: (shardIds: Iterable<ShardId>) => Effect.Effect<void, PersistenceError>;
    readonly resetAddress: (address: import("./EntityAddress.js").EntityAddress) => Effect.Effect<void, PersistenceError>;
    readonly clearAddress: (address: import("./EntityAddress.js").EntityAddress) => Effect.Effect<void, PersistenceError>;
}, never, Snowflake.Generator | SqlClient.SqlClient>;
/**
 * @since 1.0.0
 * @category Layers
 */
export declare const layer: Layer.Layer<MessageStorage.MessageStorage, never, SqlClient.SqlClient | ShardingConfig>;
/**
 * @since 1.0.0
 * @category Layers
 */
export declare const layerWith: (options: {
    readonly prefix?: string | undefined;
    readonly replyPollInterval?: DurationInput | undefined;
}) => Layer.Layer<MessageStorage.MessageStorage, never, SqlClient.SqlClient | ShardingConfig>;
//# sourceMappingURL=SqlMessageStorage.d.ts.map