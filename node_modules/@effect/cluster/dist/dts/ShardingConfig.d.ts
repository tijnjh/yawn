/**
 * @since 1.0.0
 */
import * as Config from "effect/Config";
import type { ConfigError } from "effect/ConfigError";
import * as Context from "effect/Context";
import type { DurationInput } from "effect/Duration";
import * as Effect from "effect/Effect";
import * as Layer from "effect/Layer";
import * as Option from "effect/Option";
import { RunnerAddress } from "./RunnerAddress.js";
declare const ShardingConfig_base: Context.TagClass<ShardingConfig, "@effect/cluster/ShardingConfig", {
    /**
     * The address for the current runner that other runners can use to
     * communicate with it.
     *
     * If `None`, the runner is not part of the cluster and will be in a client-only
     * mode.
     */
    readonly runnerAddress: Option.Option<RunnerAddress>;
    /**
     * The listen address for the current runner.
     *
     * Defaults to the `runnerAddress`.
     */
    readonly runnerListenAddress: Option.Option<RunnerAddress>;
    /**
     * The version of the current runner.
     */
    readonly serverVersion: number;
    /**
     * The shard groups that are assigned to this runner.
     *
     * Defaults to `["default"]`.
     */
    readonly shardGroups: ReadonlyArray<string>;
    /**
     * The number of shards to allocate per shard group.
     *
     * **Note**: this value should be consistent across all runners.
     */
    readonly shardsPerGroup: number;
    /**
     * The address of the shard manager.
     */
    readonly shardManagerAddress: RunnerAddress;
    /**
     * If the shard manager is unavailable for this duration, all the shard
     * assignments will be reset.
     */
    readonly shardManagerUnavailableTimeout: DurationInput;
    /**
     * The default capacity of the mailbox for entities.
     */
    readonly entityMailboxCapacity: number | "unbounded";
    /**
     * The maximum duration of inactivity (i.e. without receiving a message)
     * after which an entity will be interrupted.
     */
    readonly entityMaxIdleTime: DurationInput;
    /**
     * The maximum duration of time to wait for an entity to terminate.
     *
     * By default this is set to 15 seconds to stay within kubernetes defaults.
     */
    readonly entityTerminationTimeout: DurationInput;
    /**
     * The interval at which to poll for unprocessed messages from storage.
     */
    readonly entityMessagePollInterval: DurationInput;
    /**
     * The interval at which to poll for client replies from storage.
     */
    readonly entityReplyPollInterval: DurationInput;
    readonly refreshAssignmentsInterval: DurationInput;
    /**
     * The interval to retry a send if EntityNotAssignedToRunner is returned.
     */
    readonly sendRetryInterval: DurationInput;
    /**
     * Simulate serialization and deserialization to remote runners for local
     * entities.
     */
    readonly simulateRemoteSerialization: boolean;
}>;
/**
 * Represents the configuration for the `Sharding` service on a given runner.
 *
 * @since 1.0.0
 * @category models
 */
export declare class ShardingConfig extends ShardingConfig_base {
}
/**
 * @since 1.0.0
 * @category defaults
 */
export declare const defaults: ShardingConfig["Type"];
/**
 * @since 1.0.0
 * @category Layers
 */
export declare const layer: (options?: Partial<ShardingConfig["Type"]>) => Layer.Layer<ShardingConfig>;
/**
 * @since 1.0.0
 * @category defaults
 */
export declare const layerDefaults: Layer.Layer<ShardingConfig>;
/**
 * @since 1.0.0
 * @category Config
 */
export declare const config: Config.Config<ShardingConfig["Type"]>;
/**
 * @since 1.0.0
 * @category Config
 */
export declare const configFromEnv: Effect.Effect<{
    /**
     * The address for the current runner that other runners can use to
     * communicate with it.
     *
     * If `None`, the runner is not part of the cluster and will be in a client-only
     * mode.
     */
    readonly runnerAddress: Option.Option<RunnerAddress>;
    /**
     * The listen address for the current runner.
     *
     * Defaults to the `runnerAddress`.
     */
    readonly runnerListenAddress: Option.Option<RunnerAddress>;
    /**
     * The version of the current runner.
     */
    readonly serverVersion: number;
    /**
     * The shard groups that are assigned to this runner.
     *
     * Defaults to `["default"]`.
     */
    readonly shardGroups: ReadonlyArray<string>;
    /**
     * The number of shards to allocate per shard group.
     *
     * **Note**: this value should be consistent across all runners.
     */
    readonly shardsPerGroup: number;
    /**
     * The address of the shard manager.
     */
    readonly shardManagerAddress: RunnerAddress;
    /**
     * If the shard manager is unavailable for this duration, all the shard
     * assignments will be reset.
     */
    readonly shardManagerUnavailableTimeout: DurationInput;
    /**
     * The default capacity of the mailbox for entities.
     */
    readonly entityMailboxCapacity: number | "unbounded";
    /**
     * The maximum duration of inactivity (i.e. without receiving a message)
     * after which an entity will be interrupted.
     */
    readonly entityMaxIdleTime: DurationInput;
    /**
     * The maximum duration of time to wait for an entity to terminate.
     *
     * By default this is set to 15 seconds to stay within kubernetes defaults.
     */
    readonly entityTerminationTimeout: DurationInput;
    /**
     * The interval at which to poll for unprocessed messages from storage.
     */
    readonly entityMessagePollInterval: DurationInput;
    /**
     * The interval at which to poll for client replies from storage.
     */
    readonly entityReplyPollInterval: DurationInput;
    readonly refreshAssignmentsInterval: DurationInput;
    /**
     * The interval to retry a send if EntityNotAssignedToRunner is returned.
     */
    readonly sendRetryInterval: DurationInput;
    /**
     * Simulate serialization and deserialization to remote runners for local
     * entities.
     */
    readonly simulateRemoteSerialization: boolean;
}, ConfigError, never>;
/**
 * @since 1.0.0
 * @category Layers
 */
export declare const layerFromEnv: (options?: Partial<ShardingConfig["Type"]> | undefined) => Layer.Layer<ShardingConfig, ConfigError>;
export {};
//# sourceMappingURL=ShardingConfig.d.ts.map