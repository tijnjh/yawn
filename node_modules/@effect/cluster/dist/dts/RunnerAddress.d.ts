/**
 * @since 1.0.0
 */
import * as Equal from "effect/Equal";
import * as Hash from "effect/Hash";
import { NodeInspectSymbol } from "effect/Inspectable";
import * as Schema from "effect/Schema";
/**
 * @since 1.0.0
 * @category type ids
 */
export declare const TypeId: unique symbol;
/**
 * @since 1.0.0
 * @category type ids
 */
export type TypeId = typeof TypeId;
declare const RunnerAddress_base: Schema.Class<RunnerAddress, {
    host: typeof Schema.NonEmptyString;
    port: typeof Schema.Int;
}, Schema.Struct.Encoded<{
    host: typeof Schema.NonEmptyString;
    port: typeof Schema.Int;
}>, never, {
    readonly host: string;
} & {
    readonly port: number;
}, {}, {}>;
/**
 * @since 1.0.0
 * @category models
 */
export declare class RunnerAddress extends RunnerAddress_base {
    /**
     * @since 1.0.0
     */
    readonly [TypeId]: symbol;
    /**
     * @since 1.0.0
     */
    [Equal.symbol](that: RunnerAddress): boolean;
    /**
     * @since 1.0.0
     */
    [Hash.symbol](): number;
    /**
     * @since 1.0.0
     */
    toString(): string;
    /**
     * @since 1.0.0
     */
    [NodeInspectSymbol](): string;
}
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const make: (host: string, port: number) => RunnerAddress;
export {};
//# sourceMappingURL=RunnerAddress.d.ts.map