"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.make = void 0;
var Rpc = _interopRequireWildcard(require("@effect/rpc/Rpc"));
var Cron = _interopRequireWildcard(require("effect/Cron"));
var DateTime = _interopRequireWildcard(require("effect/DateTime"));
var Duration = _interopRequireWildcard(require("effect/Duration"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Exit = _interopRequireWildcard(require("effect/Exit"));
var Layer = _interopRequireWildcard(require("effect/Layer"));
var Option = _interopRequireWildcard(require("effect/Option"));
var PrimaryKey = _interopRequireWildcard(require("effect/PrimaryKey"));
var Schedule = _interopRequireWildcard(require("effect/Schedule"));
var Schema = _interopRequireWildcard(require("effect/Schema"));
var _ClusterSchema = _interopRequireWildcard(require("./ClusterSchema.js"));
var ClusterSchema = _ClusterSchema;
var DeliverAt = _interopRequireWildcard(require("./DeliverAt.js"));
var Entity = _interopRequireWildcard(require("./Entity.js"));
var Singleton = _interopRequireWildcard(require("./Singleton.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * @since 1.0.0
 */

/**
 * @since 1.0.0
 * @category Constructors
 */
const make = options => {
  const CronEntity = Entity.make(`ClusterCron/${options.name}`, [Rpc.make("run", {
    payload: CronPayload
  }).annotate(_ClusterSchema.Persisted, true).annotate(_ClusterSchema.Uninterruptible, true)]).annotate(ClusterSchema.ShardGroup, () => options.shardGroup ?? "default").annotate(ClusterSchema.ClientTracingEnabled, false);
  const InitialRun = Singleton.make(`ClusterCron/${options.name}`, Effect.gen(function* () {
    const client = (yield* CronEntity.client)("initial");
    const now = yield* DateTime.now;
    const next = Cron.next(options.cron, now);
    yield* client.run({
      dateTime: DateTime.unsafeFromDate(next)
    }, {
      discard: true
    });
  }), {
    shardGroup: options.shardGroup
  });
  const skipIfOlderThan = Option.fromNullable(options.skipIfOlderThan).pipe(Option.map(Duration.decode), Option.getOrElse(() => Duration.days(1)));
  const effect = Effect.fnUntraced(function* (dateTime) {
    const now = yield* DateTime.now;
    if (DateTime.lessThan(dateTime, DateTime.subtractDuration(now, skipIfOlderThan))) {
      return;
    }
    return yield* options.execute;
  }, Effect.orDie);
  const EntityLayer = CronEntity.toLayer(Effect.gen(function* () {
    const makeClient = yield* CronEntity.client;
    return {
      run: request => effect(request.payload.dateTime).pipe(Effect.exit, Effect.flatMap(Effect.fnUntraced(function* (exit) {
        if (Exit.isFailure(exit)) {
          yield* Effect.logWarning(exit.cause);
        }
        const now = yield* DateTime.now;
        const next = DateTime.unsafeFromDate(Cron.next(options.cron, options.calculateNextRunFromPrevious ? request.payload.dateTime : now));
        const client = makeClient(DateTime.formatIso(next));
        return yield* client.run({
          dateTime: next
        }, {
          discard: true
        }).pipe(Effect.tapErrorCause(cause => Effect.logWarning("Failed to schedule next run, retrying", cause)), Effect.sandbox, Effect.retry(retryPolicy), Effect.orDie);
      })), Effect.annotateLogs({
        module: "ClusterCron",
        name: options.name,
        dateTime: request.payload.dateTime
      }))
    };
  }));
  return Layer.merge(InitialRun, EntityLayer);
};
exports.make = make;
const retryPolicy = /*#__PURE__*/Schedule.exponential(200, 1.5).pipe(/*#__PURE__*/Schedule.union(/*#__PURE__*/Schedule.spaced("1 minute")));
class CronPayload extends /*#__PURE__*/Schema.Class("@effect/cluster/ClusterCron/CronPayload")({
  dateTime: Schema.DateTimeUtc
}) {
  [PrimaryKey.symbol]() {
    return "";
  }
  [DeliverAt.symbol]() {
    return this.dateTime;
  }
}
//# sourceMappingURL=ClusterCron.js.map