"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeRpcClient = exports.makeRpc = exports.makeNoop = exports.make = exports.layerRpc = exports.layerNoop = exports.Runners = exports.Rpcs = exports.RpcClientProtocol = void 0;
var Rpc = _interopRequireWildcard(require("@effect/rpc/Rpc"));
var RpcClient_ = _interopRequireWildcard(require("@effect/rpc/RpcClient"));
var RpcGroup = _interopRequireWildcard(require("@effect/rpc/RpcGroup"));
var RpcSchema = _interopRequireWildcard(require("@effect/rpc/RpcSchema"));
var Cause = _interopRequireWildcard(require("effect/Cause"));
var Context = _interopRequireWildcard(require("effect/Context"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Exit = _interopRequireWildcard(require("effect/Exit"));
var FiberRef = _interopRequireWildcard(require("effect/FiberRef"));
var Layer = _interopRequireWildcard(require("effect/Layer"));
var Option = _interopRequireWildcard(require("effect/Option"));
var RcMap = _interopRequireWildcard(require("effect/RcMap"));
var Schema = _interopRequireWildcard(require("effect/Schema"));
var _ClusterError = require("./ClusterError.js");
var _ClusterSchema = require("./ClusterSchema.js");
var Envelope = _interopRequireWildcard(require("./Envelope.js"));
var Message = _interopRequireWildcard(require("./Message.js"));
var MessageStorage = _interopRequireWildcard(require("./MessageStorage.js"));
var Reply = _interopRequireWildcard(require("./Reply.js"));
var _ShardingConfig = require("./ShardingConfig.js");
var Snowflake = _interopRequireWildcard(require("./Snowflake.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * @since 1.0.0
 */

/**
 * @since 1.0.0
 * @category context
 */
class Runners extends /*#__PURE__*/Context.Tag("@effect/cluster/Runners")() {}
/**
 * @since 1.0.0
 * @category Constructors
 */
exports.Runners = Runners;
const make = exports.make = /*#__PURE__*/Effect.fnUntraced(function* (options) {
  const storage = yield* MessageStorage.MessageStorage;
  const runnersScope = yield* Effect.scope;
  const snowflakeGen = yield* Snowflake.Generator;
  const config = yield* _ShardingConfig.ShardingConfig;
  const requestIdRewrites = new Map();
  function notifyWith(message, afterPersist) {
    const rpc = message.rpc;
    const persisted = Context.get(rpc.annotations, _ClusterSchema.Persisted);
    if (!persisted) {
      return Effect.dieMessage("Runners.notify only supports persisted messages");
    }
    if (message._tag === "OutgoingEnvelope") {
      const rewriteId = requestIdRewrites.get(message.envelope.requestId);
      const requestId = rewriteId ?? message.envelope.requestId;
      const entry = storageRequests.get(requestId);
      if (rewriteId) {
        message = new Message.OutgoingEnvelope({
          ...message,
          envelope: message.envelope.withRequestId(rewriteId)
        });
      }
      return storage.saveEnvelope(message).pipe(Effect.catchTag("MalformedMessage", Effect.die), Effect.zipRight(entry ? Effect.zipRight(entry.latch.open, afterPersist(message, false)) : afterPersist(message, false)));
    }
    // For requests, after persisting the request, we need to check if the
    // request is a duplicate. If it is, we need to resume from the last
    // received reply.
    //
    // Otherwise, we notify the remote entity and then reply from storage.
    return Effect.flatMap(Effect.catchTag(storage.saveRequest(message), "MalformedMessage", Effect.die), MessageStorage.SaveResult.$match({
      Success: () => afterPersist(message, false),
      Duplicate: ({
        lastReceivedReply,
        originalId
      }) => {
        // If the last received reply is an exit, we can just return it
        // as the response.
        if (Option.isSome(lastReceivedReply) && lastReceivedReply.value._tag === "WithExit") {
          return message.respond(lastReceivedReply.value.withRequestId(message.envelope.requestId));
        }
        requestIdRewrites.set(message.envelope.requestId, originalId);
        return afterPersist(new Message.OutgoingRequest({
          ...message,
          lastReceivedReply,
          envelope: Envelope.makeRequest({
            ...message.envelope,
            requestId: originalId
          }),
          respond(reply) {
            if (reply._tag === "WithExit") {
              requestIdRewrites.delete(message.envelope.requestId);
            }
            return message.respond(reply.withRequestId(message.envelope.requestId));
          }
        }), true);
      }
    }));
  }
  const storageRequests = new Map();
  const waitingStorageRequests = new Map();
  const replyFromStorage = Effect.fnUntraced(function* (message) {
    let entry = storageRequests.get(message.envelope.requestId);
    if (entry) {
      entry.messages.add(message);
      entry.doneLatch ??= Effect.unsafeMakeLatch(false);
      return yield* entry.doneLatch.await;
    } else {
      entry = {
        latch: Effect.unsafeMakeLatch(false),
        doneLatch: undefined,
        replies: [],
        messages: new Set([message])
      };
      storageRequests.set(message.envelope.requestId, entry);
    }
    while (true) {
      // wait for the storage loop to notify us
      entry.latch.unsafeClose();
      waitingStorageRequests.set(message.envelope.requestId, message);
      storageLatch.unsafeOpen();
      yield* entry.latch.await;
      // send the replies back
      for (let i = 0; i < entry.replies.length; i++) {
        const reply = entry.replies[i];
        // we have reached the end
        if (reply._tag === "WithExit") {
          for (const message of entry.messages) {
            yield* message.respond(reply);
          }
          entry.doneLatch?.unsafeOpen();
          return;
        }
        entry.latch.unsafeClose();
        for (const message of entry.messages) {
          yield* message.respond(reply);
        }
        yield* entry.latch.await;
      }
      entry.replies = [];
    }
  }, (effect, message) => Effect.ensuring(effect, Effect.sync(() => {
    const entry = storageRequests.get(message.envelope.requestId);
    if (!entry || entry.messages.size > 1) {
      entry?.messages.delete(message);
      return;
    }
    storageRequests.delete(message.envelope.requestId);
    waitingStorageRequests.delete(message.envelope.requestId);
  })));
  const storageLatch = Effect.unsafeMakeLatch(false);
  if (storage !== MessageStorage.noop) {
    yield* Effect.gen(function* () {
      while (true) {
        yield* storageLatch.await;
        storageLatch.unsafeClose();
        const replies = yield* storage.repliesFor(waitingStorageRequests.values()).pipe(Effect.catchAllCause(cause => Effect.as(Effect.annotateLogs(Effect.logDebug(cause), {
          package: "@effect/cluster",
          module: "Runners",
          fiber: "Read replies loop"
        }), [])));
        const foundRequests = new Set();
        // put the replies into the storage requests and then open the latches
        for (let i = 0; i < replies.length; i++) {
          const reply = replies[i];
          const entry = storageRequests.get(reply.requestId);
          if (!entry) continue;
          entry.replies.push(reply);
          waitingStorageRequests.delete(reply.requestId);
          foundRequests.add(entry);
        }
        foundRequests.forEach(entry => entry.latch.unsafeOpen());
      }
    }).pipe(Effect.interruptible, Effect.forkIn(runnersScope));
    yield* Effect.suspend(() => {
      if (waitingStorageRequests.size === 0) {
        return storageLatch.await;
      }
      return storageLatch.open;
    }).pipe(Effect.delay(config.entityReplyPollInterval), Effect.forever, Effect.interruptible, Effect.forkIn(runnersScope));
  }
  return Runners.of({
    ...options,
    sendLocal(options) {
      const message = options.message;
      if (!options.simulateRemoteSerialization) {
        return options.send(Message.incomingLocalFromOutgoing(message));
      }
      return Message.serialize(message).pipe(Effect.flatMap(encoded => Message.deserializeLocal(message, encoded)), Effect.flatMap(options.send), Effect.catchTag("MalformedMessage", error => {
        if (message._tag === "OutgoingEnvelope") {
          return Effect.die(error);
        }
        return message.respond(new Reply.WithExit({
          id: snowflakeGen.unsafeNext(),
          requestId: message.envelope.requestId,
          exit: Exit.die(error)
        }));
      }));
    },
    notify(options_) {
      const {
        discard,
        message
      } = options_;
      return notifyWith(message, (message, duplicate) => {
        if (discard || message._tag === "OutgoingEnvelope") {
          return options.notify(options_);
        } else if (!duplicate && options_.address._tag === "Some") {
          return Effect.catchAll(options.send({
            address: options_.address.value,
            message
          }), error => {
            if (error._tag === "EntityNotManagedByRunner") {
              return Effect.fail(error);
            }
            return replyFromStorage(message);
          });
        }
        return options.notify(options_).pipe(Effect.andThen(replyFromStorage(message)));
      });
    },
    notifyLocal(options) {
      return notifyWith(options.message, (message, duplicate) => {
        if (options.discard || message._tag === "OutgoingEnvelope") {
          return Effect.catchTag(options.notify(Message.incomingLocalFromOutgoing(message)), "EntityNotAssignedToRunner", () => Effect.void);
        } else if (!duplicate && options.storageOnly !== true) {
          return storage.registerReplyHandler(message, Effect.suspend(() => replyFromStorage(message).pipe(Effect.forkIn(runnersScope), Effect.interruptible))).pipe(Effect.andThen(options.notify(Message.incomingLocalFromOutgoing(message))), Effect.catchTag("EntityNotAssignedToRunner", () => Effect.void));
        }
        return options.notify(Message.incomingLocalFromOutgoing(message)).pipe(Effect.catchTag("EntityNotAssignedToRunner", () => Effect.void), Effect.andThen(replyFromStorage(message)));
      });
    }
  });
});
/**
 * @since 1.0.0
 * @category No-op
 */
const makeNoop = exports.makeNoop = /*#__PURE__*/make({
  send: ({
    message
  }) => Effect.fail(new _ClusterError.EntityNotManagedByRunner({
    address: message.envelope.address
  })),
  notify: () => Effect.void,
  ping: () => Effect.void
});
/**
 * @since 1.0.0
 * @category Layers
 */
const layerNoop = exports.layerNoop = /*#__PURE__*/Layer.scoped(Runners, makeNoop).pipe(/*#__PURE__*/Layer.provide([Snowflake.layerGenerator]));
const rpcErrors = /*#__PURE__*/Schema.Union(_ClusterError.EntityNotManagedByRunner, _ClusterError.EntityNotAssignedToRunner, _ClusterError.MailboxFull, _ClusterError.AlreadyProcessingMessage);
/**
 * @since 1.0.0
 * @category Rpcs
 */
class Rpcs extends /*#__PURE__*/RpcGroup.make(/*#__PURE__*/Rpc.make("Ping"), /*#__PURE__*/Rpc.make("Notify", {
  payload: {
    envelope: Envelope.PartialEncoded
  },
  success: Schema.Void,
  error: /*#__PURE__*/Schema.Union(_ClusterError.EntityNotManagedByRunner, _ClusterError.EntityNotAssignedToRunner, _ClusterError.AlreadyProcessingMessage)
}), /*#__PURE__*/Rpc.make("Effect", {
  payload: {
    request: Envelope.PartialEncodedRequest,
    persisted: Schema.Boolean
  },
  success: Schema.Object,
  error: rpcErrors
}), /*#__PURE__*/Rpc.make("Stream", {
  payload: {
    request: Envelope.PartialEncodedRequest,
    persisted: Schema.Boolean
  },
  error: rpcErrors,
  success: Schema.Object,
  stream: true
}), /*#__PURE__*/Rpc.make("Envelope", {
  payload: {
    envelope: /*#__PURE__*/Schema.Union(Envelope.AckChunk, Envelope.Interrupt),
    persisted: Schema.Boolean
  },
  error: rpcErrors
})) {}
/**
 * @since 1.0.0
 * @category Rpcs
 */
exports.Rpcs = Rpcs;
const makeRpcClient = exports.makeRpcClient = /*#__PURE__*/RpcClient_.make(Rpcs, {
  spanPrefix: "Runners",
  disableTracing: true
});
/**
 * @since 1.0.0
 * @category constructors
 */
const makeRpc = exports.makeRpc = /*#__PURE__*/Effect.gen(function* () {
  const makeClientProtocol = yield* RpcClientProtocol;
  const snowflakeGen = yield* Snowflake.Generator;
  const clients = yield* RcMap.make({
    lookup: address => Effect.flatMap(makeClientProtocol(address), protocol => Effect.provideService(makeRpcClient, RpcClient_.Protocol, protocol)),
    idleTimeToLive: "3 minutes"
  });
  return yield* make({
    ping(address) {
      return RcMap.get(clients, address).pipe(Effect.flatMap(client => client.Ping()), Effect.catchAllCause(() => Effect.fail(new _ClusterError.RunnerUnavailable({
        address
      }))), Effect.scoped);
    },
    send({
      address,
      message
    }) {
      const rpc = message.rpc;
      const isPersisted = Context.get(rpc.annotations, _ClusterSchema.Persisted);
      if (message._tag === "OutgoingEnvelope") {
        return RcMap.get(clients, address).pipe(Effect.flatMap(client => client.Envelope({
          envelope: message.envelope,
          persisted: isPersisted
        })), Effect.catchTag("RpcClientError", Effect.die), Effect.scoped, Effect.catchAllDefect(() => Effect.fail(new _ClusterError.RunnerUnavailable({
          address
        }))));
      }
      const isStream = RpcSchema.isStreamSchema(rpc.successSchema);
      if (!isStream) {
        return Effect.matchEffect(Message.serializeRequest(message), {
          onSuccess: request => RcMap.get(clients, address).pipe(Effect.flatMap(client => client.Effect({
            request,
            persisted: isPersisted
          })), Effect.catchTag("RpcClientError", Effect.die), Effect.flatMap(reply => Schema.decode(Reply.Reply(message.rpc))(reply).pipe(Effect.locally(FiberRef.currentContext, message.context), Effect.orDie)), Effect.flatMap(message.respond), Effect.scoped, Effect.catchAllDefect(() => Effect.fail(new _ClusterError.RunnerUnavailable({
            address
          })))),
          onFailure: error => message.respond(new Reply.WithExit({
            id: snowflakeGen.unsafeNext(),
            requestId: message.envelope.requestId,
            exit: Exit.die(error)
          }))
        });
      }
      return Effect.matchEffect(Message.serializeRequest(message), {
        onSuccess: request => RcMap.get(clients, address).pipe(Effect.flatMap(client => client.Stream({
          request,
          persisted: isPersisted
        }, {
          asMailbox: true
        })), Effect.flatMap(mailbox => {
          const decode = Schema.decode(Reply.Reply(message.rpc));
          return mailbox.take.pipe(Effect.flatMap(reply => Effect.orDie(decode(reply))), Effect.flatMap(message.respond), Effect.forever, Effect.catchTag("RpcClientError", Effect.die), Effect.locally(FiberRef.currentContext, message.context), Effect.catchIf(Cause.isNoSuchElementException, () => Effect.void), Effect.catchAllDefect(() => Effect.fail(new _ClusterError.RunnerUnavailable({
            address
          }))));
        }), Effect.scoped),
        onFailure: error => message.respond(new Reply.WithExit({
          id: snowflakeGen.unsafeNext(),
          requestId: message.envelope.requestId,
          exit: Exit.die(error)
        }))
      });
    },
    notify({
      address,
      message
    }) {
      if (Option.isNone(address)) {
        return Effect.void;
      }
      const envelope = message.envelope;
      return RcMap.get(clients, address.value).pipe(Effect.flatMap(client => client.Notify({
        envelope
      })), Effect.scoped, Effect.catchAll(error => {
        if (error._tag === "EntityNotManagedByRunner") {
          return Effect.fail(error);
        }
        return Effect.void;
      }));
    }
  });
});
/**
 * @since 1.0.0
 * @category Layers
 */
const layerRpc = exports.layerRpc = /*#__PURE__*/Layer.scoped(Runners, makeRpc).pipe(/*#__PURE__*/Layer.provide(Snowflake.layerGenerator));
/**
 * @since 1.0.0
 * @category Client
 */
class RpcClientProtocol extends /*#__PURE__*/Context.Tag("@effect/cluster/Runners/RpcClientProtocol")() {}
exports.RpcClientProtocol = RpcClientProtocol;
//# sourceMappingURL=Runners.js.map