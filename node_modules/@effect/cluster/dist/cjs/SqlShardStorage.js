"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.make = exports.layerWith = exports.layer = void 0;
var SqlClient = _interopRequireWildcard(require("@effect/sql/SqlClient"));
var Arr = _interopRequireWildcard(require("effect/Array"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Layer = _interopRequireWildcard(require("effect/Layer"));
var _ClusterError = require("./ClusterError.js");
var ShardStorage = _interopRequireWildcard(require("./ShardStorage.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * @since 1.0.0
 */

const withTracerDisabled = /*#__PURE__*/Effect.withTracerEnabled(false);
/**
 * @since 1.0.0
 * @category Constructors
 */
const make = exports.make = /*#__PURE__*/Effect.fnUntraced(function* (options) {
  const sql = (yield* SqlClient.SqlClient).withoutTransforms();
  const prefix = options?.prefix ?? "cluster";
  const table = name => `${prefix}_${name}`;
  const runnersTable = table("runners");
  const runnersTableSql = sql(runnersTable);
  yield* sql.onDialectOrElse({
    mssql: () => sql`
        IF OBJECT_ID(N'${runnersTableSql}', N'U') IS NULL
        CREATE TABLE ${runnersTableSql} (
          address VARCHAR(255) PRIMARY KEY,
          runner TEXT NOT NULL
        )
      `,
    mysql: () => sql`
        CREATE TABLE IF NOT EXISTS ${runnersTableSql} (
          address VARCHAR(255) PRIMARY KEY,
          runner TEXT NOT NULL
        )
      `,
    pg: () => sql`
        CREATE TABLE IF NOT EXISTS ${runnersTableSql} (
          address VARCHAR(255) PRIMARY KEY,
          runner TEXT NOT NULL
        )
      `,
    orElse: () =>
    // sqlite
    sql`
        CREATE TABLE IF NOT EXISTS ${runnersTableSql} (
          address TEXT PRIMARY KEY,
          runner TEXT NOT NULL
        )
      `
  });
  const shardsTable = table("shards");
  const shardsTableSql = sql(shardsTable);
  yield* sql.onDialectOrElse({
    mssql: () => sql`
        IF OBJECT_ID(N'${shardsTableSql}', N'U') IS NULL
        CREATE TABLE ${shardsTableSql} (
          shard_id VARCHAR(50) PRIMARY KEY,
          address VARCHAR(255)
        )
      `,
    mysql: () => sql`
        CREATE TABLE IF NOT EXISTS ${shardsTableSql} (
          shard_id VARCHAR(50) PRIMARY KEY,
          address VARCHAR(255)
        )
      `,
    pg: () => sql`
        CREATE TABLE IF NOT EXISTS ${shardsTableSql} (
          shard_id VARCHAR(50) PRIMARY KEY,
          address VARCHAR(255)
        )
      `,
    orElse: () =>
    // sqlite
    sql`
        CREATE TABLE IF NOT EXISTS ${shardsTableSql} (
          shard_id TEXT PRIMARY KEY,
          address TEXT
        )
      `
  });
  const locksTable = table("locks");
  const locksTableSql = sql(locksTable);
  yield* sql.onDialectOrElse({
    mssql: () => sql`
        IF OBJECT_ID(N'${locksTableSql}', N'U') IS NULL
        CREATE TABLE ${locksTableSql} (
          shard_id VARCHAR(50) PRIMARY KEY,
          address VARCHAR(255) NOT NULL,
          acquired_at DATETIME NOT NULL
        )
      `,
    mysql: () => sql`
        CREATE TABLE IF NOT EXISTS ${locksTableSql} (
          shard_id VARCHAR(50) PRIMARY KEY,
          address VARCHAR(255) NOT NULL,
          acquired_at DATETIME NOT NULL
        )
      `,
    pg: () => sql`
        CREATE TABLE IF NOT EXISTS ${locksTableSql} (
          shard_id VARCHAR(50) PRIMARY KEY,
          address VARCHAR(255) NOT NULL,
          acquired_at TIMESTAMP NOT NULL
        )
      `,
    orElse: () =>
    // sqlite
    sql`
        CREATE TABLE IF NOT EXISTS ${locksTableSql} (
          shard_id TEXT PRIMARY KEY,
          address TEXT NOT NULL,
          acquired_at DATETIME NOT NULL
        )
      `
  });
  const sqlNowString = sql.onDialectOrElse({
    pg: () => "NOW()",
    mysql: () => "NOW()",
    mssql: () => "GETDATE()",
    orElse: () => "CURRENT_TIMESTAMP"
  });
  const sqlNow = sql.literal(sqlNowString);
  const lockExpiresAt = sql.onDialectOrElse({
    pg: () => sql`${sqlNow} - INTERVAL '5 seconds'`,
    mysql: () => sql`DATE_SUB(${sqlNow}, INTERVAL 5 SECOND)`,
    mssql: () => sql`DATEADD(SECOND, -5, ${sqlNow})`,
    orElse: () => sql`datetime(${sqlNow}, '-5 seconds')`
  });
  const acquireLock = sql.onDialectOrElse({
    pg: () => (address, values) => sql`
        INSERT INTO ${locksTableSql} (shard_id, address, acquired_at) VALUES ${sql.csv(values)}
        ON CONFLICT (shard_id) DO UPDATE
        SET address = ${address}, acquired_at = ${sqlNow}
        WHERE ${locksTableSql}.address = ${address}
          OR ${locksTableSql}.acquired_at < ${lockExpiresAt}
      `,
    mysql: () => (_address, values) => sql`
        INSERT INTO ${locksTableSql} (shard_id, address, acquired_at) VALUES ${sql.csv(values)}
        ON DUPLICATE KEY UPDATE
        address = IF(address = VALUES(address) OR acquired_at < ${lockExpiresAt}, VALUES(address), address),
        acquired_at = IF(address = VALUES(address) OR acquired_at < ${lockExpiresAt}, VALUES(acquired_at), acquired_at)
      `.unprepared,
    mssql: () => (_address, values) => sql`
        MERGE ${locksTableSql} WITH (HOLDLOCK) AS target
        USING (SELECT * FROM (VALUES ${sql.csv(values)})) AS source (shard_id, address, acquired_at)
        ON target.shard_id = source.shard_id
        WHEN MATCHED AND (target.address = source.address OR DATEDIFF(SECOND, target.acquired_at, ${sqlNow}) > 5) THEN
          UPDATE SET address = source.address, acquired_at = source.acquired_at
        WHEN NOT MATCHED THEN
          INSERT (shard_id, address, acquired_at)
          VALUES (source.shard_id, source.address, source.acquired_at);
      `,
    orElse: () => (address, values) =>
    // sqlite
    sql`
        WITH source(shard_id, address, acquired_at) AS (VALUES ${sql.csv(values)})
        INSERT INTO ${locksTableSql} (shard_id, address, acquired_at)
        SELECT source.shard_id, source.address, source.acquired_at
        FROM source
        WHERE NOT EXISTS (
          SELECT 1 FROM ${locksTableSql}
          WHERE shard_id = source.shard_id
          AND address != ${address}
          AND (strftime('%s', ${sqlNow}) - strftime('%s', acquired_at)) <= 5
        )
        ON CONFLICT(shard_id) DO UPDATE
        SET address = ${address}, acquired_at = ${sqlNow}
      `
  });
  const wrapString = sql.onDialectOrElse({
    mssql: () => s => `N'${s}'`,
    orElse: () => s => `'${s}'`
  });
  const wrapStringArr = arr => sql.literal(arr.map(wrapString).join(", "));
  const refreshShards = sql.onDialectOrElse({
    mysql: () => (address, shardIds) => {
      const shardIdsStr = wrapStringArr(shardIds);
      return sql`
        UPDATE ${locksTableSql}
        SET acquired_at = ${sqlNow}
        WHERE address = ${address} AND shard_id IN (${shardIdsStr});
        SELECT shard_id FROM ${locksTableSql} WHERE address = ${address} AND shard_id IN (${shardIdsStr})
      `.unprepared.pipe(Effect.map(rows => rows[1].map(row => [row.shard_id])));
    },
    mssql: () => (address, shardIds) => sql`
        UPDATE ${locksTableSql}
        SET acquired_at = ${sqlNow}
        OUTPUT inserted.shard_id
        WHERE address = ${address} AND shard_id IN (${wrapStringArr(shardIds)})
      `.values,
    orElse: () => (address, shardIds) => sql`
        UPDATE ${locksTableSql}
        SET acquired_at = ${sqlNow}
        WHERE address = ${address} AND shard_id IN (${wrapStringArr(shardIds)})
        RETURNING shard_id
      `.values
  });
  return ShardStorage.makeEncoded({
    getAssignments: sql`SELECT shard_id, address FROM ${shardsTableSql} ORDER BY shard_id`.values.pipe(_ClusterError.PersistenceError.refail, withTracerDisabled),
    saveAssignments: assignments => {
      const remove = sql`DELETE FROM ${shardsTableSql}`;
      if (assignments.length === 0) {
        return _ClusterError.PersistenceError.refail(remove);
      }
      const values = assignments.map(([shardId, address]) => sql`(${shardId}, ${address})`);
      return remove.pipe(Effect.andThen(sql`INSERT INTO ${shardsTableSql} (shard_id, address) VALUES ${sql.csv(values)}`.unprepared), sql.withTransaction, _ClusterError.PersistenceError.refail, withTracerDisabled);
    },
    getRunners: sql`SELECT address, runner FROM ${runnersTableSql}`.values.pipe(_ClusterError.PersistenceError.refail, Effect.map(Arr.map(([address, runner]) => [String(address), String(runner)])), withTracerDisabled),
    saveRunners: runners => {
      const remove = sql`DELETE FROM ${runnersTableSql}`;
      if (runners.length === 0) {
        return _ClusterError.PersistenceError.refail(remove);
      }
      const values = runners.map(([address, runner]) => sql`(${address}, ${runner})`);
      const insert = sql`INSERT INTO ${runnersTableSql} (address, runner) VALUES ${sql.csv(values)}`.unprepared;
      return remove.pipe(Effect.andThen(insert), sql.withTransaction, _ClusterError.PersistenceError.refail, withTracerDisabled);
    },
    acquire: Effect.fnUntraced(function* (address, shardIds) {
      if (shardIds.length > 0) {
        const values = shardIds.map(shardId => sql`(${shardId}, ${address}, ${sqlNow})`);
        yield* acquireLock(address, values);
      }
      const currentLocks = yield* sql`
          SELECT shard_id FROM ${sql(locksTable)}
          WHERE address = ${address} AND acquired_at >= ${lockExpiresAt}
        `.values;
      return currentLocks.map(row => row[0]);
    }, sql.withTransaction, _ClusterError.PersistenceError.refail, withTracerDisabled),
    refresh: (address, shardIds) => shardIds.length === 0 ? Effect.succeed([]) : refreshShards(address, shardIds).pipe(Effect.map(rows => rows.map(row => row[0])), _ClusterError.PersistenceError.refail, withTracerDisabled),
    release: (address, shardId) => sql`DELETE FROM ${locksTableSql} WHERE address = ${address} AND shard_id = ${shardId}`.pipe(_ClusterError.PersistenceError.refail, withTracerDisabled),
    releaseAll: address => sql`DELETE FROM ${locksTableSql} WHERE address = ${address}`.pipe(_ClusterError.PersistenceError.refail, withTracerDisabled)
  });
}, withTracerDisabled);
/**
 * @since 1.0.0
 * @category Layers
 */
const layer = exports.layer = /*#__PURE__*/Layer.effect(ShardStorage.ShardStorage, /*#__PURE__*/make());
/**
 * @since 1.0.0
 * @category Layers
 */
const layerWith = options => Layer.scoped(ShardStorage.ShardStorage, make(options));
exports.layerWith = layerWith;
//# sourceMappingURL=SqlShardStorage.js.map