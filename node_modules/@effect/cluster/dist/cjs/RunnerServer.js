"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.layerWithClients = exports.layerHandlers = exports.layerClientOnly = exports.layer = void 0;
var RpcServer = _interopRequireWildcard(require("@effect/rpc/RpcServer"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var _Function = require("effect/Function");
var Layer = _interopRequireWildcard(require("effect/Layer"));
var Mailbox = _interopRequireWildcard(require("effect/Mailbox"));
var Option = _interopRequireWildcard(require("effect/Option"));
var ClusterError = _interopRequireWildcard(require("./ClusterError.js"));
var Message = _interopRequireWildcard(require("./Message.js"));
var MessageStorage = _interopRequireWildcard(require("./MessageStorage.js"));
var Reply = _interopRequireWildcard(require("./Reply.js"));
var Runners = _interopRequireWildcard(require("./Runners.js"));
var Sharding = _interopRequireWildcard(require("./Sharding.js"));
var _ShardingConfig = require("./ShardingConfig.js");
var ShardManager = _interopRequireWildcard(require("./ShardManager.js"));
var ShardStorage = _interopRequireWildcard(require("./ShardStorage.js"));
var SynchronizedClock = _interopRequireWildcard(require("./SynchronizedClock.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * @since 1.0.0
 */

const constVoid = /*#__PURE__*/(0, _Function.constant)(Effect.void);
/**
 * @since 1.0.0
 * @category Layers
 */
const layerHandlers = exports.layerHandlers = /*#__PURE__*/Runners.Rpcs.toLayer(/*#__PURE__*/Effect.gen(function* () {
  const sharding = yield* Sharding.Sharding;
  const storage = yield* MessageStorage.MessageStorage;
  return {
    Ping: () => Effect.void,
    Notify: ({
      envelope
    }) => sharding.notify(envelope._tag === "Request" ? new Message.IncomingRequest({
      envelope,
      respond: constVoid,
      lastSentReply: Option.none()
    }) : new Message.IncomingEnvelope({
      envelope
    })),
    Effect: ({
      persisted,
      request
    }) => {
      let resume;
      let replyEncoded;
      const message = new Message.IncomingRequest({
        envelope: request,
        lastSentReply: Option.none(),
        respond(reply) {
          return Effect.flatMap(Reply.serialize(reply), reply => {
            if (resume) {
              resume(Effect.succeed(reply));
            } else {
              replyEncoded = reply;
            }
            return Effect.void;
          });
        }
      });
      return Effect.zipRight(persisted ? Effect.zipRight(storage.registerReplyHandler(message, Effect.sync(() => resume(Effect.fail(new ClusterError.EntityNotAssignedToRunner({
        address: request.address
      }))))), sharding.notify(message)) : sharding.send(message), Effect.async(resume_ => {
        if (replyEncoded) {
          resume_(Effect.succeed(replyEncoded));
        } else {
          resume = resume_;
        }
      }));
    },
    Stream: ({
      persisted,
      request
    }) => Effect.flatMap(Mailbox.make(), mailbox => {
      const message = new Message.IncomingRequest({
        envelope: request,
        lastSentReply: Option.none(),
        respond(reply) {
          return Effect.flatMap(Reply.serialize(reply), reply => {
            mailbox.unsafeOffer(reply);
            return Effect.void;
          });
        }
      });
      return Effect.as(persisted ? Effect.zipRight(storage.registerReplyHandler(message, Effect.suspend(() => mailbox.fail(new ClusterError.EntityNotAssignedToRunner({
        address: request.address
      })))), sharding.notify(message)) : sharding.send(message), mailbox);
    }),
    Envelope: ({
      envelope
    }) => sharding.send(new Message.IncomingEnvelope({
      envelope
    }))
  };
}));
/**
 * The `RunnerServer` recieves messages from other Runners and forwards them to the
 * `Sharding` layer.
 *
 * It also responds to `Ping` requests.
 *
 * @since 1.0.0
 * @category Layers
 */
const layer = exports.layer = /*#__PURE__*/RpcServer.layer(Runners.Rpcs, {
  spanPrefix: "RunnerServer",
  disableTracing: true
}).pipe(/*#__PURE__*/Layer.provide(layerHandlers));
/**
 * A `RunnerServer` layer that includes the `Runners` & `Sharding` clients.
 *
 * @since 1.0.0
 * @category Layers
 */
const layerWithClients = exports.layerWithClients = /*#__PURE__*/layer.pipe(/*#__PURE__*/Layer.provideMerge(Sharding.layer), /*#__PURE__*/Layer.provideMerge(Runners.layerRpc), /*#__PURE__*/Layer.provideMerge(SynchronizedClock.layer), /*#__PURE__*/Layer.provide(ShardManager.layerClientRpc));
/**
 * A `Runners` layer that is client only.
 *
 * It will not register with the ShardManager and recieve shard assignments,
 * so this layer can be used to embed a cluster client inside another effect
 * application.
 *
 * @since 1.0.0
 * @category Layers
 */
const layerClientOnly = exports.layerClientOnly = /*#__PURE__*/Sharding.layer.pipe(/*#__PURE__*/Layer.provideMerge(Runners.layerRpc), /*#__PURE__*/Layer.provide(ShardManager.layerClientRpc), /*#__PURE__*/Layer.provide(ShardStorage.layerNoop), /*#__PURE__*/Layer.updateService(_ShardingConfig.ShardingConfig, config => ({
  ...config,
  runnerAddress: Option.none()
})));
//# sourceMappingURL=RunnerServer.js.map