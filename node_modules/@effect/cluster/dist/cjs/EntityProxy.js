"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toRpcGroup = exports.toHttpApiGroup = void 0;
var HttpApiEndpoint = _interopRequireWildcard(require("@effect/platform/HttpApiEndpoint"));
var HttpApiGroup = _interopRequireWildcard(require("@effect/platform/HttpApiGroup"));
var Rpc = _interopRequireWildcard(require("@effect/rpc/Rpc"));
var RpcGroup = _interopRequireWildcard(require("@effect/rpc/RpcGroup"));
var Schema = _interopRequireWildcard(require("effect/Schema"));
var _ClusterError = require("./ClusterError.js");
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * @since 1.0.0
 */

const clientErrors = [_ClusterError.MailboxFull, _ClusterError.AlreadyProcessingMessage, _ClusterError.PersistenceError, _ClusterError.EntityNotManagedByRunner];
/**
 * Derives an `RpcGroup` from an `Entity`.
 *
 * ```ts
 * import { ClusterSchema, Entity, EntityProxy, EntityProxyServer } from "@effect/cluster"
 * import { Rpc, RpcServer } from "@effect/rpc"
 * import { Layer, Schema } from "effect"
 *
 * export const Counter = Entity.make("Counter", [
 *   Rpc.make("Increment", {
 *     payload: { id: Schema.String, amount: Schema.Number },
 *     primaryKey: ({ id }) => id,
 *     success: Schema.Number
 *   })
 * ]).annotateRpcs(ClusterSchema.Persisted, true)
 *
 * // Use EntityProxy.toRpcGroup to create a `RpcGroup` from the Counter entity
 * export class MyRpcs extends EntityProxy.toRpcGroup(Counter) {}
 *
 * // Use EntityProxyServer.layerRpcHandlers to create a layer that implements
 * // the rpc handlers
 * const RpcServerLayer = RpcServer.layer(MyRpcs).pipe(
 *   Layer.provide(EntityProxyServer.layerRpcHandlers(Counter))
 * )
 * ```
 *
 * @since 1.0.0
 * @category Constructors
 */
const toRpcGroup = entity => {
  const rpcs = [];
  for (const parentRpc_ of entity.protocol.requests.values()) {
    const parentRpc = parentRpc_;
    const payloadSchema = Schema.Struct({
      entityId: Schema.String,
      payload: parentRpc.payloadSchema
    });
    const oldMake = payloadSchema.make;
    payloadSchema.make = (input, options) => {
      return oldMake({
        entityId: input.entityId,
        payload: parentRpc.payloadSchema.make ? parentRpc.payloadSchema.make(input.payload, options) : input.payload
      }, options);
    };
    const rpc = Rpc.make(`${entity.type}.${parentRpc._tag}`, {
      payload: payloadSchema,
      error: Schema.Union(parentRpc.errorSchema, ...clientErrors),
      success: parentRpc.successSchema
    }).annotateContext(parentRpc.annotations);
    const rpcDiscard = Rpc.make(`${entity.type}.${parentRpc._tag}Discard`, {
      payload: payloadSchema,
      error: Schema.Union(...clientErrors)
    }).annotateContext(parentRpc.annotations);
    rpcs.push(rpc, rpcDiscard);
  }
  return RpcGroup.make(...rpcs);
};
exports.toRpcGroup = toRpcGroup;
const entityIdPath = /*#__PURE__*/Schema.Struct({
  entityId: Schema.String
});
/**
 * Derives an `HttpApiGroup` from an `Entity`.
 *
 * ```ts
 * import { ClusterSchema, Entity, EntityProxy, EntityProxyServer } from "@effect/cluster"
 * import { HttpApi, HttpApiBuilder } from "@effect/platform"
 * import { Rpc } from "@effect/rpc"
 * import { Layer, Schema } from "effect"
 *
 * export const Counter = Entity.make("Counter", [
 *   Rpc.make("Increment", {
 *     payload: { id: Schema.String, amount: Schema.Number },
 *     primaryKey: ({ id }) => id,
 *     success: Schema.Number
 *   })
 * ]).annotateRpcs(ClusterSchema.Persisted, true)
 *
 * // Use EntityProxy.toHttpApiGroup to create a `HttpApiGroup` from the
 * // Counter entity
 * export class MyApi extends HttpApi.make("api")
 *   .add(
 *     EntityProxy.toHttpApiGroup("counter", Counter)
 *       .prefix("/counter")
 *   )
 * {}
 *
 * // Use EntityProxyServer.layerHttpApi to create a layer that implements
 * // the handlers for the HttpApiGroup
 * const ApiLayer = HttpApiBuilder.api(MyApi).pipe(
 *   Layer.provide(EntityProxyServer.layerHttpApi(MyApi, "counter", Counter))
 * )
 * ```
 *
 * @since 1.0.0
 * @category Constructors
 */
const toHttpApiGroup = (name, entity) => {
  let group = HttpApiGroup.make(name);
  for (const parentRpc_ of entity.protocol.requests.values()) {
    const parentRpc = parentRpc_;
    const endpoint = HttpApiEndpoint.post(parentRpc._tag, `/${tagToPath(parentRpc._tag)}/:entityId`).setPath(entityIdPath).setPayload(parentRpc.payloadSchema).addSuccess(parentRpc.successSchema).addError(Schema.Union(parentRpc.errorSchema, ...clientErrors)).annotateContext(parentRpc.annotations);
    const endpointDiscard = HttpApiEndpoint.post(`${parentRpc._tag}Discard`, `/${tagToPath(parentRpc._tag)}/:entityId/discard`).setPath(entityIdPath).setPayload(parentRpc.payloadSchema).addError(Schema.Union(...clientErrors)).annotateContext(parentRpc.annotations);
    group = group.add(endpoint).add(endpointDiscard);
  }
  return group;
};
exports.toHttpApiGroup = toHttpApiGroup;
const tagToPath = tag => tag.replace(/[^a-zA-Z0-9]+/g, "-") // Replace non-alphanumeric characters with hyphen
.replace(/([a-z])([A-Z])/g, "$1-$2") // Insert hyphen before uppercase letters
.toLowerCase();
//# sourceMappingURL=EntityProxy.js.map