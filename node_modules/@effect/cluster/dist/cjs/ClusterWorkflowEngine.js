"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.make = exports.layer = void 0;
var Rpc = _interopRequireWildcard(require("@effect/rpc/Rpc"));
var _workflow = require("@effect/workflow");
var Activity = _interopRequireWildcard(require("@effect/workflow/Activity"));
var DurableClock = _interopRequireWildcard(require("@effect/workflow/DurableClock"));
var Workflow = _interopRequireWildcard(require("@effect/workflow/Workflow"));
var _WorkflowEngine = require("@effect/workflow/WorkflowEngine");
var Arr = _interopRequireWildcard(require("effect/Array"));
var Context = _interopRequireWildcard(require("effect/Context"));
var DateTime = _interopRequireWildcard(require("effect/DateTime"));
var Duration = _interopRequireWildcard(require("effect/Duration"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Fiber = _interopRequireWildcard(require("effect/Fiber"));
var Layer = _interopRequireWildcard(require("effect/Layer"));
var Option = _interopRequireWildcard(require("effect/Option"));
var PrimaryKey = _interopRequireWildcard(require("effect/PrimaryKey"));
var RcMap = _interopRequireWildcard(require("effect/RcMap"));
var Record = _interopRequireWildcard(require("effect/Record"));
var Runtime = _interopRequireWildcard(require("effect/Runtime"));
var Schedule = _interopRequireWildcard(require("effect/Schedule"));
var Schema = _interopRequireWildcard(require("effect/Schema"));
var ClusterSchema = _interopRequireWildcard(require("./ClusterSchema.js"));
var DeliverAt = _interopRequireWildcard(require("./DeliverAt.js"));
var Entity = _interopRequireWildcard(require("./Entity.js"));
var _EntityAddress = require("./EntityAddress.js");
var _EntityId = require("./EntityId.js");
var _EntityType = require("./EntityType.js");
var _MessageStorage = require("./MessageStorage.js");
var Sharding = _interopRequireWildcard(require("./Sharding.js"));
var Snowflake = _interopRequireWildcard(require("./Snowflake.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * @since 1.0.0
 */

/**
 * @since 1.0.0
 * @category Constructors
 */
const make = exports.make = /*#__PURE__*/Effect.gen(function* () {
  const sharding = yield* Sharding.Sharding;
  const storage = yield* _MessageStorage.MessageStorage;
  const workflows = new Map();
  const entities = new Map();
  const partialEntities = new Map();
  const ensureEntity = workflow => {
    let entity = entities.get(workflow.name);
    if (!entity) {
      entity = makeWorkflowEntity(workflow);
      workflows.set(workflow.name, workflow);
      entities.set(workflow.name, entity);
    }
    return entity;
  };
  const ensurePartialEntity = workflowName => {
    let entity = partialEntities.get(workflowName);
    if (!entity) {
      entity = makePartialWorkflowEntity(workflowName);
      partialEntities.set(workflowName, entity);
    }
    return entity;
  };
  const activities = new Map();
  const activityLatches = new Map();
  const clients = yield* RcMap.make({
    lookup: Effect.fnUntraced(function* (workflowName) {
      const entity = entities.get(workflowName);
      if (!entity) {
        return yield* Effect.dieMessage(`Workflow ${workflowName} not registered`);
      }
      return yield* entity.client;
    }),
    idleTimeToLive: "5 minutes"
  });
  const clientsPartial = yield* RcMap.make({
    lookup: Effect.fnUntraced(function* (workflowName) {
      const entity = entities.get(workflowName) ?? ensurePartialEntity(workflowName);
      return yield* entity.client;
    }),
    idleTimeToLive: "5 minutes"
  });
  const clockClient = yield* ClockEntity.client;
  const requestIdFor = Effect.fnUntraced(function* (options) {
    const shardGroup = Context.get(options.workflow.annotations, ClusterSchema.ShardGroup)(options.executionId);
    const entityId = _EntityId.EntityId.make(options.executionId);
    const address = new _EntityAddress.EntityAddress({
      entityType: _EntityType.EntityType.make(options.entityType),
      entityId,
      shardId: sharding.getShardId(entityId, shardGroup)
    });
    return yield* storage.requestIdForPrimaryKey({
      address,
      tag: options.tag,
      id: options.id
    });
  });
  const replyForRequestId = Effect.fnUntraced(function* (requestId) {
    const replies = yield* storage.repliesForUnfiltered([requestId]);
    return Arr.last(replies).pipe(Option.filter(reply => reply._tag === "WithExit"), Option.map(reply => reply));
  });
  const requestReply = Effect.fnUntraced(function* (options) {
    const requestId = yield* requestIdFor(options);
    if (Option.isNone(requestId)) {
      return Option.none();
    }
    return yield* replyForRequestId(requestId.value);
  });
  const resetActivityAttempt = Effect.fnUntraced(function* (options) {
    const requestId = yield* requestIdFor({
      workflow: options.workflow,
      entityType: `Workflow/${options.workflow.name}`,
      executionId: options.executionId,
      tag: "activity",
      id: activityPrimaryKey(options.activity.name, options.attempt)
    });
    if (Option.isNone(requestId)) return;
    yield* sharding.reset(requestId.value);
  }, Effect.retry({
    times: 3,
    schedule: Schedule.exponential(250)
  }), Effect.orDie, (effect, {
    activity,
    attempt,
    executionId
  }) => Effect.withSpan(effect, "WorkflowEngine.resetActivityAttempt", {
    captureStackTrace: false,
    attributes: {
      name: activity.name,
      executionId,
      attempt
    }
  }));
  const clearClock = Effect.fnUntraced(function* (options) {
    const shardGroup = Context.get(options.workflow.annotations, ClusterSchema.ShardGroup)(options.executionId);
    const entityId = _EntityId.EntityId.make(options.executionId);
    const shardId = sharding.getShardId(entityId, shardGroup);
    const clockAddress = new _EntityAddress.EntityAddress({
      entityType: ClockEntity.type,
      entityId,
      shardId
    });
    yield* storage.clearAddress(clockAddress);
  });
  const resume = Effect.fnUntraced(function* (workflow, executionId) {
    const maybeReply = yield* requestReply({
      workflow,
      entityType: `Workflow/${workflow.name}`,
      executionId,
      tag: "run",
      id: ""
    });
    const maybeSuspended = Option.filter(maybeReply, reply => reply.exit._tag === "Success" && reply.exit.value._tag === "Suspended");
    if (Option.isNone(maybeSuspended)) return;
    yield* sharding.reset(Snowflake.Snowflake(maybeSuspended.value.requestId));
    yield* sharding.pollStorage;
  });
  const sendResumeParent = Effect.fnUntraced(function* (options) {
    const client = (yield* RcMap.get(clientsPartial, options.workflowName))(options.executionId);
    return yield* client.resume(void 0, {
      discard: true
    });
  }, Effect.scoped);
  return _WorkflowEngine.WorkflowEngine.of({
    register(workflow, execute) {
      // eslint-disable-next-line @typescript-eslint/no-this-alias
      const engine = this;
      return Effect.suspend(() => {
        if (entities.has(workflow.name)) {
          return Effect.dieMessage(`Workflow ${workflow.name} already registered`);
        }
        return sharding.registerEntity(ensureEntity(workflow), Effect.gen(function* () {
          const address = yield* Entity.CurrentAddress;
          const executionId = address.entityId;
          return {
            run: request => {
              const instance = _WorkflowEngine.WorkflowInstance.initial(workflow, executionId);
              let payload = request.payload;
              let parent;
              if (payload[payloadParentKey]) {
                parent = payload[payloadParentKey];
                payload = Record.remove(payload, payloadParentKey);
              }
              return execute(payload, executionId).pipe(Effect.ensuring(Effect.suspend(() => {
                if (!instance.suspended) {
                  return parent ? ensureSuccess(sendResumeParent(parent)) : Effect.void;
                }
                return engine.deferredResult(InterruptSignal).pipe(Effect.flatMap(maybeResult => {
                  if (Option.isNone(maybeResult)) {
                    return Effect.void;
                  }
                  instance.suspended = false;
                  instance.interrupted = true;
                  return Effect.zipRight(Effect.ignore(clearClock({
                    workflow,
                    executionId
                  })), Effect.withFiberRuntime(fiber => Effect.interruptible(Fiber.interrupt(fiber))));
                }), Effect.orDie);
              })), Workflow.intoResult, Effect.provideService(_WorkflowEngine.WorkflowInstance, instance));
            },
            activity: Effect.fnUntraced(function* (request) {
              const activityId = `${executionId}/${request.payload.name}`;
              let entry = activities.get(activityId);
              while (!entry) {
                const latch = Effect.unsafeMakeLatch();
                activityLatches.set(activityId, latch);
                yield* latch.await;
                entry = activities.get(activityId);
              }
              const instance = _WorkflowEngine.WorkflowInstance.initial(workflow, executionId);
              const contextMap = new Map(entry.runtime.context.unsafeMap);
              contextMap.set(Activity.CurrentAttempt.key, request.payload.attempt);
              contextMap.set(_WorkflowEngine.WorkflowInstance.key, instance);
              const runtime = Runtime.make({
                context: Context.unsafeMake(contextMap),
                fiberRefs: entry.runtime.fiberRefs,
                runtimeFlags: Runtime.defaultRuntimeFlags
              });
              return yield* entry.activity.executeEncoded.pipe(Effect.interruptible, Effect.onInterrupt(() => {
                instance.suspended = true;
                return Effect.void;
              }), Workflow.intoResult, Effect.provide(runtime), Effect.ensuring(Effect.sync(() => {
                activities.delete(activityId);
              })));
            }, Rpc.wrap({
              fork: true,
              uninterruptible: true
            })),
            deferred: Effect.fnUntraced(function* (request) {
              yield* ensureSuccess(resume(workflow, executionId));
              return request.payload.exit;
            }),
            resume: () => ensureSuccess(resume(workflow, executionId))
          };
        }));
      });
    },
    execute: ({
      discard,
      executionId,
      parent,
      payload,
      workflow
    }) => {
      ensureEntity(workflow);
      return RcMap.get(clients, workflow.name).pipe(Effect.flatMap(make => make(executionId).run(parent ? {
        ...payload,
        [payloadParentKey]: {
          workflowName: parent.workflow.name,
          executionId: parent.executionId
        }
      } : payload, {
        discard
      })), Effect.orDie, Effect.scoped);
    },
    poll: Effect.fnUntraced(function* ({
      executionId,
      workflow
    }) {
      const entity = ensureEntity(workflow);
      const exitSchema = Rpc.exitSchema(entity.protocol.requests.get("run"));
      const oreply = yield* requestReply({
        workflow,
        entityType: `Workflow/${workflow.name}`,
        executionId,
        tag: "run",
        id: ""
      });
      if (Option.isNone(oreply)) return undefined;
      const exit = yield* Schema.decode(exitSchema)(oreply.value.exit);
      return yield* exit;
    }, Effect.orDie),
    interrupt: Effect.fnUntraced(function* (workflow, executionId) {
      ensureEntity(workflow);
      const oreply = yield* requestReply({
        workflow,
        entityType: `Workflow/${workflow.name}`,
        executionId,
        tag: "run",
        id: ""
      });
      const nonSuspendedReply = oreply.pipe(Option.filter(reply => reply.exit._tag !== "Success" || reply.exit.value._tag !== "Suspended"));
      if (Option.isSome(nonSuspendedReply)) {
        return;
      }
      yield* this.deferredDone({
        workflowName: workflow.name,
        executionId,
        deferredName: InterruptSignal.name,
        exit: {
          _tag: "Success",
          value: void 0
        }
      });
    }, Effect.retry({
      while: e => e._tag === "PersistenceError",
      times: 3,
      schedule: Schedule.exponential(250)
    }), Effect.orDie, (effect, workflow, executionId) => Effect.withSpan(effect, "WorkflowEngine.interrupt", {
      captureStackTrace: false,
      attributes: {
        name: workflow.name,
        executionId
      }
    })),
    resume: (workflow, executionId) => ensureSuccess(resume(workflow, executionId)).pipe(Effect.withSpan("WorkflowEngine.resume", {
      captureStackTrace: false,
      attributes: {
        name: workflow.name,
        executionId
      }
    })),
    activityExecute: Effect.fnUntraced(function* ({
      activity,
      attempt
    }) {
      const runtime = yield* Effect.runtime();
      const context = runtime.context;
      const instance = Context.get(context, _WorkflowEngine.WorkflowInstance);
      yield* Effect.annotateCurrentSpan("executionId", instance.executionId);
      const activityId = `${instance.executionId}/${activity.name}`;
      activities.set(activityId, {
        activity,
        runtime
      });
      const latch = activityLatches.get(activityId);
      if (latch) {
        yield* latch.release;
        activityLatches.delete(activityId);
      }
      const client = (yield* RcMap.get(clientsPartial, instance.workflow.name))(instance.executionId);
      while (true) {
        const result = yield* Effect.orDie(client.activity({
          name: activity.name,
          attempt
        }));
        // If the activity has suspended and did not execute, we need to resume
        // it by resetting the attempt and re-executing.
        if (result._tag === "Suspended" && activities.has(activityId)) {
          yield* resetActivityAttempt({
            workflow: instance.workflow,
            executionId: instance.executionId,
            activity,
            attempt
          });
          continue;
        }
        activities.delete(activityId);
        return result;
      }
    }, Effect.scoped, (effect, {
      activity,
      attempt
    }) => Effect.withSpan(effect, "WorkflowEngine.activityExecute", {
      captureStackTrace: false,
      attributes: {
        name: activity.name,
        attempt
      }
    })),
    deferredResult: deferred => _WorkflowEngine.WorkflowInstance.pipe(Effect.tap(instance => Effect.annotateCurrentSpan("executionId", instance.executionId)), Effect.flatMap(instance => requestReply({
      workflow: instance.workflow,
      entityType: `Workflow/${instance.workflow.name}`,
      executionId: instance.executionId,
      tag: "deferred",
      id: deferred.name
    })), Effect.map(Option.map(reply => reply.exit._tag === "Success" ? reply.exit.value : reply.exit)), Effect.retry({
      while: e => e._tag === "PersistenceError",
      times: 3,
      schedule: Schedule.exponential(250)
    }), Effect.orDie, Effect.withSpan("WorkflowEngine.deferredResult", {
      captureStackTrace: false,
      attributes: {
        name: deferred.name
      }
    })),
    deferredDone: Effect.fnUntraced(function* ({
      deferredName,
      executionId,
      exit,
      workflowName
    }) {
      const client = yield* RcMap.get(clientsPartial, workflowName);
      return yield* Effect.orDie(client(executionId).deferred({
        name: deferredName,
        exit
      }, {
        discard: true
      }));
    }, Effect.scoped, (effect, {
      deferredName,
      executionId
    }) => Effect.withSpan(effect, "WorkflowEngine.deferredDone", {
      captureStackTrace: false,
      attributes: {
        name: deferredName,
        executionId
      }
    })),
    scheduleClock(options) {
      const client = clockClient(options.executionId);
      return DateTime.now.pipe(Effect.flatMap(now => client.run({
        name: options.clock.name,
        workflowName: options.workflow.name,
        wakeUp: DateTime.addDuration(now, options.clock.duration)
      }, {
        discard: true
      })), Effect.orDie);
    }
  });
});
const retryPolicy = /*#__PURE__*/Schedule.exponential(200, 1.5).pipe(/*#__PURE__*/Schedule.union(/*#__PURE__*/Schedule.spaced("1 minute")));
const ensureSuccess = effect => effect.pipe(Effect.sandbox, Effect.retry(retryPolicy), Effect.orDie);
const ActivityRpc = /*#__PURE__*/Rpc.make("activity", {
  payload: {
    name: Schema.String,
    attempt: Schema.Number
  },
  primaryKey: ({
    attempt,
    name
  }) => activityPrimaryKey(name, attempt),
  success: Workflow.Result({
    success: Schema.Unknown,
    error: Schema.Unknown
  })
}).annotate(ClusterSchema.Persisted, true);
const payloadParentKey = "~@effect/workflow/parent";
const makeWorkflowEntity = workflow => Entity.make(`Workflow/${workflow.name}`, [Rpc.make("run", {
  payload: {
    ...workflow.payloadSchema.fields,
    [payloadParentKey]: Schema.optional(Schema.Struct({
      workflowName: Schema.String,
      executionId: Schema.String
    }))
  },
  primaryKey: () => "",
  success: Workflow.Result({
    success: workflow.successSchema,
    error: workflow.errorSchema
  })
}).annotate(ClusterSchema.Persisted, true).annotate(ClusterSchema.Uninterruptible, true), DeferredRpc, ResumeRpc, ActivityRpc]).annotateContext(workflow.annotations);
const ExitUnknown = /*#__PURE__*/Schema.encodedSchema(/*#__PURE__*/Schema.Exit({
  success: Schema.Unknown,
  failure: Schema.Unknown,
  defect: Schema.Defect
}));
const DeferredRpc = /*#__PURE__*/Rpc.make("deferred", {
  payload: {
    name: Schema.String,
    exit: ExitUnknown
  },
  primaryKey: ({
    name
  }) => name,
  success: ExitUnknown
}).annotate(ClusterSchema.Persisted, true).annotate(ClusterSchema.Uninterruptible, true);
const ResumeRpc = /*#__PURE__*/Rpc.make("resume").annotate(ClusterSchema.Persisted, true).annotate(ClusterSchema.Uninterruptible, true);
const makePartialWorkflowEntity = workflowName => Entity.make(`Workflow/${workflowName}`, [DeferredRpc, ResumeRpc, ActivityRpc]);
const activityPrimaryKey = (activity, attempt) => `${activity}/${attempt}`;
class ClockPayload extends /*#__PURE__*/Schema.Class(`Workflow/DurableClock/Run`)({
  name: Schema.String,
  workflowName: Schema.String,
  wakeUp: Schema.DateTimeUtcFromNumber
}) {
  [PrimaryKey.symbol]() {
    return this.name;
  }
  [DeliverAt.symbol]() {
    return this.wakeUp;
  }
}
const ClockEntity = /*#__PURE__*/Entity.make("Workflow/-/DurableClock", [/*#__PURE__*/Rpc.make("run", {
  payload: ClockPayload
}).annotate(ClusterSchema.Persisted, true).annotate(ClusterSchema.Uninterruptible, true)]);
const ClockEntityLayer = /*#__PURE__*/ClockEntity.toLayer(/*#__PURE__*/Effect.gen(function* () {
  const engine = yield* _WorkflowEngine.WorkflowEngine;
  const address = yield* Entity.CurrentAddress;
  const executionId = address.entityId;
  return {
    run(request) {
      const deferred = DurableClock.make({
        name: request.payload.name,
        duration: Duration.zero
      }).deferred;
      return ensureSuccess(engine.deferredDone({
        workflowName: request.payload.workflowName,
        executionId,
        deferredName: deferred.name,
        exit: {
          _tag: "Success",
          value: void 0
        }
      }));
    }
  };
}));
const InterruptSignal = /*#__PURE__*/_workflow.DurableDeferred.make("Workflow/InterruptSignal");
/**
 * @since 1.0.0
 * @category Layers
 */
const layer = exports.layer = /*#__PURE__*/ClockEntityLayer.pipe(/*#__PURE__*/Layer.provideMerge(/*#__PURE__*/Layer.scoped(_WorkflowEngine.WorkflowEngine, make)));
//# sourceMappingURL=ClusterWorkflowEngine.js.map