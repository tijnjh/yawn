import * as Context from "effect/Context";
import * as DateTime from "effect/DateTime";
import * as Effect from "effect/Effect";
import { identity } from "effect/Function";
import * as Layer from "effect/Layer";
import * as Schema from "effect/Schema";
/**
 * @since 1.0.0
 * @category Symbols
 */
export const TypeId = /*#__PURE__*/Symbol.for("@effect/cluster/Snowflake");
/**
 * @since 1.0.0
 * @category Models
 */
export const Snowflake = input => typeof input === "string" ? BigInt(input) : input;
/**
 * @since 1.0.0
 * @category Schemas
 */
export const SnowflakeFromBigInt = /*#__PURE__*/Schema.BigIntFromSelf.pipe(/*#__PURE__*/Schema.brand(TypeId));
/**
 * @since 1.0.0
 * @category Schemas
 */
export const SnowflakeFromString = /*#__PURE__*/Schema.BigInt.pipe(/*#__PURE__*/Schema.brand(TypeId));
/**
 * @since 1.0.0
 * @category Epoch
 */
export const constEpochMillis = /*#__PURE__*/Date.UTC(2025, 0, 1);
const sinceUnixEpoch = constEpochMillis - /*#__PURE__*/Date.UTC(1970, 0, 1);
const constBigInt12 = /*#__PURE__*/BigInt(12);
const constBigInt22 = /*#__PURE__*/BigInt(22);
const constBigInt1024 = /*#__PURE__*/BigInt(1024);
const constBigInt4096 = /*#__PURE__*/BigInt(4096);
/**
 * @since 1.0.0
 * @category constructors
 */
export const make = options => BigInt(options.timestamp - constEpochMillis) << constBigInt22 | BigInt(options.machineId % 1024) << constBigInt12 | BigInt(options.sequence % 4096);
/**
 * @since 1.0.0
 * @category Parts
 */
export const timestamp = snowflake => Number(snowflake >> constBigInt22) + sinceUnixEpoch;
/**
 * @since 1.0.0
 * @category Parts
 */
export const dateTime = snowflake => DateTime.unsafeMake(timestamp(snowflake));
/**
 * @since 1.0.0
 * @category Parts
 */
export const machineId = snowflake => Number((snowflake >> constBigInt12) % constBigInt1024);
/**
 * @since 1.0.0
 * @category Parts
 */
export const sequence = snowflake => Number(snowflake % constBigInt4096);
/**
 * @since 1.0.0
 * @category Parts
 */
export const toParts = snowflake => ({
  timestamp: timestamp(snowflake),
  machineId: machineId(snowflake),
  sequence: sequence(snowflake)
});
/**
 * @since 1.0.0
 * @category Generator
 */
export const makeGenerator = /*#__PURE__*/Effect.gen(function* () {
  let machineId = Math.floor(Math.random() * 1024);
  const clock = yield* Effect.clock;
  let sequence = 0;
  let sequenceAt = Math.floor(clock.unsafeCurrentTimeMillis());
  return identity({
    setMachineId: newMachineId => Effect.sync(() => {
      machineId = newMachineId;
    }),
    unsafeNext() {
      let now = Math.floor(clock.unsafeCurrentTimeMillis());
      // account for clock drift, only allow time to move forward
      if (now < sequenceAt) {
        now = sequenceAt;
      } else if (now > sequenceAt) {
        // reset sequence if we're in a new millisecond
        sequence = 0;
        sequenceAt = now;
      } else if (sequence >= 1024) {
        // if we've hit the max sequence for this millisecond, go to the next
        // millisecond
        sequenceAt++;
        sequence = 0;
      }
      return make({
        machineId,
        sequence: sequence++,
        timestamp: sequenceAt
      });
    }
  });
});
/**
 * @since 1.0.0
 * @category Generator
 */
export class Generator extends /*#__PURE__*/Context.Tag("@effect/cluster/Snowflake/Generator")() {}
/**
 * @since 1.0.0
 * @category Generator
 */
export const layerGenerator = /*#__PURE__*/Layer.effect(Generator, makeGenerator);
//# sourceMappingURL=Snowflake.js.map