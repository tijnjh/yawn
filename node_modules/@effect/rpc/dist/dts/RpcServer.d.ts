import * as HttpApp from "@effect/platform/HttpApp";
import * as HttpLayerRouter from "@effect/platform/HttpLayerRouter";
import * as HttpRouter from "@effect/platform/HttpRouter";
import * as SocketServer from "@effect/platform/SocketServer";
import type { WorkerError } from "@effect/platform/WorkerError";
import * as WorkerRunner from "@effect/platform/WorkerRunner";
import * as Context from "effect/Context";
import * as Effect from "effect/Effect";
import * as FiberId from "effect/FiberId";
import * as Layer from "effect/Layer";
import * as Mailbox from "effect/Mailbox";
import * as Option from "effect/Option";
import * as Scope from "effect/Scope";
import type * as Sink from "effect/Sink";
import * as Stream from "effect/Stream";
import * as Rpc from "./Rpc.js";
import type * as RpcGroup from "./RpcGroup.js";
import type { FromClient, FromClientEncoded, FromServer, FromServerEncoded } from "./RpcMessage.js";
import * as RpcSerialization from "./RpcSerialization.js";
/**
 * @since 1.0.0
 * @category server
 */
export interface RpcServer<A extends Rpc.Any> {
    readonly write: (clientId: number, message: FromClient<A>) => Effect.Effect<void>;
    readonly disconnect: (clientId: number) => Effect.Effect<void>;
}
/**
 * @since 1.0.0
 * @category server
 */
export declare const makeNoSerialization: <Rpcs extends Rpc.Any>(group: RpcGroup.RpcGroup<Rpcs>, options: {
    readonly onFromServer: (response: FromServer<Rpcs>) => Effect.Effect<void>;
    readonly disableTracing?: boolean | undefined;
    readonly disableSpanPropagation?: boolean | undefined;
    readonly spanPrefix?: string | undefined;
    readonly spanAttributes?: Record<string, unknown> | undefined;
    readonly disableClientAcks?: boolean | undefined;
    readonly concurrency?: number | "unbounded" | undefined;
    readonly disableFatalDefects?: boolean | undefined;
}) => Effect.Effect<RpcServer<Rpcs>, never, Rpc.ToHandler<Rpcs> | Rpc.Middleware<Rpcs> | Scope.Scope>;
/**
 * @since 1.0.0
 * @category server
 */
export declare const make: <Rpcs extends Rpc.Any>(group: RpcGroup.RpcGroup<Rpcs>, options?: {
    readonly disableTracing?: boolean | undefined;
    readonly spanPrefix?: string | undefined;
    readonly spanAttributes?: Record<string, unknown> | undefined;
    readonly concurrency?: number | "unbounded" | undefined;
    readonly disableFatalDefects?: boolean | undefined;
} | undefined) => Effect.Effect<never, never, Protocol | Rpc.ToHandler<Rpcs> | Rpc.Middleware<Rpcs>>;
/**
 * @since 1.0.0
 * @category server
 */
export declare const layer: <Rpcs extends Rpc.Any>(group: RpcGroup.RpcGroup<Rpcs>, options?: {
    readonly disableTracing?: boolean | undefined;
    readonly spanPrefix?: string | undefined;
    readonly spanAttributes?: Record<string, unknown> | undefined;
    readonly concurrency?: number | "unbounded" | undefined;
}) => Layer.Layer<never, never, Protocol | Rpc.ToHandler<Rpcs> | Rpc.Middleware<Rpcs>>;
/**
 * Create a RPC server that registers a HTTP route with a `HttpLayerRouter`.
 *
 * It defaults to using websockets for communication, but can be configured to
 * use HTTP.
 *
 * @since 1.0.0
 * @category protocol
 */
export declare const layerHttpRouter: <Rpcs extends Rpc.Any>(options: {
    readonly group: RpcGroup.RpcGroup<Rpcs>;
    readonly path: HttpRouter.PathInput;
    readonly protocol?: "http" | "websocket" | undefined;
    readonly disableTracing?: boolean | undefined;
    readonly spanPrefix?: string | undefined;
    readonly spanAttributes?: Record<string, unknown> | undefined;
    readonly concurrency?: number | "unbounded" | undefined;
}) => Layer.Layer<never, never, RpcSerialization.RpcSerialization | HttpLayerRouter.HttpRouter | Rpc.ToHandler<Rpcs> | Rpc.Middleware<Rpcs>>;
declare const Protocol_base: Context.TagClass<Protocol, "@effect/rpc/RpcServer/Protocol", {
    readonly run: (f: (clientId: number, data: FromClientEncoded) => Effect.Effect<void>) => Effect.Effect<never>;
    readonly disconnects: Mailbox.ReadonlyMailbox<number>;
    readonly send: (clientId: number, response: FromServerEncoded, transferables?: ReadonlyArray<globalThis.Transferable>) => Effect.Effect<void>;
    readonly end: (clientId: number) => Effect.Effect<void>;
    readonly clientIds: Effect.Effect<ReadonlySet<number>>;
    readonly initialMessage: Effect.Effect<Option.Option<unknown>>;
    readonly supportsAck: boolean;
    readonly supportsTransferables: boolean;
    readonly supportsSpanPropagation: boolean;
}>;
/**
 * @since 1.0.0
 * @category protocol
 */
export declare class Protocol extends Protocol_base {
    /**
     * @since 1.0.0
     */
    static make: <EX, RX>(f: (write: (clientId: number, data: FromClientEncoded) => Effect.Effect<void>) => Effect.Effect<Omit<{
        readonly run: (f: (clientId: number, data: FromClientEncoded) => Effect.Effect<void>) => Effect.Effect<never>;
        readonly disconnects: Mailbox.ReadonlyMailbox<number>;
        readonly send: (clientId: number, response: FromServerEncoded, transferables?: ReadonlyArray<globalThis.Transferable>) => Effect.Effect<void>;
        readonly end: (clientId: number) => Effect.Effect<void>;
        readonly clientIds: Effect.Effect<ReadonlySet<number>>;
        readonly initialMessage: Effect.Effect<Option.Option<unknown>>;
        readonly supportsAck: boolean;
        readonly supportsTransferables: boolean;
        readonly supportsSpanPropagation: boolean;
    }, "run">, EX, RX>) => Effect.Effect<{
        readonly run: (f: (clientId: number, data: FromClientEncoded) => Effect.Effect<void>) => Effect.Effect<never>;
        readonly disconnects: Mailbox.ReadonlyMailbox<number>;
        readonly send: (clientId: number, response: FromServerEncoded, transferables?: ReadonlyArray<globalThis.Transferable>) => Effect.Effect<void>;
        readonly end: (clientId: number) => Effect.Effect<void>;
        readonly clientIds: Effect.Effect<ReadonlySet<number>>;
        readonly initialMessage: Effect.Effect<Option.Option<unknown>>;
        readonly supportsAck: boolean;
        readonly supportsTransferables: boolean;
        readonly supportsSpanPropagation: boolean;
    }, EX, RX>;
}
/**
 * @since 1.0.0
 * @category protocol
 */
export declare const makeProtocolSocketServer: Effect.Effect<{
    readonly run: (f: (clientId: number, data: FromClientEncoded) => Effect.Effect<void>) => Effect.Effect<never>;
    readonly disconnects: Mailbox.ReadonlyMailbox<number>;
    readonly send: (clientId: number, response: FromServerEncoded, transferables?: ReadonlyArray<globalThis.Transferable>) => Effect.Effect<void>;
    readonly end: (clientId: number) => Effect.Effect<void>;
    readonly clientIds: Effect.Effect<ReadonlySet<number>>;
    readonly initialMessage: Effect.Effect<Option.Option<unknown>>;
    readonly supportsAck: boolean;
    readonly supportsTransferables: boolean;
    readonly supportsSpanPropagation: boolean;
}, never, Scope.Scope | RpcSerialization.RpcSerialization | SocketServer.SocketServer>;
/**
 * A rpc protocol that uses `SocketServer` for communication.
 *
 * @since 1.0.0
 * @category protocol
 */
export declare const layerProtocolSocketServer: Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization | SocketServer.SocketServer>;
/**
 * @since 1.0.0
 * @category protocol
 */
export declare const makeProtocolWithHttpAppWebsocket: Effect.Effect<{
    readonly protocol: Protocol["Type"];
    readonly httpApp: HttpApp.Default<never, Scope.Scope>;
}, never, RpcSerialization.RpcSerialization>;
/**
 * @since 1.0.0
 * @category protocol
 */
export declare const makeProtocolWebsocket: <I = HttpRouter.Default>(options: {
    readonly path: HttpRouter.PathInput;
    readonly routerTag?: Context.Tag<I, HttpRouter.HttpRouter.Service<any, any>>;
}) => Effect.Effect<Protocol["Type"], never, RpcSerialization.RpcSerialization | I>;
/**
 * @since 1.0.0
 * @category protocol
 */
export declare const makeProtocolWebsocketRouter: (options: {
    readonly path: HttpRouter.PathInput;
}) => Effect.Effect<Protocol["Type"], never, RpcSerialization.RpcSerialization | HttpLayerRouter.HttpRouter>;
/**
 * A rpc protocol that uses websockets for communication.
 *
 * @since 1.0.0
 * @category protocol
 */
export declare const layerProtocolWebsocket: <I = HttpRouter.Default>(options: {
    readonly path: HttpRouter.PathInput;
    readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>;
}) => Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization>;
/**
 * A rpc protocol that uses websockets for communication.
 *
 * Uses a `HttpLayerRouter` to provide the websocket endpoint.
 *
 * @since 1.0.0
 * @category protocol
 */
export declare const layerProtocolWebsocketRouter: (options: {
    readonly path: HttpLayerRouter.PathInput;
}) => Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization | HttpLayerRouter.HttpRouter>;
/**
 * @since 1.0.0
 * @category protocol
 */
export declare const makeProtocolWithHttpApp: Effect.Effect<{
    readonly protocol: Protocol["Type"];
    readonly httpApp: HttpApp.Default<never, Scope.Scope>;
}, never, RpcSerialization.RpcSerialization>;
/**
 * @since 1.0.0
 * @category protocol
 */
export declare const makeProtocolHttp: <I = HttpRouter.Default>(options: {
    readonly path: HttpRouter.PathInput;
    readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>;
}) => Effect.Effect<{
    readonly run: (f: (clientId: number, data: FromClientEncoded) => Effect.Effect<void>) => Effect.Effect<never>;
    readonly disconnects: Mailbox.ReadonlyMailbox<number>;
    readonly send: (clientId: number, response: FromServerEncoded, transferables?: ReadonlyArray<globalThis.Transferable>) => Effect.Effect<void>;
    readonly end: (clientId: number) => Effect.Effect<void>;
    readonly clientIds: Effect.Effect<ReadonlySet<number>>;
    readonly initialMessage: Effect.Effect<Option.Option<unknown>>;
    readonly supportsAck: boolean;
    readonly supportsTransferables: boolean;
    readonly supportsSpanPropagation: boolean;
}, never, RpcSerialization.RpcSerialization | I>;
/**
 * @since 1.0.0
 * @category protocol
 */
export declare const makeProtocolHttpRouter: (options: {
    readonly path: HttpRouter.PathInput;
}) => Effect.Effect<{
    readonly run: (f: (clientId: number, data: FromClientEncoded) => Effect.Effect<void>) => Effect.Effect<never>;
    readonly disconnects: Mailbox.ReadonlyMailbox<number>;
    readonly send: (clientId: number, response: FromServerEncoded, transferables?: ReadonlyArray<globalThis.Transferable>) => Effect.Effect<void>;
    readonly end: (clientId: number) => Effect.Effect<void>;
    readonly clientIds: Effect.Effect<ReadonlySet<number>>;
    readonly initialMessage: Effect.Effect<Option.Option<unknown>>;
    readonly supportsAck: boolean;
    readonly supportsTransferables: boolean;
    readonly supportsSpanPropagation: boolean;
}, never, RpcSerialization.RpcSerialization | HttpLayerRouter.HttpRouter>;
/**
 * @since 1.0.0
 * @category protocol
 */
export declare const makeProtocolWorkerRunner: Effect.Effect<Protocol["Type"], WorkerError, WorkerRunner.PlatformRunner | Scope.Scope>;
/**
 * @since 1.0.0
 * @category protocol
 */
export declare const layerProtocolWorkerRunner: Layer.Layer<Protocol, WorkerError, WorkerRunner.PlatformRunner>;
/**
 * A rpc protocol that uses streaming http for communication.
 *
 * @since 1.0.0
 * @category protocol
 */
export declare const layerProtocolHttp: <I = HttpRouter.Default>(options: {
    readonly path: HttpRouter.PathInput;
    readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>;
}) => Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization>;
/**
 * A rpc protocol that uses streaming http for communication.
 *
 * Uses a `HttpLayerRouter` to provide the http endpoint.
 *
 * @since 1.0.0
 * @category protocol
 */
export declare const layerProtocolHttpRouter: (options: {
    readonly path: HttpRouter.PathInput;
}) => Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization | HttpLayerRouter.HttpRouter>;
/**
 * @since 1.0.0
 * @category http app
 */
export declare const toHttpApp: <Rpcs extends Rpc.Any>(group: RpcGroup.RpcGroup<Rpcs>, options?: {
    readonly disableTracing?: boolean | undefined;
    readonly spanPrefix?: string | undefined;
    readonly spanAttributes?: Record<string, unknown> | undefined;
} | undefined) => Effect.Effect<HttpApp.Default<never, Scope.Scope>, never, Scope.Scope | RpcSerialization.RpcSerialization | Rpc.ToHandler<Rpcs> | Rpc.Middleware<Rpcs>>;
/**
 * @since 1.0.0
 * @category http app
 */
export declare const toHttpAppWebsocket: <Rpcs extends Rpc.Any>(group: RpcGroup.RpcGroup<Rpcs>, options?: {
    readonly disableTracing?: boolean | undefined;
    readonly spanPrefix?: string | undefined;
    readonly spanAttributes?: Record<string, unknown> | undefined;
} | undefined) => Effect.Effect<HttpApp.Default<never, Scope.Scope>, never, Scope.Scope | RpcSerialization.RpcSerialization | Rpc.ToHandler<Rpcs> | Rpc.Middleware<Rpcs>>;
/**
 * Construct an http web handler from an `RpcGroup`.
 *
 * @since 1.0.0
 * @category constructors
 */
export declare const toWebHandler: <Rpcs extends Rpc.Any, LE>(group: RpcGroup.RpcGroup<Rpcs>, options: {
    readonly layer: Layer.Layer<Rpc.ToHandler<Rpcs> | Rpc.Middleware<Rpcs> | RpcSerialization.RpcSerialization | HttpRouter.HttpRouter.DefaultServices, LE>;
    readonly disableTracing?: boolean | undefined;
    readonly spanPrefix?: string | undefined;
    readonly spanAttributes?: Record<string, unknown> | undefined;
    readonly middleware?: (httpApp: HttpApp.Default) => HttpApp.Default<never, HttpRouter.HttpRouter.DefaultServices>;
    readonly memoMap?: Layer.MemoMap;
}) => {
    readonly handler: (request: globalThis.Request, context?: Context.Context<never> | undefined) => Promise<Response>;
    readonly dispose: () => Promise<void>;
};
/**
 * Create a protocol that uses the provided `Stream` and `Sink` for communication.
 *
 * @since 1.0.0
 * @category protocol
 */
export declare const makeProtocolStdio: <EIn, EOut, RIn, ROut>(options: {
    readonly stdin: Stream.Stream<Uint8Array, EIn, RIn>;
    readonly stdout: Sink.Sink<void, Uint8Array | string, unknown, EOut, ROut>;
}) => Effect.Effect<{
    readonly run: (f: (clientId: number, data: FromClientEncoded) => Effect.Effect<void>) => Effect.Effect<never>;
    readonly disconnects: Mailbox.ReadonlyMailbox<number>;
    readonly send: (clientId: number, response: FromServerEncoded, transferables?: ReadonlyArray<globalThis.Transferable>) => Effect.Effect<void>;
    readonly end: (clientId: number) => Effect.Effect<void>;
    readonly clientIds: Effect.Effect<ReadonlySet<number>>;
    readonly initialMessage: Effect.Effect<Option.Option<unknown>>;
    readonly supportsAck: boolean;
    readonly supportsTransferables: boolean;
    readonly supportsSpanPropagation: boolean;
}, never, Scope.Scope | RpcSerialization.RpcSerialization | RIn | Exclude<ROut, Scope.Scope>>;
/**
 * Create a protocol that uses the provided `Stream` and `Sink` for communication.
 *
 * @since 1.0.0
 * @category protocol
 */
export declare const layerProtocolStdio: <EIn, EOut, RIn, ROut>(options: {
    readonly stdin: Stream.Stream<Uint8Array, EIn, RIn>;
    readonly stdout: Sink.Sink<void, Uint8Array | string, unknown, EOut, ROut>;
}) => Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization | RIn | ROut>;
/**
 * Fiber id used for client interruptions.
 *
 * @since 1.0.0
 * @category Interruption
 */
export declare const fiberIdClientInterrupt: FiberId.FiberId;
export {};
//# sourceMappingURL=RpcServer.d.ts.map