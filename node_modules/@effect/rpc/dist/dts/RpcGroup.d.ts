/**
 * @since 1.0.0
 */
import type { Headers } from "@effect/platform/Headers";
import * as Context from "effect/Context";
import * as Effect from "effect/Effect";
import * as Layer from "effect/Layer";
import type { ReadonlyMailbox } from "effect/Mailbox";
import { type Pipeable } from "effect/Pipeable";
import type { Scope } from "effect/Scope";
import * as Stream from "effect/Stream";
import * as Rpc from "./Rpc.js";
import type * as RpcMiddleware from "./RpcMiddleware.js";
/**
 * @since 1.0.0
 * @category type ids
 */
export declare const TypeId: unique symbol;
/**
 * @since 1.0.0
 * @category type ids
 */
export type TypeId = typeof TypeId;
/**
 * @since 1.0.0
 * @category groups
 */
export interface RpcGroup<in out R extends Rpc.Any> extends Pipeable {
    new (_: never): {};
    readonly [TypeId]: TypeId;
    readonly requests: ReadonlyMap<string, R>;
    readonly annotations: Context.Context<never>;
    /**
     * Add one or more procedures to the group.
     */
    add<const Rpcs2 extends ReadonlyArray<Rpc.Any>>(...rpcs: Rpcs2): RpcGroup<R | Rpcs2[number]>;
    /**
     * Merge this group with one or more other groups.
     */
    merge<const Groups extends ReadonlyArray<Any>>(...groups: Groups): RpcGroup<R | Rpcs<Groups[number]>>;
    /**
     * Add middleware to all the procedures added to the group until this point.
     */
    middleware<M extends RpcMiddleware.TagClassAny>(middleware: M): RpcGroup<Rpc.AddMiddleware<R, M>>;
    /**
     * Add a prefix to the procedures in this group, returning a new group
     */
    prefix<const Prefix extends string>(prefix: Prefix): RpcGroup<Rpc.Prefixed<R, Prefix>>;
    /**
     * Implement the handlers for the procedures in this group, returning a
     * context object.
     */
    toHandlersContext<Handlers extends HandlersFrom<R>, EX = never, RX = never>(build: Handlers | Effect.Effect<Handlers, EX, RX>): Effect.Effect<Context.Context<Rpc.ToHandler<R>>, EX, RX | HandlersContext<R, Handlers>>;
    /**
     * Implement the handlers for the procedures in this group.
     */
    toLayer<Handlers extends HandlersFrom<R>, EX = never, RX = never>(build: Handlers | Effect.Effect<Handlers, EX, RX>): Layer.Layer<Rpc.ToHandler<R>, EX, Exclude<RX, Scope> | HandlersContext<R, Handlers>>;
    of<const Handlers extends HandlersFrom<R>>(handlers: Handlers): Handlers;
    /**
     * Implement a single handler from the group.
     */
    toLayerHandler<const Tag extends R["_tag"], Handler extends HandlerFrom<R, Tag>, EX = never, RX = never>(tag: Tag, build: Handler | Effect.Effect<Handler, EX, RX>): Layer.Layer<Rpc.Handler<Tag>, EX, Exclude<RX, Scope> | HandlerContext<R, Tag, Handler>>;
    /**
     * Retrieve a handler for a specific procedure in the group.
     */
    accessHandler<const Tag extends R["_tag"]>(tag: Tag): Effect.Effect<(payload: Rpc.Payload<Extract<R, {
        readonly _tag: Tag;
    }>>, headers: Headers) => Rpc.ResultFrom<Extract<R, {
        readonly _tag: Tag;
    }>, never>, never, Rpc.Handler<Tag>>;
    /**
     * Annotate the group with a value.
     */
    annotate<I, S>(tag: Context.Tag<I, S>, value: S): RpcGroup<R>;
    /**
     * Annotate the Rpc's above this point with a value.
     */
    annotateRpcs<I, S>(tag: Context.Tag<I, S>, value: S): RpcGroup<R>;
    /**
     * Annotate the group with a context object.
     */
    annotateContext<S>(context: Context.Context<S>): RpcGroup<R>;
    /**
     * Annotate the Rpc's above this point with a context object.
     */
    annotateRpcsContext<S>(context: Context.Context<S>): RpcGroup<R>;
}
/**
 * @since 1.0.0
 * @category groups
 */
export interface Any {
    readonly [TypeId]: TypeId;
}
/**
 * @since 1.0.0
 * @category groups
 */
export type HandlersFrom<Rpc extends Rpc.Any> = {
    readonly [Current in Rpc as Current["_tag"]]: Rpc.ToHandlerFn<Current>;
};
/**
 * @since 1.0.0
 * @category groups
 */
export type HandlerFrom<Rpc extends Rpc.Any, Tag extends Rpc["_tag"]> = Extract<Rpc, {
    readonly _tag: Tag;
}> extends infer Current ? Current extends Rpc.Any ? Rpc.ToHandlerFn<Current> : never : never;
/**
 * @since 1.0.0
 * @category groups
 */
export type HandlersContext<Rpcs extends Rpc.Any, Handlers> = keyof Handlers extends infer K ? K extends keyof Handlers & string ? HandlerContext<Rpcs, K, Handlers[K]> : never : never;
/**
 * @since 1.0.0
 * @category groups
 */
export type HandlerContext<Rpcs extends Rpc.Any, K extends Rpcs["_tag"], Handler> = [Rpc.IsStream<Rpcs, K>] extends [
    true
] ? Handler extends (...args: any) => Stream.Stream<infer _A, infer _E, infer _R> | Rpc.Wrapper<Stream.Stream<infer _A, infer _E, infer _R>> | Effect.Effect<ReadonlyMailbox<infer _A, infer _E>, infer _EX, infer _R> | Rpc.Wrapper<Effect.Effect<ReadonlyMailbox<infer _A, infer _E>, infer _EX, infer _R>> ? Exclude<Rpc.ExcludeProvides<_R, Rpcs, K>, Scope> : never : Handler extends (...args: any) => Effect.Effect<infer _A, infer _E, infer _R> | Rpc.Wrapper<Effect.Effect<infer _A, infer _E, infer _R>> ? Rpc.ExcludeProvides<_R, Rpcs, K> : never;
/**
 * @since 1.0.0
 * @category groups
 */
export type Rpcs<Group> = Group extends RpcGroup<infer R> ? string extends R["_tag"] ? never : R : never;
/**
 * @since 1.0.0
 * @category groups
 */
export declare const make: <const Rpcs extends ReadonlyArray<Rpc.Any>>(...rpcs: Rpcs) => RpcGroup<Rpcs[number]>;
//# sourceMappingURL=RpcGroup.d.ts.map