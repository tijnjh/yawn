/**
 * @since 1.0.0
 */
import * as Headers from "@effect/platform/Headers";
import * as HttpClient from "@effect/platform/HttpClient";
import * as Socket from "@effect/platform/Socket";
import * as Worker from "@effect/platform/Worker";
import type { WorkerError } from "@effect/platform/WorkerError";
import * as Context from "effect/Context";
import type * as Duration from "effect/Duration";
import * as Effect from "effect/Effect";
import * as FiberRef from "effect/FiberRef";
import * as Layer from "effect/Layer";
import * as Mailbox from "effect/Mailbox";
import * as Schema from "effect/Schema";
import * as Scope from "effect/Scope";
import * as Stream from "effect/Stream";
import * as Rpc from "./Rpc.js";
import { RpcClientError } from "./RpcClientError.js";
import type * as RpcGroup from "./RpcGroup.js";
import type { FromClient, FromClientEncoded, FromServer, FromServerEncoded } from "./RpcMessage.js";
import { RequestId } from "./RpcMessage.js";
import * as RpcSchema from "./RpcSchema.js";
import * as RpcSerialization from "./RpcSerialization.js";
/**
 * @since 1.0.0
 * @category client
 */
export type RpcClient<Rpcs extends Rpc.Any, E = never> = Schema.Simplify<RpcClient.From<RpcClient.NonPrefixed<Rpcs>, E, ""> & {
    readonly [CurrentPrefix in RpcClient.Prefixes<Rpcs>]: RpcClient.From<RpcClient.Prefixed<Rpcs, CurrentPrefix>, E, CurrentPrefix>;
}>;
/**
 * @since 1.0.0
 * @category client
 */
export declare namespace RpcClient {
    /**
     * @since 1.0.0
     * @category client
     */
    type Prefixes<Rpcs extends Rpc.Any> = Rpcs["_tag"] extends infer Tag ? Tag extends `${infer Prefix}.${string}` ? Prefix : never : never;
    /**
     * @since 1.0.0
     * @category client
     */
    type NonPrefixed<Rpcs extends Rpc.Any> = Exclude<Rpcs, {
        readonly _tag: `${string}.${string}`;
    }>;
    /**
     * @since 1.0.0
     * @category client
     */
    type Prefixed<Rpcs extends Rpc.Any, Prefix extends string> = Extract<Rpcs, {
        readonly _tag: `${Prefix}.${string}`;
    }>;
    /**
     * @since 1.0.0
     * @category client
     */
    type From<Rpcs extends Rpc.Any, E = never, Prefix extends string = ""> = {
        readonly [Current in Rpcs as Current["_tag"] extends `${Prefix}.${infer Method}` ? Method : Current["_tag"]]: <const AsMailbox extends boolean = false, const Discard = false>(input: Rpc.PayloadConstructor<Current>, options?: Rpc.Success<Current> extends Stream.Stream<infer _A, infer _E, infer _R> ? {
            readonly asMailbox?: AsMailbox | undefined;
            readonly streamBufferSize?: number | undefined;
            readonly headers?: Headers.Input | undefined;
            readonly context?: Context.Context<never> | undefined;
        } : {
            readonly headers?: Headers.Input | undefined;
            readonly context?: Context.Context<never> | undefined;
            readonly discard?: Discard | undefined;
        }) => Current extends Rpc.Rpc<infer _Tag, infer _Payload, infer _Success, infer _Error, infer _Middleware> ? [_Success] extends [RpcSchema.Stream<infer _A, infer _E>] ? AsMailbox extends true ? Effect.Effect<Mailbox.ReadonlyMailbox<_A["Type"], _E["Type"] | _Error["Type"] | E | _Middleware["failure"]["Type"]>, never, Scope.Scope | _Payload["Context"] | _Success["Context"] | _Error["Context"] | _Middleware["failure"]["Context"]> : Stream.Stream<_A["Type"], _E["Type"] | _Error["Type"] | E | _Middleware["failure"]["Type"], _Payload["Context"] | _Success["Context"] | _Error["Context"] | _Middleware["failure"]["Context"]> : Effect.Effect<Discard extends true ? void : _Success["Type"], Discard extends true ? E : _Error["Type"] | E | _Middleware["failure"]["Type"], _Payload["Context"] | _Success["Context"] | _Error["Context"] | _Middleware["failure"]["Context"]> : never;
    };
    /**
     * @since 1.0.0
     * @category client
     */
    type Flat<Rpcs extends Rpc.Any, E = never> = <const Tag extends Rpcs["_tag"], const AsMailbox extends boolean = false, const Discard = false>(tag: Tag, payload: Rpc.PayloadConstructor<Rpc.ExtractTag<Rpcs, Tag>>, options?: Rpc.Success<Rpc.ExtractTag<Rpcs, Tag>> extends Stream.Stream<infer _A, infer _E, infer _R> ? {
        readonly asMailbox?: AsMailbox | undefined;
        readonly streamBufferSize?: number | undefined;
        readonly headers?: Headers.Input | undefined;
        readonly context?: Context.Context<never> | undefined;
    } : {
        readonly headers?: Headers.Input | undefined;
        readonly context?: Context.Context<never> | undefined;
        readonly discard?: Discard | undefined;
    }) => Rpc.ExtractTag<Rpcs, Tag> extends Rpc.Rpc<infer _Tag, infer _Payload, infer _Success, infer _Error, infer _Middleware> ? [_Success] extends [RpcSchema.Stream<infer _A, infer _E>] ? AsMailbox extends true ? Effect.Effect<Mailbox.ReadonlyMailbox<_A["Type"], _E["Type"] | _Error["Type"] | E | _Middleware["failure"]["Type"]>, never, Scope.Scope | _Payload["Context"] | _Success["Context"] | _Error["Context"] | _Middleware["failure"]["Context"]> : Stream.Stream<_A["Type"], _E["Type"] | _Error["Type"] | E | _Middleware["failure"]["Type"], _Payload["Context"] | _Success["Context"] | _Error["Context"] | _Middleware["failure"]["Context"]> : Effect.Effect<Discard extends true ? void : _Success["Type"], Discard extends true ? E : _Error["Type"] | E | _Middleware["failure"]["Type"], _Payload["Context"] | _Success["Context"] | _Error["Context"] | _Middleware["failure"]["Context"]> : never;
}
/**
 * @since 1.0.0
 * @category client
 */
export type FromGroup<Group, E = never> = RpcClient<RpcGroup.Rpcs<Group>, E>;
/**
 * @since 1.0.0
 * @category client
 */
export declare const makeNoSerialization: <Rpcs extends Rpc.Any, E, const Flatten extends boolean = false>(group: RpcGroup.RpcGroup<Rpcs>, options: {
    readonly onFromClient: (options: {
        readonly message: FromClient<Rpcs>;
        readonly context: Context.Context<never>;
        readonly discard: boolean;
    }) => Effect.Effect<void, E>;
    readonly supportsAck?: boolean | undefined;
    readonly spanPrefix?: string | undefined;
    readonly spanAttributes?: Record<string, unknown> | undefined;
    readonly generateRequestId?: (() => RequestId) | undefined;
    readonly disableTracing?: boolean | undefined;
    readonly flatten?: Flatten | undefined;
}) => Effect.Effect<{
    readonly client: Flatten extends true ? RpcClient.Flat<Rpcs, E> : RpcClient<Rpcs, E>;
    readonly write: (message: FromServer<Rpcs>) => Effect.Effect<void>;
}, never, Scope.Scope | Rpc.MiddlewareClient<Rpcs>>;
/**
 * @since 1.0.0
 * @category client
 */
export declare const make: <Rpcs extends Rpc.Any, const Flatten extends boolean = false>(group: RpcGroup.RpcGroup<Rpcs>, options?: {
    readonly spanPrefix?: string | undefined;
    readonly spanAttributes?: Record<string, unknown> | undefined;
    readonly generateRequestId?: (() => RequestId) | undefined;
    readonly disableTracing?: boolean | undefined;
    readonly flatten?: Flatten | undefined;
} | undefined) => Effect.Effect<Flatten extends true ? RpcClient.Flat<Rpcs, RpcClientError> : RpcClient<Rpcs, RpcClientError>, never, Protocol | Rpc.MiddlewareClient<Rpcs> | Scope.Scope>;
/**
 * @since 1.0.0
 * @category headers
 */
export declare const currentHeaders: FiberRef.FiberRef<Headers.Headers>;
/**
 * @since 1.0.0
 * @category headers
 */
export declare const withHeaders: {
    /**
     * @since 1.0.0
     * @category headers
     */
    (headers: Headers.Input): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>;
    /**
     * @since 1.0.0
     * @category headers
     */
    <A, E, R>(effect: Effect.Effect<A, E, R>, headers: Headers.Input): Effect.Effect<A, E, R>;
};
/**
 * @since 1.0.0
 * @category headers
 */
export declare const withHeadersEffect: {
    /**
     * @since 1.0.0
     * @category headers
     */
    <E2, R2>(headers: Effect.Effect<Headers.Input, E2, R2>): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E2, R | R2>;
    /**
     * @since 1.0.0
     * @category headers
     */
    <A, E, R, E2, R2>(effect: Effect.Effect<A, E, R>, headers: Effect.Effect<Headers.Input, E2, R2>): Effect.Effect<A, E | E2, R | R2>;
};
declare const Protocol_base: Context.TagClass<Protocol, "@effect/rpc/RpcClient/Protocol", {
    readonly run: (f: (data: FromServerEncoded) => Effect.Effect<void>) => Effect.Effect<never>;
    readonly send: (request: FromClientEncoded, transferables?: ReadonlyArray<globalThis.Transferable>) => Effect.Effect<void, RpcClientError>;
    readonly supportsAck: boolean;
    readonly supportsTransferables: boolean;
}>;
/**
 * @since 1.0.0
 * @category protocol
 */
export declare class Protocol extends Protocol_base {
    /**
     * @since 1.0.0
     */
    static make: <EX, RX>(f: (write: (data: FromServerEncoded) => Effect.Effect<void>) => Effect.Effect<Omit<{
        readonly run: (f: (data: FromServerEncoded) => Effect.Effect<void>) => Effect.Effect<never>;
        readonly send: (request: FromClientEncoded, transferables?: ReadonlyArray<globalThis.Transferable>) => Effect.Effect<void, RpcClientError>;
        readonly supportsAck: boolean;
        readonly supportsTransferables: boolean;
    }, "run">, EX, RX>) => Effect.Effect<{
        readonly run: (f: (data: FromServerEncoded) => Effect.Effect<void>) => Effect.Effect<never>;
        readonly send: (request: FromClientEncoded, transferables?: ReadonlyArray<globalThis.Transferable>) => Effect.Effect<void, RpcClientError>;
        readonly supportsAck: boolean;
        readonly supportsTransferables: boolean;
    }, EX, RX>;
}
/**
 * @since 1.0.0
 * @category protocol
 */
export declare const makeProtocolHttp: (client: HttpClient.HttpClient) => Effect.Effect<Protocol["Type"], never, RpcSerialization.RpcSerialization>;
/**
 * @since 1.0.0
 * @category protocol
 */
export declare const layerProtocolHttp: (options: {
    readonly url: string;
    readonly transformClient?: <E, R>(client: HttpClient.HttpClient.With<E, R>) => HttpClient.HttpClient.With<E, R>;
}) => Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization | HttpClient.HttpClient>;
/**
 * @since 1.0.0
 * @category protocol
 */
export declare const makeProtocolSocket: (options?: {
    readonly retryTransientErrors?: boolean | undefined;
}) => Effect.Effect<Protocol["Type"], never, Scope.Scope | RpcSerialization.RpcSerialization | Socket.Socket>;
/**
 * @since 1.0.0
 * @category protocol
 */
export declare const makeProtocolWorker: (options: {
    readonly size: number;
    readonly concurrency?: number | undefined;
    readonly targetUtilization?: number | undefined;
} | {
    readonly minSize: number;
    readonly maxSize: number;
    readonly concurrency?: number | undefined;
    readonly targetUtilization?: number | undefined;
    readonly timeToLive: Duration.DurationInput;
}) => Effect.Effect<Protocol["Type"], WorkerError, Scope.Scope | Worker.PlatformWorker | Worker.Spawner>;
/**
 * @since 1.0.0
 * @category protocol
 */
export declare const layerProtocolWorker: (options: {
    readonly size: number;
    readonly concurrency?: number | undefined;
    readonly targetUtilization?: number | undefined;
} | {
    readonly minSize: number;
    readonly maxSize: number;
    readonly concurrency?: number | undefined;
    readonly targetUtilization?: number | undefined;
    readonly timeToLive: Duration.DurationInput;
}) => Layer.Layer<Protocol, WorkerError, Worker.PlatformWorker | Worker.Spawner>;
/**
 * @since 1.0.0
 * @category protocol
 */
export declare const layerProtocolSocket: (options?: {
    readonly retryTransientErrors?: boolean | undefined;
}) => Layer.Layer<Protocol, never, Socket.Socket | RpcSerialization.RpcSerialization>;
export {};
//# sourceMappingURL=RpcClient.d.ts.map