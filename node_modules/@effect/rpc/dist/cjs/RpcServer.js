"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toWebHandler = exports.toHttpAppWebsocket = exports.toHttpApp = exports.makeProtocolWorkerRunner = exports.makeProtocolWithHttpAppWebsocket = exports.makeProtocolWithHttpApp = exports.makeProtocolWebsocketRouter = exports.makeProtocolWebsocket = exports.makeProtocolStdio = exports.makeProtocolSocketServer = exports.makeProtocolHttpRouter = exports.makeProtocolHttp = exports.makeNoSerialization = exports.make = exports.layerProtocolWorkerRunner = exports.layerProtocolWebsocketRouter = exports.layerProtocolWebsocket = exports.layerProtocolStdio = exports.layerProtocolSocketServer = exports.layerProtocolHttpRouter = exports.layerProtocolHttp = exports.layerHttpRouter = exports.layer = exports.fiberIdClientInterrupt = exports.Protocol = void 0;
var Headers = _interopRequireWildcard(require("@effect/platform/Headers"));
var HttpApp = _interopRequireWildcard(require("@effect/platform/HttpApp"));
var HttpLayerRouter = _interopRequireWildcard(require("@effect/platform/HttpLayerRouter"));
var HttpRouter = _interopRequireWildcard(require("@effect/platform/HttpRouter"));
var HttpServerRequest = _interopRequireWildcard(require("@effect/platform/HttpServerRequest"));
var HttpServerResponse = _interopRequireWildcard(require("@effect/platform/HttpServerResponse"));
var SocketServer = _interopRequireWildcard(require("@effect/platform/SocketServer"));
var Transferable = _interopRequireWildcard(require("@effect/platform/Transferable"));
var WorkerRunner = _interopRequireWildcard(require("@effect/platform/WorkerRunner"));
var Arr = _interopRequireWildcard(require("effect/Array"));
var Cause = _interopRequireWildcard(require("effect/Cause"));
var Chunk = _interopRequireWildcard(require("effect/Chunk"));
var Context = _interopRequireWildcard(require("effect/Context"));
var Deferred = _interopRequireWildcard(require("effect/Deferred"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Exit = _interopRequireWildcard(require("effect/Exit"));
var Fiber = _interopRequireWildcard(require("effect/Fiber"));
var FiberId = _interopRequireWildcard(require("effect/FiberId"));
var FiberSet = _interopRequireWildcard(require("effect/FiberSet"));
var _Function = require("effect/Function");
var Layer = _interopRequireWildcard(require("effect/Layer"));
var Mailbox = _interopRequireWildcard(require("effect/Mailbox"));
var Option = _interopRequireWildcard(require("effect/Option"));
var _ParseResult = require("effect/ParseResult");
var Predicate = _interopRequireWildcard(require("effect/Predicate"));
var Runtime = _interopRequireWildcard(require("effect/Runtime"));
var RuntimeFlags = _interopRequireWildcard(require("effect/RuntimeFlags"));
var Schedule = _interopRequireWildcard(require("effect/Schedule"));
var Schema = _interopRequireWildcard(require("effect/Schema"));
var Scope = _interopRequireWildcard(require("effect/Scope"));
var Stream = _interopRequireWildcard(require("effect/Stream"));
var Tracer = _interopRequireWildcard(require("effect/Tracer"));
var _utils = require("./internal/utils.js");
var Rpc = _interopRequireWildcard(require("./Rpc.js"));
var _RpcMessage = require("./RpcMessage.js");
var RpcSchema = _interopRequireWildcard(require("./RpcSchema.js"));
var RpcSerialization = _interopRequireWildcard(require("./RpcSerialization.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * @since 1.0.0
 */

/**
 * @since 1.0.0
 * @category server
 */
const makeNoSerialization = exports.makeNoSerialization = /*#__PURE__*/Effect.fnUntraced(function* (group, options) {
  const enableTracing = options.disableTracing !== true;
  const enableSpanPropagation = options.disableSpanPropagation !== true;
  const supportsAck = options.disableClientAcks !== true;
  const spanPrefix = options.spanPrefix ?? "RpcServer";
  const concurrency = options.concurrency ?? "unbounded";
  const disableFatalDefects = options.disableFatalDefects ?? false;
  const context = yield* Effect.context();
  const scope = Context.get(context, Scope.Scope);
  const fiberSet = yield* FiberSet.make();
  const runFork = yield* FiberSet.runtime(fiberSet)().pipe(Effect.interruptible);
  const concurrencySemaphore = concurrency === "unbounded" ? undefined : yield* Effect.makeSemaphore(concurrency);
  const clients = new Map();
  let isShutdown = false;
  const shutdownLatch = Effect.unsafeMakeLatch(false);
  yield* Scope.addFinalizer(scope, Effect.fiberIdWith(fiberId => {
    isShutdown = true;
    for (const client of clients.values()) {
      client.ended = true;
      if (client.fibers.size === 0) {
        runFork(endClient(client));
        continue;
      }
      for (const fiber of client.fibers.values()) {
        fiber.unsafeInterruptAsFork(fiberId);
      }
    }
    if (clients.size === 0) {
      return Effect.void;
    }
    return shutdownLatch.await;
  }));
  const disconnect = clientId => Effect.fiberIdWith(fiberId => {
    const client = clients.get(clientId);
    if (!client) return Effect.void;
    for (const fiber of client.fibers.values()) {
      fiber.unsafeInterruptAsFork(fiberId);
    }
    clients.delete(clientId);
    return Effect.void;
  });
  const write = (clientId, message) => Effect.catchAllDefect(Effect.withFiberRuntime(requestFiber => {
    if (isShutdown) return Effect.interrupt;
    let client = clients.get(clientId);
    if (!client) {
      client = {
        id: clientId,
        latches: new Map(),
        fibers: new Map(),
        ended: false
      };
      clients.set(clientId, client);
    } else if (client.ended) {
      return Effect.interrupt;
    }
    switch (message._tag) {
      case "Request":
        {
          return handleRequest(requestFiber, client, message);
        }
      case "Ack":
        {
          const latch = client.latches.get(message.requestId);
          return latch ? latch.open : Effect.void;
        }
      case "Interrupt":
        {
          const fiber = client.fibers.get(message.requestId);
          return fiber ? Fiber.interruptAsFork(fiber, fiberIdClientInterrupt) : options.onFromServer({
            _tag: "Exit",
            clientId,
            requestId: message.requestId,
            exit: Exit.interrupt(FiberId.none)
          });
        }
      case "Eof":
        {
          client.ended = true;
          if (client.fibers.size > 0) return Effect.void;
          return endClient(client);
        }
      default:
        {
          return sendDefect(client, `Unknown request tag: ${message._tag}`);
        }
    }
  }), defect => sendDefect(clients.get(clientId), defect));
  const endClient = client => {
    clients.delete(client.id);
    const write = options.onFromServer({
      _tag: "ClientEnd",
      clientId: client.id
    });
    if (isShutdown && clients.size === 0) {
      return Effect.zipRight(write, shutdownLatch.open);
    }
    return write;
  };
  const handleRequest = (requestFiber, client, request) => {
    if (client.fibers.has(request.id)) {
      return Effect.interrupt;
    }
    const rpc = group.requests.get(request.tag);
    const entry = context.unsafeMap.get(rpc?.key);
    if (!rpc || !entry) {
      const write = Effect.catchAllDefect(options.onFromServer({
        _tag: "Exit",
        clientId: client.id,
        requestId: request.id,
        exit: Exit.die(`Unknown request tag: ${request.tag}`)
      }), defect => sendDefect(client, defect));
      if (!client.ended || client.fibers.size > 0) return write;
      return Effect.zipRight(write, endClient(client));
    }
    const isStream = RpcSchema.isStreamSchema(rpc.successSchema);
    const result = entry.handler(request.payload, {
      clientId: client.id,
      headers: request.headers
    });
    // if the handler requested forking, then we skip the concurrency control
    const isWrapper = Rpc.isWrapper(result);
    const isFork = isWrapper && result.fork;
    const isUninterruptible = isWrapper && result.uninterruptible;
    // unwrap the fork data type
    const streamOrEffect = isWrapper ? result.value : result;
    const handler = applyMiddleware(rpc, context, client.id, request.payload, request.headers, isStream ? streamEffect(client, request, streamOrEffect) : streamOrEffect);
    let responded = false;
    let effect = Effect.matchCauseEffect(isUninterruptible ? handler : Effect.interruptible(handler), {
      onSuccess: value => {
        responded = true;
        return options.onFromServer({
          _tag: "Exit",
          clientId: client.id,
          requestId: request.id,
          exit: Exit.succeed(value)
        });
      },
      onFailure: cause => {
        responded = true;
        if (!disableFatalDefects && Cause.isDie(cause) && !Cause.isInterrupted(cause)) {
          return sendDefect(client, Cause.squash(cause));
        }
        return options.onFromServer({
          _tag: "Exit",
          clientId: client.id,
          requestId: request.id,
          exit: Exit.failCause(cause)
        });
      }
    });
    if (enableTracing) {
      const parentSpan = requestFiber.currentContext.unsafeMap.get(Tracer.ParentSpan.key);
      effect = Effect.withSpan(effect, `${spanPrefix}.${request.tag}`, {
        captureStackTrace: false,
        attributes: options.spanAttributes,
        parent: enableSpanPropagation && request.spanId ? {
          _tag: "ExternalSpan",
          traceId: request.traceId,
          spanId: request.spanId,
          sampled: request.sampled,
          context: Context.empty()
        } : undefined,
        links: enableSpanPropagation && parentSpan ? [{
          _tag: "SpanLink",
          span: parentSpan,
          attributes: {}
        }] : undefined
      });
    }
    if (!isFork && concurrencySemaphore) {
      effect = concurrencySemaphore.withPermits(1)(effect);
    }
    const runtime = Runtime.make({
      context: Context.merge(entry.context, requestFiber.currentContext),
      fiberRefs: requestFiber.getFiberRefs(),
      runtimeFlags: RuntimeFlags.disable(Runtime.defaultRuntime.runtimeFlags, RuntimeFlags.Interruption)
    });
    const fiber = Runtime.runFork(runtime, effect);
    FiberSet.unsafeAdd(fiberSet, fiber);
    client.fibers.set(request.id, fiber);
    fiber.addObserver(exit => {
      if (!responded && exit._tag === "Failure") {
        FiberSet.unsafeAdd(fiberSet, Runtime.runFork(runtime, options.onFromServer({
          _tag: "Exit",
          clientId: client.id,
          requestId: request.id,
          exit: Exit.interrupt(FiberId.none)
        })));
      }
      client.fibers.delete(request.id);
      client.latches.delete(request.id);
      if (client.ended && client.fibers.size === 0) {
        FiberSet.unsafeAdd(fiberSet, Runtime.runFork(runtime, endClient(client)));
      }
    });
    return Effect.void;
  };
  const streamEffect = (client, request, stream) => {
    let latch = client.latches.get(request.id);
    if (supportsAck && !latch) {
      latch = Effect.unsafeMakeLatch(false);
      client.latches.set(request.id, latch);
    }
    if (Effect.isEffect(stream)) {
      let done = false;
      return stream.pipe(Effect.flatMap(mailbox => Effect.whileLoop({
        while: () => !done,
        body: (0, _Function.constant)(Effect.flatMap(mailbox.takeAll, ([chunk, done_]) => {
          done = done_;
          if (!Chunk.isNonEmpty(chunk)) return Effect.void;
          const write = options.onFromServer({
            _tag: "Chunk",
            clientId: client.id,
            requestId: request.id,
            values: Chunk.toReadonlyArray(chunk)
          });
          if (!latch) return write;
          latch.unsafeClose();
          return Effect.zipRight(write, latch.await);
        })),
        step: _Function.constVoid
      })), Effect.scoped);
    }
    return Stream.runForEachChunk(stream, chunk => {
      if (!Chunk.isNonEmpty(chunk)) return Effect.void;
      const write = options.onFromServer({
        _tag: "Chunk",
        clientId: client.id,
        requestId: request.id,
        values: Chunk.toReadonlyArray(chunk)
      });
      if (!latch) return write;
      latch.unsafeClose();
      return Effect.zipRight(write, latch.await);
    });
  };
  const sendDefect = (client, defect) => Effect.suspend(() => {
    const shouldEnd = client.ended && client.fibers.size === 0;
    const write = options.onFromServer({
      _tag: "Defect",
      clientId: client.id,
      defect
    });
    if (!shouldEnd) return write;
    return Effect.zipRight(write, endClient(client));
  });
  return (0, _Function.identity)({
    write,
    disconnect
  });
});
const applyMiddleware = (rpc, context, clientId, payload, headers, handler) => {
  if (rpc.middlewares.size === 0) {
    return handler;
  }
  const options = {
    rpc,
    payload,
    headers,
    clientId
  };
  for (const tag of rpc.middlewares) {
    if (tag.wrap) {
      const middleware = Context.unsafeGet(context, tag);
      handler = middleware({
        ...options,
        next: handler
      });
    } else if (tag.optional) {
      const middleware = Context.unsafeGet(context, tag);
      const previous = handler;
      handler = Effect.matchEffect(middleware(options), {
        onFailure: () => previous,
        onSuccess: tag.provides !== undefined ? value => Effect.provideService(previous, tag.provides, value) : _ => previous
      });
    } else {
      const middleware = Context.unsafeGet(context, tag);
      handler = tag.provides !== undefined ? Effect.provideServiceEffect(handler, tag.provides, middleware(options)) : Effect.zipRight(middleware(options), handler);
    }
  }
  return handler;
};
/**
 * @since 1.0.0
 * @category server
 */
const make = exports.make = /*#__PURE__*/Effect.fnUntraced(function* (group, options) {
  const {
    disconnects,
    end,
    run,
    send,
    supportsAck,
    supportsSpanPropagation,
    supportsTransferables
  } = yield* Protocol;
  const context = yield* Effect.context();
  const scope = yield* Scope.make();
  const server = yield* makeNoSerialization(group, {
    ...options,
    disableClientAcks: !supportsAck,
    disableSpanPropagation: !supportsSpanPropagation,
    onFromServer(response) {
      const client = clients.get(response.clientId);
      if (!client) return Effect.void;
      switch (response._tag) {
        case "Chunk":
          {
            const schemas = client.schemas.get(response.requestId);
            if (!schemas) return Effect.void;
            return handleEncode(client, response.requestId, schemas.collector, Effect.provide(schemas.encodeChunk(response.values), schemas.context), values => ({
              _tag: "Chunk",
              requestId: String(response.requestId),
              values
            }));
          }
        case "Exit":
          {
            const schemas = client.schemas.get(response.requestId);
            if (!schemas) return Effect.void;
            client.schemas.delete(response.requestId);
            return handleEncode(client, response.requestId, schemas.collector, Effect.provide(schemas.encodeExit(response.exit), schemas.context), exit => ({
              _tag: "Exit",
              requestId: String(response.requestId),
              exit
            }));
          }
        case "Defect":
          {
            return sendDefect(client, response.defect);
          }
        case "ClientEnd":
          {
            clients.delete(response.clientId);
            return end(response.clientId);
          }
      }
    }
  }).pipe(Scope.extend(scope));
  // handle disconnects
  yield* Effect.fork(Effect.interruptible(Effect.whileLoop({
    while: _Function.constTrue,
    body: (0, _Function.constant)(Effect.flatMap(disconnects.take, clientId => {
      clients.delete(clientId);
      return server.disconnect(clientId);
    })),
    step: _Function.constVoid
  })));
  const schemasCache = new WeakMap();
  const getSchemas = rpc => {
    let schemas = schemasCache.get(rpc);
    if (!schemas) {
      const entry = context.unsafeMap.get(rpc.key);
      const streamSchemas = RpcSchema.getStreamSchemas(rpc.successSchema.ast);
      schemas = {
        decode: Schema.decodeUnknown(rpc.payloadSchema),
        encodeChunk: Schema.encodeUnknown(Schema.Array(Option.isSome(streamSchemas) ? streamSchemas.value.success : Schema.Any)),
        encodeExit: Schema.encodeUnknown(Rpc.exitSchema(rpc)),
        context: entry.context
      };
      schemasCache.set(rpc, schemas);
    }
    return schemas;
  };
  const clients = new Map();
  const handleEncode = (client, requestId, collector, effect, onSuccess) => (collector ? Effect.provideService(effect, Transferable.Collector, collector) : effect).pipe(Effect.flatMap(a => send(client.id, onSuccess(a), collector && collector.unsafeClear())), Effect.catchAllCause(cause => {
    client.schemas.delete(requestId);
    const defect = Cause.squash(Cause.map(cause, _ParseResult.TreeFormatter.formatErrorSync));
    return Effect.zipRight(sendRequestDefect(client, requestId, defect), server.write(client.id, {
      _tag: "Interrupt",
      requestId,
      interruptors: []
    }));
  }));
  const sendRequestDefect = (client, requestId, defect) => Effect.catchAllCause(send(client.id, {
    _tag: "Exit",
    requestId: String(requestId),
    exit: {
      _tag: "Failure",
      cause: {
        _tag: "Die",
        defect
      }
    }
  }), cause => sendDefect(client, Cause.squash(cause)));
  const sendDefect = (client, defect) => Effect.catchAllCause(send(client.id, {
    _tag: "Defect",
    defect
  }), cause => Effect.annotateLogs(Effect.logDebug(cause), {
    module: "RpcServer",
    method: "sendDefect"
  }));
  // main server loop
  return yield* run((clientId, request) => {
    let client = clients.get(clientId);
    if (!client) {
      client = {
        id: clientId,
        schemas: new Map()
      };
      clients.set(clientId, client);
    }
    switch (request._tag) {
      case "Request":
        {
          const tag = Predicate.hasProperty(request, "tag") ? request.tag : "";
          const rpc = group.requests.get(tag);
          if (!rpc) {
            return sendDefect(client, `Unknown request tag: ${tag}`);
          }
          let requestId;
          switch (typeof request.id) {
            case "bigint":
            case "string":
              {
                requestId = (0, _RpcMessage.RequestId)(request.id);
                break;
              }
            default:
              {
                return sendDefect(client, `Invalid request id: ${request.id}`);
              }
          }
          const schemas = getSchemas(rpc);
          return Effect.matchEffect(Effect.provide(schemas.decode(request.payload), schemas.context), {
            onFailure: error => sendRequestDefect(client, requestId, _ParseResult.TreeFormatter.formatErrorSync(error)),
            onSuccess: payload => {
              client.schemas.set(requestId, supportsTransferables ? {
                ...schemas,
                collector: Transferable.unsafeMakeCollector()
              } : schemas);
              return server.write(clientId, {
                ...request,
                id: requestId,
                payload,
                headers: Headers.fromInput(request.headers)
              });
            }
          });
        }
      case "Ping":
        {
          return Effect.catchAllCause(send(client.id, _RpcMessage.constPong), cause => sendDefect(client, Cause.squash(cause)));
        }
      case "Eof":
        {
          return server.write(clientId, request);
        }
      case "Ack":
        {
          return server.write(clientId, {
            ...request,
            requestId: (0, _RpcMessage.RequestId)(request.requestId)
          });
        }
      case "Interrupt":
        {
          return server.write(clientId, {
            ...request,
            requestId: (0, _RpcMessage.RequestId)(request.requestId),
            interruptors: []
          });
        }
      default:
        {
          return sendDefect(client, `Unknown request tag: ${request._tag}`);
        }
    }
  }).pipe(Effect.interruptible, Effect.tapErrorCause(cause => Effect.logFatal("BUG: RpcServer protocol crashed", cause)), Effect.onExit(exit => Scope.close(scope, exit)));
});
/**
 * @since 1.0.0
 * @category server
 */
const layer = (group, options) => Layer.scopedDiscard(Effect.forkScoped(Effect.interruptible(make(group, options))));
/**
 * Create a RPC server that registers a HTTP route with a `HttpLayerRouter`.
 *
 * It defaults to using websockets for communication, but can be configured to
 * use HTTP.
 *
 * @since 1.0.0
 * @category protocol
 */
exports.layer = layer;
const layerHttpRouter = options => layer(options.group, options).pipe(Layer.provide(options.protocol === "http" ? layerProtocolHttpRouter(options) : layerProtocolWebsocketRouter(options)));
/**
 * @since 1.0.0
 * @category protocol
 */
exports.layerHttpRouter = layerHttpRouter;
class Protocol extends /*#__PURE__*/Context.Tag("@effect/rpc/RpcServer/Protocol")() {
  /**
   * @since 1.0.0
   */
  static make = /*#__PURE__*/(0, _utils.withRun)();
}
/**
 * @since 1.0.0
 * @category protocol
 */
exports.Protocol = Protocol;
const makeProtocolSocketServer = exports.makeProtocolSocketServer = /*#__PURE__*/Effect.gen(function* () {
  const server = yield* SocketServer.SocketServer;
  const {
    onSocket,
    protocol
  } = yield* makeSocketProtocol;
  yield* Effect.forkScoped(Effect.interruptible(server.run(Effect.fnUntraced(onSocket, Effect.scoped))));
  return protocol;
});
/**
 * A rpc protocol that uses `SocketServer` for communication.
 *
 * @since 1.0.0
 * @category protocol
 */
const layerProtocolSocketServer = exports.layerProtocolSocketServer = /*#__PURE__*/Layer.scoped(Protocol, makeProtocolSocketServer);
/**
 * @since 1.0.0
 * @category protocol
 */
const makeProtocolWithHttpAppWebsocket = exports.makeProtocolWithHttpAppWebsocket = /*#__PURE__*/Effect.gen(function* () {
  const {
    onSocket,
    protocol
  } = yield* makeSocketProtocol;
  const httpApp = Effect.gen(function* () {
    const request = yield* HttpServerRequest.HttpServerRequest;
    const socket = yield* Effect.orDie(request.upgrade);
    yield* onSocket(socket, Object.entries(request.headers));
    return HttpServerResponse.empty();
  });
  return {
    protocol,
    httpApp
  };
});
/**
 * @since 1.0.0
 * @category protocol
 */
const makeProtocolWebsocket = exports.makeProtocolWebsocket = /*#__PURE__*/Effect.fnUntraced(function* (options) {
  const {
    httpApp,
    protocol
  } = yield* makeProtocolWithHttpAppWebsocket;
  const router = yield* options.routerTag ?? HttpRouter.Default;
  yield* router.get(options.path, httpApp);
  return protocol;
});
/**
 * @since 1.0.0
 * @category protocol
 */
const makeProtocolWebsocketRouter = exports.makeProtocolWebsocketRouter = /*#__PURE__*/Effect.fnUntraced(function* (options) {
  const router = yield* HttpLayerRouter.HttpRouter;
  const {
    httpApp,
    protocol
  } = yield* makeProtocolWithHttpAppWebsocket;
  yield* router.add("GET", options.path, httpApp);
  return protocol;
});
/**
 * A rpc protocol that uses websockets for communication.
 *
 * @since 1.0.0
 * @category protocol
 */
const layerProtocolWebsocket = options => {
  const routerTag = options.routerTag ?? HttpRouter.Default;
  return Layer.effect(Protocol, makeProtocolWebsocket(options)).pipe(Layer.provide(routerTag.Live));
};
/**
 * A rpc protocol that uses websockets for communication.
 *
 * Uses a `HttpLayerRouter` to provide the websocket endpoint.
 *
 * @since 1.0.0
 * @category protocol
 */
exports.layerProtocolWebsocket = layerProtocolWebsocket;
const layerProtocolWebsocketRouter = options => Layer.effect(Protocol, makeProtocolWebsocketRouter(options));
/**
 * @since 1.0.0
 * @category protocol
 */
exports.layerProtocolWebsocketRouter = layerProtocolWebsocketRouter;
const makeProtocolWithHttpApp = exports.makeProtocolWithHttpApp = /*#__PURE__*/Effect.gen(function* () {
  const serialization = yield* RpcSerialization.RpcSerialization;
  const includesFraming = serialization.includesFraming;
  const isBinary = !serialization.contentType.includes("json");
  const disconnects = yield* Mailbox.make();
  let writeRequest;
  let clientId = 0;
  const clients = new Map();
  const clientIds = new Set();
  const encoder = new TextEncoder();
  const httpApp = Effect.gen(function* () {
    const request = yield* HttpServerRequest.HttpServerRequest;
    const scope = yield* Effect.scope;
    const requestHeaders = Object.entries(request.headers);
    const data = yield* Effect.orDie(isBinary ? Effect.map(request.arrayBuffer, ab => new Uint8Array(ab)) : request.text);
    const id = clientId++;
    const mailbox = yield* Mailbox.make();
    const parser = serialization.unsafeMake();
    const offer = data => typeof data === "string" ? mailbox.offer(encoder.encode(data)) : mailbox.offer(data);
    clientIds.add(id);
    const client = {
      write: !includesFraming ? response => mailbox.offer(response) : response => {
        try {
          const encoded = parser.encode(response);
          if (encoded === undefined) return Effect.void;
          return offer(encoded);
        } catch (cause) {
          return offer(parser.encode((0, _RpcMessage.ResponseDefectEncoded)(cause)));
        }
      },
      end: mailbox.end
    };
    clients.set(id, client);
    yield* Scope.addFinalizerExit(scope, () => {
      clientIds.delete(id);
      clients.delete(id);
      disconnects.unsafeOffer(id);
      if (mailbox.unsafeSize()._tag === "None") return Effect.void;
      return Effect.forEach(requestIds, requestId => writeRequest(id, {
        _tag: "Interrupt",
        requestId: String(requestId)
      }), {
        discard: true
      });
    });
    const requestIds = [];
    try {
      const decoded = parser.decode(data);
      for (const message of decoded) {
        if (message._tag === "Request") {
          requestIds.push((0, _RpcMessage.RequestId)(message.id));
          message.headers = requestHeaders.concat(message.headers);
        }
        yield* writeRequest(id, message);
      }
    } catch (cause) {
      yield* client.write((0, _RpcMessage.ResponseDefectEncoded)(cause));
    }
    yield* writeRequest(id, _RpcMessage.constEof);
    if (!includesFraming) {
      const responses = Arr.empty();
      while (true) {
        const [items, done] = yield* mailbox.takeAll;
        // eslint-disable-next-line no-restricted-syntax
        responses.push(...items);
        if (done) break;
      }
      return HttpServerResponse.text(parser.encode(responses), {
        contentType: serialization.contentType
      });
    }
    const [initialChunk, done] = yield* mailbox.takeAll;
    if (done) {
      return HttpServerResponse.uint8Array(mergeUint8Arrays(initialChunk), {
        contentType: serialization.contentType
      });
    }
    return HttpServerResponse.stream(Stream.fromChunk(initialChunk).pipe(Stream.concat(Mailbox.toStream(mailbox))), {
      contentType: serialization.contentType
    });
  }).pipe(Effect.interruptible);
  const protocol = yield* Protocol.make(writeRequest_ => {
    writeRequest = writeRequest_;
    return Effect.succeed({
      disconnects,
      send(clientId, response) {
        const client = clients.get(clientId);
        if (!client) return Effect.void;
        return client.write(response);
      },
      end(clientId) {
        const client = clients.get(clientId);
        if (!client) return Effect.void;
        return client.end;
      },
      clientIds: Effect.sync(() => clientIds),
      initialMessage: Effect.succeedNone,
      supportsAck: false,
      supportsTransferables: false,
      supportsSpanPropagation: false
    });
  });
  return {
    protocol,
    httpApp
  };
});
const mergeUint8Arrays = arrays => {
  if (arrays.length === 0) return new Uint8Array(0);
  if (arrays.length === 1) return Chunk.unsafeHead(arrays);
  const length = Chunk.reduce(arrays, 0, (acc, a) => acc + a.length);
  const result = new Uint8Array(length);
  let offset = 0;
  for (const array of arrays) {
    result.set(array, offset);
    offset += array.length;
  }
  return result;
};
/**
 * @since 1.0.0
 * @category protocol
 */
const makeProtocolHttp = exports.makeProtocolHttp = /*#__PURE__*/Effect.fnUntraced(function* (options) {
  const {
    httpApp,
    protocol
  } = yield* makeProtocolWithHttpApp;
  const router = yield* options.routerTag ?? HttpRouter.Default;
  yield* router.post(options.path, httpApp);
  return protocol;
});
/**
 * @since 1.0.0
 * @category protocol
 */
const makeProtocolHttpRouter = exports.makeProtocolHttpRouter = /*#__PURE__*/Effect.fnUntraced(function* (options) {
  const router = yield* HttpLayerRouter.HttpRouter;
  const {
    httpApp,
    protocol
  } = yield* makeProtocolWithHttpApp;
  yield* router.add("POST", options.path, httpApp);
  return protocol;
});
/**
 * @since 1.0.0
 * @category protocol
 */
const makeProtocolWorkerRunner = exports.makeProtocolWorkerRunner = /*#__PURE__*/Protocol.make(/*#__PURE__*/Effect.fnUntraced(function* (writeRequest) {
  const fiber = yield* Effect.withFiberRuntime(Effect.succeed);
  const runner = yield* WorkerRunner.PlatformRunner;
  const closeLatch = yield* WorkerRunner.CloseLatch;
  const backing = yield* runner.start(closeLatch);
  const initialMessage = yield* Deferred.make();
  const clientIds = new Set();
  const disconnects = yield* Mailbox.make();
  yield* Deferred.await(closeLatch).pipe(Effect.onExit(() => {
    fiber.currentScheduler.scheduleTask(() => fiber.unsafeInterruptAsFork(fiber.id()), 0);
    return Effect.void;
  }), Effect.forkScoped);
  yield* backing.run((clientId, message) => {
    clientIds.add(clientId);
    if (message._tag === "InitialMessage") {
      return Deferred.succeed(initialMessage, message.value);
    }
    return writeRequest(clientId, message);
  });
  yield* disconnects.take.pipe(Effect.tap(clientId => {
    clientIds.delete(clientId);
    return disconnects.offer(clientId);
  }), Effect.forkScoped);
  return {
    disconnects,
    send: backing.send,
    end(_clientId) {
      return Effect.void;
    },
    clientIds: Effect.sync(() => clientIds),
    initialMessage: Effect.asSome(Deferred.await(initialMessage)),
    supportsAck: true,
    supportsTransferables: true,
    supportsSpanPropagation: true
  };
}));
/**
 * @since 1.0.0
 * @category protocol
 */
const layerProtocolWorkerRunner = exports.layerProtocolWorkerRunner = /*#__PURE__*/Layer.scoped(Protocol, makeProtocolWorkerRunner);
/**
 * A rpc protocol that uses streaming http for communication.
 *
 * @since 1.0.0
 * @category protocol
 */
const layerProtocolHttp = options => {
  const routerTag = options.routerTag ?? HttpRouter.Default;
  return Layer.effect(Protocol, makeProtocolHttp(options)).pipe(Layer.provide(routerTag.Live));
};
/**
 * A rpc protocol that uses streaming http for communication.
 *
 * Uses a `HttpLayerRouter` to provide the http endpoint.
 *
 * @since 1.0.0
 * @category protocol
 */
exports.layerProtocolHttp = layerProtocolHttp;
const layerProtocolHttpRouter = options => Layer.effect(Protocol, makeProtocolHttpRouter(options));
/**
 * @since 1.0.0
 * @category http app
 */
exports.layerProtocolHttpRouter = layerProtocolHttpRouter;
const toHttpApp = exports.toHttpApp = /*#__PURE__*/Effect.fnUntraced(function* (group, options) {
  const {
    httpApp,
    protocol
  } = yield* makeProtocolWithHttpApp;
  yield* make(group, options).pipe(Effect.provideService(Protocol, protocol), Effect.interruptible, Effect.forkScoped);
  return httpApp;
});
/**
 * @since 1.0.0
 * @category http app
 */
const toHttpAppWebsocket = exports.toHttpAppWebsocket = /*#__PURE__*/Effect.fnUntraced(function* (group, options) {
  const {
    httpApp,
    protocol
  } = yield* makeProtocolWithHttpAppWebsocket;
  yield* make(group, options).pipe(Effect.provideService(Protocol, protocol), Effect.interruptible, Effect.forkScoped);
  return httpApp;
});
/**
 * Construct an http web handler from an `RpcGroup`.
 *
 * @since 1.0.0
 * @category constructors
 */
const toWebHandler = (group, options) => HttpApp.toWebHandlerLayerWith(Layer.mergeAll(options.layer, Layer.scope), {
  memoMap: options?.memoMap,
  middleware: options?.middleware,
  toHandler: r => Effect.provide(toHttpApp(group, options), r)
});
/**
 * Create a protocol that uses the provided `Stream` and `Sink` for communication.
 *
 * @since 1.0.0
 * @category protocol
 */
exports.toWebHandler = toWebHandler;
const makeProtocolStdio = exports.makeProtocolStdio = /*#__PURE__*/Effect.fnUntraced(function* (options) {
  const fiber = Option.getOrThrow(Fiber.getCurrentFiber());
  const serialization = yield* RpcSerialization.RpcSerialization;
  return yield* Protocol.make(Effect.fnUntraced(function* (writeRequest) {
    const mailbox = yield* Mailbox.make();
    const parser = serialization.unsafeMake();
    yield* options.stdin.pipe(Stream.runForEach(data => {
      const decoded = parser.decode(data);
      if (decoded.length === 0) return Effect.void;
      let i = 0;
      return Effect.whileLoop({
        while: () => i < decoded.length,
        body: () => writeRequest(0, decoded[i++]),
        step: _Function.constVoid
      });
    }), Effect.sandbox, Effect.tapError(Effect.logError), Effect.retry(Schedule.spaced(500)), Effect.ensuring(Fiber.interruptFork(fiber)), Effect.forkScoped, Effect.interruptible);
    yield* Mailbox.toStream(mailbox).pipe(Stream.run(options.stdout), Effect.retry(Schedule.spaced(500)), Effect.forkScoped, Effect.interruptible);
    return {
      disconnects: yield* Mailbox.make(),
      send(_clientId, response) {
        const responseEncoded = parser.encode(response);
        if (responseEncoded === undefined) {
          return Effect.void;
        }
        return mailbox.offer(responseEncoded);
      },
      end(_clientId) {
        return mailbox.end;
      },
      clientIds: Effect.succeed(new Set([0])),
      initialMessage: Effect.succeedNone,
      supportsAck: true,
      supportsTransferables: false,
      supportsSpanPropagation: true
    };
  }));
});
/**
 * Create a protocol that uses the provided `Stream` and `Sink` for communication.
 *
 * @since 1.0.0
 * @category protocol
 */
const layerProtocolStdio = options => Layer.scoped(Protocol, makeProtocolStdio(options));
/**
 * Fiber id used for client interruptions.
 *
 * @since 1.0.0
 * @category Interruption
 */
exports.layerProtocolStdio = layerProtocolStdio;
const fiberIdClientInterrupt = exports.fiberIdClientInterrupt = /*#__PURE__*/FiberId.make(-499, 0);
// internal
const makeSocketProtocol = /*#__PURE__*/Effect.gen(function* () {
  const serialization = yield* RpcSerialization.RpcSerialization;
  const disconnects = yield* Mailbox.make();
  let clientId = 0;
  const clients = new Map();
  const clientIds = new Set();
  let writeRequest;
  const onSocket = function* (socket, headers) {
    const scope = yield* Effect.scope;
    const parser = serialization.unsafeMake();
    const id = clientId++;
    yield* Scope.addFinalizerExit(scope, () => {
      clientIds.delete(id);
      clients.delete(id);
      return disconnects.offer(id);
    });
    const writeRaw = yield* socket.writer;
    const write = response => {
      try {
        const encoded = parser.encode(response);
        if (encoded === undefined) {
          return Effect.void;
        }
        return Effect.orDie(writeRaw(encoded));
      } catch (cause) {
        return Effect.orDie(writeRaw(parser.encode((0, _RpcMessage.ResponseDefectEncoded)(cause))));
      }
    };
    clientIds.add(id);
    clients.set(id, {
      write
    });
    yield* socket.runRaw(data => {
      try {
        const decoded = parser.decode(data);
        if (decoded.length === 0) return Effect.void;
        let i = 0;
        return Effect.whileLoop({
          while: () => i < decoded.length,
          body() {
            const message = decoded[i++];
            if (message._tag === "Request" && headers) {
              ;
              message.headers = headers.concat(message.headers);
            }
            return writeRequest(id, message);
          },
          step: _Function.constVoid
        });
      } catch (cause) {
        return writeRaw(parser.encode((0, _RpcMessage.ResponseDefectEncoded)(cause)));
      }
    }).pipe(Effect.interruptible, Effect.catchIf(error => error.reason === "Close", () => Effect.void), Effect.orDie);
  };
  const protocol = yield* Protocol.make(writeRequest_ => {
    writeRequest = writeRequest_;
    return Effect.succeed({
      disconnects,
      send: (clientId, response) => {
        const client = clients.get(clientId);
        if (!client) return Effect.void;
        return Effect.orDie(client.write(response));
      },
      end(_clientId) {
        return Effect.void;
      },
      clientIds: Effect.sync(() => clientIds),
      initialMessage: Effect.succeedNone,
      supportsAck: true,
      supportsTransferables: false,
      supportsSpanPropagation: true
    });
  });
  return {
    protocol,
    onSocket
  };
});
//# sourceMappingURL=RpcServer.js.map